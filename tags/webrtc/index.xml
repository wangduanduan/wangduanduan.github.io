<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Webrtc on 洞香春</title>
    <link>https://wdd.js.org/tags/webrtc/</link>
    <description>Recent content in Webrtc on 洞香春</description>
    <image>
      <title>洞香春</title>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <lastBuildDate>Wed, 01 Jun 2022 08:27:53 +0800</lastBuildDate>
    <atom:link href="https://wdd.js.org/tags/webrtc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WebRTC 人声检测与舒适噪音</title>
      <link>https://wdd.js.org/freeswitch/webrtc-vad-cng/</link>
      <pubDate>Wed, 01 Jun 2022 08:27:53 +0800</pubDate>
      <guid>https://wdd.js.org/freeswitch/webrtc-vad-cng/</guid>
      <description>&lt;h1 id=&#34;人声检测-vad&#34;&gt;人声检测 VAD&lt;/h1&gt;
&lt;p&gt;人声检测(VAD: Voice Activity Detection)是区分语音中是人说话的声音，还是其他例如环境音的一种功能。&lt;/p&gt;
&lt;p&gt;除此以外，人声检测还能用于减少网络中语音包传输的数据量，从而极大的降低语音的带宽，极限情况下能降低50%的带宽。&lt;/p&gt;
&lt;p&gt;在一个通话中，一般都是只有一个人说话，另一人听。很少可能是两个人都说话的。&lt;/p&gt;
&lt;p&gt;例如A在说话的时候，B可能在等待。&lt;/p&gt;
&lt;p&gt;虽然B在等待过程中，B的语音流依然再按照原始速度和编码再发给A, 即使这里面是环境噪音或者是无声。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;A ----&amp;gt; B # A在说话
A &amp;lt;---  B # B在等待过程中，B的语音流依然再按照原始速度和编码再发给A
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果B具有VAD检测功能，那么B就可以在不说话的时候，发送特殊标记的语音流或者通过减少语音流发送的频率，来减少无意义语音的发送。&lt;/p&gt;
&lt;p&gt;从而极大的降低B-&amp;gt;A的语音流。&lt;/p&gt;
&lt;p&gt;下图是Wireshark抓包的两种RTP包，g711编码的占214字节，但是用舒适噪音编码的只有63字节。将近减少了4倍的带宽。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wdd.js.org/images/Xnip2022-06-01_14-08-05.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;舒适噪音生成器-cng&#34;&gt;舒适噪音生成器 CNG&lt;/h1&gt;
&lt;p&gt;舒适噪音(CN stands for Comfort Noise), 是一种模拟的背景环境音。舒适噪音生成器在接收端根据发送到给的参数，来产生类似接收端的舒适噪音, 用来模拟发送方的噪音环境。&lt;/p&gt;
&lt;p&gt;CN也是一种RTP包的格式，定义在&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc3389&#34;&gt;RFC 3389&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;舒适噪音的payload, 也被称作静音插入描述帧(SID: a Silence Insertion Descriptor frame), 包括一个字节的数据，用来描述噪音的级别。也可以包含其他的额外的数据。早期版本的舒适噪音的格式定义在RFC 1890中，这个版本的格式只包含一个字段，就是噪音级别。&lt;/p&gt;
&lt;p&gt;噪音级别占用一个字节，其中第一个bit必须是0， 因此噪音级别有127中可能。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|0|   level     |
+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;跟着噪音级别的后续字节都是声音的频谱信息。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Byte        1      2    3    ...   M+1
       +-----+-----+-----+-----+-----+
       |level|  N1 |  N2 | ... |  NM |
       +-----+-----+-----+-----+-----+

Figure 2: CN Payload Packing Format
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SIP INVITE的SDP中也可以看到编码，如下面的CN&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于 WebRTC 构建 Web SIP Phone</title>
      <link>https://wdd.js.org/posts/2018/02/webrtc-web-sip-phone/</link>
      <pubDate>Sun, 11 Feb 2018 14:44:58 +0800</pubDate>
      <guid>https://wdd.js.org/posts/2018/02/webrtc-web-sip-phone/</guid>
      <description>&lt;h1 id=&#34;0-阅前须知&#34;&gt;0 阅前须知&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本文并不是教程，只是实现方案&lt;/li&gt;
&lt;li&gt;我只是从WEB端考虑这个问题，实际还需要后端sip服务器的配合&lt;/li&gt;
&lt;li&gt;jsSIP有个非常不错的在线demo, 可以去哪里玩耍，很好玩呢 &lt;a href=&#34;https://tryit.jssip.net/&#34;&gt;try jssip &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wdd.js.org/img/images/20180211144554_nUwjgc_Screenshot.jpeg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-技术简介&#34;&gt;1. 技术简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WebRTC&lt;/code&gt;: WebRTC，名称源自&lt;code&gt;网页即时通信&lt;/code&gt;（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SIP&lt;/code&gt;: &lt;code&gt;会话发起协议&lt;/code&gt;（Session Initiation Protocol，缩写SIP）是一个由IETF MMUSIC工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000年11月，SIP被正式批准成为3GPP信号协议之一，并成为IMS体系结构的一个永久单元。SIP与H.323一样，是用于VoIP最主要的信令协议之一。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wdd.js.org/img/images/20180211144604_Zdxh2x_Screenshot.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;一般来说，要么使用实体话机，要么在系统上安装基于sip的客户端程序。实体话机硬件成本高，基于sip的客户端往往兼容性差，无法跨平台，易被杀毒软件查杀。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;WebRTC&lt;/code&gt;或许是更好的解决方案，只要一个浏览器就可以实时语音视频通话，这是很不错的解决方案。WebSocket可以用来传递sip信令，而WebRTC用来实时传输语音视频流。&lt;/p&gt;
&lt;h1 id=&#34;2-前端webrtc实现方案&#34;&gt;2. 前端WebRTC实现方案&lt;/h1&gt;
&lt;p&gt;其实我们不需要去自己处理WebRTC的相关方法，或者去处理视频或者媒体流。市面上已经有不错的模块可供选择。&lt;/p&gt;
&lt;h2 id=&#34;21-jssiphttpjssipnet&#34;&gt;2.1 &lt;a href=&#34;http://jssip.net/&#34;&gt;jsSIP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jsSIP是JavaScript SIP 库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wdd.js.org/img/images/20180211144616_7c5Pf0_Screenshot.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;功能特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在浏览器或者Nodejs中运行&lt;/li&gt;
&lt;li&gt;使用WebSocket传递SIP协议&lt;/li&gt;
&lt;li&gt;视频音频实时消息使用WebRTC&lt;/li&gt;
&lt;li&gt;非常轻量&lt;/li&gt;
&lt;li&gt;100%纯JavaScript&lt;/li&gt;
&lt;li&gt;使用简单并且具有强大的Api&lt;/li&gt;
&lt;li&gt;服务端支持 OverSIP, Kamailio, Asterisk, OfficeSIP，reSIProcate，Frafos ABC SBC，TekSIP&lt;/li&gt;
&lt;li&gt;是RFC 7118 and OverSIP的作者写的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是使用JsSIP打电话的例子，非常简单吧&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Create our JsSIP instance and run it:

var socket = new JsSIP.WebSocketInterface(&amp;#39;wss://sip.myhost.com&amp;#39;);
var configuration = {
  sockets  : [ socket ],
  uri      : &amp;#39;sip:alice@example.com&amp;#39;,
  password : &amp;#39;superpassword&amp;#39;
};

var ua = new JsSIP.UA(configuration);

ua.start();

// Register callbacks to desired call events
var eventHandlers = {
  &amp;#39;progress&amp;#39;: function(e) {
    console.log(&amp;#39;call is in progress&amp;#39;);
  },
  &amp;#39;failed&amp;#39;: function(e) {
    console.log(&amp;#39;call failed with cause: &amp;#39;+ e.data.cause);
  },
  &amp;#39;ended&amp;#39;: function(e) {
    console.log(&amp;#39;call ended with cause: &amp;#39;+ e.data.cause);
  },
  &amp;#39;confirmed&amp;#39;: function(e) {
    console.log(&amp;#39;call confirmed&amp;#39;);
  }
};

var options = {
  &amp;#39;eventHandlers&amp;#39;    : eventHandlers,
  &amp;#39;mediaConstraints&amp;#39; : { &amp;#39;audio&amp;#39;: true, &amp;#39;video&amp;#39;: true }
};

var session = ua.call(&amp;#39;sip:bob@example.com&amp;#39;, options);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;22-sipjshttpssipjscom&#34;&gt;2.2 &lt;a href=&#34;https://sipjs.com/&#34;&gt;SIP.js&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;sip.js项目实际是fork自jsSIP的，这里主要介绍它的服务端支持情况。其他接口自己自行查阅&lt;/p&gt;</description>
    </item>
    <item>
      <title>120行代码实现 浏览器WebRTC视频聊天</title>
      <link>https://wdd.js.org/posts/2018/02/webrtc-tutorial-simple-video-chat/</link>
      <pubDate>Fri, 09 Feb 2018 12:56:12 +0800</pubDate>
      <guid>https://wdd.js.org/posts/2018/02/webrtc-tutorial-simple-video-chat/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本例子是参考&lt;a href=&#34;https://www.scaledrone.com/blog/posts/webrtc-tutorial-simple-video-chat&#34;&gt;webrtc-tutorial-simple-video-chat&lt;/a&gt;做的。
这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/wangduanduan/webrtc&#34;&gt;本栗子的地址&lt;/a&gt;
&lt;a href=&#34;https://wangduanduan.github.io/webrtc/&#34;&gt;本栗子的pages地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-准备&#34;&gt;1. 准备&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用最新版谷歌浏览器（62版）&lt;/li&gt;
&lt;li&gt;视频聊天中 一个是windows, 一个是mac&lt;/li&gt;
&lt;li&gt;stun服务器使用谷歌的，trun使用&lt;a href=&#34;https://www.scaledrone.com/&#34;&gt;ScaleDrone&lt;/a&gt;的sdk，这样我就不用管服务端了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-先上效果图&#34;&gt;2. 先上效果图&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://wdd.js.org/img/images/20180209125722_GO0Ee0_Screenshot.jpeg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-再上在线例子点击此处httpswangduanduangithubiowebrtcdemoschat-with-your-friendhtml&#34;&gt;3. 再上在线例子&lt;a href=&#34;https://wangduanduan.github.io/webrtc/demos/chat-with-your-friend.html&#34;&gt;点击此处&lt;/a&gt;&lt;/h1&gt;
&lt;h1 id=&#34;4-源码分析&#34;&gt;4. 源码分析&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 产生随机数
if (!location.hash) {
    location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16);
}
// 获取房间号
var roomHash = location.hash.substring(1);

// 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel
// 你也可以自己创建
var drone = new ScaleDrone(&amp;#39;87fYv4ncOoa0Cjne&amp;#39;);
// 房间名必须以 &amp;#39;observable-&amp;#39;开头
var roomName = &amp;#39;observable-&amp;#39; + roomHash;
var configuration = {
    iceServers: [{
        urls: &amp;#39;stun:stun.l.google.com:19302&amp;#39; // 使用谷歌的stun服务
    }]
};

var room;
var pc;
function onSuccess() {}

function onError(error) {
    console.error(error);
}

drone.on(&amp;#39;open&amp;#39;, function(error){
    if (error) { return console.error(error);}

    room = drone.subscribe(roomName);
    room.on(&amp;#39;open&amp;#39;, function(error){
        if (error) {onError(error);}
    });

    // 已经链接到房间后，就会收到一个 members 数组，代表房间里的成员
    // 这时候信令服务已经就绪
    room.on(&amp;#39;members&amp;#39;, function(members){
        console.log(&amp;#39;MEMBERS&amp;#39;, members);

        // 如果你是第二个链接到房间的人，就会创建offer
        var isOfferer = members.length === 2;
        startWebRTC(isOfferer);
    });
});

// 通过Scaledrone发送信令消息
function sendMessage(message) {
    drone.publish({
        room: roomName,
        message
    });
}

function startWebRTC(isOfferer) {
    pc = new RTCPeerConnection(configuration);

    // 当本地ICE Agent需要通过信号服务器发送信息到其他端时
    // 会触发icecandidate事件回调
    pc.onicecandidate = function(event){
        if (event.candidate) {
            sendMessage({ &amp;#39;candidate&amp;#39;: event.candidate });
        }
    };

    // 如果用户是第二个进入的人，就在negotiationneeded 事件后创建sdp
    if (isOfferer) {
        // onnegotiationneeded 在要求sesssion协商时发生
        pc.onnegotiationneeded = function() {
            // 创建本地sdp描述 SDP (Session Description Protocol) session描述协议
            pc.createOffer().then(localDescCreated).catch(onError);
        };
    }

    // 当远程数据流到达时，将数据流装载到video中
    pc.onaddstream = function(event){
        remoteVideo.srcObject = event.stream;
    };

    // 获取本地媒体流
    navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true,
    }).then( function(stream) {
        // 将本地捕获的视频流装载到本地video中
        localVideo.srcObject = stream;

        // 将本地流加入RTCPeerConnection 实例中 发送到其他端
        pc.addStream(stream);
    }, onError);

    // 从Scaledrone监听信令数据
    room.on(&amp;#39;data&amp;#39;, function(message, client){
        // 消息是我自己发送的，则不处理
        if (client.id === drone.clientId) {
            return;
        }

        if (message.sdp) {
            // 设置远程sdp, 在offer 或者 answer后
            pc.setRemoteDescription(new RTCSessionDescription(message.sdp), function(){
                // 当收到offer 后就接听
                if (pc.remoteDescription.type === &amp;#39;offer&amp;#39;) {
                    pc.createAnswer().then(localDescCreated).catch(onError);
                }
            }, onError);
        }
        else if (message.candidate) {
            // 增加新的 ICE canidatet 到本地的链接中
            pc.addIceCandidate(
                new RTCIceCandidate(message.candidate), onSuccess, onError
            );
        }
    });
}

function localDescCreated(desc) {
    pc.setLocalDescription(desc, function(){
        sendMessage({ &amp;#39;sdp&amp;#39;: pc.localDescription });
    },onError);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;5-webrtc简介&#34;&gt;5. WebRTC简介&lt;/h1&gt;
&lt;h2 id=&#34;51-介绍&#34;&gt;5.1. 介绍&lt;/h2&gt;
&lt;p&gt;WebRTC 是一个开源项目，用于Web浏览器之间进行实时音频视频通讯，数据传递。
WebRTC有几个JavaScript APIS。 点击链接去查看demo。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
