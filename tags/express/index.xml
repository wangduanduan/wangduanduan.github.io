<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Express on 洞香春</title>
    <link>https://wdd.js.org/tags/express/</link>
    <description>Recent content in Express on 洞香春</description>
    <image>
      <title>洞香春</title>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <lastBuildDate>Sun, 30 Sep 2018 09:41:44 +0800</lastBuildDate>
    <atom:link href="https://wdd.js.org/tags/express/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Express代理中间件问题与解决方案</title>
      <link>https://wdd.js.org/posts/2018/09/express-middleware-order-proxy-problem/</link>
      <pubDate>Sun, 30 Sep 2018 09:41:44 +0800</pubDate>
      <guid>https://wdd.js.org/posts/2018/09/express-middleware-order-proxy-problem/</guid>
      <description>&lt;h1 id=&#34;前后端分离应用的架构&#34;&gt;前后端分离应用的架构&lt;/h1&gt;
&lt;p&gt;在前后端分离架构中，为了避免跨域以及暴露内部服务地址。一般来说，我会在Express这层中加入一个反向代理。&lt;/p&gt;
&lt;p&gt;所有向后端服务访问的请求，都通过代理转发到内部的各个服务。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://on-img.com/chart_image/5ac48a5fe4b00dc8a02d30f4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个反向代理服务器，做起来很简单。用&lt;a href=&#34;https://github.com/chimurai/http-proxy-middleware&#34;&gt;http-proxy-middleware&lt;/a&gt;这个模块，几行代码就可以搞定。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// app.js
Object.keys(proxyTable).forEach(function (context) {
  app.use(proxyMiddleware(context, proxyTable[context]))
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;http-proxy-middleware实际上是对于&lt;a href=&#34;https://github.com/nodejitsu/node-http-proxy&#34;&gt;node-http-proxy&lt;/a&gt;的更加简便的封装。node-http-proxy是http-proxy-middleware的底层包，如果node-http-proxy有问题，那么这个问题就会影响到http-proxy-middleware这个包。&lt;/p&gt;
&lt;h1 id=&#34;最近的bug&#34;&gt;最近的bug&lt;/h1&gt;
&lt;p&gt;http-proxy-middleware最近有个问题，请求体在被代理转发前，如果请求体被解析了。那么后端服务将会收不到请求结束的消息，从浏览器的网络面板可以看出，一个请求一直在pending状态。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/chimurai/http-proxy-middleware/issues/299&#34;&gt;Cannot proxy after parsing body #299&lt;/a&gt;, 实际上这个问题在node-http-proxy也被提出过，而且处于open状态。&lt;a href=&#34;https://github.com/nodejitsu/node-http-proxy/issues/1279&#34;&gt;POST fails/hangs examples to restream also not working #1279&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前这个bug还是处于open状态，但是还是有解决方案的。就是&lt;code&gt;将请求体解析的中间件挂载在代理之后&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面的代码，express.json()会对json格式的请求体进行解析。方案1在代理前就进行body解析，所有格式是json的请求体都会被解析。&lt;/p&gt;
&lt;p&gt;但是有些走代理的请求，如果我们并不关心请求体的内容是什么，实际上我们可以不解析那些走代理的请求。所以，可以先挂载代理中间件，然后挂载请求体解析中间件，最后挂载内部的一些接口服务。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 方案1 bad
app.use(express.json())
Object.keys(proxyTable).forEach(function (context) {
  app.use(proxyMiddleware(context, proxyTable[context]))
})
app.use(&amp;#39;/api&amp;#39;, (req, res, next)=&amp;gt; {

})

// 方案2 good
Object.keys(proxyTable).forEach(function (context) {
  app.use(proxyMiddleware(context, proxyTable[context]))
})
app.use(express.json())
app.use(&amp;#39;/api&amp;#39;, (req, res, next)=&amp;gt; {

})
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;经过这个问题，我对Express中间件的挂载顺序有了更加深刻的认识。&lt;/p&gt;
&lt;p&gt;同时，在使用第三方包的过程中，如果该包bug，那么也需要自行找出合适的解决方案。而这个能力，往往就是高手与新手的区别。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Express静态文件浏览器缓存设置与缓存清除</title>
      <link>https://wdd.js.org/posts/2018/04/express-static-file-cache-setting-and-cleaning/</link>
      <pubDate>Sun, 08 Apr 2018 09:00:48 +0800</pubDate>
      <guid>https://wdd.js.org/posts/2018/04/express-static-file-cache-setting-and-cleaning/</guid>
      <description>&lt;h1 id=&#34;1-express设置缓存&#34;&gt;1. Express设置缓存&lt;/h1&gt;
&lt;p&gt;Express设置静态文件的方法很简单，一行代码搞定。&lt;code&gt;app.use(express.static(path.join(__dirname, &#39;public&#39;), {maxAge: MAX_AGE}))&lt;/code&gt;,
注意MAX_AGE的单位是毫秒。这句代码的含义是让pulic目录下的所有文件都可以在浏览器中缓存，过期时长为MAX_AGE毫秒。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;app.use(express.static(path.join(__dirname, &amp;#39;public&amp;#39;), {maxAge: config.get(&amp;#39;maxAge&amp;#39;)}))
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;2-express让浏览器清除缓存&#34;&gt;2. Express让浏览器清除缓存&lt;/h1&gt;
&lt;p&gt;缓存的好处是可以更快的访问服务，但是缓存也有坏处。例如设置缓存为10天，第二天的时候服务更新了。如果客户端不强制刷新页面的话，浏览器会一致使用更新前的静态文件，这样会导致一些BUG。你总当每次出问题时，客户打电话给你后，你让他强制刷新浏览器吧？&lt;/p&gt;
&lt;p&gt;所以，最好在服务重启后，重新让浏览器获取最新的静态文件。&lt;/p&gt;
&lt;p&gt;设置的方式是给每一个静态文件设置一个时间戳。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;vendor/loadjs/load.js?_=123898923423&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-express-路由&#34;&gt;2.1. Express 路由&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// /routes/index.js
router.get(&amp;#39;/home&amp;#39;, function (req, res, next) {
  res.render(&amp;#39;home&amp;#39;, {config: config, serverStartTimestamp: new Date().getTime()})
})
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;22-视图文件&#34;&gt;2.2. 视图文件&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// views/home.html
&amp;lt;script src=&amp;#34;vendor/loadjs/load.js?_=&amp;lt;%= serverStartTimestamp %&amp;gt;&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置之后，每次服务更新或者重启，浏览器都会使用最新的时间戳serverStartTimestamp，去获取静态文件。&lt;/p&gt;
&lt;h2 id=&#34;23-动态加载js文件&#34;&gt;2.3. 动态加载JS文件&lt;/h2&gt;
&lt;p&gt;有时候js文件并不是直接在HTML中引入，可能是使用了一些js文件加载库，例如requirejs, LABjs等。这些情况下，可以在全局设置环境变量SERVER_START_TIMESTAMP，用来表示服务启动的时间戳，在获取js的时候，将该时间戳拼接在路径上。&lt;/p&gt;
&lt;p&gt;注意：&lt;code&gt;环境变量SERVER_START_TIMESTAMP，一定要在其他脚本使用前定义。&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// views/home.html
&amp;lt;script&amp;gt;
  var SERVER_START_TIMESTAMP = &amp;lt;%= serverStartTimestamp %&amp;gt;
&amp;lt;/script&amp;gt;

// load.js
&amp;#39;vendor/contact-center/skill.js?_=&amp;#39; + SERVER_START_TIMESTAMP
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
