<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>setTimeout on 洞香春</title>
    <link>https://wdd.js.org/tags/settimeout/</link>
    <description>Recent content in setTimeout on 洞香春</description>
    <image>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 08 Feb 2018 14:09:54 +0000</lastBuildDate><atom:link href="https://wdd.js.org/tags/settimeout/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>定时器学习：利用定时器分解耗时任务案例</title>
      <link>https://wdd.js.org/posts/2018/settimeout-to-splice-big-work/</link>
      <pubDate>Thu, 08 Feb 2018 14:09:54 +0000</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/settimeout-to-splice-big-work/</guid>
      <description>对于执行时间过长的脚本，有的浏览器会弹出警告，说页面无响应。有的浏览器会直接终止脚本。总而言之，浏览器不希望某一个代码块长时间处于运行状态，因为js是单线程的。一个代码块长时间运行，将会导致其他任何任务都必须等待。从用户体验上来说，很有可能发生页面渲染卡顿或者点击事件无响应的状态。
如果一段脚本的运行时间超过5秒，有些浏览器（比如Firefox和Opera）将弹出一个对话框警告用户该脚本“无法响应”。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。&amp;ndash;《JavaScript忍者秘籍》
JavaScript忍者秘籍里有个很好的比喻：页面上发生的各种事情就好像一群人在讨论事情，如果有个人一直在说个不停，其他人肯定不乐意。我们希望有个裁判，定时的切换其他人来说话。
Js利用定时器来分解任务，关键点有两个。
按什么维度去分解任务
任务的现场保存与现场恢复
1. 例子 要求：动态创建一个表格，一共10000行，每行10个单元格
1.1. 一次性创建 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var tbody = document.getElementsByTagName(&amp;#39;tbody&amp;#39;)[0]; var allLines = 10000; // 每次渲染的行数 console.time(&amp;#39;wd&amp;#39;); for(var i=0; i&amp;lt;allLines; i++){ var tr = document.createElement(&amp;#39;tr&amp;#39;); for(var j=0; j&amp;lt;10; j++){ var td = document.createElement(&amp;#39;td&amp;#39;); td.appendChild(document.createTextNode(i+&amp;#39;,&amp;#39;+j)); tr.appendChild(td); } tbody.appendChild(tr); } console.timeEnd(&amp;#39;wd&amp;#39;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 总共耗时180ms, 浏览器已经给出警告！[Violation] &#39;setTimeout&#39; handler took 53ms。
1.2. 分批次动态创建 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var tbody = document.</description>
    </item>
    
  </channel>
</rss>
