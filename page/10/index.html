<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>洞香春</title><meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="端端的个人博客"><meta name=author content="王端端"><link rel=canonical href=https://wdd.js.org/><meta name=google-site-verification content="G-SGW660ZWKM"><link crossorigin=anonymous href=/assets/css/stylesheet.min.6aef73bcd11b501f30d40511dda695ff4635a6911499b91e84cfbca3c398c0e8.css integrity="sha256-au9zvNEbUB8w1AUR3aaV/0Y1ppEUmbkehM+8o8OYwOg=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/logo.ico as=image><link rel=icon href=https://wdd.js.org/logo.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/logo.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/logo.ico><link rel=apple-touch-icon href=https://wdd.js.org/logo.ico><link rel=mask-icon href=https://wdd.js.org/logo.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><link rel=alternate type=application/rss+xml href=https://wdd.js.org/index.xml><link rel=alternate type=application/json href=https://wdd.js.org/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-SGW660ZWKM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SGW660ZWKM",{anonymize_ip:!1})}</script><meta property="og:title" content="洞香春"><meta property="og:description" content="端端的个人博客"><meta property="og:type" content="website"><meta property="og:url" content="https://wdd.js.org/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="洞香春"><meta name=twitter:description content="端端的个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"洞香春","url":"https://wdd.js.org","description":"端端的个人博客","thumbnailUrl":"https://wdd.js.org/logo.ico","sameAs":["https://github.com/wangduanduan","mailto://1779706607@qq.com","https://yuque.com/wangdd"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/logo.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>笔记 node最佳实践1 项目工程最佳实践</h2></header><section class=entry-content><p>原文阅读: nodebestpractices
1. 工程结构最佳实践 1.1. 组件化 bad: 按照功能划分
controllers api.js home.js order.js product.js user.js models order.js product.js user.js test testOrder.js testProduct.js testUser.js good：按照组件划分
order product user index.js user.js userApi.js userError.js userTesting.js userAction.js 1.2. 层次化 不要在express中写太多业务逻辑，express专注web层 业务层要单独抽出 数据库层单独抽出 1.3. NPM化 把常用组件做成NPM包
1.4. 分离Express的 app 和 server 1.5. 配置化 环境感知： 根据不同环境使用不同配置</p></section><footer class=entry-footer><span title='2018-02-09 11:56:11 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 笔记 node最佳实践1 项目工程最佳实践" href=https://wdd.js.org/posts/2018/nodejs-project-best-struct/></a></article><article class=post-entry><header class=entry-header><h2>grep awk 搜索日志常用命令</h2></header><section class=entry-content><p>1. grep 常用参数 参考： GNU Grep 3.0
--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log > error.log
4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log
5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log
6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log
7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log
8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E 'ERROR|DEBUG' trace....</p></section><footer class=entry-footer><span title='2018-02-09 10:45:31 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to grep awk 搜索日志常用命令" href=https://wdd.js.org/posts/2018/grep-awk-search-log/></a></article><article class=post-entry><header class=entry-header><h2>我的谷歌浏览器插件集（15个）</h2></header><section class=entry-content><p>1. 广告拦截：AdBlock 2. 获取网页样式：CSS Peeper 3. 扩展管理：扩展管理器（Extension Manager） 4. json格式化：JSON-handle 5. 多点高亮查找：Multi-highlight 6. github源码阅读：Octotree 7. http接口调试：Postman 8. 脚本增强：Tampermonkey 9. 脚本注入：Script Injector 10. 键步如飞：Vimium 11. Vue开发利器：Vue.js devtools 12. 前端资讯：掘金 13. 让不支持markdown的富文本编辑器支持markdown: Markdown Here 14. 多标签页时，自动释放内存，开100个标签页也毫无压力：The Great Suspender 15. 接口测试：Restlet Client - REST API Testing restlet Client和post man功能差不多，restlet更轻量，只在新开一个标签页。postman 需要打开一个app。</p></section><footer class=entry-footer><span title='2018-02-09 10:27:34 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 我的谷歌浏览器插件集（15个）" href=https://wdd.js.org/posts/2018/my-chrome-extensions-collection/></a></article><article class=post-entry><header class=entry-header><h2>哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首</h2></header><section class=entry-content><p>1. 问题现象 使用netstat -ntp命令时发现，Recv-Q 1692012 异常偏高（正常情况下，该值应该是0），导致应用占用过多的内存。
tcp 1692012 0 172.17.72.4:48444 10.254.149.149:58080 ESTABLISHED 27/node 问题原因：代理的转发时，没有删除逐跳首部
2. 什么是Hop-by-hop 逐跳首部？ http首部可以分为两种
端到端首部 End-to-end: 端到端首部代理在转发时必须携带的 逐跳首部 Hop-by-hop: 逐跳首部只对单次转发有效，代理在转发时，必须删除这些首部 逐跳首部有以下几个, 这些首部在代理进行转发前必须删除
Connetion Keep-Alive Proxy-Authenticate Proxy-Authortization Trailer TE Transfer-Encodeing Upgrade 3. 什么是哑代理？ 很多老的或简单的代理都是盲中继(blind relay),它们只是将字节从一个连接转发到另一个连接中去,不对Connection首部进行特殊的处理。
(1)在图4-15a中 Web客户端向代理发送了一条报文,其中包含了Connection:Keep-Alive首部,如果可能的话请求建立一条keep-alive连接。客户端等待响应,以确定对方是否认可它对keep-alive信道的请求。
(2) 哑代理收到了这条HTTP请求,但它并不理解 Connection首部(只是将其作为一个扩展首部对待)。代理不知道keep-alive是什么意思,因此只是沿着转发链路将报文一字不漏地发送给服务器(图4-15b)。但Connection首部是个逐跳首部,只适用于单条传输链路,不应该沿着传输链路向下传输。接下来,就要发生一些很糟糕的事情了。
(3) 在图4-15b中,经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时,会误以为代理(对服务器来说,这个代理看起来就和所有其他客户端一样)希望进行keep-alive对话!对Web服务器来说这没什么问题——它同意进行keep-alive对话,并在图4-15c中回送了一个Connection: Keep-Alive响应首部。所以,此时W eb服务器认为它在与代理进行keep-alive对话,会遵循keep-alive的规则。但代理却对keep-alive一无所知。不妙。
(4) 在图4-15d中,哑代理将Web服务器的响应报文回送给客户端,并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部,就会认为代理同意进行keep-alive对话。所以,此时客户端和服务器都认为它们在进行keep-alive对话,但与它们进行对话的代理却对keep-alive一无所知。
(5) 由于代理对keep-alive一无所知,所以会将收到的所有数据都回送给客户端,然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了,所以不会去关闭连接。这样,代理就会挂在那里等待连接的关闭。
(6) 客户端在图4-15d中收到了回送的响应报文时,会立即转向下一条请求,在keep-alive连接上向代理发送另一条请求(参见图4-15e)。而代理并不认为同一条连接上会有其他请求到来,请求被忽略,浏览器就在这里转圈,不会有任何进展了。
(7) 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 –《HTTP权威指南》
这是HTTP权威指南中，关于HTTP哑代理的描述。这里这里说了哑代理会造成的一个问题。
这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 实际上，我认为哑代理还是造成以下问题的原因
TCP链接高Recv-Q tcp链接不断开，导致服务器内存过高，内存泄露 节点iowait高 在我们自己的代理的代码中，我有发现，在代理进行转发时，只删除了headers.host, 并没有删除headers.Connection等逐跳首部的字段
delete req.headers.host var option = { url: url, headers: req....</p></section><footer class=entry-footer><span title='2018-02-08 21:58:31 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首" href=https://wdd.js.org/posts/2018/tcp-high-recv-q-or-send-q-reasons/></a></article><article class=post-entry><header class=entry-header><h2>一些关于Hexo的疑问</h2></header><section class=entry-content><p>1. 文件名重复了怎么办？ 使用hexo new filename命令用来新建一个文章，但是如果你创建文章时，已经存在了同样的一个文件名，那么Hexo会怎样处理？
报错 覆盖之前的文章 在文件名后面加个序号 实际上Hexo使用第三个方式来处理，例如
// 执行下面命令两次，会产生两个文件 filename.md, filename-1.md hexo new filename hexo new filename 所以，在创建文章时，你根本不需要考虑文章重名的事情，Hexo会自动帮你加上序号后处理。</p></section><footer class=entry-footer><span title='2018-02-08 21:29:18 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 一些关于Hexo的疑问" href=https://wdd.js.org/posts/2018/something-you-may-dont-konw-about-hexo/></a></article><article class=post-entry><header class=entry-header><h2>Hexo NexT主题设置封面的方法</h2></header><section class=entry-content><p>默认情况下NexT主题的首页，每篇文章几乎都会全部渲染出来。这是这样来看，首页就会变得非常长，不利于快速浏览。
而我希望首页可以尽量缩短，每个文章只需要稍微一点介绍，如果有图片，就设置一张封面就好了。
下面是具体的设置步骤
1. Next主题设置摘要 filename: themes/next/_config.yml，将auto_excerpt.enable设置成true，length属性表示摘要的字数限制。
auto_excerpt: enable: true length: 150 2. 文章具体设置 在 &lt;!-- more -->上面放一张图片就可以了
--- title: Hexo NexT主题设置封面的方法 date: 2018-02-08 21:09:50 tags: - hexo --- ![](https://wdd.js.org/img/images/20180208212257_BZZjA5_1200px-The_Great_Wave_off_Kanagawa.jpeg) 文章摘要 &lt;!-- more --> 文章正文</p></section><footer class=entry-footer><span title='2018-02-08 21:09:50 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to Hexo NexT主题设置封面的方法" href=https://wdd.js.org/posts/2018/hexo-next-theme-set-cover/></a></article><article class=post-entry><header class=entry-header><h2>寻一片净土 书写我自己的芳华</h2></header><section class=entry-content><p>我曾经在csdn上写过博客
后来因为csdn的广告太多，我就不再csdn上写了
我也曾在博客园上写过博客
后来因为博客园上对markdown支持不够好，所以我也放弃了
我也曾在segmentfault上写过博客
它上面的markdown编辑器也还好用
但是有时候不知道是什么原因
它的markdown编辑器有时候太卡了，而且经常会出现上传图片失败
最让我不能容忍的是
你在SegmentFault删除自己的博客，那其实是逻辑删除
别人还是可以通过连接去访问的
而且SegmentFault上的广告也开始慢慢变多了
而且SegmentFault上对文章的限制也是比较多的
大树底下好乘凉，但是你的流量也是需要给大树的
互联网时代，看似任何服务都是免费的
其实免费的才是最贵的
你用了别人的服务，无论如何，你总要提供给别人价值
无论怎样，你总要做出你的回报
但是，无论如何，我总是需要一个更加独立的领地
她可以完全属于我
无论是野草还是野花
无论是杨柳依依还是雨雪霏霏
我都可以放肆潇洒
我需要一片净土
来书写我自己的芳华
所以，最近一直在把SegmentFault上的文章搬迁到github pages上
另外图片全部存在七牛云上
使用hexo next主题，做一个完全自主的静态博客</p></section><footer class=entry-footer><span title='2018-02-08 20:18:42 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 寻一片净土 书写我自己的芳华" href=https://wdd.js.org/posts/2018/write-blog-belong-myself/></a></article><article class=post-entry><header class=entry-header><h2>定时器学习：利用定时器分解耗时任务案例</h2></header><section class=entry-content><p>对于执行时间过长的脚本，有的浏览器会弹出警告，说页面无响应。有的浏览器会直接终止脚本。总而言之，浏览器不希望某一个代码块长时间处于运行状态，因为js是单线程的。一个代码块长时间运行，将会导致其他任何任务都必须等待。从用户体验上来说，很有可能发生页面渲染卡顿或者点击事件无响应的状态。
如果一段脚本的运行时间超过5秒，有些浏览器（比如Firefox和Opera）将弹出一个对话框警告用户该脚本“无法响应”。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。–《JavaScript忍者秘籍》
JavaScript忍者秘籍里有个很好的比喻：页面上发生的各种事情就好像一群人在讨论事情，如果有个人一直在说个不停，其他人肯定不乐意。我们希望有个裁判，定时的切换其他人来说话。
Js利用定时器来分解任务，关键点有两个。
按什么维度去分解任务
任务的现场保存与现场恢复
1. 例子 要求：动态创建一个表格，一共10000行，每行10个单元格
1.1. 一次性创建 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;table> &lt;tbody>&lt;/tbody> &lt;/table> &lt;script type="text/javascript"> var tbody = document.getElementsByTagName('tbody')[0]; var allLines = 10000; // 每次渲染的行数 console.time('wd'); for(var i=0; i&lt;allLines; i++){ var tr = document.createElement('tr'); for(var j=0; j&lt;10; j++){ var td = document.createElement('td'); td.appendChild(document.createTextNode(i+','+j)); tr.appendChild(td); } tbody.appendChild(tr); } console.timeEnd('wd'); &lt;/script> &lt;/body> &lt;/html> 总共耗时180ms, 浏览器已经给出警告！[Violation] 'setTimeout' handler took 53ms。
1.2. 分批次动态创建 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;table> &lt;tbody>&lt;/tbody> &lt;/table> &lt;script type="text/javascript"> var tbody = document....</p></section><footer class=entry-footer><span title='2018-02-08 14:09:54 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 定时器学习：利用定时器分解耗时任务案例" href=https://wdd.js.org/posts/2018/settimeout-to-splice-big-work/></a></article><article class=post-entry><header class=entry-header><h2>关于JavaScropt函数式编程，我多么希望能早点看到这本书</h2></header><section class=entry-content><p>我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。
然后我继续看了这本书的中文版。有些醍醐灌顶的感觉。 随之在github搜了一下。 我想，即使付费，我也愿意看。
中文版地址：https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details github原文地址：https://github.com/MostlyAdequate/mostly-adequate-guide
1. 后记 其实我是想学点函数柯里化的东西，然后用谷歌搜索了一下。第一个结果就是这本书。非常感谢谷歌搜索，如果我用百度，可能就没有缘分遇到这本书了。</p></section><footer class=entry-footer><span title='2018-02-08 14:06:22 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 关于JavaScropt函数式编程，我多么希望能早点看到这本书" href=https://wdd.js.org/posts/2018/js-functional-programming/></a></article><article class=post-entry><header class=entry-header><h2>终于找到你！如何将前端console.log的日志保存成文件?</h2></header><section class=entry-content><p>本篇文章来自一个需求，前端websocket会收到各种消息，但是调试的时候，我希望把websoekt推送过来的消息都保存到一个文件里，如果出问题的时候，我可以把这些消息的日志文件提交给后端开发区分析错误。但是在浏览器里，js一般是不能写文件的。鼠标另存为的方法也是不太好，因为会保存所有的console.log的输出。于是，终于找到这个debugout.js。
debugout.js的原理是将所有日志序列化后，保存到一个变量里。当然这个变量不会无限大，因为默认的最大日志限制是2500行，这个是可配置的。另外，debugout.js也支持在localStorage里存储日志的。
1. debugout.js 一般来说，可以使用打开console面板，然后右键save，是可以将console.log输出的信息另存为log文件的。但是这就把所有的日志都包含进来了，如何只保存我想要的日志呢？
（调试输出）从您的日志中生成可以搜索，时间戳，下载等的文本文件。 参见下面的一些例子。
Debugout的log（）接受任何类型的对象，包括函数。 Debugout不是一个猴子补丁，而是一个单独的记录类，你使用而不是控制台。
调试的一些亮点：
在运行时或任何时间获取整个日志或尾部 搜索并切片日志 更好地了解可选时间戳的使用模式 在一个地方切换实时日志记录（console.log） 可选地将输出存储在window.localStorage中，并在每个会话中持续添加到同一个日志 可选地，将日志上限为X个最新行以限制内存消耗 下图是使用downloadLog方法下载的日志文件。
官方提供的demo示例，欢迎试玩。http://inorganik.github.io/debugout.js/
2. 使用 在脚本顶部的全局命名空间中创建一个新的调试对象，并使用debugout的日志方法替换所有控制台日志方法：
var bugout = new debugout(); // instead of console.log('some object or string') bugout.log('some object or string'); 3. API log() -像console.log(), 但是会自动存储 getLog() - 返回所有日志 tail(numLines) - 返回尾部执行行日志，默认100行 search(string) - 搜索日志 getSlice(start, numLines) - 日志切割 downloadLog() - 下载日志 clear() - 清空日志 determineType() - 一个更细粒度的typeof为您提供方便 4. 可选配置 ··· // log in real time (forwards to console....</p></section><footer class=entry-footer><span title='2018-02-08 13:56:40 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 终于找到你！如何将前端console.log的日志保存成文件?" href=https://wdd.js.org/posts/2018/save-console-log-as-file/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wdd.js.org/page/9/>« Prev Page</a>
<a class=next href=https://wdd.js.org/page/11/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>