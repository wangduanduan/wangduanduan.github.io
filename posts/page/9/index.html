<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 洞香春</title><meta name=keywords content><meta name=description content="Posts - 洞香春"><meta name=author content="王端端"><link rel=canonical href=https://wdd.js.org/posts/><meta name=google-site-verification content="G-SGW660ZWKM"><link crossorigin=anonymous href=/assets/css/stylesheet.min.6aef73bcd11b501f30d40511dda695ff4635a6911499b91e84cfbca3c398c0e8.css integrity="sha256-au9zvNEbUB8w1AUR3aaV/0Y1ppEUmbkehM+8o8OYwOg=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/logo.ico as=image><link rel=icon href=https://wdd.js.org/logo.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/logo.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/logo.ico><link rel=apple-touch-icon href=https://wdd.js.org/logo.ico><link rel=mask-icon href=https://wdd.js.org/logo.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><link rel=alternate type=application/rss+xml href=https://wdd.js.org/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-SGW660ZWKM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SGW660ZWKM",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="端端的个人博客"><meta property="og:type" content="website"><meta property="og:url" content="https://wdd.js.org/posts/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="端端的个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://wdd.js.org/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/logo.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>一行命令搭建简易静态文件http服务器</h2></header><section class=entry-content><p>简易服务器：在命令执行的所在路径启动一个http服务器，然后你可以通过浏览器访问该路径下的所有文件。
在局域网内传文件，或者自己测试使用都是非常方便的。
1. 基于python 1.1. 基于Python2 python -m SimpleHTTPServer port
> python -m SimpleHTTPServer 8099 Serving HTTP on 0.0.0.0 port 8099 ... 127.0.0.1 - - [24/Oct/2017 11:07:56] "GET / HTTP/1.1" 200 - 1.2. 基于python3 python3 -m http.server port
> python3 -m http.server 8099 Serving HTTP on 0.0.0.0 port 8099 (http://0.0.0.0:8099/) ... 127.0.0.1 - - [24/Oct/2017 11:05:06] "GET / HTTP/1.1" 200 - 127.0.0.1 - - [24/Oct/2017 11:05:06] code 404, message File not found 127....</p></section><footer class=entry-footer><span title='2018-02-09 13:01:14 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 一行命令搭建简易静态文件http服务器" href=https://wdd.js.org/posts/2018/one-command-create-static-file-server/></a></article><article class=post-entry><header class=entry-header><h2>top-javascript-tools-in-2017</h2></header><section class=entry-content><p>原文地址 git地址
1. 基础工具 accounting.js async axios chance date-fns format.js immutable is.js lodash Math.js Moment.js Numeral.js string.js underscore.js voca wait xregexp.com 2. 编译 / 类型检查 Babel TypeScript Flow 3. 代码分析引擎 Tern 4. JavaScript兼容性检查器 jscc.info/ 5. Linting/ Hinting & Style Linter eslint 6. 单元测试 AVA Jasmine Mocha Tape 7. 单元测试断言库 Chai expect.js should.js 8. 单元测试数据模拟 sinon.js Kakapo.js mockjs 9. E2E测试 puppeteer 10. 代码格式化 / 整洁 esformatter js-beautify jsfmt prettier 11. 性能测试 benchmark....</p></section><footer class=entry-footer><span title='2018-02-09 12:59:38 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to top-javascript-tools-in-2017" href=https://wdd.js.org/posts/2018/top-javascript-tools-in-2017/></a></article><article class=post-entry><header class=entry-header><h2>120行代码实现 浏览器WebRTC视频聊天</h2></header><section class=entry-content><p>本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。
本栗子的地址 本栗子的pages地址
因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的
1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone('87fYv4ncOoa0Cjne'); // 房间名必须以 'observable-'开头 var roomName = 'observable-' + roomHash; var configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console....</p></section><footer class=entry-footer><span title='2018-02-09 12:56:12 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 120行代码实现 浏览器WebRTC视频聊天" href=https://wdd.js.org/posts/2018/webrtc-tutorial-simple-video-chat/></a></article><article class=post-entry><header class=entry-header><h2>如何写好技术文档?</h2></header><section class=entry-content><p>本文来自于公司内部的一个分享。 在文档方面，对内的一些接口文档主要是用swagger来写的。虽然可以在线测试，比较方便。但是也存在着一些更新不及时，swgger文档无法导出成文件的问题。 在对外提供的文档方面：我主要负责做一个浏览器端的一个js sdk。文档还算可以github地址，所以想把一些写文档的心得分享给大家。
1. 衡量好文档的唯一标准是什么？ Martin(Bob大叔)曾在《代码整洁之道》一书打趣地说：当你的代码在做 Code Review 时，审查者要是愤怒地吼道：
“What the fuck is this shit?” “Dude, What the fuck！” 等言辞激烈的词语时，那说明你写的代码是 Bad Code，如果审查者只是漫不经心的吐出几个
“What the fuck?”，
那说明你写的是 Good Code。衡量代码质量的唯一标准就是每分钟骂出“WTF” 的频率。
衡量文档的标准也是如此。
2. 好文档的特点 简洁：一句话可以说完的事情，就不要分两句话来说。并不是文档越厚越好，太厚的文档大多没人看。 准确: 字段类型，默认值，备注，是否必填等属性说明。 逻辑性: 文档如何划分？ 利于查看。 demo胜千言: 好的demo胜过各种字段说明，可以复制下来直接使用。 读者心: 从读者的角度考虑, 方法尽量简洁。可以传递一个参数搞定的事情，绝对不要让用户去传两个参数。 及时更新: 不更新的文档比bug更严重。 向后兼容: 不要随意废弃已有的接口或者某个字段，除非你考虑到这样做的后果。 建立文档词汇表：每个概念只有一个名字，不要随意起名字，名不正则言不顺。 格式统一：例如时间格式。我曾见过2017-09-12 09:32:23, 或2017.09.12 09:32:23或2017.09.12 09:32:23。变量名user_name, userName。 使用专业词语：不要过于口语化 3. 总结: 写出好文档要有以下四点 逻辑性：便于查找 专业性: 值得信赖，质量保证 责任心：及时更新，准确性，向后兼容 读者心：你了解的东西，别人可能并不清楚。从读者的角度去考虑，他们需要什么，而不是一味去强调你能提供什么。 4. 写文档的工具 markdown: 方便快捷，可以导出各种格式的文件 swagger: 功能强大，需要部署，不方便传递文件 5....</p></section><footer class=entry-footer><span title='2018-02-09 12:52:57 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 如何写好技术文档?" href=https://wdd.js.org/posts/2018/how-to-write-a-technical-document/></a></article><article class=post-entry><header class=entry-header><h2>Vue + Vue-router + Element-ui 搭建一个非常简单的dashboard demo</h2></header><section class=entry-content><p>做完这个demo后，你会体会到，Vue组件化，webpack, Vue-router等，并不是很难学习，你需要的只是拿起斧头的勇气
在做demo的过程中，我遇到一个问题，就是vue-router懒加载一直实现不了，纠结了半天。后来回到原点，去vue-route官网看文档，发现是因为syntax-dynamic-import插件没有安装。
所以说：你以为的bug, 实际上是你没看透文档
初次学习这个教程，你不需要有任何担忧某些东西不会，你也不需要写任何代码。因为基本上所有代码都是从element官网上拷贝的，你所做的只是把他们组装在一起罢了。
在线预览 仓库地址：https://github.com/wangduanduan/vue-el-dashboard
效果图： 使用到的技术：
Vue Vue-router Element-ui webpack Normalize.css vue-awesome babel 1. vue-cli 安装模板 ➜ vue-el-dashboard git:(master) vue init webpack ? Generate project in current directory? Yes ? Project name vue-el-dashboard ? Project description A Vue.js project ? Author wangdd &lt;wangdd@welljoint.com> ? Vue build standalone ? Install vue-router? Yes ? Use ESLint to lint your code? Yes ? Pick an ESLint preset Standard ?...</p></section><footer class=entry-footer><span title='2018-02-09 12:02:05 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to Vue + Vue-router + Element-ui 搭建一个非常简单的dashboard demo" href=https://wdd.js.org/posts/2018/vue-vue-router-elementui-stupid-simple-dashboard/></a></article><article class=post-entry><header class=entry-header><h2>笔记 node最佳实践1 项目工程最佳实践</h2></header><section class=entry-content><p>原文阅读: nodebestpractices
1. 工程结构最佳实践 1.1. 组件化 bad: 按照功能划分
controllers api.js home.js order.js product.js user.js models order.js product.js user.js test testOrder.js testProduct.js testUser.js good：按照组件划分
order product user index.js user.js userApi.js userError.js userTesting.js userAction.js 1.2. 层次化 不要在express中写太多业务逻辑，express专注web层 业务层要单独抽出 数据库层单独抽出 1.3. NPM化 把常用组件做成NPM包
1.4. 分离Express的 app 和 server 1.5. 配置化 环境感知： 根据不同环境使用不同配置</p></section><footer class=entry-footer><span title='2018-02-09 11:56:11 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 笔记 node最佳实践1 项目工程最佳实践" href=https://wdd.js.org/posts/2018/nodejs-project-best-struct/></a></article><article class=post-entry><header class=entry-header><h2>grep awk 搜索日志常用命令</h2></header><section class=entry-content><p>1. grep 常用参数 参考： GNU Grep 3.0
--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log > error.log
4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log
5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log
6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log
7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log
8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E 'ERROR|DEBUG' trace....</p></section><footer class=entry-footer><span title='2018-02-09 10:45:31 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to grep awk 搜索日志常用命令" href=https://wdd.js.org/posts/2018/grep-awk-search-log/></a></article><article class=post-entry><header class=entry-header><h2>我的谷歌浏览器插件集（15个）</h2></header><section class=entry-content><p>1. 广告拦截：AdBlock 2. 获取网页样式：CSS Peeper 3. 扩展管理：扩展管理器（Extension Manager） 4. json格式化：JSON-handle 5. 多点高亮查找：Multi-highlight 6. github源码阅读：Octotree 7. http接口调试：Postman 8. 脚本增强：Tampermonkey 9. 脚本注入：Script Injector 10. 键步如飞：Vimium 11. Vue开发利器：Vue.js devtools 12. 前端资讯：掘金 13. 让不支持markdown的富文本编辑器支持markdown: Markdown Here 14. 多标签页时，自动释放内存，开100个标签页也毫无压力：The Great Suspender 15. 接口测试：Restlet Client - REST API Testing restlet Client和post man功能差不多，restlet更轻量，只在新开一个标签页。postman 需要打开一个app。</p></section><footer class=entry-footer><span title='2018-02-09 10:27:34 +0000 UTC'>2018-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 我的谷歌浏览器插件集（15个）" href=https://wdd.js.org/posts/2018/my-chrome-extensions-collection/></a></article><article class=post-entry><header class=entry-header><h2>哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首</h2></header><section class=entry-content><p>1. 问题现象 使用netstat -ntp命令时发现，Recv-Q 1692012 异常偏高（正常情况下，该值应该是0），导致应用占用过多的内存。
tcp 1692012 0 172.17.72.4:48444 10.254.149.149:58080 ESTABLISHED 27/node 问题原因：代理的转发时，没有删除逐跳首部
2. 什么是Hop-by-hop 逐跳首部？ http首部可以分为两种
端到端首部 End-to-end: 端到端首部代理在转发时必须携带的 逐跳首部 Hop-by-hop: 逐跳首部只对单次转发有效，代理在转发时，必须删除这些首部 逐跳首部有以下几个, 这些首部在代理进行转发前必须删除
Connetion Keep-Alive Proxy-Authenticate Proxy-Authortization Trailer TE Transfer-Encodeing Upgrade 3. 什么是哑代理？ 很多老的或简单的代理都是盲中继(blind relay),它们只是将字节从一个连接转发到另一个连接中去,不对Connection首部进行特殊的处理。
(1)在图4-15a中 Web客户端向代理发送了一条报文,其中包含了Connection:Keep-Alive首部,如果可能的话请求建立一条keep-alive连接。客户端等待响应,以确定对方是否认可它对keep-alive信道的请求。
(2) 哑代理收到了这条HTTP请求,但它并不理解 Connection首部(只是将其作为一个扩展首部对待)。代理不知道keep-alive是什么意思,因此只是沿着转发链路将报文一字不漏地发送给服务器(图4-15b)。但Connection首部是个逐跳首部,只适用于单条传输链路,不应该沿着传输链路向下传输。接下来,就要发生一些很糟糕的事情了。
(3) 在图4-15b中,经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时,会误以为代理(对服务器来说,这个代理看起来就和所有其他客户端一样)希望进行keep-alive对话!对Web服务器来说这没什么问题——它同意进行keep-alive对话,并在图4-15c中回送了一个Connection: Keep-Alive响应首部。所以,此时W eb服务器认为它在与代理进行keep-alive对话,会遵循keep-alive的规则。但代理却对keep-alive一无所知。不妙。
(4) 在图4-15d中,哑代理将Web服务器的响应报文回送给客户端,并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部,就会认为代理同意进行keep-alive对话。所以,此时客户端和服务器都认为它们在进行keep-alive对话,但与它们进行对话的代理却对keep-alive一无所知。
(5) 由于代理对keep-alive一无所知,所以会将收到的所有数据都回送给客户端,然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了,所以不会去关闭连接。这样,代理就会挂在那里等待连接的关闭。
(6) 客户端在图4-15d中收到了回送的响应报文时,会立即转向下一条请求,在keep-alive连接上向代理发送另一条请求(参见图4-15e)。而代理并不认为同一条连接上会有其他请求到来,请求被忽略,浏览器就在这里转圈,不会有任何进展了。
(7) 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 –《HTTP权威指南》
这是HTTP权威指南中，关于HTTP哑代理的描述。这里这里说了哑代理会造成的一个问题。
这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 实际上，我认为哑代理还是造成以下问题的原因
TCP链接高Recv-Q tcp链接不断开，导致服务器内存过高，内存泄露 节点iowait高 在我们自己的代理的代码中，我有发现，在代理进行转发时，只删除了headers.host, 并没有删除headers.Connection等逐跳首部的字段
delete req.headers.host var option = { url: url, headers: req....</p></section><footer class=entry-footer><span title='2018-02-08 21:58:31 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首" href=https://wdd.js.org/posts/2018/tcp-high-recv-q-or-send-q-reasons/></a></article><article class=post-entry><header class=entry-header><h2>一些关于Hexo的疑问</h2></header><section class=entry-content><p>1. 文件名重复了怎么办？ 使用hexo new filename命令用来新建一个文章，但是如果你创建文章时，已经存在了同样的一个文件名，那么Hexo会怎样处理？
报错 覆盖之前的文章 在文件名后面加个序号 实际上Hexo使用第三个方式来处理，例如
// 执行下面命令两次，会产生两个文件 filename.md, filename-1.md hexo new filename hexo new filename 所以，在创建文章时，你根本不需要考虑文章重名的事情，Hexo会自动帮你加上序号后处理。</p></section><footer class=entry-footer><span title='2018-02-08 21:29:18 +0000 UTC'>2018-02-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端</footer><a class=entry-link aria-label="post link to 一些关于Hexo的疑问" href=https://wdd.js.org/posts/2018/something-you-may-dont-konw-about-hexo/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wdd.js.org/posts/page/8/>« Prev Page</a>
<a class=next href=https://wdd.js.org/posts/page/10/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>