<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>120行代码实现 浏览器WebRTC视频聊天 | 洞香春</title><meta name=keywords content="webrtc"><meta name=description content="本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。
本栗子的地址 本栗子的pages地址
因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的
1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone('87fYv4ncOoa0Cjne'); // 房间名必须以 'observable-'开头 var roomName = 'observable-' + roomHash; var configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/posts/2018/02/webrtc-tutorial-simple-video-chat/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.112.5"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="120行代码实现 浏览器WebRTC视频聊天"><meta property="og:description" content="本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。
本栗子的地址 本栗子的pages地址
因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的
1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone('87fYv4ncOoa0Cjne'); // 房间名必须以 'observable-'开头 var roomName = 'observable-' + roomHash; var configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/posts/2018/02/webrtc-tutorial-simple-video-chat/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-09T12:56:12+08:00"><meta property="article:modified_time" content="2018-02-09T12:56:12+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="120行代码实现 浏览器WebRTC视频聊天"><meta name=twitter:description content="本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。
本栗子的地址 本栗子的pages地址
因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的
1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone('87fYv4ncOoa0Cjne'); // 房间名必须以 'observable-'开头 var roomName = 'observable-' + roomHash; var configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://wdd.js.org/posts/"},{"@type":"ListItem","position":3,"name":"120行代码实现 浏览器WebRTC视频聊天","item":"https://wdd.js.org/posts/2018/02/webrtc-tutorial-simple-video-chat/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"120行代码实现 浏览器WebRTC视频聊天","name":"120行代码实现 浏览器WebRTC视频聊天","description":"本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。\n本栗子的地址 本栗子的pages地址\n因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的\n1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone(\u0026#39;87fYv4ncOoa0Cjne\u0026#39;); // 房间名必须以 \u0026#39;observable-\u0026#39;开头 var roomName = \u0026#39;observable-\u0026#39; + roomHash; var configuration = { iceServers: [{ urls: \u0026#39;stun:stun.l.google.com:19302\u0026#39; // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console.","keywords":["webrtc"],"articleBody":" 本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。\n本栗子的地址 本栗子的pages地址\n因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的\n1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone('87fYv4ncOoa0Cjne'); // 房间名必须以 'observable-'开头 var roomName = 'observable-' + roomHash; var configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console.error(error); } drone.on('open', function(error){ if (error) { return console.error(error);} room = drone.subscribe(roomName); room.on('open', function(error){ if (error) {onError(error);} }); // 已经链接到房间后，就会收到一个 members 数组，代表房间里的成员 // 这时候信令服务已经就绪 room.on('members', function(members){ console.log('MEMBERS', members); // 如果你是第二个链接到房间的人，就会创建offer var isOfferer = members.length === 2; startWebRTC(isOfferer); }); }); // 通过Scaledrone发送信令消息 function sendMessage(message) { drone.publish({ room: roomName, message }); } function startWebRTC(isOfferer) { pc = new RTCPeerConnection(configuration); // 当本地ICE Agent需要通过信号服务器发送信息到其他端时 // 会触发icecandidate事件回调 pc.onicecandidate = function(event){ if (event.candidate) { sendMessage({ 'candidate': event.candidate }); } }; // 如果用户是第二个进入的人，就在negotiationneeded 事件后创建sdp if (isOfferer) { // onnegotiationneeded 在要求sesssion协商时发生 pc.onnegotiationneeded = function() { // 创建本地sdp描述 SDP (Session Description Protocol) session描述协议 pc.createOffer().then(localDescCreated).catch(onError); }; } // 当远程数据流到达时，将数据流装载到video中 pc.onaddstream = function(event){ remoteVideo.srcObject = event.stream; }; // 获取本地媒体流 navigator.mediaDevices.getUserMedia({ audio: true, video: true, }).then( function(stream) { // 将本地捕获的视频流装载到本地video中 localVideo.srcObject = stream; // 将本地流加入RTCPeerConnection 实例中 发送到其他端 pc.addStream(stream); }, onError); // 从Scaledrone监听信令数据 room.on('data', function(message, client){ // 消息是我自己发送的，则不处理 if (client.id === drone.clientId) { return; } if (message.sdp) { // 设置远程sdp, 在offer 或者 answer后 pc.setRemoteDescription(new RTCSessionDescription(message.sdp), function(){ // 当收到offer 后就接听 if (pc.remoteDescription.type === 'offer') { pc.createAnswer().then(localDescCreated).catch(onError); } }, onError); } else if (message.candidate) { // 增加新的 ICE canidatet 到本地的链接中 pc.addIceCandidate( new RTCIceCandidate(message.candidate), onSuccess, onError ); } }); } function localDescCreated(desc) { pc.setLocalDescription(desc, function(){ sendMessage({ 'sdp': pc.localDescription }); },onError); } 5. WebRTC简介 5.1. 介绍 WebRTC 是一个开源项目，用于Web浏览器之间进行实时音频视频通讯，数据传递。 WebRTC有几个JavaScript APIS。 点击链接去查看demo。\ngetUserMedia(): 捕获音频视频 MediaRecorder: 记录音频视频 RTCPeerConnection: 在用户之间传递音频流和视频流 RTCDataChannel: 在用户之间传递文件流 5.2. 在哪里使用WebRTC? Chrome FireFox Opera Android iOS 5.3. 什么是信令 WebRTC使用RTCPeerConnection在浏览器之间传递流数据, 但是也需要一种机制去协调收发控制信息，这就是信令。信令的方法和协议并不是在WebRTC中明文规定的。 在codelad中用的是Node，也有许多其他的方法。\n5.4. 什么是STUN和TURN和ICE? STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 wikipedia STUN\nTURN（全名Traversal Using Relay NAT, NAT中继穿透），是一种资料传输协议（data-transfer protocol）。允许在TCP或UDP的连线上跨越NAT或防火墙。 TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过取得应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通讯开始前与TURN server进行交互，并要求TURN server产生\"relay port\"，也就是relayed-transport-address。这时TURN server会建立peer，即远端端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将资料传送至peer，再由peer转传到另一方的TURN client。wikipedia TURN\nICE （Interactive Connectivity Establishment，互动式连接建立 ），一种综合性的NAT穿越的技术。 互动式连接建立是由IETF的MMUSIC工作组开发出来的一种framework，可整合各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。[wikipedia ICE]\nWebRTC被设计用于点对点之间工作，因此用户可以通过最直接的途径连接。然而，WebRTC的构建是为了应付现实中的网络: 客户端应用程序需要穿越NAT网关和防火墙，并且对等网络需要在直接连接失败的情况下进行回调。 作为这个过程的一部分，WebRTC api使用STUN服务器来获取计算机的IP地址，并将服务器作为中继服务器运行，以防止对等通信失败。(现实世界中的WebRTC更详细地解释了这一点。)\n5.5. WebRTC是否安全? WebRTC组件是强制要求加密的，并且它的JavaScript APIS只能在安全的域下使用(HTTPS 或者 localhost)。信令机制并没有被WebRTC标准定义，所以是否使用安全的协议就取决于你自己了。\n6. WebRTC 参考资料 官网教程\nWebRTC 简单的视频聊天 repo\nWebRTC 教程\nMDN WebRTC API\n谷歌codelab WebRT教程\ngithub上WebRTC各种例子\nsegemntfault上关于WebRTC的教程\n","wordCount":"369","inLanguage":"en","datePublished":"2018-02-09T12:56:12+08:00","dateModified":"2018-02-09T12:56:12+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/posts/2018/02/webrtc-tutorial-simple-video-chat/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/posts/>Posts</a></div><h1 class=post-title>120行代码实现 浏览器WebRTC视频聊天</h1><div class=post-meta><span title='2018-02-09 12:56:12 +0800 CST'>2018-02-09 12:56:12</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Eddie Wang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e5%87%86%e5%a4%87 aria-label="1. 准备">1. 准备</a></li><li><a href=#2-%e5%85%88%e4%b8%8a%e6%95%88%e6%9e%9c%e5%9b%be aria-label="2. 先上效果图">2. 先上效果图</a></li><li><a href=#3-%e5%86%8d%e4%b8%8a%e5%9c%a8%e7%ba%bf%e4%be%8b%e5%ad%90%e7%82%b9%e5%87%bb%e6%ad%a4%e5%a4%84httpswangduanduangithubiowebrtcdemoschat-with-your-friendhtml aria-label="3. 再上在线例子点击此处">3. 再上在线例子<a href=https://wangduanduan.github.io/webrtc/demos/chat-with-your-friend.html>点击此处</a></a></li><li><a href=#4-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label="4. 源码分析">4. 源码分析</a></li><li><a href=#5-webrtc%e7%ae%80%e4%bb%8b aria-label="5. WebRTC简介">5. WebRTC简介</a><ul><li><a href=#51-%e4%bb%8b%e7%bb%8d aria-label="5.1. 介绍">5.1. 介绍</a></li><li><a href=#52-%e5%9c%a8%e5%93%aa%e9%87%8c%e4%bd%bf%e7%94%a8webrtc aria-label="5.2. 在哪里使用WebRTC?">5.2. 在哪里使用WebRTC?</a></li><li><a href=#53-%e4%bb%80%e4%b9%88%e6%98%af%e4%bf%a1%e4%bb%a4 aria-label="5.3. 什么是信令">5.3. 什么是信令</a></li><li><a href=#54-%e4%bb%80%e4%b9%88%e6%98%afstun%e5%92%8cturn%e5%92%8cice aria-label="5.4. 什么是STUN和TURN和ICE?">5.4. 什么是STUN和TURN和ICE?</a></li><li><a href=#55-webrtc%e6%98%af%e5%90%a6%e5%ae%89%e5%85%a8 aria-label="5.5. WebRTC是否安全?">5.5. WebRTC是否安全?</a></li></ul></li><li><a href=#6-webrtc-%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label="6. WebRTC 参考资料">6. WebRTC 参考资料</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>本例子是参考<a href=https://www.scaledrone.com/blog/posts/webrtc-tutorial-simple-video-chat>webrtc-tutorial-simple-video-chat</a>做的。
这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。</p></blockquote><p><a href=https://github.com/wangduanduan/webrtc>本栗子的地址</a>
<a href=https://wangduanduan.github.io/webrtc/>本栗子的pages地址</a></p><p><code>因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的</code></p><h1 id=1-准备>1. 准备<a hidden class=anchor aria-hidden=true href=#1-准备>#</a></h1><ul><li>使用最新版谷歌浏览器（62版）</li><li>视频聊天中 一个是windows, 一个是mac</li><li>stun服务器使用谷歌的，trun使用<a href=https://www.scaledrone.com/>ScaleDrone</a>的sdk，这样我就不用管服务端了。</li></ul><h1 id=2-先上效果图>2. 先上效果图<a hidden class=anchor aria-hidden=true href=#2-先上效果图>#</a></h1><p><img loading=lazy src=https://wdd.js.org/img/images/20180209125722_GO0Ee0_Screenshot.jpeg alt></p><h1 id=3-再上在线例子点击此处httpswangduanduangithubiowebrtcdemoschat-with-your-friendhtml>3. 再上在线例子<a href=https://wangduanduan.github.io/webrtc/demos/chat-with-your-friend.html>点击此处</a><a hidden class=anchor aria-hidden=true href=#3-再上在线例子点击此处httpswangduanduangithubiowebrtcdemoschat-with-your-friendhtml>#</a></h1><h1 id=4-源码分析>4. 源码分析<a hidden class=anchor aria-hidden=true href=#4-源码分析>#</a></h1><pre tabindex=0><code>// 产生随机数
if (!location.hash) {
    location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16);
}
// 获取房间号
var roomHash = location.hash.substring(1);

// 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel
// 你也可以自己创建
var drone = new ScaleDrone(&#39;87fYv4ncOoa0Cjne&#39;);
// 房间名必须以 &#39;observable-&#39;开头
var roomName = &#39;observable-&#39; + roomHash;
var configuration = {
    iceServers: [{
        urls: &#39;stun:stun.l.google.com:19302&#39; // 使用谷歌的stun服务
    }]
};

var room;
var pc;
function onSuccess() {}

function onError(error) {
    console.error(error);
}

drone.on(&#39;open&#39;, function(error){
    if (error) { return console.error(error);}

    room = drone.subscribe(roomName);
    room.on(&#39;open&#39;, function(error){
        if (error) {onError(error);}
    });

    // 已经链接到房间后，就会收到一个 members 数组，代表房间里的成员
    // 这时候信令服务已经就绪
    room.on(&#39;members&#39;, function(members){
        console.log(&#39;MEMBERS&#39;, members);

        // 如果你是第二个链接到房间的人，就会创建offer
        var isOfferer = members.length === 2;
        startWebRTC(isOfferer);
    });
});

// 通过Scaledrone发送信令消息
function sendMessage(message) {
    drone.publish({
        room: roomName,
        message
    });
}

function startWebRTC(isOfferer) {
    pc = new RTCPeerConnection(configuration);

    // 当本地ICE Agent需要通过信号服务器发送信息到其他端时
    // 会触发icecandidate事件回调
    pc.onicecandidate = function(event){
        if (event.candidate) {
            sendMessage({ &#39;candidate&#39;: event.candidate });
        }
    };

    // 如果用户是第二个进入的人，就在negotiationneeded 事件后创建sdp
    if (isOfferer) {
        // onnegotiationneeded 在要求sesssion协商时发生
        pc.onnegotiationneeded = function() {
            // 创建本地sdp描述 SDP (Session Description Protocol) session描述协议
            pc.createOffer().then(localDescCreated).catch(onError);
        };
    }

    // 当远程数据流到达时，将数据流装载到video中
    pc.onaddstream = function(event){
        remoteVideo.srcObject = event.stream;
    };

    // 获取本地媒体流
    navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true,
    }).then( function(stream) {
        // 将本地捕获的视频流装载到本地video中
        localVideo.srcObject = stream;

        // 将本地流加入RTCPeerConnection 实例中 发送到其他端
        pc.addStream(stream);
    }, onError);

    // 从Scaledrone监听信令数据
    room.on(&#39;data&#39;, function(message, client){
        // 消息是我自己发送的，则不处理
        if (client.id === drone.clientId) {
            return;
        }

        if (message.sdp) {
            // 设置远程sdp, 在offer 或者 answer后
            pc.setRemoteDescription(new RTCSessionDescription(message.sdp), function(){
                // 当收到offer 后就接听
                if (pc.remoteDescription.type === &#39;offer&#39;) {
                    pc.createAnswer().then(localDescCreated).catch(onError);
                }
            }, onError);
        }
        else if (message.candidate) {
            // 增加新的 ICE canidatet 到本地的链接中
            pc.addIceCandidate(
                new RTCIceCandidate(message.candidate), onSuccess, onError
            );
        }
    });
}

function localDescCreated(desc) {
    pc.setLocalDescription(desc, function(){
        sendMessage({ &#39;sdp&#39;: pc.localDescription });
    },onError);
}
</code></pre><h1 id=5-webrtc简介>5. WebRTC简介<a hidden class=anchor aria-hidden=true href=#5-webrtc简介>#</a></h1><h2 id=51-介绍>5.1. 介绍<a hidden class=anchor aria-hidden=true href=#51-介绍>#</a></h2><p>WebRTC 是一个开源项目，用于Web浏览器之间进行实时音频视频通讯，数据传递。
WebRTC有几个JavaScript APIS。 点击链接去查看demo。</p><ul><li><a href>getUserMedia(): 捕获音频视频</a></li><li><a href>MediaRecorder: 记录音频视频</a></li><li><a href>RTCPeerConnection: 在用户之间传递音频流和视频流</a></li><li><a href>RTCDataChannel: 在用户之间传递文件流</a></li></ul><h2 id=52-在哪里使用webrtc>5.2. 在哪里使用WebRTC?<a hidden class=anchor aria-hidden=true href=#52-在哪里使用webrtc>#</a></h2><ul><li>Chrome</li><li>FireFox</li><li>Opera</li><li>Android</li><li>iOS</li></ul><h2 id=53-什么是信令>5.3. 什么是信令<a hidden class=anchor aria-hidden=true href=#53-什么是信令>#</a></h2><p>WebRTC使用<code>RTCPeerConnection</code>在浏览器之间传递流数据, 但是也需要一种机制去协调收发控制信息，这就是信令。信令的方法和协议并不是在WebRTC中明文规定的。 在codelad中用的是Node，也有许多其他的方法。</p><h2 id=54-什么是stun和turn和ice>5.4. 什么是STUN和TURN和ICE?<a hidden class=anchor aria-hidden=true href=#54-什么是stun和turn和ice>#</a></h2><blockquote><p>STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 <a href=https://zh.wikipedia.org/wiki/STUN>wikipedia STUN</a></p></blockquote><blockquote><p>TURN（全名Traversal Using Relay NAT, NAT中继穿透），是一种资料传输协议（data-transfer protocol）。允许在TCP或UDP的连线上跨越NAT或防火墙。
TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过取得应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通讯开始前与TURN server进行交互，并要求TURN server产生"relay port"，也就是relayed-transport-address。这时TURN server会建立peer，即远端端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将资料传送至peer，再由peer转传到另一方的TURN client。<a href=https://zh.wikipedia.org/wiki/TURN>wikipedia TURN</a></p></blockquote><blockquote><p>ICE （Interactive Connectivity Establishment，互动式连接建立 ），一种综合性的NAT穿越的技术。
互动式连接建立是由IETF的MMUSIC工作组开发出来的一种framework，可整合各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。[wikipedia ICE]</p></blockquote><p><img loading=lazy src=https://wdd.js.org/img/images/20180209125753_F5e9Xf_Screenshot.jpeg alt></p><p><img loading=lazy src=https://wdd.js.org/img/images/20180209125803_bcjg2P_Screenshot.jpeg alt></p><p>WebRTC被设计用于点对点之间工作，因此用户可以通过最直接的途径连接。然而，WebRTC的构建是为了应付现实中的网络: <code>客户端应用程序需要穿越NAT网关和防火墙，并且对等网络需要在直接连接失败的情况下进行回调。</code> 作为这个过程的一部分，WebRTC api使用STUN服务器来获取计算机的IP地址，并将服务器作为中继服务器运行，以防止对等通信失败。(现实世界中的WebRTC更详细地解释了这一点。)</p><h2 id=55-webrtc是否安全>5.5. WebRTC是否安全?<a hidden class=anchor aria-hidden=true href=#55-webrtc是否安全>#</a></h2><p>WebRTC组件是强制要求加密的，并且它的JavaScript APIS只能在安全的域下使用(HTTPS 或者 localhost)。信令机制并没有被WebRTC标准定义，所以是否使用安全的协议就取决于你自己了。</p><h1 id=6-webrtc-参考资料>6. WebRTC 参考资料<a hidden class=anchor aria-hidden=true href=#6-webrtc-参考资料>#</a></h1><ul><li><p><a href=https://webrtc.org/>官网教程</a></p></li><li><p><a href=https://www.scaledrone.com/blog/posts/webrtc-tutorial-simple-video-chat>WebRTC 简单的视频聊天</a> <a href=https://github.com/ScaleDrone/webrtc>repo</a></p></li><li><p><a href=https://www.tutorialspoint.com/webrtc/index.html>WebRTC 教程</a></p></li><li><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API>MDN WebRTC API</a></p></li><li><p><a href=https://codelabs.developers.google.com/codelabs/webrtc-web/#0>谷歌codelab WebRT教程</a></p></li><li><p><a href=https://github.com/webrtc/samples>github上WebRTC各种例子</a></p></li><li><p><a href=https://segmentfault.com/bookmark/1230000011819985>segemntfault上关于WebRTC的教程</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wdd.js.org/tags/webrtc/>WebRTC</a></li></ul><nav class=paginav><a class=prev href=https://wdd.js.org/posts/2018/02/one-command-create-static-file-server/><span class=title>« Prev Page</span><br><span>一行命令搭建简易静态文件http服务器</span></a>
<a class=next href=https://wdd.js.org/posts/2018/02/how-to-write-a-technical-document/><span class=title>Next Page »</span><br><span>如何写好技术文档?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>