<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何写好接口文档？ | 洞香春</title><meta name=keywords content="接口文档"><meta name=description content='
1. HTTP携带信息的方式

url
headers
body: 包括请求体，响应体

2. 分离通用信息
一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数
3. 路径中的参数表达式
URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}
例如：

/api/user/{userId}
/api/user/{userType}?age={age}&amp;gender={gender}

4. 数据模型定义
数据模型定义包括：

路径与查询字符串参数模型
请求体参数模型
响应体参数模型

数据模型的最小数据集：

名称
是否必须
说明


“最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。
一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。
另外：数据模型非常建议使用表格来表现。
举个栗子🌰：

  
      
          名称
          是否必须
          说明
      
  
  
      
          userType
          是
          用户类型。commom表示普通用户，vip表示vip用户
      
      
          age
          否
          用户年龄
      
      
          gender
          否
          用户性别。1表示男，0表示女
      
  

5. 请求示例
// general 
POST http://www.testapi.com/api/user

// request payload
{
	"name": "qianxun",
	"age": 14,
	"like": ["music", "reading"],
	"userType": "vip"
}

// response
{
	"id": "asdkfjalsdkf"
}
6. 异常处理
异常处理最小数据集'><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/posts/2018/01/how-to-write-better-api-docs/><link crossorigin=anonymous href=/assets/css/stylesheet.a2acda249b8eac62938bb2d2f1c562c5f74d5728640d2a1a7d6aeaec5c50ef24.css integrity="sha256-oqzaJJuOrGKTi7LS8cVixfdNVyhkDSoafWrq7FxQ7yQ=" rel="preload stylesheet" as=style><link rel=icon href=https://wdd.js.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/favicon.ico><link rel=apple-touch-icon href=https://wdd.js.org/favicon.ico><link rel=mask-icon href=https://wdd.js.org/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wdd.js.org/posts/2018/01/how-to-write-better-api-docs/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/firacode@6.2.0/distr/fira_code.css><style>body{font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,helvetica neue,Arial,noto sans,sans-serif,apple color emoji,segoe ui emoji;font-size:16px;line-height:1.6;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}h1,h2,h3,h4,h5,h6{font-weight:600;letter-spacing:-.02em}code,pre{font-family:fira code,jetbrains mono,Consolas,monospace;font-variant-ligatures:normal;font-size:.95em}</style><meta property="og:url" content="https://wdd.js.org/posts/2018/01/how-to-write-better-api-docs/"><meta property="og:site_name" content="洞香春"><meta property="og:title" content="如何写好接口文档？"><meta property="og:description" content='
1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息 一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数
3. 路径中的参数表达式 URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}
例如：
/api/user/{userId} /api/user/{userType}?age={age}&amp;gender={gender} 4. 数据模型定义 数据模型定义包括：
路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集：
名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。
一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。
另外：数据模型非常建议使用表格来表现。
举个栗子🌰：
名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例 // general POST http://www.testapi.com/api/user // request payload { "name": "qianxun", "age": 14, "like": ["music", "reading"], "userType": "vip" } // response { "id": "asdkfjalsdkf" } 6. 异常处理 异常处理最小数据集'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-29T22:01:55+08:00"><meta property="article:modified_time" content="2018-01-29T22:01:55+08:00"><meta property="article:tag" content="接口文档"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何写好接口文档？"><meta name=twitter:description content='
1. HTTP携带信息的方式

url
headers
body: 包括请求体，响应体

2. 分离通用信息
一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数
3. 路径中的参数表达式
URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}
例如：

/api/user/{userId}
/api/user/{userType}?age={age}&amp;gender={gender}

4. 数据模型定义
数据模型定义包括：

路径与查询字符串参数模型
请求体参数模型
响应体参数模型

数据模型的最小数据集：

名称
是否必须
说明


“最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。
一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。
另外：数据模型非常建议使用表格来表现。
举个栗子🌰：

  
      
          名称
          是否必须
          说明
      
  
  
      
          userType
          是
          用户类型。commom表示普通用户，vip表示vip用户
      
      
          age
          否
          用户年龄
      
      
          gender
          否
          用户性别。1表示男，0表示女
      
  

5. 请求示例
// general 
POST http://www.testapi.com/api/user

// request payload
{
	"name": "qianxun",
	"age": 14,
	"like": ["music", "reading"],
	"userType": "vip"
}

// response
{
	"id": "asdkfjalsdkf"
}
6. 异常处理
异常处理最小数据集'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wdd.js.org/posts/"},{"@type":"ListItem","position":2,"name":"如何写好接口文档？","item":"https://wdd.js.org/posts/2018/01/how-to-write-better-api-docs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何写好接口文档？","name":"如何写好接口文档？","description":"\n1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息 一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数\n3. 路径中的参数表达式 URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}\n例如：\n/api/user/{userId} /api/user/{userType}?age={age}\u0026amp;gender={gender} 4. 数据模型定义 数据模型定义包括：\n路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集：\n名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。\n一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。\n另外：数据模型非常建议使用表格来表现。\n举个栗子🌰：\n名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例 // general POST http://www.testapi.com/api/user // request payload { \u0026#34;name\u0026#34;: \u0026#34;qianxun\u0026#34;, \u0026#34;age\u0026#34;: 14, \u0026#34;like\u0026#34;: [\u0026#34;music\u0026#34;, \u0026#34;reading\u0026#34;], \u0026#34;userType\u0026#34;: \u0026#34;vip\u0026#34; } // response { \u0026#34;id\u0026#34;: \u0026#34;asdkfjalsdkf\u0026#34; } 6. 异常处理 异常处理最小数据集\n","keywords":["接口文档"],"articleBody":"\n1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息 一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数\n3. 路径中的参数表达式 URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}\n例如：\n/api/user/{userId} /api/user/{userType}?age={age}\u0026gender={gender} 4. 数据模型定义 数据模型定义包括：\n路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集：\n名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。\n一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。\n另外：数据模型非常建议使用表格来表现。\n举个栗子🌰：\n名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例 // general POST http://www.testapi.com/api/user // request payload { \"name\": \"qianxun\", \"age\": 14, \"like\": [\"music\", \"reading\"], \"userType\": \"vip\" } // response { \"id\": \"asdkfjalsdkf\" } 6. 异常处理 异常处理最小数据集\n状态码 说明 解决方案 举个栗子🌰：\n状态码 说明 解决方案 401 用户名密码错误 检查用户名密码是否正确 424 超过最大在线数量 请在控制台修改最大在线数量 之前我一直不想把解决方案加入异常处理的最小数据集，但是对于很多开发者来说，即使它知道424代表超过最大在线数量。如果你不告诉如果解决这个问题，那么他们可能就会直接来问你。所以最好能够一步到位，直接告诉他应该如何解决，这样省时省力。\n7. 如何组织？ 7.1. 一个创建用户的例子：创建用户 1 请求示例\n// general POST http://www.testapi.com/api/user/vip/?token=abcdefg // request payload { \"name\": \"qianxun\", \"age\": 14, \"like\": [\"music\", \"reading\"] } // response { \"id\": \"asdkfjalsdkf\" } 2 路径与查询字符串参数模型\nPOST http://www.testapi.com/api/user/{userType}/?token={token}\n名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 token 是 认证令牌 3 请求体参数模型\n名称 是否必须 说明 name 是 用户名。4-50个字符 age 否 年龄 like 否 爱好。最多20个 4 响应体参数模型\n名称 说明 id 用户id 5 异常处理\n状态码 说明 解决方案 401 token过期 请重新申请token 424 超过最大在创建人数 请在控制台修改最大创建人数 7.2. 这样组织的原因 请求示例: 请求示例放在第一位的原因是，要用最快的方式告诉开发者，这个接口应该如何请求 路径与查询字符串参数模型： 使用mustache包裹参数 请求体参数模型：如果没有请求体，可以不写 响应体参数模型： 异常处理 8. 文档提供的形式 文档建议由一下两种形式，在线文档，pdf文档。\n在线文档 更新方便 易于随时阅读 易于查找 pdf文档 内容表现始终如一，不依赖文档阅读器 文档只读，不会被轻易修改 其中由于是面对第三方开发者，公开的在线文档必须提供；由于某些特殊的原因，可能需要提供文件形式的文档，建议提供pdf文档。当然，以下的文档形式是非常不建议提供的：\nword文档 markdown文档 word文档和markdown文档有以下缺点：\n文档的表现形式非常依赖文档查看器：各个版本的word文档对word的表现形式差异很大，可能在你的电脑上内容表现很好的文档，到别人的电脑上就会一团乱麻；另外markdown文件也是如此。而且markdown中引入文件只能依靠图片链接，如果文档中含有图片，很可能会出现图片丢失的情况。 文档无法只读：文档无法只读，就有可能会被第三方开发者在不经意间修改，那么文档就无法保证其准确性了。 总结一下，文档形式的要点：\n只读性：保证文档不会被开发者轻易修改 一致性：保证文档在不同设备，不同文档查看器上内容表现始终如一 易于版本管理：文档即软件（DAAS: Document as a Software），一般意义上说软件 = 数据 + 算法, 但是我认为文档也是一种组成软件的重要形式。既然软件需要版本管理，文档的版本管理也是比不可少的。 ","wordCount":"194","inLanguage":"en","datePublished":"2018-01-29T22:01:55+08:00","dateModified":"2018-01-29T22:01:55+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/posts/2018/01/how-to-write-better-api-docs/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org/ accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/favicon.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/kamailio/ title=Kamailio><span>Kamailio</span></a></li><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org/>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">如何写好接口文档？</h1><div class=post-meta><span title='2018-01-29 22:01:55 +0800 CST'>2018-01-29 22:01:55</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Eddie Wang</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2018/01/how-to-write-better-api-docs.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-http%e6%90%ba%e5%b8%a6%e4%bf%a1%e6%81%af%e7%9a%84%e6%96%b9%e5%bc%8f aria-label="1. HTTP携带信息的方式">1. HTTP携带信息的方式</a></li><li><a href=#2-%e5%88%86%e7%a6%bb%e9%80%9a%e7%94%a8%e4%bf%a1%e6%81%af aria-label="2. 分离通用信息">2. 分离通用信息</a></li><li><a href=#3-%e8%b7%af%e5%be%84%e4%b8%ad%e7%9a%84%e5%8f%82%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f aria-label="3. 路径中的参数表达式">3. 路径中的参数表达式</a></li><li><a href=#4-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e5%ae%9a%e4%b9%89 aria-label="4. 数据模型定义">4. 数据模型定义</a></li><li><a href=#5-%e8%af%b7%e6%b1%82%e7%a4%ba%e4%be%8b aria-label="5. 请求示例">5. 请求示例</a></li><li><a href=#6-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86 aria-label="6. 异常处理">6. 异常处理</a></li><li><a href=#7-%e5%a6%82%e4%bd%95%e7%bb%84%e7%bb%87 aria-label="7. 如何组织？">7. 如何组织？</a><ul><li><a href=#71-%e4%b8%80%e4%b8%aa%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7%e7%9a%84%e4%be%8b%e5%ad%90%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7 aria-label="7.1. 一个创建用户的例子：创建用户">7.1. 一个创建用户的例子：创建用户</a></li><li><a href=#72-%e8%bf%99%e6%a0%b7%e7%bb%84%e7%bb%87%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label="7.2. 这样组织的原因">7.2. 这样组织的原因</a></li></ul></li><li><a href=#8-%e6%96%87%e6%a1%a3%e6%8f%90%e4%be%9b%e7%9a%84%e5%bd%a2%e5%bc%8f aria-label="8. 文档提供的形式">8. 文档提供的形式</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><img loading=lazy src=http://p394yuy0c.bkt.clouddn.com/20180128223141_GeUnII_Jietu20180128-223059.jpeg></p><h1 id=1-http携带信息的方式>1. HTTP携带信息的方式<a hidden class=anchor aria-hidden=true href=#1-http携带信息的方式>#</a></h1><ul><li>url</li><li>headers</li><li>body: 包括请求体，响应体</li></ul><h1 id=2-分离通用信息>2. 分离通用信息<a hidden class=anchor aria-hidden=true href=#2-分离通用信息>#</a></h1><p>一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数</p><h1 id=3-路径中的参数表达式>3. 路径中的参数表达式<a hidden class=anchor aria-hidden=true href=#3-路径中的参数表达式>#</a></h1><p>URL中参数表达式使用<code>{}</code>的形式，参数包裹在大括号之中<code>{paramName}</code></p><p>例如：</p><ul><li><code>/api/user/{userId}</code></li><li><code>/api/user/{userType}?age={age}&amp;gender={gender}</code></li></ul><h1 id=4-数据模型定义>4. 数据模型定义<a hidden class=anchor aria-hidden=true href=#4-数据模型定义>#</a></h1><p>数据模型定义包括：</p><ul><li>路径与查询字符串参数模型</li><li>请求体参数模型</li><li>响应体参数模型</li></ul><p>数据模型的最小数据集：</p><ul><li>名称</li><li>是否必须</li><li>说明</li></ul><blockquote><p>“最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。</p></blockquote><p>一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。</p><p>另外：<code>数据模型非常建议使用表格来表现</code>。</p><p>举个栗子🌰：</p><table><thead><tr><th>名称</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>userType</td><td>是</td><td>用户类型。<code>commom</code>表示普通用户，<code>vip</code>表示vip用户</td></tr><tr><td>age</td><td>否</td><td>用户年龄</td></tr><tr><td>gender</td><td>否</td><td>用户性别。<code>1</code>表示男，<code>0</code>表示女</td></tr></tbody></table><h1 id=5-请求示例>5. 请求示例<a hidden class=anchor aria-hidden=true href=#5-请求示例>#</a></h1><pre tabindex=0><code>// general 
POST http://www.testapi.com/api/user

// request payload
{
	&#34;name&#34;: &#34;qianxun&#34;,
	&#34;age&#34;: 14,
	&#34;like&#34;: [&#34;music&#34;, &#34;reading&#34;],
	&#34;userType&#34;: &#34;vip&#34;
}

// response
{
	&#34;id&#34;: &#34;asdkfjalsdkf&#34;
}
</code></pre><h1 id=6-异常处理>6. 异常处理<a hidden class=anchor aria-hidden=true href=#6-异常处理>#</a></h1><p>异常处理最小数据集</p><ul><li>状态码</li><li>说明</li><li>解决方案</li></ul><p>举个栗子🌰：</p><table><thead><tr><th>状态码</th><th>说明</th><th>解决方案</th></tr></thead><tbody><tr><td>401</td><td>用户名密码错误</td><td>检查用户名密码是否正确</td></tr><tr><td>424</td><td>超过最大在线数量</td><td>请在控制台修改最大在线数量</td></tr></tbody></table><p>之前我一直不想把解决方案加入异常处理的最小数据集，但是对于很多开发者来说，即使它知道<code>424</code>代表<code>超过最大在线数量</code>。如果你不告诉如果解决这个问题，那么他们可能就会直接来问你。所以最好能够一步到位，直接告诉他应该如何解决，这样省时省力。</p><h1 id=7-如何组织>7. 如何组织？<a hidden class=anchor aria-hidden=true href=#7-如何组织>#</a></h1><h2 id=71-一个创建用户的例子创建用户>7.1. 一个创建用户的例子：创建用户<a hidden class=anchor aria-hidden=true href=#71-一个创建用户的例子创建用户>#</a></h2><p><strong>1 请求示例</strong></p><pre tabindex=0><code>// general 
POST http://www.testapi.com/api/user/vip/?token=abcdefg

// request payload
{
	&#34;name&#34;: &#34;qianxun&#34;,
	&#34;age&#34;: 14,
	&#34;like&#34;: [&#34;music&#34;, &#34;reading&#34;]
}

// response
{
	&#34;id&#34;: &#34;asdkfjalsdkf&#34;
}
</code></pre><p><strong>2 路径与查询字符串参数模型</strong></p><p><code>POST http://www.testapi.com/api/user/{userType}/?token={token}</code></p><table><thead><tr><th>名称</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>userType</td><td>是</td><td>用户类型。<code>commom</code>表示普通用户，<code>vip</code>表示vip用户</td></tr><tr><td>token</td><td>是</td><td>认证令牌</td></tr></tbody></table><p><strong>3 请求体参数模型</strong></p><table><thead><tr><th>名称</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>是</td><td>用户名。4-50个字符</td></tr><tr><td>age</td><td>否</td><td>年龄</td></tr><tr><td>like</td><td>否</td><td>爱好。最多20个</td></tr></tbody></table><p><strong>4 响应体参数模型</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>用户id</td></tr></tbody></table><p><strong>5 异常处理</strong></p><table><thead><tr><th>状态码</th><th>说明</th><th>解决方案</th></tr></thead><tbody><tr><td>401</td><td>token过期</td><td>请重新申请token</td></tr><tr><td>424</td><td>超过最大在创建人数</td><td>请在控制台修改最大创建人数</td></tr></tbody></table><h2 id=72-这样组织的原因>7.2. 这样组织的原因<a hidden class=anchor aria-hidden=true href=#72-这样组织的原因>#</a></h2><ol><li><code>请求示例</code>: 请求示例放在第一位的原因是，要用<code>最快的方式</code>告诉开发者，这个接口应该如何请求</li><li><code>路径与查询字符串参数模型</code>： 使用<code>mustache</code>包裹参数</li><li><code>请求体参数模型</code>：如果没有请求体，可以不写</li><li><code>响应体参数模型</code>：</li><li><code>异常处理</code></li></ol><h1 id=8-文档提供的形式>8. 文档提供的形式<a hidden class=anchor aria-hidden=true href=#8-文档提供的形式>#</a></h1><p>文档建议由一下两种形式，<code>在线文档</code>，<code>pdf文档</code>。</p><ul><li><code>在线文档</code><ul><li>更新方便</li><li>易于随时阅读</li><li>易于查找</li></ul></li><li><code>pdf文档</code><ul><li>内容表现始终如一，不依赖文档阅读器</li><li>文档只读，不会被轻易修改</li></ul></li></ul><p>其中由于是面对第三方开发者，<code>公开的在线文档必须提供</code>；由于某些特殊的原因，可能需要提供文件形式的文档，建议提供pdf文档。当然，以下的文档形式是<code>非常不建议</code>提供的：</p><ul><li>word文档</li><li>markdown文档</li></ul><p>word文档和markdown文档有以下缺点：</p><ul><li><code>文档的表现形式非常依赖文档查看器</code>：各个版本的word文档对word的表现形式差异很大，可能在你的电脑上内容表现很好的文档，到别人的电脑上就会一团乱麻；另外markdown文件也是如此。而且markdown中引入文件只能依靠图片链接，如果文档中含有图片，很可能会出现图片丢失的情况。</li><li><code>文档无法只读</code>：文档无法只读，就有可能会被第三方开发者在不经意间修改，那么文档就无法保证其准确性了。</li></ul><p>总结一下，文档形式的要点：</p><ul><li><code>只读性</code>：保证文档不会被开发者轻易修改</li><li><code>一致性</code>：保证文档在不同设备，不同文档查看器上内容表现始终如一</li><li><code>易于版本管理</code>：文档即软件（DAAS: Document as a Software），一般意义上说<code>软件 = 数据 + 算法</code>, 但是我认为<code>文档也是一种组成软件的重要形式</code>。既然软件需要版本管理，文档的版本管理也是比不可少的。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wdd.js.org/tags/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/>接口文档</a></li></ul><nav class=paginav><a class=prev href=https://wdd.js.org/posts/2018/01/fork-sync-learn/><span class=title>« Prev</span><br><span>git合并上游仓库即同步fork后的仓库</span>
</a><a class=next href=https://wdd.js.org/posts/2018/01/ie11-without-devtool/><span class=title>Next »</span><br><span>win7 ie11 开发者工具打开后一片空白</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=wangduanduan/wangduanduan.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxMTkyMjMyNjA=" data-category=Announcements data-category-id=DIC_kwDOBxsz3M4CAjBq data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://wdd.js.org/>洞香春</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>