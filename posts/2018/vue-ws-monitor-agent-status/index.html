<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vue+websocket+stompjs 实时监控坐席状态demo | 洞香春</title><meta name=keywords content="Vue,WebSocket,stompjs"><meta name=description content="由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。
2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。
html
<!DOCTYPE html> <html lang=&#34;zh-cn&#34;> <head> <meta charset=&#34;utf-8&#34;> <link href=&#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&#34; rel=&#34;stylesheet&#34;> </head> <body> <table class=&#34;table&#34; id=&#34;event-queue&#34;> <thead> <tr> <th>当前状态</th> <th>状态改变时间</th> <th>姓名</th> <th>工号</th> <th>分机号</th> <th>对方号码</th> <th>呼入数</th> <th>呼出数</th> </tr> </thead> <tbody> <tr v-for=&#34;item in eventQueue&#34;> <td>{{item.agentStatus | transAgentStatus}}</td> <td>{{item.agentStatusTime}}</td> <td>{{item.userName}}</td> <td>{{item.loginName}}</td> <td>{{item.deviceId}}</td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <script src=&#34;http://cdn.bootcss.com/vue/1.0.26/vue.js&#34;></script> <script src=&#34;js/websocket-suport.min.js&#34;></script> <script src=&#34;js/main.js&#34;></script> </body> </html> js
var tm = (function(){ var App = function(){}; var app = App."><meta name=author content="王端端"><link rel=canonical href=https://wdd.js.org/posts/2018/vue-ws-monitor-agent-status/><meta name=google-site-verification content="G-SGW660ZWKM"><link crossorigin=anonymous href=/assets/css/stylesheet.min.6aef73bcd11b501f30d40511dda695ff4635a6911499b91e84cfbca3c398c0e8.css integrity="sha256-au9zvNEbUB8w1AUR3aaV/0Y1ppEUmbkehM+8o8OYwOg=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/logo.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/logo.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/logo.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/logo.ico><link rel=apple-touch-icon href=https://wdd.js.org/logo.ico><link rel=mask-icon href=https://wdd.js.org/logo.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-SGW660ZWKM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SGW660ZWKM",{anonymize_ip:!1})}</script><meta property="og:title" content="Vue+websocket+stompjs 实时监控坐席状态demo"><meta property="og:description" content="由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。
2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。
html
<!DOCTYPE html> <html lang=&#34;zh-cn&#34;> <head> <meta charset=&#34;utf-8&#34;> <link href=&#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&#34; rel=&#34;stylesheet&#34;> </head> <body> <table class=&#34;table&#34; id=&#34;event-queue&#34;> <thead> <tr> <th>当前状态</th> <th>状态改变时间</th> <th>姓名</th> <th>工号</th> <th>分机号</th> <th>对方号码</th> <th>呼入数</th> <th>呼出数</th> </tr> </thead> <tbody> <tr v-for=&#34;item in eventQueue&#34;> <td>{{item.agentStatus | transAgentStatus}}</td> <td>{{item.agentStatusTime}}</td> <td>{{item.userName}}</td> <td>{{item.loginName}}</td> <td>{{item.deviceId}}</td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <script src=&#34;http://cdn.bootcss.com/vue/1.0.26/vue.js&#34;></script> <script src=&#34;js/websocket-suport.min.js&#34;></script> <script src=&#34;js/main.js&#34;></script> </body> </html> js
var tm = (function(){ var App = function(){}; var app = App."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/posts/2018/vue-ws-monitor-agent-status/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-07T09:36:49+00:00"><meta property="article:modified_time" content="2018-02-07T09:36:49+00:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Vue+websocket+stompjs 实时监控坐席状态demo"><meta name=twitter:description content="由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。
2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。
html
<!DOCTYPE html> <html lang=&#34;zh-cn&#34;> <head> <meta charset=&#34;utf-8&#34;> <link href=&#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&#34; rel=&#34;stylesheet&#34;> </head> <body> <table class=&#34;table&#34; id=&#34;event-queue&#34;> <thead> <tr> <th>当前状态</th> <th>状态改变时间</th> <th>姓名</th> <th>工号</th> <th>分机号</th> <th>对方号码</th> <th>呼入数</th> <th>呼出数</th> </tr> </thead> <tbody> <tr v-for=&#34;item in eventQueue&#34;> <td>{{item.agentStatus | transAgentStatus}}</td> <td>{{item.agentStatusTime}}</td> <td>{{item.userName}}</td> <td>{{item.loginName}}</td> <td>{{item.deviceId}}</td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <script src=&#34;http://cdn.bootcss.com/vue/1.0.26/vue.js&#34;></script> <script src=&#34;js/websocket-suport.min.js&#34;></script> <script src=&#34;js/main.js&#34;></script> </body> </html> js
var tm = (function(){ var App = function(){}; var app = App."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://wdd.js.org/posts/"},{"@type":"ListItem","position":3,"name":"Vue+websocket+stompjs 实时监控坐席状态demo","item":"https://wdd.js.org/posts/2018/vue-ws-monitor-agent-status/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vue+websocket+stompjs 实时监控坐席状态demo","name":"Vue\u002bwebsocket\u002bstompjs 实时监控坐席状态demo","description":"由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。\n2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。\nhtml\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-cn\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34; id=\u0026#34;event-queue\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;当前状态\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;状态改变时间\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;工号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;分机号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;对方号码\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;呼入数\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;呼出数\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in eventQueue\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{item.agentStatus | transAgentStatus}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.agentStatusTime}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.userName}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.loginName}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.deviceId}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/vue/1.0.26/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/websocket-suport.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; js\nvar tm = (function(){ var App = function(){}; var app = App.","keywords":["Vue","WebSocket","stompjs"],"articleBody":"由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。\n2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。\nhtml\n\u003c!DOCTYPE html\u003e 当前状态 状态改变时间 姓名 工号 分机号 对方号码 呼入数 呼出数 {{item.agentStatus | transAgentStatus}} {{item.agentStatusTime}} {{item.userName}} {{item.loginName}} {{item.deviceId}} js\nvar tm = (function(){ var App = function(){}; var app = App.prototype; var config = { dest: 'http://xxx.xxx.xxx.xxx:58080/mvc/stomp', topic: '/topic/csta/namespace/testwdd2.com' // topic: '/topic/csta/device/8002@testwdd2.com' }; var eventQueue = []; var vm = new Vue({ el:'#event-queue', data:{ eventQueue: eventQueue } }); Vue.filter('transAgentStatus', function(status){ switch(status){ case 'NotReady': return '未就绪'; case 'WorkNotReady': return '话后处理状态'; case 'Idle': return '就绪'; case 'OnCallIn': return '呼入通话'; case 'OnCallOut': return '呼出通话'; case 'Logout': return '登出'; case 'Ringing': return '振铃'; case 'OffHook': return '摘机'; case 'CallInternal': return '内部通话'; case 'Dailing': return '外线已经振铃'; case 'Ringback': return '回铃'; case 'Conference': return '会议'; case 'OnHold': return '保持'; case 'Other': return '其他'; } return ''; }); /** * [render description] * @Author Wdd * @DateTime 2016-12-26T16:06:16+0800 * @param {[string]} tpl [模板字符串] * @param {[object]} data [data对象] * @return {[string]} [渲染后的字符串] */ app.render = function(tpl,data){ var re = /{{([^}]+)?}}/g; while(match = re.exec(tpl)){ tpl = tpl.replace(match[0],data[match[1]] || ''); } return tpl; }; app.initWebSocket = function(dest, topic){ dest = dest || config.dest; topic = topic || config.topic; var socket = new SockJS(dest); var ws = Stomp.over(socket); ws.connect({}, function(frame) { ws.subscribe(topic, function(event) { // var eventInfo = JSON.parse(event.body); app.handerEvent(JSON.parse(event.body)); }); }, function(frame) { console.log(frame); console.error(new Date() + 'websocket失去连接'); }); }; /** * [findAgentIndex description] * @Author Wdd * @DateTime 2016-12-28T10:34:13+0800 * @param {[string]} agentId [description] * @return {[int]} [description] */ app.findAgentIndex = function(agentId){ for(var i = eventQueue.length - 1; i \u003e= 0; i--){ if(eventQueue[i].agentId === agentId){ return i; } } return -1; }; /** * [handerEvent 处理websocket事件] * @Author Wdd * @DateTime 2016-12-28T10:33:03+0800 * @param {[object]} data [description] * @return {[type]} [description] */ app.handerEvent = function(data){ if(data.eventType === 'CallEvent'){ return; } if(!data.eventSrc){ return; } var eventItem = { agentStatus: '', eventName: data.eventName, agentId: '', loginName: '', userName: '', deviceId: data.deviceId, agentStatusTime: '' }; var agent = data.eventSrc.agent || ''; if(agent){ eventItem.agentId = agent.agentId; eventItem.loginName = agent.loginName; eventItem.userName = agent.userName; eventItem.agentStatus = agent.agentStatus; eventItem.agentStatusTime = agent.agentStatusTime; } // 针对登出事件的agentId在外层 else if(data.agentMode){ eventItem.agentStatus = data.agentMode; eventItem.agentId = data.agentId; } else if(data.agentStatus){ eventItem.agentStatus = data.agentStatus; } if(!eventItem.agentId){ return; } var itemIndex = app.findAgentIndex(eventItem.agentId); // 新的座席加入 if(itemIndex === -1){ eventQueue.push(eventItem); } // 更新已有座席的状态 else{ eventQueue[itemIndex].agentStatus = eventItem.agentStatus; eventQueue[itemIndex].agentStatusTime = eventItem.agentStatusTime; eventQueue[itemIndex].eventName = eventItem.eventName; } }; return new App(); })(); 打开控制台，输入tm.initWebsocket()后，websocket连接正常。 之后坐席状态改变，可以看到有事件推送过来。 看下整个页面： 最后，这个小小的监控如果用jQuery写，也可以，不过就是太坑了，每次都要去找到Dom元素，再更新DOM，用了Vue这类的框架，页面的dom操作完全不用关心了，真是太舒服了。\\(^o^)/\n1. 关于stomp的重连 程序后服务端使用RabbitMQ 这里我直接引用我的另一个项目的部分代码，这个没有使用SockJS， 直接使用浏览器原生的WebSocket。 重连的原理很简单，就是检测到断开时，去调用我的reconnectWs方法，这里我也做了重连的次数限制。\ninitWebSocket: function(callback, errorCallback) { callback = callback || function(){}; if(ws \u0026\u0026 ws.connected){ return; } Config.isManCloseWs = false; var url = Config.wsProtocol + Config.SDK + Config.eventPort + Config.eventBasePath + \"/websocket\"; if(typeof WebSocket != 'function'){ alert('您的浏览器版本太太太老了，请升级你的浏览器到IE11，或使用任何支持原生WebSocket的浏览器'); return; } try{ var socket = new WebSocket(url); } catch(e){ console.log(e); return; } var wsHeartbeatId = ''; ws = Stomp.over(socket); if(!Config.useWsLog){ ws.debug = null; } ws.connect({}, function(frame) { Config.currentReconnectTimes = 0; var dest = Config.newWsTopic + env.loginId.replace(/\\./g,'_'); var lastEventSerial = ''; ws.subscribe(dest, function(event) { var eventInfo = {}; try{ eventInfo = JSON.parse(event.body); delete eventInfo.params; delete eventInfo._type; delete eventInfo.topics; } catch(e){ console.log(e); return; } if(lastEventSerial === eventInfo.serial){ util.error('Error: event repeat sent !'); return; } else{ lastEventSerial = eventInfo.serial; } if(Config.useEventLog){ util.debugout.log(' ' + JSON.stringify(eventInfo)); } eventHandler.deliverEvent(eventInfo); }); callback(); }, function(frame) { // websocket upexpected disconnected // maybe network disconnection, or browser in offline // this condition will emit wsDisconnected event if(Config.isManCloseWs){return;} errorCallback(); util.log(frame); util.error(new Date() + 'websocket disconnect'); // clearInterval(wsHeartbeatId); if(Config.currentReconnectTimes \u003c Config.maxReconnectTimes){ Config.currentReconnectTimes++; util.reconnectWs(); } else{ var errorMsg = { eventName: 'wsDisconnected', msg: 'websocket disconnect' }; wellClient.ui.main({ eventName:'wsDisconnected' }); util.debugout.log('\u003e\u003e\u003e websocket disconnect'); wellClient.triggerInnerOn(errorMsg); } }); }, reconnectWs: function(){ setTimeout(function(){ util.log('\u003e\u003e\u003e try to reconnect'); util.debugout.log('\u003e\u003e\u003e try to reconnect'); util.initWebSocket(function(){},function(){}); }, Config.timeout * 1000); }, 2. 参考 STOMP Over WebSocket\n","wordCount":"629","inLanguage":"en","datePublished":"2018-02-07T09:36:49Z","dateModified":"2018-02-07T09:36:49Z","author":{"@type":"Person","name":"王端端"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/posts/2018/vue-ws-monitor-agent-status/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/logo.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/logo.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/posts/>Posts</a></div><h1 class=post-title>Vue+websocket+stompjs 实时监控坐席状态demo</h1><div class=post-meta><span title='2018-02-07 09:36:49 +0000 UTC'>2018-02-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;王端端&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2018/vue-ws-monitor-agent-status.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e5%85%b3%e4%ba%8estomp%e7%9a%84%e9%87%8d%e8%bf%9e aria-label="1. 关于stomp的重连">1. 关于stomp的重连</a></li><li><a href=#2-%e5%8f%82%e8%80%83 aria-label="2. 参考">2. 参考</a></li></ul></div></details></div><div class=post-content><p>由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。</p><p>2018-01-09新增：
后端的MQ事件结构现在也改了，该demo只能看看了。</p><p>html</p><pre tabindex=0><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;zh-cn&#34;&gt;
&lt;head&gt;
	&lt;meta charset=&#34;utf-8&#34;&gt;
	&lt;link href=&#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&#34; rel=&#34;stylesheet&#34;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;table class=&#34;table&#34; id=&#34;event-queue&#34;&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;当前状态&lt;/th&gt;
			&lt;th&gt;状态改变时间&lt;/th&gt;
			&lt;th&gt;姓名&lt;/th&gt;
			&lt;th&gt;工号&lt;/th&gt;
			&lt;th&gt;分机号&lt;/th&gt;
			&lt;th&gt;对方号码&lt;/th&gt;
			&lt;th&gt;呼入数&lt;/th&gt;
			&lt;th&gt;呼出数&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr v-for=&#34;item in eventQueue&#34;&gt;
			&lt;td&gt;{{item.agentStatus | transAgentStatus}}&lt;/td&gt;
			&lt;td&gt;{{item.agentStatusTime}}&lt;/td&gt;
			&lt;td&gt;{{item.userName}}&lt;/td&gt;
			&lt;td&gt;{{item.loginName}}&lt;/td&gt;
			&lt;td&gt;{{item.deviceId}}&lt;/td&gt;
			&lt;td&gt;&lt;/td&gt;
			&lt;td&gt;&lt;/td&gt;
			&lt;td&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;


	&lt;script src=&#34;http://cdn.bootcss.com/vue/1.0.26/vue.js&#34;&gt;&lt;/script&gt;
	&lt;script src=&#34;js/websocket-suport.min.js&#34;&gt;&lt;/script&gt;
	&lt;script src=&#34;js/main.js&#34;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>js</p><pre tabindex=0><code>var tm = (function(){
	var App = function(){};
	var app = App.prototype;
	var config = {
		dest: &#39;http://xxx.xxx.xxx.xxx:58080/mvc/stomp&#39;,
		topic: &#39;/topic/csta/namespace/testwdd2.com&#39;
		// topic: &#39;/topic/csta/device/8002@testwdd2.com&#39;
	};


	var eventQueue = [];
	var vm = new Vue({
		el:&#39;#event-queue&#39;,
		data:{
			eventQueue: eventQueue
		}
	});

	Vue.filter(&#39;transAgentStatus&#39;, function(status){
		switch(status){
			case &#39;NotReady&#39;: return &#39;未就绪&#39;;
			case &#39;WorkNotReady&#39;: return &#39;话后处理状态&#39;;
			case &#39;Idle&#39;: return &#39;就绪&#39;;
			case &#39;OnCallIn&#39;: return &#39;呼入通话&#39;;
			case &#39;OnCallOut&#39;: return &#39;呼出通话&#39;;
			case &#39;Logout&#39;: return &#39;登出&#39;;
			case &#39;Ringing&#39;: return &#39;振铃&#39;;
			case &#39;OffHook&#39;: return &#39;摘机&#39;;
			case &#39;CallInternal&#39;: return &#39;内部通话&#39;;
			case &#39;Dailing&#39;: return &#39;外线已经振铃&#39;;
			case &#39;Ringback&#39;: return &#39;回铃&#39;;
			case &#39;Conference&#39;: return &#39;会议&#39;;
			case &#39;OnHold&#39;: return &#39;保持&#39;;
			case &#39;Other&#39;: return &#39;其他&#39;;
		}

		return &#39;&#39;;
	});

	/**
	 * [render description]
	 * @Author   Wdd
	 * @DateTime 2016-12-26T16:06:16+0800
	 * @param    {[string]} tpl [模板字符串]
	 * @param    {[object]} data [data对象]
	 * @return   {[string]} [渲染后的字符串]
	 */
	app.render = function(tpl,data){
        var re = /{{([^}]+)?}}/g;

        while(match = re.exec(tpl)){
            tpl = tpl.replace(match[0],data[match[1]] || &#39;&#39;);
        }

        return tpl;
    };

	app.initWebSocket = function(dest, topic){
		dest = dest || config.dest;
		topic = topic || config.topic;

		var socket = new SockJS(dest);
		var ws = Stomp.over(socket);

		ws.connect({}, function(frame) {

		    ws.subscribe(topic, function(event) {
		        // var eventInfo = JSON.parse(event.body);
		        app.handerEvent(JSON.parse(event.body));
		    });
		}, function(frame) {

		    console.log(frame);
		    console.error(new Date() + &#39;websocket失去连接&#39;);
		});
	};

	/**
	 * [findAgentIndex description]
	 * @Author   Wdd
	 * @DateTime 2016-12-28T10:34:13+0800
	 * @param    {[string]} agentId [description]
	 * @return   {[int]} [description]
	 */
	app.findAgentIndex = function(agentId){
		for(var i = eventQueue.length - 1; i &gt;= 0; i--){
			if(eventQueue[i].agentId === agentId){
				return i;
			}
		}

		return -1;
	};

	/**
	 * [handerEvent 处理websocket事件]
	 * @Author   Wdd
	 * @DateTime 2016-12-28T10:33:03+0800
	 * @param    {[object]} data [description]
	 * @return   {[type]} [description]
	 */
	app.handerEvent = function(data){
		if(data.eventType === &#39;CallEvent&#39;){
			return;
		}
		if(!data.eventSrc){
			return;
		}

		var eventItem = {
			agentStatus: &#39;&#39;,
			eventName: data.eventName,
			agentId: &#39;&#39;,
			loginName: &#39;&#39;,
			userName: &#39;&#39;,
			deviceId: data.deviceId,
			agentStatusTime: &#39;&#39;
		};

		var agent = data.eventSrc.agent || &#39;&#39;;

		if(agent){
			eventItem.agentId = agent.agentId;
			eventItem.loginName = agent.loginName;
			eventItem.userName = agent.userName;
			eventItem.agentStatus = agent.agentStatus;
			eventItem.agentStatusTime = agent.agentStatusTime;
		}
		// 针对登出事件的agentId在外层
		else if(data.agentMode){
			eventItem.agentStatus = data.agentMode;
			eventItem.agentId = data.agentId;
		}
		else if(data.agentStatus){
			eventItem.agentStatus = data.agentStatus;
		}

		if(!eventItem.agentId){
			return;
		}

		var itemIndex = app.findAgentIndex(eventItem.agentId);

		// 新的座席加入
		if(itemIndex === -1){
			eventQueue.push(eventItem);
		}
		// 更新已有座席的状态
		else{
			eventQueue[itemIndex].agentStatus = eventItem.agentStatus;
			eventQueue[itemIndex].agentStatusTime = eventItem.agentStatusTime;
			eventQueue[itemIndex].eventName = eventItem.eventName;
		}

	};


	return new App();
})();
</code></pre><p>打开控制台，输入tm.initWebsocket()后，websocket连接正常。
<img loading=lazy src=https://wdd.js.org/img/images/20180207093803_2QPxWp_Screenshot.jpeg alt></p><p>之后坐席状态改变，可以看到有事件推送过来。
<img loading=lazy src=https://wdd.js.org/img/images/20180207093819_vbKAv5_Screenshot.jpeg alt></p><p>看下整个页面：
<img loading=lazy src=https://wdd.js.org/img/images/20180207093836_bj5ctf_Screenshot.jpeg alt></p><p><code>最后，这个小小的监控如果用jQuery写，也可以，不过就是太坑了，每次都要去找到Dom元素，再更新DOM，用了Vue这类的框架，页面的dom操作完全不用关心了，真是太舒服了。\(^o^)/</code></p><h1 id=1-关于stomp的重连>1. 关于stomp的重连<a hidden class=anchor aria-hidden=true href=#1-关于stomp的重连>#</a></h1><p><code>程序后服务端使用RabbitMQ</code>
这里我直接引用我的另一个项目的部分代码，这个没有使用SockJS， 直接使用浏览器原生的WebSocket。
重连的原理很简单，就是检测到断开时，去调用我的reconnectWs方法，这里我也做了重连的次数限制。</p><pre tabindex=0><code>initWebSocket: function(callback, errorCallback) {
            callback = callback || function(){};

            if(ws &amp;&amp; ws.connected){
                return;
            }

            Config.isManCloseWs = false;

            var url = Config.wsProtocol + Config.SDK + Config.eventPort + Config.eventBasePath + &#34;/websocket&#34;;

            if(typeof WebSocket != &#39;function&#39;){
                alert(&#39;您的浏览器版本太太太老了，请升级你的浏览器到IE11，或使用任何支持原生WebSocket的浏览器&#39;);
                return;
            }

            try{
                var socket = new WebSocket(url);
            }
            catch(e){
                console.log(e);
                return;
            }


            var wsHeartbeatId = &#39;&#39;;

            ws = Stomp.over(socket);

            if(!Config.useWsLog){
                ws.debug = null;
            }

            ws.connect({}, function(frame) {

                Config.currentReconnectTimes = 0;

                var dest = Config.newWsTopic + env.loginId.replace(/\./g,&#39;_&#39;);

                var lastEventSerial = &#39;&#39;;

                ws.subscribe(dest, function(event) {
                    var eventInfo = {};

                    try{
                        eventInfo = JSON.parse(event.body);
                        delete eventInfo.params;
                        delete eventInfo._type;
                        delete eventInfo.topics;
                    }
                    catch(e){
                        console.log(e);
                        return;
                    }

                    if(lastEventSerial === eventInfo.serial){
                        util.error(&#39;Error: event repeat sent !&#39;);
                        return;
                    }
                    else{
                        lastEventSerial = eventInfo.serial;
                    }

                    if(Config.useEventLog){
                        util.debugout.log(&#39; &#39; + JSON.stringify(eventInfo));
                    }

                    eventHandler.deliverEvent(eventInfo);
                });
                callback();

            }, function(frame) {
                // websocket upexpected disconnected
                // maybe network disconnection, or browser in offline
                // this condition will emit wsDisconnected event
                if(Config.isManCloseWs){return;}
                errorCallback();

                util.log(frame);
                util.error(new Date() + &#39;websocket disconnect&#39;);
                // clearInterval(wsHeartbeatId);

                if(Config.currentReconnectTimes &lt; Config.maxReconnectTimes){
                    Config.currentReconnectTimes++;
                    util.reconnectWs();
                }
                else{
                    var errorMsg = {
                        eventName: &#39;wsDisconnected&#39;,
                        msg: &#39;websocket disconnect&#39;
                    };
                    wellClient.ui.main({
                        eventName:&#39;wsDisconnected&#39;
                    });
                    util.debugout.log(&#39;&gt;&gt;&gt; websocket disconnect&#39;);

                    wellClient.triggerInnerOn(errorMsg);
                }
            });
        },

        reconnectWs: function(){
            setTimeout(function(){
                util.log(&#39;&gt;&gt;&gt; try to reconnect&#39;);
                util.debugout.log(&#39;&gt;&gt;&gt; try to reconnect&#39;);
                util.initWebSocket(function(){},function(){});

            }, Config.timeout * 1000);
        },
</code></pre><h1 id=2-参考>2. 参考<a hidden class=anchor aria-hidden=true href=#2-参考>#</a></h1><ul><li><p><a href=http://jmesnil.net/stomp-websocket/doc/>STOMP Over WebSocket</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wdd.js.org/tags/vue/>Vue</a></li><li><a href=https://wdd.js.org/tags/websocket/>websocket</a></li><li><a href=https://wdd.js.org/tags/stompjs/>stompjs</a></li></ul><nav class=paginav><a class=prev href=https://wdd.js.org/posts/2018/i-realy-dont-know-js/><span class=title>« Prev Page</span><br><span>突然觉得自己好像没学过JS</span></a>
<a class=next href=https://wdd.js.org/posts/2018/windows-powerful-tools/><span class=title>Next Page »</span><br><span>自从装了windows神器，再也不用羡慕mac了</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>