<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Restful API 架构思考 | 洞香春</title><meta name=keywords content><meta name=description content="1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia
REST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。
RESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。
2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。
4. 状态码 1xx - informational; 2xx - success; 3xx - redirection; 4xx - client error; 5xx - server error. 5. RESTful架构设计 GET /users - get all users; GET /users/123 - get a particular user with id = 123; GET /posts - get all posts."><meta name=author content="王端端"><link rel=canonical href=https://wdd.js.org/posts/old-blog/irl0p4/><meta name=google-site-verification content="G-SGW660ZWKM"><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.105.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-SGW660ZWKM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SGW660ZWKM",{anonymize_ip:!1})}</script><meta property="og:title" content="Restful API 架构思考"><meta property="og:description" content="1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia
REST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。
RESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。
2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。
4. 状态码 1xx - informational; 2xx - success; 3xx - redirection; 4xx - client error; 5xx - server error. 5. RESTful架构设计 GET /users - get all users; GET /users/123 - get a particular user with id = 123; GET /posts - get all posts."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/posts/old-blog/irl0p4/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-15T22:32:40+08:00"><meta property="article:modified_time" content="2019-10-15T22:32:40+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Restful API 架构思考"><meta name=twitter:description content="1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia
REST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。
RESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。
2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。
4. 状态码 1xx - informational; 2xx - success; 3xx - redirection; 4xx - client error; 5xx - server error. 5. RESTful架构设计 GET /users - get all users; GET /users/123 - get a particular user with id = 123; GET /posts - get all posts."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://wdd.js.org/posts/"},{"@type":"ListItem","position":3,"name":"Restful API 架构思考","item":"https://wdd.js.org/posts/old-blog/irl0p4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Restful API 架构思考","name":"Restful API 架构思考","description":"1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia\nREST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。\nRESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。\n2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。\n4. 状态码 1xx - informational; 2xx - success; 3xx - redirection; 4xx - client error; 5xx - server error. 5. RESTful架构设计 GET /users - get all users; GET /users/123 - get a particular user with id = 123; GET /posts - get all posts.","keywords":[],"articleBody":"1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia\nREST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。\nRESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。\n2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。\n4. 状态码 1xx - informational; 2xx - success; 3xx - redirection; 4xx - client error; 5xx - server error. 5. RESTful架构设计 GET /users - get all users; GET /users/123 - get a particular user with id = 123; GET /posts - get all posts. POST /users. PUT /users/123 - upgrade a user entity with id = 123. DELETE /users/123 - delete a user with id = 123. 6. 文档 7. 版本 版本管理一般有两种\n位于url中的版本标识： http://example.com/api/v1 位于请求头中的版本标识：Accept: application/vnd.redkavasyl+json; version=2.0 8. 深入理解状态与无状态 我认为REST架构最难理解的就是状态与无状态。下面我画出两个示意图。\n图1是有状态的服务，状态存储于单个服务之中，一旦一个服务挂了，状态就没了，有状态服务很难扩展。无状态的服务，状态存储于客户端，一个请求可以被投递到任何服务端，即使一个服务挂了，也不回影响到同一个客户端发来的下一个请求。\n【图1 有状态的架构】\n【图2 无状态的架构】\neach request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server. Session state is therefore kept entirely on the client. rest_arch_style stateless\n每一个请求自身必须携带所有的信息，让客户端理解这个请求。举个栗子，常见的翻页操作，应该客户端告诉服务端想要看第几页的数据，而不应该让服务端记住客户端看到了第几页。\n9. 参考 A Beginner’s Tutorial for Understanding RESTful API Versioning REST Services http://ruanyifeng.com/blog/2018/10/restful-api-best-practices.html https://florimond.dev/en/posts/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy/ https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md https://github.com/cocoajin/http-api-design-ZH_CN https://www.cnblogs.com/welan/p/9875103.html ","wordCount":"193","inLanguage":"en","datePublished":"2019-10-15T22:32:40+08:00","dateModified":"2019-10-15T22:32:40+08:00","author":{"@type":"Person","name":"王端端"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/posts/old-blog/irl0p4/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/posts/>Posts</a></div><h1 class=post-title>Restful API 架构思考</h1><div class=post-meta><span title='2019-10-15 22:32:40 +0800 CST'>2019-10-15 22:32:40</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/old-blog/irl0p4/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e4%bb%80%e4%b9%88%e6%98%afrest aria-label="1. 什么是REST?">1. 什么是REST?</a></li><li><a href=#2-rest-api%e6%9c%80%e4%b8%ba%e9%87%8d%e8%a6%81%e7%9a%84%e7%ba%a6%e6%9d%9f aria-label="2. REST API最为重要的约束">2. REST API最为重要的约束</a></li><li><a href=#3-rest-api-http%e6%96%b9%e6%b3%95-%e4%b8%8e-curd aria-label="3. REST API HTTP方法 与 CURD">3. REST API HTTP方法 与 CURD</a></li><li><a href=#4-%e7%8a%b6%e6%80%81%e7%a0%81 aria-label="4. 状态码">4. 状态码</a></li><li><a href=#5-restful%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label="5. RESTful架构设计">5. RESTful架构设计</a></li><li><a href=#6-%e6%96%87%e6%a1%a3 aria-label="6. 文档">6. 文档</a></li><li><a href=#7-%e7%89%88%e6%9c%ac aria-label="7. 版本">7. 版本</a></li><li><a href=#8-%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e7%8a%b6%e6%80%81%e4%b8%8e%e6%97%a0%e7%8a%b6%e6%80%81 aria-label="8. 深入理解状态与无状态">8. 深入理解状态与无状态</a></li><li><a href=#9-%e5%8f%82%e8%80%83 aria-label="9. 参考">9. 参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1-什么是rest>1. 什么是REST?<a hidden class=anchor aria-hidden=true href=#1-什么是rest>#</a></h1><blockquote><p>表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。<a href=https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2>wikipdeia</a></p></blockquote><p><img loading=lazy src=2022-10-29-20-02-04.png alt></p><p><code>REST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。</code></p><p>RESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。</p><p><img loading=lazy src=2022-10-29-20-02-12.png alt></p><h1 id=2-rest-api最为重要的约束>2. REST API最为重要的约束<a hidden class=anchor aria-hidden=true href=#2-rest-api最为重要的约束>#</a></h1><ul><li><code>Client-Server</code> 通信只能由客户端单方面发起，表现为请求-响应的形式</li><li><code>Stateless</code> 通信的会话状态（Session State）应该全部由客户端负责维护</li><li><code>Cache</code> 响应内容可以在通信链的某处被缓存，以改善网络效率</li><li><code>Uniform Interface</code> 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性</li><li><code>Layered System</code> 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。</li><li><code>Code-On-Demand</code> 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。</li></ul><h1 id=3-rest-api-http方法-与-curd>3. REST API HTTP方法 与 CURD<a hidden class=anchor aria-hidden=true href=#3-rest-api-http方法-与-curd>#</a></h1><p>REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。</p><p><img loading=lazy src=2022-10-29-20-02-20.png alt></p><h1 id=4-状态码>4. 状态码<a hidden class=anchor aria-hidden=true href=#4-状态码>#</a></h1><ul><li><code>1xx</code> - informational;</li><li><code>2xx</code> - success;</li><li><code>3xx</code> - redirection;</li><li><code>4xx</code> - client error;</li><li><code>5xx</code> - server error.</li></ul><h1 id=5-restful架构设计>5. RESTful架构设计<a hidden class=anchor aria-hidden=true href=#5-restful架构设计>#</a></h1><ul><li><code>GET</code> /users - get all users;</li><li><code>GET</code> /users/123 - get a particular user with id = 123;</li><li><code>GET</code> /posts - get all posts.</li><li><code>POST</code> /users.</li><li><code>PUT</code> /users/123 - upgrade a user entity with id = 123.</li><li><code>DELETE</code> /users/123 - delete a user with id = 123.</li></ul><h1 id=6-文档>6. 文档<a hidden class=anchor aria-hidden=true href=#6-文档>#</a></h1><p><img loading=lazy src=2022-10-29-20-02-30.png alt></p><p><img loading=lazy src=2022-10-29-20-02-35.png alt></p><h1 id=7-版本>7. 版本<a hidden class=anchor aria-hidden=true href=#7-版本>#</a></h1><p>版本管理一般有两种</p><ul><li>位于url中的版本标识： <a href=http://example.com/api/v1>http://example.com/api/v1</a></li><li>位于请求头中的版本标识：Accept: application/vnd.redkavasyl+json; <code>version=2.0</code></li></ul><h1 id=8-深入理解状态与无状态>8. 深入理解状态与无状态<a hidden class=anchor aria-hidden=true href=#8-深入理解状态与无状态>#</a></h1><p>我认为REST架构最难理解的就是状态与无状态。下面我画出两个示意图。</p><p>图1是有状态的服务，状态存储于单个服务之中，一旦一个服务挂了，状态就没了，有状态服务很难扩展。无状态的服务，状态存储于客户端，一个请求可以被投递到任何服务端，即使一个服务挂了，也不回影响到同一个客户端发来的下一个请求。</p><p><img loading=lazy src=2022-10-29-20-02-50.png alt>
【图1 有状态的架构】</p><p><img loading=lazy src=2022-10-29-20-03-00.png alt></p><p>【图2 无状态的架构】</p><blockquote><p>each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server. Session state is therefore kept entirely on the client. <a href=https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3>rest_arch_style stateless</a></p></blockquote><p>每一个请求自身必须携带所有的信息，让客户端理解这个请求。举个栗子，常见的翻页操作，应该客户端告诉服务端想要看第几页的数据，而不应该让服务端记住客户端看到了第几页。</p><h1 id=9-参考>9. 参考<a hidden class=anchor aria-hidden=true href=#9-参考>#</a></h1><ul><li><a href=https://mlsdev.com/blog/81-a-beginner-s-tutorial-for-understanding-restful-api>A Beginner’s Tutorial for Understanding RESTful API</a></li><li><a href="http://www.informit.com/articles/article.aspx?p=1566460">Versioning REST Services</a></li><li><a href=http://ruanyifeng.com/blog/2018/10/restful-api-best-practices.html>http://ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></li><li><a href=https://florimond.dev/en/posts/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy/>https://florimond.dev/en/posts/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy/</a></li><li><a href=https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design>https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design</a></li><li><a href=https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md>https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md</a></li><li><a href=https://github.com/cocoajin/http-api-design-ZH_CN>https://github.com/cocoajin/http-api-design-ZH_CN</a></li><li><a href=https://www.cnblogs.com/welan/p/9875103.html>https://www.cnblogs.com/welan/p/9875103.html</a></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://wdd.js.org/posts/old-blog/ikg19e/><span class=title>« Prev Page</span><br><span>Jenkins 全局变量参考</span></a>
<a class=next href=https://wdd.js.org/posts/old-blog/giflpm/><span class=title>Next Page »</span><br><span>掌握谷歌搜索高级指令</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>