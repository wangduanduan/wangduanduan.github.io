<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Networks on 洞香春</title>
    <link>https://wdd.js.org/network/</link>
    <description>Recent content in Networks on 洞香春</description>
    <image>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 25 Oct 2022 09:12:00 +0800</lastBuildDate><atom:link href="https://wdd.js.org/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Wireshark抓包教程</title>
      <link>https://wdd.js.org/network/wireshark/</link>
      <pubDate>Tue, 25 Oct 2022 09:12:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/wireshark/</guid>
      <description>1. HTTP抓包例子 案例：本地向 http://192.168.40.134:31204/some-api，如何过滤？
http and ip.addr == 192.168.40.134 and tcp.port == 31204 语句分析：
http 表示我只需要http的包 ip.addr 表示只要源ip或者目标ip地址中包含192.168.40.134 tcp.port 表示只要源端口或者目标端口中包含31204 2. 为什么我写的表达式总是不对呢？😂 很多时候，你写的表达式背景色变成红色，说明表达式错误了，例如下图：http and ip.port == 31204
写出ip.port这个语句，往往是对传输协议理解不清晰。😅
ip是网络层的协议，port是传输层tcp或者udp中使用的。例如你写tcp.port == 80，udp.port ==3000这样是没问题的。但是port不能跟在ip的后面，如果你不清楚怎么写，你可以选择wireshark的智能提示。
智能提示会提示所有可用的表达式。
3. 常用过滤表达式 一般我们的过滤都是基于协议，ip地址或者端口号进行过滤的，
3.1. 基于协议的过滤 直接输入协议名进行过滤
3.2. 基于IP地址的过滤 3.3. 基于端口的过滤 基于端口的过滤一般就两种
tcp.port == xxx udp.port == xxx 3.4. 基于host的过滤 4. 比较运算符支持 == 等于 != 不等于 &amp;gt; 大于 &amp;lt; 小于 &amp;gt;= 大于等于 &amp;lt;= 小于等于 ip.addr == 192.168.2.4 5. 逻辑运算符 and 条件与 or 条件或 xor 仅能有一个条件为真 not 所有条件都不能为真 ip.</description>
    </item>
    
    <item>
      <title>Tcpdump抓包教程</title>
      <link>https://wdd.js.org/network/tcpdump/</link>
      <pubDate>Tue, 25 Oct 2022 09:09:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/tcpdump/</guid>
      <description>查看帮助文档 从帮助文档可以看出，包过滤的表达式一定要放在最后一个参数
tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ --count ] [ -C file_size ] [ -E spi@ipaddr algo:secret,... ] [ -F file ] [ -G rotate_seconds ] [ -i interface ] [ --immediate-mode ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ] [ -r file ] [ -s snaplen ] [ -T type ] [ --version ] [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ --time-stamp-precision=tstamp_precision ] [ --micro ] [ --nano ] [ expression ] 列出所有网卡 tcpdump -D 1.</description>
    </item>
    
    <item>
      <title>http抓包工具httpry使用</title>
      <link>https://wdd.js.org/network/httpry/</link>
      <pubDate>Tue, 25 Oct 2022 09:07:04 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/httpry/</guid>
      <description>git clone https://gitee.com/nuannuande/httpry.git cd httpry yum install libpcap-devel -y make make install cp -f httpry /usr/sbin/ httpry -i eth0 </description>
    </item>
    
    <item>
      <title>Tshark入门到精通</title>
      <link>https://wdd.js.org/network/tshark/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/tshark/</guid>
      <description>1. 使用摘要 一个命令的使用摘要非常重要，摘要里包含了这个工具最常用的用法。
要注意的是，如果要用过滤器，一定要放到最后。
tshark [ -i &amp;lt;capture interface&amp;gt;|- ] [ -f &amp;lt;capture filter&amp;gt; ] [ -2 ] [ -r &amp;lt;infile&amp;gt; ] [ -w &amp;lt;outfile&amp;gt;|- ] [ options ] [ &amp;lt;filter&amp;gt; ] tshark -G [ &amp;lt;report type&amp;gt; ] [ --elastic-mapping-filter &amp;lt;protocols&amp;gt; ] 2. 为什么要学习tshark? 一般情况下，我们可能会在服务端用tcpdump抓包，然后把包拿下来，用wireshark分析。那么我们为什么要学习tshark呢？
相比于wireshark， tshark有以下的优点
速度飞快：wireshark在加载包的时候，tshark可能已经给出了结果。 更稳定：wireshark在处理包的时候，常常容易崩溃 更适合做文本处理：tshark的输出是文本，这个文本很容易被awk, sort, uniq等等命令处理 但是我不建议上来就学习，更建议在熟悉wireshark之后，再去进一步学习tshark
3. 使用场景 3.1 基本场景 用wireshark最基本的场景的把pcap文件拖动到wireshark中，然后可能加入一些过滤条件。
tshark -r demo.pcap tshark -r demo.pcap -c 1 # 只读一个包就停止 输出的列分别为：序号，相对时间，绝对时间，源ip, 源端口，目标ip, 目标端口</description>
    </item>
    
    <item>
      <title>Udp Checksum Offload</title>
      <link>https://wdd.js.org/network/udp-checksum-offload/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/udp-checksum-offload/</guid>
      <description>在服务端抓包，然后在wireshark上分析，发现wireshark提示：udp checksum字段有问题
checksum 0x&amp;hellip; incrorect should be 0x.. (maybe caused by udp checksum offload)
以前我从未遇到过udp checksum的问题。所以这次是第一次遇到，所以需要学习一下。 首先udp checksum是什么？
我们看下udp的协议组成的字段，其中就有16位的校验和
校验和一般都是为了检验数据包在传输过程中是否出现变动的。
如果接受端收到的udp消息校验和错误，将会被悄悄的丢弃 udp校验和是一个端到端的校验和。端到端意味它不会在中间网络设备上校验。 校验和由发送方负责计算，接收端负责验证。目的是为了发现udp首部和和数据在发送端和接受端之间是否发生了变动 udp校验和是可选的功能，但是总是应该被默认启用。 如果发送方设置了udp校验和，则接受方必须验证 发送方负责计算？具体是谁负责计算
计算一般都是CPU的工作，但是有些网卡也是支持checksum offload的。
所谓offload, 是指本来可以由cpu计算的，改变由网卡硬件负责计算。 这样做有很多好处，
可以降低cpu的负载，提高系统的性能 网卡的硬件checksum, 效率更高 为什么只有发送方出现udp checksum 错误？ 我在接受方和放松方都进行了抓包，一个比较特殊的特征是，只有发送方发现了udp checksum的错误，在接受方，同样的包，udp checksum的值却是正确的。
一句话的解释：tcpdump在接收方抓到的包，本身checksum字段还没有被计算，在后续的步骤，这个包才会被交给NIC, NIC来负责计算。
结论 maybe caused by udp checksum offload 这个报错并没有什么问题。
参考 ● 《tcp/ip 详解》 ● https://www.kernel.org/doc/html/latest/networking/checksum-offloads.html ● https://dominikrys.com/posts/disable-udp-checksum-validation/ ● https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/</description>
    </item>
    
    <item>
      <title>Wireshark 附带的19命令行程序</title>
      <link>https://wdd.js.org/network/wireshark-extra-cli/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/wireshark-extra-cli/</guid>
      <description>大多数时候我们都是图形界面的方式使用wireshak, 其实一般只要你安装了wireshark，同时也附带安装了一些命令行工具。 这些工具也可以极大的提高生产效率。 本文只是对工具的功能简介，可以使用命令 -h, 查看命令的具体使用文档。
1. editcap 编辑抓包文件 Editcap (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Edit and/or translate the format of capture files. 举例: 按照时间范围从input.pcap文件中拿出指定时间范围的包
editcap -A &amp;#39;2014-12-10 10:11:01&amp;#39; -B &amp;#39;2014-12-10 10:21:01&amp;#39; input.pcap output.pcap 2. androiddump 这个命令似乎可以用来对安卓系统进行抓包，没玩过安卓，不再多说。
Wireshark - androiddump v1.1.0 Usage: androiddump --extcap-interfaces [--adb-server-ip=&amp;lt;arg&amp;gt;] [--adb-server-tcp-port=&amp;lt;arg&amp;gt;] androiddump --extcap-interface=INTERFACE --extcap-dlts androiddump --extcap-interface=INTERFACE --extcap-config androiddump --extcap-interface=INTERFACE --fifo=PATH_FILENAME --capture 3. ciscodump 似乎是对思科的网络进行抓包的，没用过 Wireshark - ciscodump v1.0.0 Usage: ciscodump &amp;ndash;extcap-interfaces ciscodump &amp;ndash;extcap-interface=ciscodump &amp;ndash;extcap-dlts ciscodump &amp;ndash;extcap-interface=ciscodump &amp;ndash;extcap-config ciscodump &amp;ndash;extcap-interface=ciscodump &amp;ndash;remote-host myhost &amp;ndash;remote-port 22222 &amp;ndash;remote-username myuser &amp;ndash;remote-interface gigabit0/0 &amp;ndash;fifo=FILENAME &amp;ndash;capture</description>
    </item>
    
    <item>
      <title>Linux内核参数rp_filter</title>
      <link>https://wdd.js.org/network/rp_filter/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/rp_filter/</guid>
      <description>问题现象 主机上有两个网卡ens192和ens224。ens129网卡是对内网络的网卡，ens224是对网网络的网卡。
SIP信令阶段都是正常的，但是发现，对于来自node3的RTP流， 并没有从ens192网卡转发给node1上。
sequenceDiagram title network autonumber node1-&gt;&gt;ens192: INVITE ens224-&gt;&gt;node2: INVITE node2-&gt;&gt;ens224: 200 ok ens192-&gt;&gt;node1: 200 ok node1-&gt;&gt;ens192: ACK ens224-&gt;&gt;node2: ACK node1--&gt;&gt;ens192: RTP out ens224--&gt;&gt;node3: RTP out node3--&gt;&gt;ens224: RTP in 抓包程序抓到了node3发送到ens224上的包，但是排查应用服务器的日志发现，似乎应用服务器根本没有收到node3上过来的包, 所以也就无法转发。
因而怀疑是不是在内核上被拦截了。 后来通过将rp_filter设置为0, 然后语音流的转发就正常了。
事后复盘 node3的这个IP直接往应用服务器上发包，可能会被拦截。因为在信令建立的阶段，应用服务器并没有主动发
在kernel文档上 rp_filter - INTEGER 0 - No source validation. 1 - Strict mode as defined in RFC3704 Strict Reverse Path Each incoming packet is tested against the FIB and if the interface is not the best reverse path the packet check will fail.</description>
    </item>
    
    <item>
      <title>websocket tcp keepalive 机制调研</title>
      <link>https://wdd.js.org/network/pz06t2/</link>
      <pubDate>Wed, 17 Mar 2021 19:17:46 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/pz06t2/</guid>
      <description>测试目标服务器 http://www.websocket-test.com/， 该服务器使用的是未加密的ws协议。
打开这个页面，可以看到这个页面发起了连接到ws://121.40.165.18:8800/ 的websocket连接。
然后看下里面的消息，都是服务端向客户端发送的消息。
通过wireshark分析
单独的websocket也是能够看到服务端下发的消息的。
keepalive 要点关注 每隔大约45秒，客户端会像服务端发送一个keep alive包。服务端也会非常快的回复一个心跳包 </description>
    </item>
    
    <item>
      <title>tcpdump filters</title>
      <link>https://wdd.js.org/network/hhlfi1/</link>
      <pubDate>Fri, 04 Dec 2020 13:32:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/hhlfi1/</guid>
      <description>ethereal-tcpdump.pdf</description>
    </item>
    
    <item>
      <title>libpcap tutorial</title>
      <link>https://wdd.js.org/network/ivzphz/</link>
      <pubDate>Fri, 04 Dec 2020 13:31:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ivzphz/</guid>
      <description>libpcap-tutorial.pdf</description>
    </item>
    
    <item>
      <title>tcpdump zine</title>
      <link>https://wdd.js.org/network/yscigi/</link>
      <pubDate>Fri, 04 Dec 2020 13:29:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/yscigi/</guid>
      <description>tcpdump-zine.pdf</description>
    </item>
    
    <item>
      <title>pcap抓包教程</title>
      <link>https://wdd.js.org/network/uq5cii/</link>
      <pubDate>Wed, 02 Dec 2020 13:27:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/uq5cii/</guid>
      <description>准备条件 有gcc编译器 安装libpcap包 1.c 试运行 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pcap.h&amp;gt; int main(int argc, char *argv[]) { char *dev = argv[1]; printf(&amp;#34;Device: %s\n&amp;#34;, dev); return(0); } gcc ./1.c -o 1.exe -lpcap demo-libpcap git:(master) ✗ ./1.exe eth0 Device: eth0 第一个栗子非常简单，仅仅是测试相关的库是否加载正确
2.c 获取默认网卡名称 参考 http://www.tcpdump.org/pcap.html </description>
    </item>
    
    <item>
      <title>wireshark从pcap中提取语音文件</title>
      <link>https://wdd.js.org/network/zgftde/</link>
      <pubDate>Wed, 25 Nov 2020 10:34:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/zgftde/</guid>
      <description>使用tcpdump在服务端抓包，将抓包后的文件在wireshark中打开。
然后选择：Telephony - VoIP Calls，wireshark可以从抓包文件中提取出SIP呼叫列表。
呼叫列表页面 在呼叫列表页面，选择一条呼叫记录，点击Flow Sequence， 可以查看该呼叫的SIP时序图。点击Play Stream， 可以播放该条呼叫的声音。
RTPplay页面有播放按钮，点击播放可以听到通话声音。</description>
    </item>
    
    <item>
      <title>wireshark合并和按时间截取pcap文件</title>
      <link>https://wdd.js.org/network/kgrco2/</link>
      <pubDate>Wed, 25 Nov 2020 10:11:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/kgrco2/</guid>
      <description>tcpdump可以在抓包时，按照指定时间间隔或者按照指定的包大小，产生新的pcap文件。用wireshark分析这些包时，往往需要将这些包做合并或者分离操作。
mergecap 如果安装了Wireshark那么mergecap就会自动安装，可以使用它来合并多个pcap文件。
// 按照数据包中的时间顺序合并文件 mergecap -w output.pcap input1.pcap input2.pcap input3.pcap // 按照命令行中的输入数据包文件顺序合并文件 // 不加-a, 可能会导致SIP时序图重复的问题 mergecap -a -w output.pcap input1.pcap input2.pcap input3.pcap editcap 对于一个很大的pcap文件，按照时间范围分割出新的pcap包
editcap -A &amp;#39;2014-12-10 10:11:01&amp;#39; -B &amp;#39;2014-12-10 10:21:01&amp;#39; input.pcap output.pcap 参考 https://blog.csdn.net/qq_19004627/article/details/82287172 </description>
    </item>
    
    <item>
      <title>网络拆包笔记</title>
      <link>https://wdd.js.org/network/gzskun/</link>
      <pubDate>Sun, 03 May 2020 10:59:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/gzskun/</guid>
      <description>介绍 之所以要写这篇文章，是因为我要从pcap格式的抓包文件中抽取出语音文件。之间虽然对tcp协议有不错的理解，但并没有写代码去真正的解包分析。
最近用Node.js尝试去pacp文件中成功提取出了语音文件。再次做个总结。
预备知识 字节序： 关于字节序，可以参考 https://www.ruanyifeng.com/blog/2016/11/byte-order.html。读取的时候，如果字节序设置错了，就会读出来一堆无法解析的内容 PCAP格式 下面是paap文件的格式。
开局是一个全局的头文件。后续跟着一系列的包头和包体。
Global Header格式 全局头由六个字段组成，加起来一共24个字节。
typedef struct pcap_hdr_s { guint32 magic_number; /* magic number */ guint16 version_major; /* major version number */ guint16 version_minor; /* minor version number */ gint32 thiszone; /* GMT to local correction */ guint32 sigfigs; /* accuracy of timestamps */ guint32 snaplen; /* max length of captured packets, in octets */ guint32 network; /* data link type */ } pcap_hdr_t; magic_number 魔术字符，32位无符号整型，一般是0xa1b2c3d4或者0xd4c3b2a1，前者表示字段要按照大端字节序来读取，后者表示字段要按照小段字节序来读取。 version_major 大版本号，16位无符号整形。一般是2 version_minor 小版本号，16位无符号整形。一般是4 thiszone 时区 sigfigs 实际时间戳 snaplen 捕获的最大的长度 network 数据链路层的类型。参考http://www.</description>
    </item>
    
    <item>
      <title>网络包的封装和分用</title>
      <link>https://wdd.js.org/network/mlepcg/</link>
      <pubDate>Wed, 11 Mar 2020 08:24:20 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/mlepcg/</guid>
      <description>图解包在TCP/IP各个协议栈的流动情况
点击查看【undefined】</description>
    </item>
    
    <item>
      <title>IP协议 Protocol</title>
      <link>https://wdd.js.org/network/ip-protocol/</link>
      <pubDate>Thu, 05 Mar 2020 12:48:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ip-protocol/</guid>
      <description>IP协议格式 字段说明 Protocol 表示上层协议，也就是传输层是什么协议。
只需要看Decimal这列，常用的有6表示TCP, 17表示UDP, 50表示ESP。
用wireshark抓包的时候，也可以看到Protocol: UDP(17)
参考 https://tools.ietf.org/html/rfc791 https://tools.ietf.org/html/rfc790 https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers </description>
    </item>
    
    <item>
      <title>从飞机航线讲解网络分层</title>
      <link>https://wdd.js.org/network/ibhy8a/</link>
      <pubDate>Tue, 03 Mar 2020 13:48:27 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ibhy8a/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>TIME_WAIT与持久连接</title>
      <link>https://wdd.js.org/network/sq4l53/</link>
      <pubDate>Wed, 15 Jan 2020 20:23:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/sq4l53/</guid>
      <description>在事务结束之后，仍然保持在打开状态的链接称为持久连接。非持久的链接会在每个事务结束之后就会关闭。
持久连接的好处 避免缓慢的链接建立阶段 避免慢启动的拥塞适应阶段 Keep-Alive 客户端发起请求，带有Connection: Keep-Alive头。客户端在响应头中回应Connection: Keep-Alive。则说明客户端同意持久连接。
如果客户端不同意持久连接，就会在响应头中返回Connection: Close
注意事项
即使服务端同意了持久连接，服务端也可以随时关闭连接 HTTP 1.0 协议，必须显式传递Connection: Keep-Alive，服务端才会激活持久连接 HTTP 1.1 协议，默认就是持久连接 在通信双方中，主动关闭连接的一方会进入TIME_WIAT状态，而被动关闭的一方则不会进入该状态。
TIME_WAIT连接太多 服务端太多的TIME_WAIT连接，则说明连接是服务端主动去关闭的。查看了响应头，内容也是Connection: Close。
我们知道，一般情况下TIME_WAIT状态的链接至少会持续60秒。也就是说该连接占用的内存至少在60秒内不会释放。
当连接太多时，就有可能产生out of memory的问题，而操作系统就会很有可能把这个进程给kill掉，进而导致服务不可用。</description>
    </item>
    
    <item>
      <title>漫话TCP TIME-WAIT状态【ing】</title>
      <link>https://wdd.js.org/network/yoc1k0/</link>
      <pubDate>Tue, 07 Jan 2020 22:48:37 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/yoc1k0/</guid>
      <description>在《tcp/ip详解卷一》中，有幅图介绍了TCP的状态迁移，TCP的状态转移并不简单，我们本次重点关注TIME_WAIT状态。
TIME-WAIT 主机1发起FIN关闭连接请求，主机2发送ACK确认，然后也发送FIN。主机1在收到FIN之后，想主机2发送了ACK。
在主机1发送ACK时，主机1就进入了TIME-WAIT状态。
主动发起关闭连接的一方会有TIME-WAIT状态 如果两方同时发起关闭连接请求，那么两方都会进入TIME-WAIT状态 TIME-WAIT的时长在 /proc/sys/net/ipv4/tcp_fin_timeout 中配置，一般是60s 为什么要有TIME-WAIT状态？ 太多TIME-WAIT链接是否意味有故障？ </description>
    </item>
    
    <item>
      <title>2 链路层</title>
      <link>https://wdd.js.org/network/xwuvyr/</link>
      <pubDate>Thu, 28 Nov 2019 13:35:34 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/xwuvyr/</guid>
      <description>最大传输单元MTU 以太网和802.3对数据帧的长度有个限制，其最大长度分别是1500和1942。链路层的这个特性称作MTU, 最大传输单元。不同类型的网络大多数都有一个限制。
如果IP层的数据报的长度比链路层的MTU大，那么IP层就需要分片，每一片的长度要小于MTU。
使用netstat -in可以打印出网络接口的MTU
➜ ~ netstat -in Kernel Interface table Iface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg eth2 1500 0 1078767768 2264 689 0 1297577913 0 0 0 BMRU lo 16436 0 734474 0 0 0 734474 0 0 0 LRU 路径MTU 信息经过多个网络时，不同网络可能会有不同的MTU，而其中最小的一个MTU, 称为路径MTU。</description>
    </item>
    
    <item>
      <title>1 概述</title>
      <link>https://wdd.js.org/network/ir1i82/</link>
      <pubDate>Wed, 27 Nov 2019 09:20:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ir1i82/</guid>
      <description>分层 应用程序一般处理应用层的
------------------------------------------------------------ 应用层 # Telnet, FTP, Email, MySql	| 应用程序细节	| 用户进程 ------------------------------------------------------------ 运输层 # TCP, UDP | 内核(处理通信细节) 端到端通信 | ------------------------------------------| 网络层 # IP, ICMP, IGMP	| 逐跳通信，处理分组相关的活动，例如分组选路| ------------------------------------------| 链路层 # 设备驱动程序 接口卡	| 处理物理信号	| ------------------------------------------------------------ 应用层和传输层使用端到端的协议 网络层提供逐跳的协议 网桥在链路层来连接网络 路由器在网络层连接网络 以太网数据帧的物理特性是长度必须在46-1500字节之间 封装 以太网帧用来封装IP数据报。
IP数据报 = IP首部(20字节) + TCP首部(20字节) + 应用数据 # 针对TCP IP数据报 = IP首部(20字节) + UDP首部(8字节) + 应用数据 # 针对UDP 以太网帧 = 以太网首部(14字节) + IP数据报(46-1500字节) + 以太网尾部(4字节) IP数据报最大为1500字节，减去20字节IP首部，8字节UDP首部，留给UDP应用数据的只有1472字节。</description>
    </item>
    
    <item>
      <title>技巧1</title>
      <link>https://wdd.js.org/network/kttu4i/</link>
      <pubDate>Mon, 25 Nov 2019 20:24:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/kttu4i/</guid>
      <description>1 面向连接和面向非连接的区别？ 面向连接与面向非连接并不是指的物理介质，而是指的分组数据包。而实际上，连接只是一个虚拟的概念。
数据在发送前，会被分组发送。对于面向连接的协议来说，每个分组之间都有顺序的，分组会存储自己的位置信息。
可以理解在同一时间只维持一段关系。
面向非连接协议，分组直接并无任何关系，每个分组都是相互独立的。可以理解为脚踏多条船。</description>
    </item>
    
    <item>
      <title>基本套接字API回顾</title>
      <link>https://wdd.js.org/network/base-socket/</link>
      <pubDate>Mon, 25 Nov 2019 20:06:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/base-socket/</guid>
      <description>套接字API SOCKET socket(int domain, int type, int protocol) Socket API和协议无关，即可以用来创建Socket，无论是TCP还是UDP，还是进程间的通信，都可以用这个接口创建。
domain 表示通信域，最长见的有以下两个域 AF_INET 因特网通信 AF_LOCAL 进程间通信 type 表示套接字的类型 SOCK_STREAM 可靠的、全双工、面向连接的，实际上就是我们熟悉的TCP SOCK_DGRAM 不可靠、尽力而为的，无连接的。实际上指的就是UDP SOCK_RAW 允许对IP层的数据进行访问。用于特殊目的，例如ICMP protocol 表示具体通信协议 TCP/IP 本自同根生！</description>
    </item>
    
    <item>
      <title>可能被遗漏的https与http的知识点</title>
      <link>https://wdd.js.org/network/of5hny/</link>
      <pubDate>Tue, 15 Oct 2019 21:56:42 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/of5hny/</guid>
      <description>1. HTTPS域向HTTP域发送请求会被浏览器直接拒绝，HTTP向HTTPS则不会 例如在github pages页面，这是一个https页面，如果在这个页面向http发送请求，那么会直接被浏览器拒绝，并在控制台输出下面的报错信息。
jquery-1.11.3.min.js:5 Mixed Content: The page at &amp;#39;https://wangduanduan.github.io/ddddddd/&amp;#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &amp;#39;http://cccccc/&amp;#39;. This request has been blocked; the content must be served over HTTPS. 如果你在做第三方集成的系统，如果他们是在浏览器中直接调用你提供的接口，那么最好你使用https协议，这样无论对方是https还是http都可以访问。（相信我，这个很重要，我曾经经历过上线后遇到这个问题，然后连夜申请证书，把http升级到https的痛苦经历）
2. HTTPS的默认端口是443，而不是443 如果443端口已经被其他服务占用了，那么使用其他任何没有被占用的端口都可以用作HTTPS服务，只不过在请求的时候需要加上端口号罢了。</description>
    </item>
    
    <item>
      <title>ngrep明文http抓包教程</title>
      <link>https://wdd.js.org/network/pxn896/</link>
      <pubDate>Fri, 16 Aug 2019 09:59:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/pxn896/</guid>
      <description>一般使用tcpdump抓包，然后将包文件下载到本机，用wireshark去解析过滤。
但是这样会显得比较麻烦。
ngrep可以直接在linux转包，明文查看http的请求和响应信息。
安装 apt install ngrep # debian yum install ngrep # centos7 # 如果centos报错没有ngrep, 那么执行下面的命令, 然后再安装 rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm HTTP抓包 -W byline 头信息会自动换行 host 192.168.60.200 是过滤规则 源ip或者目的ip是192.168.60.200 ngrep -W byline host 192.168.60.200 interface: eth0 (192.168.1.0/255.255.255.0) filter: (ip or ip6) and ( host 192.168.60.200 ) #### T 192.168.1.102:39510 -&amp;gt; 192.168.60.200:7775 [AP] GET / HTTP/1.1. Host: 192.168.60.200:7775. User-Agent: curl/7.52.1. Accept: */*. . # T 192.168.60.200:7775 -&amp;gt; 192.168.1.102:39510 [AP] HTTP/1.1 302 Moved Temporarily.</description>
    </item>
    
    <item>
      <title>图解通信网络 第二版</title>
      <link>https://wdd.js.org/network/graph-network/</link>
      <pubDate>Mon, 08 Jul 2019 21:32:50 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/graph-network/</guid>
      <description>图片来自 https://microchipdeveloper.com/ 只不过这个网站访问速度很慢，但是里面的图片非常有意思，能够简洁明了的说明一个概念。
上学的时候，数学老师喜欢在讲课前先讲一些概念，然后再做题。但是我觉得概念并没有那么重要，我更喜欢做题。
但是，当你理解了概念后，再去实战，就有事半功倍的效果。
1. 路由器 路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。
路由器用来做网络之间的链接，所以路由器一般至少会链接到两个网络上。常见的就是一边连接外网，一边连接内网。
2. IP地址 3. 交换机 4. 五层网络模型 5. TCP vs UDP 6. TCP 和 UDP 头 7. 常见的端口号 8. 客户端和服务端 9. Socket 10. Socket建立 11. 一个Web服务器的工作过程s step1: 服务器在80端口监听消息 step2: 客户端随机选择一个端口，向服务端发起连接请求 step3: 传输层将消息传输给服务器 服务端建立一个Socket用来和客户端建立通道
step4: 服务器通过socket将html发给客户端 step5: 消息接受完毕，Socket关闭 12 NAT 参考 https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8 </description>
    </item>
    
  </channel>
</rss>
