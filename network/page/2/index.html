<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networks | 洞香春</title><meta name=keywords content><meta name=description content="Networks - 洞香春"><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/network/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.119.0"><link rel=alternate type=application/rss+xml href=https://wdd.js.org/network/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Networks"><meta property="og:description" content="Eddie Wang的个人博客"><meta property="og:type" content="website"><meta property="og:url" content="https://wdd.js.org/network/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Networks"><meta name=twitter:description content="Eddie Wang的个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Networks","item":"https://wdd.js.org/network/"}]}</script></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span class=active>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a></div><h1>Networks</h1></header><article class=post-entry><header class=entry-header><h2>tcpdump zine</h2></header><section class=entry-content><p>tcpdump-zine.pdf</p></section><footer class=entry-footer><span title='2020-12-04 13:29:53 +0800 CST'>2020-12-04 13:29:53</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to tcpdump zine" href=https://wdd.js.org/network/yscigi/></a></article><article class=post-entry><header class=entry-header><h2>pcap抓包教程</h2></header><section class=entry-content><p>准备条件 有gcc编译器 安装libpcap包 1.c 试运行 #include &lt;stdio.h> #include &lt;pcap.h> int main(int argc, char *argv[]) { char *dev = argv[1]; printf("Device: %s\n", dev); return(0); } gcc ./1.c -o 1.exe -lpcap demo-libpcap git:(master) ✗ ./1.exe eth0 Device: eth0 第一个栗子非常简单，仅仅是测试相关的库是否加载正确
2.c 获取默认网卡名称 参考 http://www.tcpdump.org/pcap.html</p></section><footer class=entry-footer><span title='2020-12-02 13:27:13 +0800 CST'>2020-12-02 13:27:13</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to pcap抓包教程" href=https://wdd.js.org/network/uq5cii/></a></article><article class=post-entry><header class=entry-header><h2>wireshark从pcap中提取语音文件</h2></header><section class=entry-content><p>使用tcpdump在服务端抓包，将抓包后的文件在wireshark中打开。
然后选择：Telephony - VoIP Calls，wireshark可以从抓包文件中提取出SIP呼叫列表。
呼叫列表页面 在呼叫列表页面，选择一条呼叫记录，点击Flow Sequence， 可以查看该呼叫的SIP时序图。点击Play Stream， 可以播放该条呼叫的声音。
RTPplay页面有播放按钮，点击播放可以听到通话声音。</p></section><footer class=entry-footer><span title='2020-11-25 10:34:52 +0800 CST'>2020-11-25 10:34:52</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to wireshark从pcap中提取语音文件" href=https://wdd.js.org/network/zgftde/></a></article><article class=post-entry><header class=entry-header><h2>wireshark合并和按时间截取pcap文件</h2></header><section class=entry-content><p>tcpdump可以在抓包时，按照指定时间间隔或者按照指定的包大小，产生新的pcap文件。用wireshark分析这些包时，往往需要将这些包做合并或者分离操作。
mergecap 如果安装了Wireshark那么mergecap就会自动安装，可以使用它来合并多个pcap文件。
// 按照数据包中的时间顺序合并文件 mergecap -w output.pcap input1.pcap input2.pcap input3.pcap // 按照命令行中的输入数据包文件顺序合并文件 // 不加-a, 可能会导致SIP时序图重复的问题 mergecap -a -w output.pcap input1.pcap input2.pcap input3.pcap editcap 对于一个很大的pcap文件，按照时间范围分割出新的pcap包
editcap -A '2014-12-10 10:11:01' -B '2014-12-10 10:21:01' input.pcap output.pcap 参考 https://blog.csdn.net/qq_19004627/article/details/82287172</p></section><footer class=entry-footer><span title='2020-11-25 10:11:22 +0800 CST'>2020-11-25 10:11:22</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to wireshark合并和按时间截取pcap文件" href=https://wdd.js.org/network/kgrco2/></a></article><article class=post-entry><header class=entry-header><h2>网络拆包笔记</h2></header><section class=entry-content><p>介绍 之所以要写这篇文章，是因为我要从pcap格式的抓包文件中抽取出语音文件。之间虽然对tcp协议有不错的理解，但并没有写代码去真正的解包分析。
最近用Node.js尝试去pacp文件中成功提取出了语音文件。再次做个总结。
预备知识 字节序： 关于字节序，可以参考 https://www.ruanyifeng.com/blog/2016/11/byte-order.html。读取的时候，如果字节序设置错了，就会读出来一堆无法解析的内容 PCAP格式 下面是paap文件的格式。
开局是一个全局的头文件。后续跟着一系列的包头和包体。
Global Header格式 全局头由六个字段组成，加起来一共24个字节。
typedef struct pcap_hdr_s { guint32 magic_number; /* magic number */ guint16 version_major; /* major version number */ guint16 version_minor; /* minor version number */ gint32 thiszone; /* GMT to local correction */ guint32 sigfigs; /* accuracy of timestamps */ guint32 snaplen; /* max length of captured packets, in octets */ guint32 network; /* data link type */ } pcap_hdr_t; magic_number 魔术字符，32位无符号整型，一般是0xa1b2c3d4或者0xd4c3b2a1，前者表示字段要按照大端字节序来读取，后者表示字段要按照小段字节序来读取。 version_major 大版本号，16位无符号整形。一般是2 version_minor 小版本号，16位无符号整形。一般是4 thiszone 时区 sigfigs 实际时间戳 snaplen 捕获的最大的长度 network 数据链路层的类型。参考http://www....</p></section><footer class=entry-footer><span title='2020-05-03 10:59:10 +0800 CST'>2020-05-03 10:59:10</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to 网络拆包笔记" href=https://wdd.js.org/network/gzskun/></a></article><article class=post-entry><header class=entry-header><h2>网络包的封装和分用</h2></header><section class=entry-content><p>图解包在TCP/IP各个协议栈的流动情况
点击查看【undefined】</p></section><footer class=entry-footer><span title='2020-03-11 08:24:20 +0800 CST'>2020-03-11 08:24:20</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to 网络包的封装和分用" href=https://wdd.js.org/network/mlepcg/></a></article><article class=post-entry><header class=entry-header><h2>IP协议 Protocol</h2></header><section class=entry-content><p>IP协议格式 字段说明 Protocol 表示上层协议，也就是传输层是什么协议。
只需要看Decimal这列，常用的有6表示TCP, 17表示UDP, 50表示ESP。
用wireshark抓包的时候，也可以看到Protocol: UDP(17)
参考 https://tools.ietf.org/html/rfc791 https://tools.ietf.org/html/rfc790 https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers</p></section><footer class=entry-footer><span title='2020-03-05 12:48:10 +0800 CST'>2020-03-05 12:48:10</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to IP协议 Protocol" href=https://wdd.js.org/network/ip-protocol/></a></article><article class=post-entry><header class=entry-header><h2>从飞机航线讲解网络分层</h2></header><section class=entry-content><p></p></section><footer class=entry-footer><span title='2020-03-03 13:48:27 +0800 CST'>2020-03-03 13:48:27</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to 从飞机航线讲解网络分层" href=https://wdd.js.org/network/ibhy8a/></a></article><article class=post-entry><header class=entry-header><h2>TIME_WAIT与持久连接</h2></header><section class=entry-content><p>在事务结束之后，仍然保持在打开状态的链接称为持久连接。非持久的链接会在每个事务结束之后就会关闭。
持久连接的好处 避免缓慢的链接建立阶段 避免慢启动的拥塞适应阶段 Keep-Alive 客户端发起请求，带有Connection: Keep-Alive头。客户端在响应头中回应Connection: Keep-Alive。则说明客户端同意持久连接。
如果客户端不同意持久连接，就会在响应头中返回Connection: Close
注意事项
即使服务端同意了持久连接，服务端也可以随时关闭连接 HTTP 1.0 协议，必须显式传递Connection: Keep-Alive，服务端才会激活持久连接 HTTP 1.1 协议，默认就是持久连接 在通信双方中，主动关闭连接的一方会进入TIME_WIAT状态，而被动关闭的一方则不会进入该状态。
TIME_WAIT连接太多 服务端太多的TIME_WAIT连接，则说明连接是服务端主动去关闭的。查看了响应头，内容也是Connection: Close。
我们知道，一般情况下TIME_WAIT状态的链接至少会持续60秒。也就是说该连接占用的内存至少在60秒内不会释放。
当连接太多时，就有可能产生out of memory的问题，而操作系统就会很有可能把这个进程给kill掉，进而导致服务不可用。</p></section><footer class=entry-footer><span title='2020-01-15 20:23:45 +0800 CST'>2020-01-15 20:23:45</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to TIME_WAIT与持久连接" href=https://wdd.js.org/network/sq4l53/></a></article><article class=post-entry><header class=entry-header><h2>漫话TCP TIME-WAIT状态【ing】</h2></header><section class=entry-content><p>在《tcp/ip详解卷一》中，有幅图介绍了TCP的状态迁移，TCP的状态转移并不简单，我们本次重点关注TIME_WAIT状态。
TIME-WAIT 主机1发起FIN关闭连接请求，主机2发送ACK确认，然后也发送FIN。主机1在收到FIN之后，想主机2发送了ACK。
在主机1发送ACK时，主机1就进入了TIME-WAIT状态。
主动发起关闭连接的一方会有TIME-WAIT状态 如果两方同时发起关闭连接请求，那么两方都会进入TIME-WAIT状态 TIME-WAIT的时长在 /proc/sys/net/ipv4/tcp_fin_timeout 中配置，一般是60s 为什么要有TIME-WAIT状态？ 太多TIME-WAIT链接是否意味有故障？</p></section><footer class=entry-footer><span title='2020-01-07 22:48:37 +0800 CST'>2020-01-07 22:48:37</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</footer><a class=entry-link aria-label="post link to 漫话TCP TIME-WAIT状态【ing】" href=https://wdd.js.org/network/yoc1k0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wdd.js.org/network/>« Prev Page</a>
<a class=next href=https://wdd.js.org/network/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>