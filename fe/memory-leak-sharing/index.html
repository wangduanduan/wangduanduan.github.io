<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JS内存泄漏分享 | 洞香春</title><meta name=keywords content><meta name=description content="什么是内存泄漏？ 单位时间内的内存变化量可能有三个值
正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。 趋近于0的值: 内存稳定维持 负数：内存在释放 实际上，在观察内存变化量时，需要有两个前提条件
一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。 至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。 下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。
有没有可能避免内存泄漏？ 除非你不写代码，否者你是无法避免内存泄漏的问题的。
第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。 第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。
为什么要关注内存泄漏？ 为什么要关注内存泄漏？我们客户的服务器可是有500G内存的
你可能有个很豪的金主。但是你不要忘记一个故事。
传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。
国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。
对于内存泄漏来说，可能500G都是不够用的。
实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。
然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~
基本类型 vs 引用类型 基本类型：undefined, null, boolean, number, string。基本类型是按值访问 引用类型的值实际上是指向内存中的对象 上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。
就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？
我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。
可以参考这个问题：https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers
内存是一张图 1代表根节点，在NodeJS里是global对象，在浏览器中是window对象 2-6代表对象 7-8代表原始类型。分别有三种，字符串，数字，布尔值 9-10代表从根节点无法到达的对象 注意，作为原始类型的值，在内存图中只能是叶子节点。 ** 从跟节点R0无法到达的节点9,10，将会在GC时被清除。
保留路径的含义是从跟对象到某一节点的最短路径。例如1->2->4->6。
对象保留树 节点： 构造函数的名称 边缘：对象的key 距离: 节点到跟节点的最短距离 支配项(Dominators) 每个对象有且仅有一个支配项 如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。 下图中
1支配2 2支配3,4,6 (想想2为什么没有支配5？) 3支配5 6支配7 5支配8 理解支配项的意义在于理解如何将资源释放。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。 对象大小 对象自身占用大小：shadow size 通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置 对象的大小的单位是字节 分析工具 heapsnapshot import {writeHeapSnapshot} from 'v8' router."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/fe/memory-leak-sharing/><link crossorigin=anonymous href=/assets/css/stylesheet.6d3944e058d85363bbe8a792a9b5f40002bca80be859dc19c466dd8de223973e.css integrity="sha256-bTlE4FjYU2O76KeSqbX0AAK8qAvoWdwZxGbdjeIjlz4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="JS内存泄漏分享"><meta property="og:description" content="什么是内存泄漏？ 单位时间内的内存变化量可能有三个值
正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。 趋近于0的值: 内存稳定维持 负数：内存在释放 实际上，在观察内存变化量时，需要有两个前提条件
一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。 至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。 下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。
有没有可能避免内存泄漏？ 除非你不写代码，否者你是无法避免内存泄漏的问题的。
第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。 第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。
为什么要关注内存泄漏？ 为什么要关注内存泄漏？我们客户的服务器可是有500G内存的
你可能有个很豪的金主。但是你不要忘记一个故事。
传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。
国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。
对于内存泄漏来说，可能500G都是不够用的。
实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。
然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~
基本类型 vs 引用类型 基本类型：undefined, null, boolean, number, string。基本类型是按值访问 引用类型的值实际上是指向内存中的对象 上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。
就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？
我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。
可以参考这个问题：https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers
内存是一张图 1代表根节点，在NodeJS里是global对象，在浏览器中是window对象 2-6代表对象 7-8代表原始类型。分别有三种，字符串，数字，布尔值 9-10代表从根节点无法到达的对象 注意，作为原始类型的值，在内存图中只能是叶子节点。 ** 从跟节点R0无法到达的节点9,10，将会在GC时被清除。
保留路径的含义是从跟对象到某一节点的最短路径。例如1->2->4->6。
对象保留树 节点： 构造函数的名称 边缘：对象的key 距离: 节点到跟节点的最短距离 支配项(Dominators) 每个对象有且仅有一个支配项 如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。 下图中
1支配2 2支配3,4,6 (想想2为什么没有支配5？) 3支配5 6支配7 5支配8 理解支配项的意义在于理解如何将资源释放。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。 对象大小 对象自身占用大小：shadow size 通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置 对象的大小的单位是字节 分析工具 heapsnapshot import {writeHeapSnapshot} from 'v8' router."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/fe/memory-leak-sharing/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="fe"><meta property="article:published_time" content="2022-10-29T11:47:38+08:00"><meta property="article:modified_time" content="2022-10-29T11:47:38+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="JS内存泄漏分享"><meta name=twitter:description content="什么是内存泄漏？ 单位时间内的内存变化量可能有三个值
正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。 趋近于0的值: 内存稳定维持 负数：内存在释放 实际上，在观察内存变化量时，需要有两个前提条件
一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。 至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。 下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。
有没有可能避免内存泄漏？ 除非你不写代码，否者你是无法避免内存泄漏的问题的。
第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。 第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。
为什么要关注内存泄漏？ 为什么要关注内存泄漏？我们客户的服务器可是有500G内存的
你可能有个很豪的金主。但是你不要忘记一个故事。
传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。
国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。
对于内存泄漏来说，可能500G都是不够用的。
实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。
然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~
基本类型 vs 引用类型 基本类型：undefined, null, boolean, number, string。基本类型是按值访问 引用类型的值实际上是指向内存中的对象 上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。
就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？
我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。
可以参考这个问题：https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers
内存是一张图 1代表根节点，在NodeJS里是global对象，在浏览器中是window对象 2-6代表对象 7-8代表原始类型。分别有三种，字符串，数字，布尔值 9-10代表从根节点无法到达的对象 注意，作为原始类型的值，在内存图中只能是叶子节点。 ** 从跟节点R0无法到达的节点9,10，将会在GC时被清除。
保留路径的含义是从跟对象到某一节点的最短路径。例如1->2->4->6。
对象保留树 节点： 构造函数的名称 边缘：对象的key 距离: 节点到跟节点的最短距离 支配项(Dominators) 每个对象有且仅有一个支配项 如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。 下图中
1支配2 2支配3,4,6 (想想2为什么没有支配5？) 3支配5 6支配7 5支配8 理解支配项的意义在于理解如何将资源释放。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。 对象大小 对象自身占用大小：shadow size 通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置 对象的大小的单位是字节 分析工具 heapsnapshot import {writeHeapSnapshot} from 'v8' router."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"前端之路","item":"https://wdd.js.org/fe/"},{"@type":"ListItem","position":3,"name":"JS内存泄漏分享","item":"https://wdd.js.org/fe/memory-leak-sharing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JS内存泄漏分享","name":"JS内存泄漏分享","description":"什么是内存泄漏？ 单位时间内的内存变化量可能有三个值\n正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。 趋近于0的值: 内存稳定维持 负数：内存在释放 实际上，在观察内存变化量时，需要有两个前提条件\n一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。 至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。 下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。\n有没有可能避免内存泄漏？ 除非你不写代码，否者你是无法避免内存泄漏的问题的。\n第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。 第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。\n为什么要关注内存泄漏？ 为什么要关注内存泄漏？我们客户的服务器可是有500G内存的\n你可能有个很豪的金主。但是你不要忘记一个故事。\n传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。\n国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。\n对于内存泄漏来说，可能500G都是不够用的。\n实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。\n然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~\n基本类型 vs 引用类型 基本类型：undefined, null, boolean, number, string。基本类型是按值访问 引用类型的值实际上是指向内存中的对象 上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。\n就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？\n我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。\n可以参考这个问题：https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers\n内存是一张图 1代表根节点，在NodeJS里是global对象，在浏览器中是window对象 2-6代表对象 7-8代表原始类型。分别有三种，字符串，数字，布尔值 9-10代表从根节点无法到达的对象 注意，作为原始类型的值，在内存图中只能是叶子节点。 ** 从跟节点R0无法到达的节点9,10，将会在GC时被清除。\n保留路径的含义是从跟对象到某一节点的最短路径。例如1-\u0026gt;2-\u0026gt;4-\u0026gt;6。\n对象保留树 节点： 构造函数的名称 边缘：对象的key 距离: 节点到跟节点的最短距离 支配项(Dominators) 每个对象有且仅有一个支配项 如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。 下图中\n1支配2 2支配3,4,6 (想想2为什么没有支配5？) 3支配5 6支配7 5支配8 理解支配项的意义在于理解如何将资源释放。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。 对象大小 对象自身占用大小：shadow size 通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置 对象的大小的单位是字节 分析工具 heapsnapshot import {writeHeapSnapshot} from \u0026#39;v8\u0026#39; router.","keywords":[],"articleBody":"什么是内存泄漏？ 单位时间内的内存变化量可能有三个值\n正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。 趋近于0的值: 内存稳定维持 负数：内存在释放 实际上，在观察内存变化量时，需要有两个前提条件\n一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。 至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。 下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。\n有没有可能避免内存泄漏？ 除非你不写代码，否者你是无法避免内存泄漏的问题的。\n第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。 第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。\n为什么要关注内存泄漏？ 为什么要关注内存泄漏？我们客户的服务器可是有500G内存的\n你可能有个很豪的金主。但是你不要忘记一个故事。\n传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。\n国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。\n对于内存泄漏来说，可能500G都是不够用的。\n实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。\n然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~\n基本类型 vs 引用类型 基本类型：undefined, null, boolean, number, string。基本类型是按值访问 引用类型的值实际上是指向内存中的对象 上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。\n就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？\n我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。\n可以参考这个问题：https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers\n内存是一张图 1代表根节点，在NodeJS里是global对象，在浏览器中是window对象 2-6代表对象 7-8代表原始类型。分别有三种，字符串，数字，布尔值 9-10代表从根节点无法到达的对象 注意，作为原始类型的值，在内存图中只能是叶子节点。 ** 从跟节点R0无法到达的节点9,10，将会在GC时被清除。\n保留路径的含义是从跟对象到某一节点的最短路径。例如1-\u003e2-\u003e4-\u003e6。\n对象保留树 节点： 构造函数的名称 边缘：对象的key 距离: 节点到跟节点的最短距离 支配项(Dominators) 每个对象有且仅有一个支配项 如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。 下图中\n1支配2 2支配3,4,6 (想想2为什么没有支配5？) 3支配5 6支配7 5支配8 理解支配项的意义在于理解如何将资源释放。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。 对象大小 对象自身占用大小：shadow size 通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置 对象的大小的单位是字节 分析工具 heapsnapshot import {writeHeapSnapshot} from 'v8' router.get('/heapdump', function (req: express.Request, res: express. Response, next: express.NextFunction) { logger.debug('help_heapdump::', req.ip, req.hostname) if (req.hostname !== 'localhost') { logger.error('error:report_bad_host:', req.hostname) return res.status(401).end() } res.status(200).end() let fileName = writeHeapSnapshot('node.heapsnapshot') logger.info('help_heapdumap_file::', fileName) }) 通过将v8 writeHeapSnapshot放到express的路由中，我们可以简单通过curl的方式产生snapshot文件。需要注意的是，writeHeapSnapshot可能需要一段时间来产生snapshot文件。在生产环境要注意，需要注意产生该函数的调用频率。\n拿到snapshot文件后，下一步是使用chrome dev-tools去打开这个文件。\n在chrome的inspect页面：chrome://inspect/#devices\n点击Open dedicated DevTools for Node。可以打开一个单独的页面dev-tools页面。当然你也可以任意一个页面打开devTools.\n点击load, 选择snapshot文件，就可以加载了。 真实的内存泄漏实战分析: socket.io内存泄漏 我写过一个使用socket.io来完成实时消息推送的服务，在做压力测试的时候，两个实例，模拟2000个客户端WebSocket连接，然后以每秒1000个速度发送消息，在持续压测15个小时之后，Node.js的内存从50M上涨到1.5G。所以，这其中必然产生了内存泄漏。\n在array这一列，可以看出它占用的Shallow Size和Retained Size占用的内存都是超过90%的。 我们展开array这一列，可以发现有很多的distance是15的对象。然后我们展开其中一个对象后。\n可以发现从距离是14到1之间的保留路径。\n展开一个对象之后，发现有很多ackClient，这个ackClient实际上对应了代码里我写的一个函数，用来确认消息是否被客户端收到的。这个确认机制是socket.io提供的。\n当我确认内存泄漏是socket.io的确认机制的问题后，我就将确认的函数从代码中移除，改为消息不确认。在一段时间的压测过后，服务的内存趋于稳定，看来问题已经定位了。\nsocket.io内存泄漏的原因 在阅读了socket.io的源码之后，可以看到每个Socket对象都有一个acks对象用来表示确认。\nfunction Socket(nsp, client, query){ this.nsp = nsp; this.server = nsp.server; this.adapter = this.nsp.adapter; this.id = nsp.name !== '/' ? nsp.name + '#' + client.id : client.id; this.client = client; this.conn = client.conn; this.rooms = {}; this.acks = {}; this.connected = true; this.disconnected = false; this.handshake = this.buildHandshake(query); this.fns = []; this.flags = {}; this._rooms = []; } 在调用socket.emit()方法时，socket.io会将消息的id附着在acks对象上，可以想象，随着消息发送的量增大，这个acks的属性将会越来越多。\nif (typeof args[args.length - 1] === 'function') { if (this._rooms.length || this.flags.broadcast) { throw new Error('Callbacks are not supported when broadcasting'); } debug('emitting packet with ack id %d', this.nsp.ids); this.acks[this.nsp.ids] = args.pop(); packet.id = this.nsp.ids++; } 当收到ack之后，acks上对应的包的属性才会被删掉。\nSocket.prototype.onack = function(packet){ var ack = this.acks[packet.id]; if ('function' == typeof ack) { debug('calling ack %s with %j', packet.id, packet.data); ack.apply(this, packet.data); delete this.acks[packet.id]; } else { debug('bad ack %s', packet.id); } }; 如果客户端不对消息进行ack确认，那么服务端就会积累非常多的待确认的消息，最终导致内存泄漏。\n虽然这个问题的最终原因是客户端没有及时确认，但是查看一下socket.io的项目，发现已经有将近500个issue没有解决。我觉得有时间的话，我会用原生的websocket替换掉socket.io。不然这个socket.io很可能回成为项目的一个瓶颈点。\n参考资料 http://slides.com/gruizdevilla/memory http://bmeck.github.io/snapshot-utils/doc/manual/terms.html https://nodejs.org/dist/latest-v12.x/docs/api/v8.html#v8_v8_writeheapsnapshot_filename https://github.com/socketio/socket.io/issues/3494 ","wordCount":"272","inLanguage":"en","datePublished":"2022-10-29T11:47:38+08:00","dateModified":"2022-10-29T11:47:38+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/fe/memory-leak-sharing/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/cowboy.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/fe/>前端之路</a></div><h1 class=post-title>JS内存泄漏分享</h1><div class=post-meta><span title='2022-10-29 11:47:38 +0800 CST'>2022-10-29 11:47:38</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Eddie Wang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/fe/memory-leak-sharing/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f aria-label=什么是内存泄漏？>什么是内存泄漏？</a></li><li><a href=#%e6%9c%89%e6%b2%a1%e6%9c%89%e5%8f%af%e8%83%bd%e9%81%bf%e5%85%8d%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f aria-label=有没有可能避免内存泄漏？>有没有可能避免内存泄漏？</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%b3%e6%b3%a8%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f aria-label=为什么要关注内存泄漏？>为什么要关注内存泄漏？</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b-vs-%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b aria-label="基本类型 vs 引用类型">基本类型 vs 引用类型</a></li><li><a href=#%e5%86%85%e5%ad%98%e6%98%af%e4%b8%80%e5%bc%a0%e5%9b%be aria-label=内存是一张图>内存是一张图</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e4%bf%9d%e7%95%99%e6%a0%91 aria-label=对象保留树>对象保留树</a></li><li><a href=#%e6%94%af%e9%85%8d%e9%a1%b9dominators aria-label=支配项(Dominators)>支配项(Dominators)</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e5%a4%a7%e5%b0%8f aria-label=对象大小>对象大小</a></li><li><a href=#%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7 aria-label=分析工具>分析工具</a><ul><li><a href=#heapsnapshot aria-label=heapsnapshot>heapsnapshot</a></li><li><a href=#%e7%9c%9f%e5%ae%9e%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9e%e6%88%98%e5%88%86%e6%9e%90-socketio%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f aria-label="真实的内存泄漏实战分析: socket.io内存泄漏">真实的内存泄漏实战分析: socket.io内存泄漏</a></li><li><a href=#socketio%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=socket.io内存泄漏的原因>socket.io内存泄漏的原因</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=什么是内存泄漏>什么是内存泄漏？<a hidden class=anchor aria-hidden=true href=#什么是内存泄漏>#</a></h1><p>单位时间内的内存变化量可能有三个值</p><ul><li>正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。</li><li>趋近于0的值: 内存稳定维持</li><li>负数：内存在释放</li></ul><p><img loading=lazy src=2022-10-29-11-48-15.png alt></p><p>实际上，在观察内存变化量时，需要有两个前提条件</p><ol><li>一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。</li><li>至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。</li></ol><p>下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。</p><p><img loading=lazy src=2022-10-29-11-48-30.png alt></p><h1 id=有没有可能避免内存泄漏>有没有可能避免内存泄漏？<a hidden class=anchor aria-hidden=true href=#有没有可能避免内存泄漏>#</a></h1><p>除非你不写代码，否者你是无法避免内存泄漏的问题的。</p><p>第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。
第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。</p><h1 id=为什么要关注内存泄漏>为什么要关注内存泄漏？<a hidden class=anchor aria-hidden=true href=#为什么要关注内存泄漏>#</a></h1><p>为什么要关注内存泄漏？我们客户的服务器可是有500G内存的</p><p>你可能有个很豪的金主。但是你不要忘记一个故事。</p><blockquote><p>传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。</p><p>国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。</p></blockquote><p>对于内存泄漏来说，可能500G都是不够用的。</p><p>实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。</p><p>然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~</p><h1 id=基本类型-vs-引用类型>基本类型 vs 引用类型<a hidden class=anchor aria-hidden=true href=#基本类型-vs-引用类型>#</a></h1><ul><li>基本类型：undefined, null, boolean, number, string。基本类型是按值访问</li><li>引用类型的值实际上是指向内存中的对象</li></ul><p>上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。</p><p>就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？</p><p>我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。</p><p>可以参考这个问题：<a href=https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers>https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers</a></p><h1 id=内存是一张图>内存是一张图<a hidden class=anchor aria-hidden=true href=#内存是一张图>#</a></h1><ul><li>1代表根节点，在NodeJS里是global对象，在浏览器中是window对象</li><li>2-6代表对象</li><li>7-8代表原始类型。分别有三种，字符串，数字，布尔值</li><li>9-10代表从根节点无法到达的对象</li></ul><p>注意，作为原始类型的值，<strong>在内存图中只能是叶子节点。</strong>
**
从跟节点R0无法到达的节点9,10，将会在GC时被清除。</p><p><img loading=lazy src=2022-10-29-11-49-19.png alt></p><p>保留路径的含义是从跟对象到某一节点的最短路径。例如1->2->4->6。</p><h1 id=对象保留树>对象保留树<a hidden class=anchor aria-hidden=true href=#对象保留树>#</a></h1><ul><li>节点： 构造函数的名称</li><li>边缘：对象的key</li><li>距离: 节点到跟节点的最短距离</li></ul><h1 id=支配项dominators>支配项(Dominators)<a hidden class=anchor aria-hidden=true href=#支配项dominators>#</a></h1><ul><li>每个对象有且仅有一个支配项</li><li>如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。</li></ul><p>下图中</p><ul><li>1支配2</li><li>2支配3,4,6 (想想2为什么没有支配5？)</li><li>3支配5</li><li>6支配7</li><li>5支配8</li></ul><p><strong>理解支配项的意义在于理解如何将资源释放</strong>。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。
<img loading=lazy src=2022-10-29-11-50-15.png alt></p><h1 id=对象大小>对象大小<a hidden class=anchor aria-hidden=true href=#对象大小>#</a></h1><ul><li>对象自身占用大小：shadow size</li><li>通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置</li><li>对象的大小的单位是字节</li></ul><p><img loading=lazy src=2022-10-29-11-50-27.png alt></p><h1 id=分析工具>分析工具<a hidden class=anchor aria-hidden=true href=#分析工具>#</a></h1><h2 id=heapsnapshot>heapsnapshot<a hidden class=anchor aria-hidden=true href=#heapsnapshot>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>import <span style=color:#f92672>{</span>writeHeapSnapshot<span style=color:#f92672>}</span> from <span style=color:#e6db74>&#39;v8&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>router.get<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;/heapdump&#39;</span>, <span style=color:#66d9ef>function</span> <span style=color:#f92672>(</span>req: express.Request, res: express. Response, next: express.NextFunction<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    logger.debug<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;help_heapdump::&#39;</span>, req.ip, req.hostname<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>req.hostname !<span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;localhost&#39;</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        logger.error<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;error:report_bad_host:&#39;</span>, req.hostname<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res.status<span style=color:#f92672>(</span>401<span style=color:#f92672>)</span>.end<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    res.status<span style=color:#f92672>(</span>200<span style=color:#f92672>)</span>.end<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    let fileName <span style=color:#f92672>=</span> writeHeapSnapshot<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;node.heapsnapshot&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    logger.info<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;help_heapdumap_file::&#39;</span>, fileName<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>})</span>
</span></span></code></pre></div><p>通过将v8 writeHeapSnapshot放到express的路由中，我们可以简单通过curl的方式产生snapshot文件。需要注意的是，writeHeapSnapshot可能需要一段时间来产生snapshot文件。在生产环境要注意，需要注意产生该函数的调用频率。</p><p>拿到snapshot文件后，下一步是使用chrome dev-tools去打开这个文件。</p><p>在chrome的inspect页面：<a href>chrome://inspect/#devices</a></p><p>点击Open dedicated DevTools for Node。可以打开一个单独的页面dev-tools页面。当然你也可以任意一个页面打开devTools.</p><p><img loading=lazy src=2022-10-29-11-50-44.png alt></p><p>点击load, 选择snapshot文件，就可以加载了。
<img loading=lazy src=2022-10-29-11-50-57.png alt></p><h2 id=真实的内存泄漏实战分析-socketio内存泄漏>真实的内存泄漏实战分析: socket.io内存泄漏<a hidden class=anchor aria-hidden=true href=#真实的内存泄漏实战分析-socketio内存泄漏>#</a></h2><p>我写过一个使用socket.io来完成实时消息推送的服务，在做压力测试的时候，两个实例，模拟2000个客户端WebSocket连接，然后以每秒1000个速度发送消息，在持续压测15个小时之后，Node.js的内存从50M上涨到1.5G。所以，这其中必然产生了内存泄漏。</p><p>在array这一列，可以看出它占用的Shallow Size和Retained Size占用的内存都是超过90%的。
<img loading=lazy src=2022-10-29-11-51-15.png alt></p><p>我们展开array这一列，可以发现有很多的distance是15的对象。然后我们展开其中一个对象后。</p><p>可以发现从距离是14到1之间的保留路径。</p><p><img loading=lazy src=2022-10-29-11-51-37.png alt></p><p>展开一个对象之后，发现有很多ackClient，这个ackClient实际上对应了代码里我写的一个函数，用来确认消息是否被客户端收到的。这个确认机制是socket.io提供的。</p><p><img loading=lazy src=2022-10-29-11-51-57.png alt></p><p>当我确认内存泄漏是socket.io的确认机制的问题后，我就将确认的函数从代码中移除，改为消息不确认。在一段时间的压测过后，服务的内存趋于稳定，看来问题已经定位了。</p><h2 id=socketio内存泄漏的原因>socket.io内存泄漏的原因<a hidden class=anchor aria-hidden=true href=#socketio内存泄漏的原因>#</a></h2><p>在阅读了socket.io的源码之后，可以看到每个Socket对象都有一个acks对象用来表示确认。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> Socket<span style=color:#f92672>(</span>nsp, client, query<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>  this.nsp <span style=color:#f92672>=</span> nsp;
</span></span><span style=display:flex><span>  this.server <span style=color:#f92672>=</span> nsp.server;
</span></span><span style=display:flex><span>  this.adapter <span style=color:#f92672>=</span> this.nsp.adapter;
</span></span><span style=display:flex><span>  this.id <span style=color:#f92672>=</span> nsp.name !<span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span> ? nsp.name + <span style=color:#e6db74>&#39;#&#39;</span> + client.id : client.id;
</span></span><span style=display:flex><span>  this.client <span style=color:#f92672>=</span> client;
</span></span><span style=display:flex><span>  this.conn <span style=color:#f92672>=</span> client.conn;
</span></span><span style=display:flex><span>  this.rooms <span style=color:#f92672>=</span> <span style=color:#f92672>{}</span>;
</span></span><span style=display:flex><span>  this.acks <span style=color:#f92672>=</span> <span style=color:#f92672>{}</span>;
</span></span><span style=display:flex><span>  this.connected <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>  this.disconnected <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  this.handshake <span style=color:#f92672>=</span> this.buildHandshake<span style=color:#f92672>(</span>query<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  this.fns <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>;
</span></span><span style=display:flex><span>  this.flags <span style=color:#f92672>=</span> <span style=color:#f92672>{}</span>;
</span></span><span style=display:flex><span>  this._rooms <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在调用socket.emit()方法时，socket.io会将消息的id附着在acks对象上，可以想象，随着消息发送的量增大，这个acks的属性将会越来越多。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>typeof args<span style=color:#f92672>[</span>args.length - 1<span style=color:#f92672>]</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>this._rooms.length <span style=color:#f92672>||</span> this.flags.broadcast<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      throw new Error<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;Callbacks are not supported when broadcasting&#39;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    debug<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;emitting packet with ack id %d&#39;</span>, this.nsp.ids<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    this.acks<span style=color:#f92672>[</span>this.nsp.ids<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> args.pop<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>    packet.id <span style=color:#f92672>=</span> this.nsp.ids++;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>当收到ack之后，acks上对应的包的属性才会被删掉。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Socket.prototype.onack <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span><span style=color:#f92672>(</span>packet<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>  var ack <span style=color:#f92672>=</span> this.acks<span style=color:#f92672>[</span>packet.id<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#39;function&#39;</span> <span style=color:#f92672>==</span> typeof ack<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    debug<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;calling ack %s with %j&#39;</span>, packet.id, packet.data<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    ack.apply<span style=color:#f92672>(</span>this, packet.data<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    delete this.acks<span style=color:#f92672>[</span>packet.id<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    debug<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;bad ack %s&#39;</span>, packet.id<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>;
</span></span></code></pre></div><p>如果客户端不对消息进行ack确认，那么服务端就会积累非常多的待确认的消息，最终导致内存泄漏。</p><p>虽然这个问题的最终原因是客户端没有及时确认，但是查看一下socket.io的项目，发现已经有将近500个issue没有解决。我觉得有时间的话，我会用原生的websocket替换掉socket.io。不然这个socket.io很可能回成为项目的一个瓶颈点。</p><h1 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h1><ul><li><a href=http://slides.com/gruizdevilla/memory>http://slides.com/gruizdevilla/memory</a></li><li><a href=http://bmeck.github.io/snapshot-utils/doc/manual/terms.html>http://bmeck.github.io/snapshot-utils/doc/manual/terms.html</a></li><li><a href=https://nodejs.org/dist/latest-v12.x/docs/api/v8.html#v8_v8_writeheapsnapshot_filename>https://nodejs.org/dist/latest-v12.x/docs/api/v8.html#v8_v8_writeheapsnapshot_filename</a></li><li><a href=https://github.com/socketio/socket.io/issues/3494>https://github.com/socketio/socket.io/issues/3494</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>