<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript内存泄露分析 | 洞香春</title><meta name=keywords content><meta name=description content="参考: http://slides.com/gruizdevilla/memory
内存是一张图 原始类型，只能作为叶子。原始类型不能引用其他类型 数字 字符串 布尔值 除了原始类型之外，其他类型都是对象，其实就是键值对 数组是一种特殊对象，它的键是连续的数字 内存从根开始 在浏览器中，根对象是window 在nodejs中，根对象是global 任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10 根节点的GC是无法控制的 路径 从根节点开始到特定对象的路径，如下图的1-2-4-6-8 支配项 每个对象有且仅有一个支配项，支配项对对象可能不是直接引用 举例子 节点1支配节点2 节点2支持节点3、4、6 节点3支配节点5 节点6支配节点7 节点5支配节点8 上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于从根节点到节点B的每一个路径中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6 V8 新生代与老生代 v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略 相比而言，新生代GC很快，老生代则较慢 新生代的内存在某些条件下会被转到老生代内存区 GC发生时，用可能应用会暂停 解除引用的一些错误 var a = {name: 'wdd'} delete a.name // 这回让对象a变成慢对象 var a = {name: 'wdd'} a.name = null // 这个则更好 关于slow Object V8 optimizing compiler makes assumptions on your code to make optimizations. It transparently creates hidden classes that represent your objects."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/fe/memory-leak-ppt/><link crossorigin=anonymous href=/assets/css/stylesheet.6d3944e058d85363bbe8a792a9b5f40002bca80be859dc19c466dd8de223973e.css integrity="sha256-bTlE4FjYU2O76KeSqbX0AAK8qAvoWdwZxGbdjeIjlz4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="JavaScript内存泄露分析"><meta property="og:description" content="参考: http://slides.com/gruizdevilla/memory
内存是一张图 原始类型，只能作为叶子。原始类型不能引用其他类型 数字 字符串 布尔值 除了原始类型之外，其他类型都是对象，其实就是键值对 数组是一种特殊对象，它的键是连续的数字 内存从根开始 在浏览器中，根对象是window 在nodejs中，根对象是global 任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10 根节点的GC是无法控制的 路径 从根节点开始到特定对象的路径，如下图的1-2-4-6-8 支配项 每个对象有且仅有一个支配项，支配项对对象可能不是直接引用 举例子 节点1支配节点2 节点2支持节点3、4、6 节点3支配节点5 节点6支配节点7 节点5支配节点8 上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于从根节点到节点B的每一个路径中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6 V8 新生代与老生代 v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略 相比而言，新生代GC很快，老生代则较慢 新生代的内存在某些条件下会被转到老生代内存区 GC发生时，用可能应用会暂停 解除引用的一些错误 var a = {name: 'wdd'} delete a.name // 这回让对象a变成慢对象 var a = {name: 'wdd'} a.name = null // 这个则更好 关于slow Object V8 optimizing compiler makes assumptions on your code to make optimizations. It transparently creates hidden classes that represent your objects."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/fe/memory-leak-ppt/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="fe"><meta property="article:published_time" content="2022-10-29T11:52:59+08:00"><meta property="article:modified_time" content="2022-10-29T11:52:59+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="JavaScript内存泄露分析"><meta name=twitter:description content="参考: http://slides.com/gruizdevilla/memory
内存是一张图 原始类型，只能作为叶子。原始类型不能引用其他类型 数字 字符串 布尔值 除了原始类型之外，其他类型都是对象，其实就是键值对 数组是一种特殊对象，它的键是连续的数字 内存从根开始 在浏览器中，根对象是window 在nodejs中，根对象是global 任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10 根节点的GC是无法控制的 路径 从根节点开始到特定对象的路径，如下图的1-2-4-6-8 支配项 每个对象有且仅有一个支配项，支配项对对象可能不是直接引用 举例子 节点1支配节点2 节点2支持节点3、4、6 节点3支配节点5 节点6支配节点7 节点5支配节点8 上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于从根节点到节点B的每一个路径中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6 V8 新生代与老生代 v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略 相比而言，新生代GC很快，老生代则较慢 新生代的内存在某些条件下会被转到老生代内存区 GC发生时，用可能应用会暂停 解除引用的一些错误 var a = {name: 'wdd'} delete a.name // 这回让对象a变成慢对象 var a = {name: 'wdd'} a.name = null // 这个则更好 关于slow Object V8 optimizing compiler makes assumptions on your code to make optimizations. It transparently creates hidden classes that represent your objects."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"前端之路","item":"https://wdd.js.org/fe/"},{"@type":"ListItem","position":3,"name":"JavaScript内存泄露分析","item":"https://wdd.js.org/fe/memory-leak-ppt/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript内存泄露分析","name":"JavaScript内存泄露分析","description":"参考: http://slides.com/gruizdevilla/memory\n内存是一张图 原始类型，只能作为叶子。原始类型不能引用其他类型 数字 字符串 布尔值 除了原始类型之外，其他类型都是对象，其实就是键值对 数组是一种特殊对象，它的键是连续的数字 内存从根开始 在浏览器中，根对象是window 在nodejs中，根对象是global 任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10 根节点的GC是无法控制的 路径 从根节点开始到特定对象的路径，如下图的1-2-4-6-8 支配项 每个对象有且仅有一个支配项，支配项对对象可能不是直接引用 举例子 节点1支配节点2 节点2支持节点3、4、6 节点3支配节点5 节点6支配节点7 节点5支配节点8 上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于从根节点到节点B的每一个路径中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6 V8 新生代与老生代 v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略 相比而言，新生代GC很快，老生代则较慢 新生代的内存在某些条件下会被转到老生代内存区 GC发生时，用可能应用会暂停 解除引用的一些错误 var a = {name: \u0026#39;wdd\u0026#39;} delete a.name // 这回让对象a变成慢对象 var a = {name: \u0026#39;wdd\u0026#39;} a.name = null // 这个则更好 关于slow Object V8 optimizing compiler makes assumptions on your code to make optimizations. It transparently creates hidden classes that represent your objects.","keywords":[],"articleBody":"参考: http://slides.com/gruizdevilla/memory\n内存是一张图 原始类型，只能作为叶子。原始类型不能引用其他类型 数字 字符串 布尔值 除了原始类型之外，其他类型都是对象，其实就是键值对 数组是一种特殊对象，它的键是连续的数字 内存从根开始 在浏览器中，根对象是window 在nodejs中，根对象是global 任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10 根节点的GC是无法控制的 路径 从根节点开始到特定对象的路径，如下图的1-2-4-6-8 支配项 每个对象有且仅有一个支配项，支配项对对象可能不是直接引用 举例子 节点1支配节点2 节点2支持节点3、4、6 节点3支配节点5 节点6支配节点7 节点5支配节点8 上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于从根节点到节点B的每一个路径中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6 V8 新生代与老生代 v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略 相比而言，新生代GC很快，老生代则较慢 新生代的内存在某些条件下会被转到老生代内存区 GC发生时，用可能应用会暂停 解除引用的一些错误 var a = {name: 'wdd'} delete a.name // 这回让对象a变成慢对象 var a = {name: 'wdd'} a.name = null // 这个则更好 关于slow Object V8 optimizing compiler makes assumptions on your code to make optimizations. It transparently creates hidden classes that represent your objects. Using this hidden classes, V8 works much faster. If you “delete” properties, these assumptions are no longer valid, and the code is de-optimized, slowing your code. // Fast Object function FastPurchase(units, price) { this.units = units; this.price = price; this.total = 0; this.x = 1; } var fast = new FastPurchase(3, 25); // Slow Object function SlowPurchase(units, price) { this.units = units; this.price = price; this.total = 0; this.x = 1; } var slow = new SlowPurchase(3, 25); //x property is useless //so I delete it delete slow.x; Timers内存泄露 // var buggyObject = { callAgain: function () { var ref = this; var val = setTimeout(function () { console.log('Called again: ' + new Date().toTimeString()); ref.callAgain(); }, 1000); } }; buggyObject.callAgain(); buggyObject = null; 闭包内存泄露 var a = function () { var largeStr = new Array(1000000).join('x'); return function () { return largeStr; }; }(); var a = function () { var smallStr = 'x', largeStr = new Array(1000000).join('x'); return function (n) { return smallStr; }; }(); var a = function () { var smallStr = 'x', largeStr = new Array(1000000).join('x'); return function (n) { eval(''); //maintains reference to largeStr return smallStr; }; }(); DOM 内存泄露 #leaf maintains a reference to it’s parent (parentNode), and recursively up to #tree, so only when leafRef is nullified is the WHOLE tree under #tree candidate to be GC\nvar select = document.querySelector; var treeRef = select(\"#tree\"); var leafRef = select(\"#leaf\"); var body = select(\"body\"); body.removeChild(treeRef); //#tree can't be GC yet due to treeRef treeRef = null; //#tree can't be GC yet, due to //indirect reference from leafRef leafRef = null; //NOW can be #tree GC 守则 Use appropiate scope Better than de-referencing, use local scopes. Unbind event listeners Unbind events that are no longer needed, specially if the related DOM objects are going to be removed. Manage local cache Be careful with storing large chunks of data that you are not going to use. 分析内存泄漏的工具 浏览器： performance.memory devtool memory profile 关于闭包的提示 给闭包命名，这样在内存分析时，就可以按照函数名找到对应的函数 ","wordCount":"400","inLanguage":"en","datePublished":"2022-10-29T11:52:59+08:00","dateModified":"2022-10-29T11:52:59+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/fe/memory-leak-ppt/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/cowboy.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/books/ title=百分之一阅读法><span>百分之一阅读法</span></a></li><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/kamailio/ title=Kamailio><span>Kamailio</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/fe/ title=前端><span>前端</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/fe/>前端之路</a></div><h1 class=post-title>JavaScript内存泄露分析</h1><div class=post-meta><span title='2022-10-29 11:52:59 +0800 CST'>2022-10-29 11:52:59</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Eddie Wang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/fe/memory-leak-ppt/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ad%98%e6%98%af%e4%b8%80%e5%bc%a0%e5%9b%be aria-label=内存是一张图>内存是一张图</a></li><li><a href=#%e5%86%85%e5%ad%98%e4%bb%8e%e6%a0%b9%e5%bc%80%e5%a7%8b aria-label=内存从根开始>内存从根开始</a></li><li><a href=#%e8%b7%af%e5%be%84 aria-label=路径>路径</a></li><li><a href=#%e6%94%af%e9%85%8d%e9%a1%b9 aria-label=支配项>支配项</a></li><li><a href=#v8-%e6%96%b0%e7%94%9f%e4%bb%a3%e4%b8%8e%e8%80%81%e7%94%9f%e4%bb%a3 aria-label="V8 新生代与老生代">V8 新生代与老生代</a></li><li><a href=#%e8%a7%a3%e9%99%a4%e5%bc%95%e7%94%a8%e7%9a%84%e4%b8%80%e4%ba%9b%e9%94%99%e8%af%af aria-label=解除引用的一些错误>解除引用的一些错误</a></li><li><a href=#%e5%85%b3%e4%ba%8eslow-object aria-label="关于slow Object">关于slow Object</a></li><li><a href=#timers%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2 aria-label=Timers内存泄露>Timers内存泄露</a></li><li><a href=#%e9%97%ad%e5%8c%85%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2 aria-label=闭包内存泄露>闭包内存泄露</a></li><li><a href=#dom-%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2 aria-label="DOM 内存泄露">DOM 内存泄露</a></li><li><a href=#%e5%ae%88%e5%88%99 aria-label=守则>守则</a></li><li><a href=#%e5%88%86%e6%9e%90%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e5%b7%a5%e5%85%b7 aria-label=分析内存泄漏的工具>分析内存泄漏的工具</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e9%97%ad%e5%8c%85%e7%9a%84%e6%8f%90%e7%a4%ba aria-label=关于闭包的提示>关于闭包的提示</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>参考: <a href=http://slides.com/gruizdevilla/memory#/7/11>http://slides.com/gruizdevilla/memory</a></p><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><h1 id=内存是一张图>内存是一张图<a hidden class=anchor aria-hidden=true href=#内存是一张图>#</a></h1><ul><li>原始类型，只能作为叶子。原始类型不能引用其他类型<ul><li>数字</li><li>字符串</li><li>布尔值</li></ul></li><li>除了原始类型之外，其他类型都是对象，其实就是键值对</li><li>数组是一种特殊对象，它的键是连续的数字</li></ul><p><img loading=lazy src=2022-10-29-11-53-40.png alt></p><h1 id=内存从根开始>内存从根开始<a hidden class=anchor aria-hidden=true href=#内存从根开始>#</a></h1><ul><li>在浏览器中，根对象是window</li><li>在nodejs中，根对象是global</li><li>任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10</li><li>根节点的GC是无法控制的</li></ul><p><img loading=lazy src=2022-10-29-11-53-49.png alt></p><h1 id=路径>路径<a hidden class=anchor aria-hidden=true href=#路径>#</a></h1><ul><li>从根节点开始到特定对象的路径，如下图的1-2-4-6-8</li></ul><p><img loading=lazy src=2022-10-29-11-53-57.png alt></p><h1 id=支配项>支配项<a hidden class=anchor aria-hidden=true href=#支配项>#</a></h1><ul><li>每个对象有且仅有一个支配项，支配项对对象可能不是直接引用</li><li>举例子<ul><li>节点1支配节点2</li><li>节点2支持节点3、4、6</li><li>节点3支配节点5</li><li>节点6支配节点7</li><li>节点5支配节点8</li><li>上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于<strong>从根节点到节点B的每一个路径</strong>中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6</li></ul></li></ul><p><img loading=lazy src=2022-10-29-11-54-06.png alt></p><h1 id=v8-新生代与老生代>V8 新生代与老生代<a hidden class=anchor aria-hidden=true href=#v8-新生代与老生代>#</a></h1><ul><li>v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略</li><li>相比而言，新生代GC很快，老生代则较慢</li><li>新生代的内存在某些条件下会被转到老生代内存区</li><li>GC发生时，用可能应用会暂停</li></ul><h1 id=解除引用的一些错误>解除引用的一些错误<a hidden class=anchor aria-hidden=true href=#解除引用的一些错误>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>var a <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>name: <span style=color:#e6db74>&#39;wdd&#39;</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>delete a.name // 这回让对象a变成慢对象
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>name: <span style=color:#e6db74>&#39;wdd&#39;</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>a.name <span style=color:#f92672>=</span> null // 这个则更好
</span></span></code></pre></div><h1 id=关于slow-object>关于slow Object<a hidden class=anchor aria-hidden=true href=#关于slow-object>#</a></h1><ul><li>V8 optimizing compiler makes assumptions on your code to make optimizations.</li><li>It transparently creates hidden classes that represent your objects.</li><li>Using this hidden classes, V8 works much faster. If you &ldquo;delete&rdquo; properties, these assumptions are no longer valid, and the code is de-optimized, slowing your code.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>// Fast Object 
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> FastPurchase<span style=color:#f92672>(</span>units, price<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    this.units <span style=color:#f92672>=</span> units;
</span></span><span style=display:flex><span>    this.price <span style=color:#f92672>=</span> price;
</span></span><span style=display:flex><span>    this.total <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    this.x <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>var fast <span style=color:#f92672>=</span> new FastPurchase<span style=color:#f92672>(</span>3, 25<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Slow Object 
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> SlowPurchase<span style=color:#f92672>(</span>units, price<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    this.units <span style=color:#f92672>=</span> units;
</span></span><span style=display:flex><span>    this.price <span style=color:#f92672>=</span> price;
</span></span><span style=display:flex><span>    this.total <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    this.x <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>var slow <span style=color:#f92672>=</span> new SlowPurchase<span style=color:#f92672>(</span>3, 25<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>//x property is useless 
</span></span><span style=display:flex><span>//so I delete it
</span></span><span style=display:flex><span>delete slow.x; 
</span></span></code></pre></div><p><img loading=lazy src=2022-10-29-11-54-19.png alt></p><h1 id=timers内存泄露>Timers内存泄露<a hidden class=anchor aria-hidden=true href=#timers内存泄露>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>// 
</span></span><span style=display:flex><span>var buggyObject <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span> callAgain: <span style=color:#66d9ef>function</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  var ref <span style=color:#f92672>=</span> this;
</span></span><span style=display:flex><span>  var val <span style=color:#f92672>=</span> setTimeout<span style=color:#f92672>(</span><span style=color:#66d9ef>function</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>   console.log<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;Called again: &#39;</span>
</span></span><span style=display:flex><span>   + new Date<span style=color:#f92672>()</span>.toTimeString<span style=color:#f92672>())</span>;
</span></span><span style=display:flex><span>   ref.callAgain<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>, 1000<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>buggyObject.callAgain<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>buggyObject <span style=color:#f92672>=</span> null;
</span></span></code></pre></div><h1 id=闭包内存泄露>闭包内存泄露<a hidden class=anchor aria-hidden=true href=#闭包内存泄露>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>var a <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  var largeStr <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>         new Array<span style=color:#f92672>(</span>1000000<span style=color:#f92672>)</span>.join<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;x&#39;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> largeStr;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}()</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    var smallStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;x&#39;</span>,
</span></span><span style=display:flex><span>           largeStr <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                new Array<span style=color:#f92672>(</span>1000000<span style=color:#f92672>)</span>.join<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;x&#39;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span> <span style=color:#f92672>(</span>n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> smallStr;
</span></span><span style=display:flex><span>   <span style=color:#f92672>}</span>; 
</span></span><span style=display:flex><span><span style=color:#f92672>}()</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>   var smallStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;x&#39;</span>,
</span></span><span style=display:flex><span>          largeStr <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              new Array<span style=color:#f92672>(</span>1000000<span style=color:#f92672>)</span>.join<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;x&#39;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span> <span style=color:#f92672>(</span>n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        eval<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>)</span>; //maintains reference to largeStr
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> smallStr;
</span></span><span style=display:flex><span>     <span style=color:#f92672>}</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}()</span>;
</span></span></code></pre></div><h1 id=dom-内存泄露>DOM 内存泄露<a hidden class=anchor aria-hidden=true href=#dom-内存泄露>#</a></h1><p>#leaf maintains a reference to it&rsquo;s parent (parentNode), and recursively up to #tree, so only when leafRef is nullified is the WHOLE tree under #tree candidate to be GC</p><p><img loading=lazy src=2022-10-29-11-54-30.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>var <span style=color:#66d9ef>select</span> <span style=color:#f92672>=</span> document.querySelector;
</span></span><span style=display:flex><span>var treeRef <span style=color:#f92672>=</span> <span style=color:#66d9ef>select</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;#tree&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>var leafRef <span style=color:#f92672>=</span> <span style=color:#66d9ef>select</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;#leaf&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>var body <span style=color:#f92672>=</span> <span style=color:#66d9ef>select</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;body&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>body.removeChild<span style=color:#f92672>(</span>treeRef<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>//#tree can<span style=color:#e6db74>&#39;t be GC yet due to treeRef
</span></span></span><span style=display:flex><span><span style=color:#e6db74>treeRef = null;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>//#tree can&#39;</span>t be GC yet, due to 
</span></span><span style=display:flex><span>//indirect reference from leafRef
</span></span><span style=display:flex><span>leafRef <span style=color:#f92672>=</span> null;
</span></span><span style=display:flex><span>//NOW can be <span style=color:#75715e>#tree GC</span>
</span></span></code></pre></div><h1 id=守则>守则<a hidden class=anchor aria-hidden=true href=#守则>#</a></h1><ul><li>Use appropiate scope<ul><li>Better than de-referencing, use local scopes.</li></ul></li><li>Unbind event listeners<ul><li>Unbind events that are no longer needed, specially if the related DOM objects are going to be removed.</li></ul></li><li>Manage local cache<ul><li>Be careful with storing large chunks of data that you are not going to use.</li></ul></li></ul><p> </p><h1 id=分析内存泄漏的工具>分析内存泄漏的工具<a hidden class=anchor aria-hidden=true href=#分析内存泄漏的工具>#</a></h1><ul><li>浏览器： <code>performance.memory</code> </li><li>devtool memory profile</li></ul><h1 id=关于闭包的提示>关于闭包的提示<a hidden class=anchor aria-hidden=true href=#关于闭包的提示>#</a></h1><ul><li>给闭包命名，这样在内存分析时，就可以按照函数名找到对应的函数</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=wangduanduan/wangduanduan.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxMTkyMjMyNjA=" data-category=Announcements data-category-id=DIC_kwDOBxsz3M4CAjBq data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>