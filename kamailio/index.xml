<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>新朋友 - kamailio学习笔记 on 洞香春</title>
    <link>https://wdd.js.org/kamailio/</link>
    <description>Recent content in 新朋友 - kamailio学习笔记 on 洞香春</description>
    <image>
      <title>洞香春</title>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 28 Dec 2024 09:43:00 +0800</lastBuildDate><atom:link href="https://wdd.js.org/kamailio/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>源码笔记 - 自定义事件路由(中)</title>
      <link>https://wdd.js.org/kamailio/route-list-action/</link>
      <pubDate>Sat, 28 Dec 2024 09:43:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/kamailio/route-list-action/</guid>
      <description>[[TOC]]
route_list route.h定义了几个函数分别用来获取、查找、新增route
// src/core/route.h int route_get(struct route_list *rt, char *name); int route_lookup(struct route_list *rt, char *name); void push(struct action *a, struct action **head); struct route_list { struct action **rlist; int idx;	/* first empty entry */ int entries;	/* total number of entries */ struct str_hash_table names; /* name to route index mappings */ }; rlist 我们对route_list数据模型进行简化:
rlist是一个固定长度的一维数组，通过索引来访问对应的值。如果数组的空间不足，那么就创建一个两倍大的空数据，然后先把原始数据复制过去。这种复制方式保持的原始数据的索引位置。有点像golang的切片扩容机制。
这里最为重要的就是保持数组元素的索引位置在扩容后不变。
static inline int route_new_list(struct route_list *rt) { int ret; struct action **tmp; ret = -1; if(rt-&amp;gt;idx &amp;gt;= rt-&amp;gt;entries) { // 两倍扩容 tmp = pkg_realloc(rt-&amp;gt;rlist, 2 * rt-&amp;gt;entries * sizeof(struct action *)); if(tmp == 0) { LM_CRIT(&amp;#34;out of memory\n&amp;#34;); goto end; } /* init the newly allocated memory chunk */ memset(&amp;amp;tmp[rt-&amp;gt;entries], 0, rt-&amp;gt;entries * sizeof(struct action *)); rt-&amp;gt;rlist = tmp; rt-&amp;gt;entries *= 2; } if(rt-&amp;gt;idx &amp;lt; rt-&amp;gt;entries) { ret = rt-&amp;gt;idx; rt-&amp;gt;idx++; } end: return ret; } str_hash_table 我们对hash_table的数据模型进行简化，它其实就是一hash表，key是路由的名，值是一个正数，正数代表了路由执行单元的索引位置。</description>
    </item>
    
    <item>
      <title>源码笔记 - 自定义事件路由(上)</title>
      <link>https://wdd.js.org/kamailio/customer-event-route/</link>
      <pubDate>Fri, 27 Dec 2024 20:45:03 +0800</pubDate>
      
      <guid>https://wdd.js.org/kamailio/customer-event-route/</guid>
      <description>[[TOC]]
事件路由简介 在某些模块中，我们看到有一些模块自定义的事件路由。
例如dispatcher模块，或者rtpengine模块。
event_route[dispatcher:dst-down] { xlog(&amp;#34;L_ERR&amp;#34;, &amp;#34;Destination down: $rm $ru ($du)\n&amp;#34;); } event_route[rtpengine:dtmf-event] { xlog(&amp;#34;L_INFO&amp;#34;, &amp;#34;callid: $avp(dtmf_event_callid)\n&amp;#34;); xlog(&amp;#34;L_INFO&amp;#34;, &amp;#34;source_tag: $avp(dtmf_event_source_tag)\n&amp;#34;); xlog(&amp;#34;L_INFO&amp;#34;, &amp;#34;timestamp: $avp(dtmf_event_timestamp)\n&amp;#34;); xlog(&amp;#34;L_INFO&amp;#34;, &amp;#34;dtmf: $avp(dtmf_event)\n&amp;#34;); } disapcher模块 在dispatch.c文件中，我们看到如下代码
if(!ds_skip_dst(old_state) &amp;amp;&amp;amp; ds_skip_dst(idx-&amp;gt;dlist[i].flags)) { ds_run_route(msg, address, &amp;#34;dispatcher:dst-down&amp;#34;, rctx); } else { if(ds_skip_dst(old_state) &amp;amp;&amp;amp; !ds_skip_dst(idx-&amp;gt;dlist[i].flags)) ds_run_route(msg, address, &amp;#34;dispatcher:dst-up&amp;#34;, rctx); } ds_run_route还是定义在dispatch.c文件中，
static void ds_run_route(sip_msg_t *msg, str *uri, char *route, ds_rctx_t *rctx) 接着又一个重要调用。 这里似乎在查找路由。
route这个参数其实就是dispatcher:dst-down， 或者 dispatcher:dst-up，
那么event_rt又是什么鬼呢？
rt = route_lookup(&amp;amp;event_rt, route); event_rt是一个route_list的结构体</description>
    </item>
    
    <item>
      <title>DMQ模块源码学习笔记</title>
      <link>https://wdd.js.org/kamailio/dmq-note/</link>
      <pubDate>Sun, 22 Dec 2024 18:07:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/kamailio/dmq-note/</guid>
      <description>背景 多个SIP注册服务器之间，如何同步分机的注册信息呢？
简单的方案就是使用共享数据库的方式同步注册信息，这个方案实现起来简单，但是分机的注册信息本身就是个需要频繁增删改查的，数据库很可能在大量注册分机的压力下，成为性能的瓶颈。
除了数据库之外，OpenSIPS和kamailio分别提供了不同的方案。
OpenSIPS提供的方案是使用cluster模块，cluster模块在多个实例之间同步分机的注册信息，注册信息的格式是OpenSIPS自定义的格式。 Kamailio的方案是DMQ模块， DMQ听起来高大上，放佛是依赖外部的一个服务。 但它其实就是扩展SIP消息，通过SIP消息来广播分机的注册信息。
KDMQ sip:notification_peer@192.168.40.15:5090 SIP/2.0 Via: SIP/2.0/UDP 192.168.40.15;branch=z9hG4bK55e5.423d95110000 To: &amp;lt;sip:notification_peer@192.168.40.15:5090&amp;gt; From: &amp;lt;sip:notification_peer@192.168.40.15:5060&amp;gt;;tag=2cdb7a33a7f21abb98fd3a44968e3ffd-5b01 CSeq: 10 KDMQ Call-ID: 1fe138e07b5d0a7a-50419@192.168.40.15 Content-Length: 116 User-Agent: kamailio (4.3.0 (x86_64/linneaus)) Max-Forwards: 1 Content-Type: text/plain sip:192.168.40.16:5060;status=active sip:192.168.40.15:5060;status=disabled sip:192.168.40.17:5060;status=active 源码分析 该模块一共暴露了8个参数，其中7个参数都是简单类型，INT和STR，就直接取对应变量的地址就可以了。
其中notification_address参数是用来配置集群中其他节点的通信地址的，因为要配置多次，所以需要用一个函数来解析。
// dmq.c static param_export_t params[] = { {&amp;#34;num_workers&amp;#34;, PARAM_INT, &amp;amp;dmq_num_workers}, {&amp;#34;ping_interval&amp;#34;, PARAM_INT, &amp;amp;dmq_ping_interval}, {&amp;#34;server_address&amp;#34;, PARAM_STR, &amp;amp;dmq_server_address}, {&amp;#34;server_socket&amp;#34;, PARAM_STR, &amp;amp;dmq_server_socket}, {&amp;#34;notification_address&amp;#34;, PARAM_STR|PARAM_USE_FUNC, dmq_add_notification_address}, {&amp;#34;notification_channel&amp;#34;, PARAM_STR, &amp;amp;dmq_notification_channel}, {&amp;#34;multi_notify&amp;#34;, PARAM_INT, &amp;amp;dmq_multi_notify}, {&amp;#34;worker_usleep&amp;#34;, PARAM_INT, &amp;amp;dmq_worker_usleep}, {0, 0, 0} }; 这些参数都没有加上static关键词，主要目的为了在dmq模块的其他c文件能使用。</description>
    </item>
    
    <item>
      <title>路由执行的顺序</title>
      <link>https://wdd.js.org/kamailio/msg-flow/</link>
      <pubDate>Sun, 22 Dec 2024 16:20:42 +0800</pubDate>
      
      <guid>https://wdd.js.org/kamailio/msg-flow/</guid>
      <description>1. 请求消息处理过程 请求可以
直接丢弃，不返回任何响应。对于恶意请求，SIP Flood攻击，最好不要返回任何响应。 直接返回状态码，不做转发，例如直接返回301重定向 无状态转发 有状态转发 执行分支路由，分支路由也可以将消息丢弃 无论有无状态，请求发出去前都会执行onsend_route路由，在onsend_route内部，已经不能对SIP消息再做拦截 2. 响应消息处理过程 首先执行reply_route{}, 在这个路由里可以将消息丢弃 然后判断消息是否有状态的 有状态，这执行onreply_route[ID]路由 如果响应是失败的，还可以执行failure_route[ID], 当前前提是在请求路由里是否设置了钩子 在失败路由可以，可以再次设置新的目标地址，进行转发； 设置了新的目标地址后，还可以设置分支路由 Tip 这里要注意的是，响应路由在失败路由之前执行。 3. 重传处理 </description>
    </item>
    
    <item>
      <title>kamailio 启动参数控制</title>
      <link>https://wdd.js.org/kamailio/kamailio-cli-params/</link>
      <pubDate>Sun, 22 Dec 2024 15:46:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/kamailio/kamailio-cli-params/</guid>
      <description>-a mode Auto aliases mode: enable with yes or on, disable with no or off 一般都是关闭 --alias=val Add an alias, the value has to be &amp;#39;[proto:]hostname[:port]&amp;#39; (like for &amp;#39;alias&amp;#39; global parameter) 设置对外别名, 在多个对外别名时，相比于在脚本中写死, 更好的方式 是在启动时传入, alias一般都是服务的对外域名或者IP 如果km有多个对外域名，并且不同的环境都不同，这块配置就合适在脚本里写死 --atexit=val Control atexit callbacks execution from external libraries which may access destroyed shm memory causing crash on shutdown. Can be y[es] or 1 to enable atexit callbacks, n[o] or 0 to disable, default is no.</description>
    </item>
    
    <item>
      <title>第一节 如何熟悉Kamailio文档的文档结构</title>
      <link>https://wdd.js.org/kamailio/docs-index/</link>
      <pubDate>Mon, 02 Dec 2024 22:43:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/kamailio/docs-index/</guid>
      <description>我始终认为，快速学习一门知识，最为重要的就是熟悉它的文档结构。
对于熟悉OpenSIPS的文档结构来说的人，看了Kamailio的文档，往往觉得无从下手。
当我们打开Km的官网(kamailio.org)后， 会重定向到https://www.kamailio.org/w/, 在页面的右侧，
接着，我们会导航到 https://www.kamailio.org/w/documentation/
这个页面的结构需要烂熟于心
1. 模块文档 如果你知道km的版本号和对应的模块，可以点击这里进入对应版本，然后再选择对应模块
2. wiki部分 2.1 必学部分 wiki部分主要是一些教程，非常值得看。
其中有三个重点部分
core cookbook： 主要讲解km的脚本的结构、全局参数、模块参数、路由类型、预处理、脚本操作等等，是编写km脚本的必学之处，各种参数都可以看看 Pseudo-Variables CookBook：主要讲解各种伪变量，用来读写SIP消息 Transformations CookBook： 主要讲解各种操作变换，例如把字符串型转为int型数据 全部函数索引 在km的wiki官网，即https://www.kamailio.org/wikidocs/， 其中Alphabetic Indexes就是所有的参数或者函数的索引。
在你学些km的脚本时，有时候想知道某个函数在哪个模块中，就可以用这个全部函数索引中查找。
源码安装 这部分讲解如何通过GIT进行源码安装。
FAQ https://www.kamailio.org/wikidocs/tutorials/faq/main/
外部资源 这里涉及了如何用km和常见的媒体服务器如何集成
其他 官方的Web版本的wiki, 对于刚入门的人来说，还是有点绕的。
另外一个问题就是mkdocs的页面渲染效果的确不太行，目录滚动一点都不灵敏。
如果你想看的不是某个模块的说明文档，我更建议你直接把https://github.com/kamailio/kamailio-wiki 这个git仓库下载到本地查看。
总结 总体来说，km的文档算是非常完整了，但是和OpenSIPS相比，还有待加强。</description>
    </item>
    
  </channel>
</rss>
