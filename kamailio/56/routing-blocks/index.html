<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等 | 洞香春</title>
<meta name=keywords content="all"><meta name=description content="1. Routing Blocks
The routing blocks are the parts of the configuration file executed by
kamailio at runtime. They can be seen as blocks of actions similar to
functions (or procedures) from common programming languages.
A routing block is identified by a specific token, followed by a name in
between square brackets and actions in between curly braces.
route_block_id[NAME] {
  ACTIONS
}
The name can be any alphanumeric string, with specific routing blocks
enforcing a particular format."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/kamailio/56/routing-blocks/><link crossorigin=anonymous href=/assets/css/stylesheet.821c51435cba3e33e49e590a06514c54c32ac7957095ffcc1e0f390c47cf3228.css integrity="sha256-ghxRQ1y6PjPknlkKBlFMVMMqx5Vwlf/MHg85DEfPMig=" rel="preload stylesheet" as=style><link rel=icon href=https://wdd.js.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/favicon.ico><link rel=apple-touch-icon href=https://wdd.js.org/favicon.ico><link rel=mask-icon href=https://wdd.js.org/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wdd.js.org/kamailio/56/routing-blocks/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://wdd.js.org/kamailio/56/routing-blocks/"><meta property="og:site_name" content="洞香春"><meta property="og:title" content="1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等"><meta property="og:description" content="1. Routing Blocks The routing blocks are the parts of the configuration file executed by kamailio at runtime. They can be seen as blocks of actions similar to functions (or procedures) from common programming languages.
A routing block is identified by a specific token, followed by a name in between square brackets and actions in between curly braces.
route_block_id[NAME] { ACTIONS } The name can be any alphanumeric string, with specific routing blocks enforcing a particular format."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="kamailio"><meta property="article:tag" content="All"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等"><meta name=twitter:description content="1. Routing Blocks
The routing blocks are the parts of the configuration file executed by
kamailio at runtime. They can be seen as blocks of actions similar to
functions (or procedures) from common programming languages.
A routing block is identified by a specific token, followed by a name in
between square brackets and actions in between curly braces.
route_block_id[NAME] {
  ACTIONS
}
The name can be any alphanumeric string, with specific routing blocks
enforcing a particular format."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"新朋友 - kamailio学习笔记","item":"https://wdd.js.org/kamailio/"},{"@type":"ListItem","position":2,"name":"Kamailio 5.6 Wiki","item":"https://wdd.js.org/kamailio/56/"},{"@type":"ListItem","position":3,"name":"1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等","item":"https://wdd.js.org/kamailio/56/routing-blocks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等","name":"1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等","description":"1. Routing Blocks The routing blocks are the parts of the configuration file executed by kamailio at runtime. They can be seen as blocks of actions similar to functions (or procedures) from common programming languages.\nA routing block is identified by a specific token, followed by a name in between square brackets and actions in between curly braces.\nroute_block_id[NAME] { ACTIONS } The name can be any alphanumeric string, with specific routing blocks enforcing a particular format.\n","keywords":["all"],"articleBody":"1. Routing Blocks The routing blocks are the parts of the configuration file executed by kamailio at runtime. They can be seen as blocks of actions similar to functions (or procedures) from common programming languages.\nA routing block is identified by a specific token, followed by a name in between square brackets and actions in between curly braces.\nroute_block_id[NAME] { ACTIONS } The name can be any alphanumeric string, with specific routing blocks enforcing a particular format.\n🔥IMPORTANT: Note: route(number) is equivalent to route(\"number\").\nRoute blocks can be executed on network events (e.g., receiving a SIP message), timer events (e.g., retransmission timeout) or particular events specific to modules.\nThere can be so called sub-route blocks, which can be invoked from another route blocks, like a function. Invocation is done with route followed by the name of sub-route to execute, enclosed in between parentheses.\nExample:\nrequest_route{ ... route(\"test\"); ... } route[\"test\"]{ ... } 2. request_route Request routing block - is executed for each SIP request.\nIt contains a set of actions to be executed for SIP requests received from the network. It is the equivalent of main() function for handling the SIP requests.\n🔥IMPORTANT: For backward compatibility reasons, the main request route block can be identified by route{...} or route[0]{...}'.\nThe implicit action after execution of the main route block is to drop the SIP request. To send a reply or forward the request, explicit actions (e.g., sl_send_reply(), forward(), t_relay()) must be called inside the route block.\nExample of usage:\nrequest_route { if(is_method(\"OPTIONS\")) { # send reply for each options request sl_send_reply(\"200\", \"ok\"); exit(); } route(FWD); } route[FWD] { # forward according to uri forward(); } 3. route This block is used to define ‘sub-routes’ - group of actions that can be executed from another routing block. Originally targeted as being executed from ‘request_route’, it can be executed now from all the other blocks. Be sure you put there the actions valid for the root routing block executing the sub-route.\nThe definition of the sub-route block follows the general rules, with a name in between square brackets and actions between curly braces. A sub-route can return an integer value back to the routing block that executed it. The return code can be retrieved via $rc variables.\nEvaluation of the return of a subroute is done with following rules:\nnegative value is evaluated as false 0 - is interpreted as exit positive value is evaluated as true request_route { if(route(POSITIVE)) { xlog(\"return number is positive\\n\"); } if( ! route(NEGATIVE)) { xlog(\"return number is negative\\n\"); } if( route(ZERO)) { xlog(\"this log message does not appear\\n\"); } } route[POSITIVE] { return 10; } route[NEGATIVE] { return -8; } route[ZERO] { return 0; } A sub-route can execute another sub-route. There is a limit to the number of recursive levels, avoiding ending up in infinite loops – see max_recursive_level global parameter.\nThe sub-route blocks allow to make the configuration file modular, simplifying the logic and helping to avoid duplication of actions.\nIf no return is at the end of the routing block, the return code is the value of the last executed action, therefore it is highly recommended to return an explicit value (e.g., return(1)) to avoid unexpected config execution.\n4. branch_route Request’s branch routing block. It contains a set of actions to be taken for each branch of a SIP request. It is executed only by TM module after it was armed via t_on_branch(\"branch_route_index\").\nExample of usage:\nrequest_route { lookup(\"location\"); t_on_branch(\"OUT\"); if(!t_relay()) { sl_send_reply(\"500\", \"relaying failed\"); } } branch_route[OUT] { if(uri=~\"10\\.10\\.10\\.10\") { # discard branches that go to 10.10.10.10 drop(); } } 5. failure_route Failed transaction routing block. It contains a set of actions to be taken each transaction that received only negative replies (\u003e=300) for all branches. The failure_route is executed only by TM module after it was armed via t_on_failure(\"failure_route_index\").\nNote that in failure_route is processed the request that initiated the transaction, not the reply .\nExample of usage:\nrequest_route { lookup(\"location\"); t_on_failure(\"TOVOICEMAIL\"); if(!t_relay()) { sl_send_reply(\"500\", \"relaying failed\"); } } failure_route[TOVOICEMAIL] { if(is_method(\"INVITE\")) { # call failed - relay to voice mail t_relay_to_udp(\"voicemail.server.com\",\"5060\"); } } 6. reply_route Main SIP response (reply) handling block - it contains a set of actions to be executed for SIP replies. It is executed for all replies received from the network.\nIt does not have a name and it is executed by the core, before any other module handling the SIP reply. It is triggered only by SIP replies received on the network.\nThere is no network route that can be enforced for a SIP reply - it is sent based on Via header, according to SIP RFC3261 - therefore no dedicated actions for forwarding the reply must be used in this block.\nThis routing block is optional, if missing, the SIP reply is sent to the address in 2nd Via header.\nOne can decide to drop a SIP reply by using drop action.\nExample:\nreply_route { if(status==\"128\") { drop; } } 🔥IMPORTANT: Note: for backward compatibility reasons, the main reply routing block can be also identified by onreply_route {...} or onreply_route[0] {...}.\n7. onreply_route SIP reply routing block executed by tm module. It contains a set of actions to be taken for SIP replies in the context of an active transaction.\nThe onreply_route must be armed for the SIP requests whose replies should be processed within it, via t_on_reply(\"onreply_route_index\").\nCore ‘reply_route’ block is executed before a possible tm ‘onreply_route’ block.\nrequest_route { lookup(\"location\"); t_on_reply(\"LOGRPL\"); if(!t_relay()) { sl_send_reply(\"500\", \"relaying failed\"); } } reply_route { if(!t_check_trans()) { drop; } } onreply_route[LOGRPL] { if(status=~\"1[0-9][0-9]\") { log(\"provisional response\\n\"); } } 8. onsend_route The route is executed in when a SIP request is sent out. Only a limited number of commands are allowed (drop, if + all the checks, msg flag manipulations, send(), log(), textops::search()).\nIn this route the final destination of the message is available and can be checked (with snd_ip, snd_port, to_ip, to_port, snd_proto, snd_af).\nThis route is executed only when forwarding requests - it is not executed for replies, retransmissions, or locally generated messages (e.g. via fifo uac).\nExample:\nonsend_route { if(to_ip==1.2.3.4 \u0026\u0026 !isflagset(12)){ log(1, \"message blocked\\n\"); drop; } } snd_ip, snd_port - behave like src_ip/src_port, but contain the ip/port Kamailio will use to send the message to_ip, to_port - like above, but contain the ip/port the message will be sent to (not to be confused with dst_ip/dst_port, which are the destination of the original received request: Kamailio’s ip and port on which the message was received) snd_proto, snd_af - behave like proto/af but contain the protocol/address family that Kamailio will use to send the message msg:len - when used in an onsend_route, msg:len will contain the length of the message on the wire (after all the changes in the script are applied, Vias are added a.s.o) and not the lentgh of the original message. 9. event_route Generic type of route executed when specific events happen.\nPrototype: event_route[groupid:eventid]\ngroupid - should be the name of the module that triggers the event eventid - some meaningful short text describing the event 9.1. Core Event Routes Implementations:\nevent_route[core:worker-one-init] - executed by core after the first udp sip worker process executed the child_init() for all modules, before starting to process sip traffic note that due to forking, other sip workers can get faster to listening for sip traffic event_route[core:worker-one-init] { xlog(\"L_INFO\",\"Hello world\\n\"); } event_route[core:msg-received] - executed when a message is received from the network. It runs with a faked request and makes available the $rcv(key) variables to access what was received and related attribtues. it has to be enabled with received_route_mode global parameter. For usage via Kemi, set kemi.received_route_callback global parameter. if drop is executed, the received message is no longer processed event_route[core:msg-received] { xlog(\"rcv on $rcv(af)/$rcv(proto): ($rcv(len)) [$rcv(buf)] from [$rcv(srcip):$rcv(srcport)] to [$rcv(rcvip):$rcv(rcvport)]\\n\"); if($rcv(srcip) == \"1.2.3.4\") { drop; } } event_route[core:pre-routing] - executed by core on receiving SIP traffic before running request_route or reply_route. if drop is used, then the message is not processed further with request_route or reply_route in the same process. This can be useful together with sworker module which can delegate the processing to another worker. async_workers_group=\"name=reg;workers=4\" ... event_route[core:pre-routing] { xinfo(\"pre-routing rules\\n\"); if(is_method(\"REGISTER\")) { # delegate processing of REGISTERs to a special group of workers if(sworker_task(\"reg\")) { drop; } } } event_route[core:receive-parse-error] - executed by core on receiving a broken SIP message that can not be parsed. note that the SIP message is broken in this case, but it gets access to source and local socket addresses (ip, port, proto, af) as well as the whole message buffer and its size event_route[core:receive-parse-error] { xlog(\"got a parsing error from $si:$sp, message $mb\\n\"); } 9.2. Module Event Routes Here are only a few examples, to see if a module exports event_route blocks and when they are executed, check the readme of the module.\nevent_route[htable:mod-init] - executed by htable module after all modules have been initialised. Good for initialising values in hash tables. modparam(\"htable\", \"htable\", \"a=\u003esize=4;\") event_route[htable:mod-init] { $sht(a=\u003ecalls-to::10.10.10.10) = 0; $sht(a=\u003emax-calls-to::10.10.10.10) = 100; } request_route { if(is_method(\"INVITE\") \u0026\u0026 !has_totag()) { switch($rd) { case \"10.10.10.10\": lock(\"calls-to::10.10.10.10\"); $sht(a=\u003ecalls-to::10.10.10.10) = $sht(a=\u003ecalls-to::10.10.10.10) + 1; unlock(\"calls-to::10.10.10.10\"); if($sht(a=\u003ecalls-to::10.10.10.10)\u003e$sht(a=\u003emax-calls-to::10.10.10.10)) { sl_send_reply(\"500\", \"To many calls to .10\"); exit; } break; ... } } } event_route[tm:local-request] - executed on locally generated requests. event_route [tm:local-request] { # Handle locally generated requests xlog(\"L_INFO\", \"Routing locally generated $rm to \u003c$ru\u003e\\n\"); t_set_fr(10000, 10000); } event_route[tm:branch-failure] - executed on all failure responses. request_route { ... t_on_branch_failure(\"myroute\"); t_relay(); } event_route[tm:branch-failure:myroute] { xlog(\"L_INFO\", \"Handling $T_reply_code response to $rm to \u003c$ru\u003e\\n\"); if (t_check_status(\"430\")) { # Outbound flow failed unregister(\"location\", \"$tu\", \"$T_reply_ruid\"); if (t_next_contact_flow()) { t_relay(); } } } ","wordCount":"1591","inLanguage":"en","image":"https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/kamailio/56/routing-blocks/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org/ accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/favicon.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/kamailio/ title=Kamailio><span>Kamailio</span></a></li><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org/>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/kamailio/>新朋友 - kamailio学习笔记</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/kamailio/56/>Kamailio 5.6 Wiki</a></div><h1 class="post-title entry-hint-parent">1.16 路由块 - 请求路由、响应路由、分支路由、失败路由等</h1><div class=post-meta>8 min&nbsp;·&nbsp;Eddie Wang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/kamailio/56/routing-blocks/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-routing-blocks aria-label="1. Routing Blocks">1. Routing Blocks</a></li><li><a href=#2-request_route aria-label="2. request_route">2. request_route</a></li><li><a href=#3-route aria-label="3. route">3. route</a></li><li><a href=#4-branch_route aria-label="4. branch_route">4. branch_route</a></li><li><a href=#5-failure_route aria-label="5. failure_route">5. failure_route</a></li><li><a href=#6-reply_route aria-label="6. reply_route">6. reply_route</a></li><li><a href=#7-onreply_route aria-label="7. onreply_route">7. onreply_route</a></li><li><a href=#8-onsend_route aria-label="8. onsend_route">8. onsend_route</a></li><li><a href=#9-event_route aria-label="9. event_route">9. event_route</a><ul><li><a href=#91-core-event-routes aria-label="9.1. Core Event Routes">9.1. Core Event Routes</a></li><li><a href=#92-module-event-routes aria-label="9.2. Module Event Routes">9.2. Module Event Routes</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1-routing-blocks>1. Routing Blocks<a hidden class=anchor aria-hidden=true href=#1-routing-blocks>#</a></h1><p>The routing blocks are the parts of the configuration file executed by
kamailio at runtime. They can be seen as blocks of actions similar to
functions (or procedures) from common programming languages.</p><p>A routing block is identified by a specific token, followed by a name in
between square brackets and actions in between curly braces.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>route_block_id[NAME] {
</span></span><span style=display:flex><span>  ACTIONS
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The name can be any alphanumeric string, with specific routing blocks
enforcing a particular format.</p><p>🔥<strong>IMPORTANT</strong>: Note: <code>route(number)</code> is equivalent to <code>route("number")</code>.</p><p>Route blocks can be executed on network events (e.g., receiving a SIP
message), timer events (e.g., retransmission timeout) or particular
events specific to modules.</p><p>There can be so called sub-route blocks, which can be invoked from
another route blocks, like a function. Invocation is done with <code>route</code>
followed by the name of sub-route to execute, enclosed in between
parentheses.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  request_route{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>route</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  route[<span style=color:#e6db74>&#34;test&#34;</span>]{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h1 id=2-request_route>2. request_route<a hidden class=anchor aria-hidden=true href=#2-request_route>#</a></h1><p>Request routing block - is executed for each SIP request.</p><p>It contains a set of actions to be executed for SIP requests received
from the network. It is the equivalent of <code>main()</code> function for
handling the SIP requests.</p><p>🔥<strong>IMPORTANT</strong>: For backward compatibility reasons, the main request
<code>route</code> block can be identified by <code>route{...}</code> or
<code>route[0]{...}</code>'.</p><p>The implicit action after execution of the main route block is to drop
the SIP request. To send a reply or forward the request, explicit
actions (e.g., sl_send_reply(), forward(), t_relay()) must be called
inside the route block.</p><p>Example of usage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    request_route {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>is_method</span>(<span style=color:#e6db74>&#34;OPTIONS&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e># send reply for each options request
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>sl_send_reply</span>(<span style=color:#e6db74>&#34;200&#34;</span>, <span style=color:#e6db74>&#34;ok&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>exit</span>();
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>route</span>(FWD);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    route[FWD] {
</span></span><span style=display:flex><span>         <span style=color:#75715e># forward according to uri
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>forward</span>();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=3-route>3. route<a hidden class=anchor aria-hidden=true href=#3-route>#</a></h1><p>This block is used to define &lsquo;sub-routes&rsquo; - group of actions that can be
executed from another routing block. Originally targeted as being
executed from &lsquo;request_route&rsquo;, it can be executed now from all the other
blocks. Be sure you put there the actions valid for the root routing
block executing the sub-route.</p><p>The definition of the sub-route block follows the general rules, with a
name in between square brackets and actions between curly braces. A
sub-route can return an integer value back to the routing block that
executed it. The return code can be retrieved via $rc variables.</p><p>Evaluation of the return of a subroute is done with following rules:</p><ul><li>negative value is evaluated as false</li><li>0 - is interpreted as <strong>exit</strong></li><li>positive value is evaluated as true</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>request_route {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>route</span>(POSITIVE)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;return number is positive</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>( <span style=color:#f92672>!</span> <span style=color:#a6e22e>route</span>(NEGATIVE)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;return number is negative</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>( <span style=color:#a6e22e>route</span>(ZERO)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;this log message does not appear</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>route[POSITIVE] {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>route[NEGATIVE] {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>route[ZERO] {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A sub-route can execute another sub-route. There is a limit to the
number of recursive levels, avoiding ending up in infinite loops &ndash; see
<strong>max_recursive_level</strong> global parameter.</p><p>The sub-route blocks allow to make the configuration file modular,
simplifying the logic and helping to avoid duplication of actions.</p><p>If no <code>return</code> is at the end of the routing block, the return code is the value
of the last executed action, therefore it is highly recommended to return an
explicit value (e.g., <code>return(1)</code>) to avoid unexpected config execution.</p><h1 id=4-branch_route>4. branch_route<a hidden class=anchor aria-hidden=true href=#4-branch_route>#</a></h1><p>Request&rsquo;s branch routing block. It contains a set of actions to be taken
for each branch of a SIP request. It is executed only by TM module after
it was armed via <code>t_on_branch("branch_route_index")</code>.</p><p>Example of usage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    request_route {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lookup</span>(<span style=color:#e6db74>&#34;location&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>t_on_branch</span>(<span style=color:#e6db74>&#34;OUT&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>t_relay</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sl_send_reply</span>(<span style=color:#e6db74>&#34;500&#34;</span>, <span style=color:#e6db74>&#34;relaying failed&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    branch_route[OUT] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(uri<span style=color:#f92672>=~</span><span style=color:#e6db74>&#34;10\.10\.10\.10&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e># discard branches that go to 10.10.10.10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>drop</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=5-failure_route>5. failure_route<a hidden class=anchor aria-hidden=true href=#5-failure_route>#</a></h1><p>Failed transaction routing block. It contains a set of actions to be
taken each transaction that received only negative replies (<code>>=300</code>) for
all branches. The <code>failure_route</code> is executed only by TM module after it
was armed via <code>t_on_failure("failure_route_index")</code>.</p><p>Note that in <code>failure_route</code> is processed the request that initiated the
transaction, not the reply .</p><p>Example of usage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    request_route {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lookup</span>(<span style=color:#e6db74>&#34;location&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>t_on_failure</span>(<span style=color:#e6db74>&#34;TOVOICEMAIL&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>t_relay</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sl_send_reply</span>(<span style=color:#e6db74>&#34;500&#34;</span>, <span style=color:#e6db74>&#34;relaying failed&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    failure_route[TOVOICEMAIL] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>is_method</span>(<span style=color:#e6db74>&#34;INVITE&#34;</span>)) {
</span></span><span style=display:flex><span>             <span style=color:#75715e># call failed - relay to voice mail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             <span style=color:#a6e22e>t_relay_to_udp</span>(<span style=color:#e6db74>&#34;voicemail.server.com&#34;</span>,<span style=color:#e6db74>&#34;5060&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=6-reply_route>6. reply_route<a hidden class=anchor aria-hidden=true href=#6-reply_route>#</a></h1><p>Main SIP response (reply) handling block - it contains a set of actions
to be executed for SIP replies. It is executed for all replies received
from the network.</p><p>It does not have a name and it is executed by the core, before any other
module handling the SIP reply. It is triggered only by SIP replies
received on the network.</p><p>There is no network route that can be enforced for a SIP reply - it is
sent based on Via header, according to SIP RFC3261 - therefore no
dedicated actions for forwarding the reply must be used in this block.</p><p>This routing block is optional, if missing, the SIP reply is sent to the
address in 2nd Via header.</p><p>One can decide to drop a SIP reply by using <strong>drop</strong> action.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>reply_route {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(status<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;128&#34;</span>) {
</span></span><span style=display:flex><span>    drop;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>🔥<strong>IMPORTANT</strong>: Note: for backward compatibility reasons, the main <code>reply</code>
routing block can be also identified by <code>onreply_route {...}</code> or
<code>onreply_route[0] {...}</code>.</p><h1 id=7-onreply_route>7. onreply_route<a hidden class=anchor aria-hidden=true href=#7-onreply_route>#</a></h1><p>SIP reply routing block executed by <strong>tm</strong> module. It contains a set of
actions to be taken for SIP replies in the context of an active
transaction.</p><p>The <code>onreply_route</code> must be armed for the SIP requests whose replies
should be processed within it, via <code>t_on_reply</code>("<code>onreply_route_index</code>").</p><p>Core &lsquo;reply_route&rsquo; block is executed before a possible <strong>tm</strong>
&lsquo;onreply_route&rsquo; block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  request_route {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>lookup</span>(<span style=color:#e6db74>&#34;location&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>t_on_reply</span>(<span style=color:#e6db74>&#34;LOGRPL&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>t_relay</span>()) {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>sl_send_reply</span>(<span style=color:#e6db74>&#34;500&#34;</span>, <span style=color:#e6db74>&#34;relaying failed&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  reply_route {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>t_check_trans</span>()) {
</span></span><span style=display:flex><span>          drop;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  onreply_route[LOGRPL] {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(status<span style=color:#f92672>=~</span><span style=color:#e6db74>&#34;1[0-9][0-9]&#34;</span>) {
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;provisional response</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h1 id=8-onsend_route>8. onsend_route<a hidden class=anchor aria-hidden=true href=#8-onsend_route>#</a></h1><p>The route is executed in when a SIP request is sent out. Only a limited
number of commands are allowed (<code>drop</code>, <code>if</code> + all the checks, msg flag
manipulations, <code>send()</code>, <code>log()</code>, <code>textops::search()</code>).</p><p>In this route the final destination of the message is available and can
be checked (with <code>snd_ip</code>, <code>snd_port</code>, <code>to_ip</code>, <code>to_port</code>, <code>snd_proto</code>, <code>snd_af</code>).</p><p>This route is executed only when forwarding requests - it is not
executed for replies, retransmissions, or locally generated messages
(e.g. via fifo uac).</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  onsend_route {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(to_ip<span style=color:#f92672>==</span><span style=color:#ae81ff>1.2.3.4</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>isflagset</span>(<span style=color:#ae81ff>12</span>)){
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;message blocked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      drop;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>snd_ip, snd_port - behave like src_ip/src_port, but contain the
ip/port Kamailio will use to send the message</li><li>to_ip, to_port - like above, but contain the ip/port the message
will be sent to (not to be confused with dst_ip/dst_port, which are
the destination of the original received request: Kamailio&rsquo;s ip and
port on which the message was received)</li><li>snd_proto, snd_af - behave like proto/af but contain the
protocol/address family that Kamailio will use to send the message</li><li>msg:len - when used in an onsend_route, msg:len will contain the
length of the message on the wire (after all the changes in the
script are applied, Vias are added a.s.o) and not the lentgh of the
original message.</li></ul><h1 id=9-event_route>9. event_route<a hidden class=anchor aria-hidden=true href=#9-event_route>#</a></h1><p>Generic type of route executed when specific events happen.</p><p>Prototype: <code>event_route[groupid:eventid]</code></p><ul><li>groupid - should be the name of the module that triggers the event</li><li>eventid - some meaningful short text describing the event</li></ul><h2 id=91-core-event-routes>9.1. Core Event Routes<a hidden class=anchor aria-hidden=true href=#91-core-event-routes>#</a></h2><p>Implementations:</p><ul><li><code>event_route[core:worker-one-init]</code> - executed by core after the
first udp sip worker process executed the child_init() for all
modules, before starting to process sip traffic<ul><li>note that due to forking, other sip workers can get faster to
listening for sip traffic</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>event_route[core:worker<span style=color:#f92672>-</span>one<span style=color:#f92672>-</span>init] {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;L_INFO&#34;</span>,<span style=color:#e6db74>&#34;Hello world</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>event_route[core:msg-received]</code> - executed when a message is
received from the network. It runs with a faked request and makes
available the $rcv(key) variables to access what was received and
related attribtues.<ul><li>it has to be enabled with received_route_mode global parameter.
For usage via Kemi, set kemi.received_route_callback global
parameter.</li><li>if drop is executed, the received message is no longer processed</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>event_route[core:msg<span style=color:#f92672>-</span>received] {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;rcv on $rcv(af)/$rcv(proto): ($rcv(len)) [$rcv(buf)] from [$rcv(srcip):$rcv(srcport)] to [$rcv(rcvip):$rcv(rcvport)]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>rcv</span>(srcip) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;1.2.3.4&#34;</span>) {
</span></span><span style=display:flex><span>    drop;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>event_route[core:pre-routing]</code> - executed by core on receiving
SIP traffic before running request_route or reply_route.<ul><li>if drop is used, then the message is not processed further with
request_route or reply_route in the same process. This can be
useful together with sworker module which can delegate the
processing to another worker.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>async_workers_group<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;name=reg;workers=4&#34;</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>event_route[core:pre<span style=color:#f92672>-</span>routing] {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xinfo</span>(<span style=color:#e6db74>&#34;pre-routing rules</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>is_method</span>(<span style=color:#e6db74>&#34;REGISTER&#34;</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e># delegate processing of REGISTERs to a special group of workers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>sworker_task</span>(<span style=color:#e6db74>&#34;reg&#34;</span>)) {
</span></span><span style=display:flex><span>            drop;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>event_route[core:receive-parse-error]</code> - executed by core
on receiving a broken SIP message that can not be parsed.<ul><li>note that the SIP message is broken in this case, but it gets
access to source and local socket addresses (ip, port, proto,
af) as well as the whole message buffer and its size</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>event_route[core:receive<span style=color:#f92672>-</span>parse<span style=color:#f92672>-</span>error] {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;got a parsing error from $si:$sp, message $mb</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=92-module-event-routes>9.2. Module Event Routes<a hidden class=anchor aria-hidden=true href=#92-module-event-routes>#</a></h2><p>Here are only a few examples, to see if a module exports event_route
blocks and when they are executed, check the readme of the module.</p><ul><li><code>event_route[htable:mod-init]</code> - executed by <strong>htable</strong> module
after all modules have been initialised. Good for initialising
values in hash tables.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>modparam</span>(<span style=color:#e6db74>&#34;htable&#34;</span>, <span style=color:#e6db74>&#34;htable&#34;</span>, <span style=color:#e6db74>&#34;a=&gt;size=4;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event_route[htable:mod<span style=color:#f92672>-</span>init] {
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>sht</span>(a<span style=color:#f92672>=&gt;</span>calls<span style=color:#f92672>-</span>to<span style=color:#f92672>::</span><span style=color:#ae81ff>10.10.10.10</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>sht</span>(a<span style=color:#f92672>=&gt;</span>max<span style=color:#f92672>-</span>calls<span style=color:#f92672>-</span>to<span style=color:#f92672>::</span><span style=color:#ae81ff>10.10.10.10</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>request_route {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>is_method</span>(<span style=color:#e6db74>&#34;INVITE&#34;</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>has_totag</span>())
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span>(<span style=color:#960050;background-color:#1e0010>$</span>rd) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;10.10.10.10&#34;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lock</span>(<span style=color:#e6db74>&#34;calls-to::10.10.10.10&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>sht</span>(a<span style=color:#f92672>=&gt;</span>calls<span style=color:#f92672>-</span>to<span style=color:#f92672>::</span><span style=color:#ae81ff>10.10.10.10</span>) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>sht</span>(a<span style=color:#f92672>=&gt;</span>calls<span style=color:#f92672>-</span>to<span style=color:#f92672>::</span><span style=color:#ae81ff>10.10.10.10</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>unlock</span>(<span style=color:#e6db74>&#34;calls-to::10.10.10.10&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>sht</span>(a<span style=color:#f92672>=&gt;</span>calls<span style=color:#f92672>-</span>to<span style=color:#f92672>::</span><span style=color:#ae81ff>10.10.10.10</span>)<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>sht</span>(a<span style=color:#f92672>=&gt;</span>max<span style=color:#f92672>-</span>calls<span style=color:#f92672>-</span>to<span style=color:#f92672>::</span><span style=color:#ae81ff>10.10.10.10</span>))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>sl_send_reply</span>(<span style=color:#e6db74>&#34;500&#34;</span>, <span style=color:#e6db74>&#34;To many calls to .10&#34;</span>);
</span></span><span style=display:flex><span>           exit;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>event_route[tm:local-request]</code> - executed on locally generated
requests.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>event_route [tm:local<span style=color:#f92672>-</span>request] { <span style=color:#960050;background-color:#1e0010>#</span> Handle locally generated requests
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;L_INFO&#34;</span>, <span style=color:#e6db74>&#34;Routing locally generated $rm to &lt;$ru&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>t_set_fr</span>(<span style=color:#ae81ff>10000</span>, <span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>event_route[tm:branch-failure]</code> - executed on all failure
responses.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>request_route {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t_on_branch_failure</span>(<span style=color:#e6db74>&#34;myroute&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t_relay</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event_route[tm:branch<span style=color:#f92672>-</span>failure:myroute] {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>xlog</span>(<span style=color:#e6db74>&#34;L_INFO&#34;</span>, <span style=color:#e6db74>&#34;Handling $T_reply_code response to $rm to &lt;$ru&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>t_check_status</span>(<span style=color:#e6db74>&#34;430&#34;</span>)) { <span style=color:#960050;background-color:#1e0010>#</span> Outbound flow failed
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unregister</span>(<span style=color:#e6db74>&#34;location&#34;</span>, <span style=color:#e6db74>&#34;$tu&#34;</span>, <span style=color:#e6db74>&#34;$T_reply_ruid&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>t_next_contact_flow</span>()) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>t_relay</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wdd.js.org/tags/all/>All</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=wangduanduan/wangduanduan.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxMTkyMjMyNjA=" data-category=Announcements data-category-id=DIC_kwDOBxsz3M4CAjBq data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://wdd.js.org/>洞香春</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>