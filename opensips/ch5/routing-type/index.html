<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>路由分类 | 洞香春</title>
<meta name=keywords content><meta name=description content="opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。
所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面
route[some_xxx]{ } 主路由分为几类
请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的
路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。"><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/ch5/routing-type/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.5b9ae0304f93db6cc493f51846f012428af399c614b4f2fbdb7fa59dd4d5ef5b.js integrity="sha256-W5rgME+T22zEk/UYRvASQorzmcYUtPL723+lndTV71s=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.120.3"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="路由分类"><meta property="og:description" content="opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。
所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面
route[some_xxx]{ } 主路由分为几类
请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的
路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。"><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/ch5/routing-type/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2019-06-16T10:46:44+08:00"><meta property="article:modified_time" content="2019-06-16T10:46:44+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="路由分类"><meta name=twitter:description content="opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。
所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面
route[some_xxx]{ } 主路由分为几类
请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的
路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"路由分类","item":"https://wdd.js.org/opensips/ch5/routing-type/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"路由分类","name":"路由分类","description":"opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。\n所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面\nroute[some_xxx]{ } 主路由分为几类\n请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的\n路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。","keywords":[],"articleBody":"opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。\n所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面\nroute[some_xxx]{ } 主路由分为几类\n请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的\n路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。\n请求路由 请求路由因为受到从外部网络来的请求而触发。\n# 主路由 route { ...... if (is_method(\"INVITE\")) { route(check_hdrs,1); # 调用子路由check_hdrs，1是传递给子路由的参数 if ($rc\u003c0) # 使用$rc获取上个子路由的处理结果 exit; } } # sub-route route[check_hdrs] { if (!is_present_hf(\"Content-Type\")) return(-1); if ( $param(1)==1 \u0026\u0026 !has_body() ) # 子路由使用$param(1), 获取传递的第一个参数 return(-2); # 使用return() 返回子路由的处理结果 return(1); } $rc和$retcode都可以获取子路由的返回结果。\n请求路由是必须的一个路由，所有从网络过来的请求，都会经过请求路由。\n在请求路由中，可以做三个动作\n给出响应 向前传递 丢弃这个请求 注意事项：\nrequest路由被到达的sip请求触发 默认的动作是丢弃这个请求 分支路由 注意事项：\nrequest路由被到达的sip请求触发 默认的动作是发出这个请求 t_on_branch并不是立即执行分支路由，而是注册分支路由的处理事件 注意所有**t_on_**开头的函数都是注册钩子，而不是立即执行。注册钩子可以理解为不是现在执行，而是未来某个时间会被触发执行。 分支路由只能用来触发一次，多次触发将会重写 你可以在这个路由中修改sip request url, 但是不能执行reply等信令方面的操作 route{ ... t_on_branch(\"nat_filter\") ... } branch_route[nat_filter]{ } 失败的路由 当收到大于等于300的响应时触发失败路由 route{ ... t_on_failure(\"vm_redirect\") ... } failure_route[vm_redirects]{ } 响应路由 当收到响应时触发，包括1xx-6xx的所有响应。\n响应路由分为两类\n全局响应路由，即不带名称的onreply_route{}, 自动触发，在带名响应路由前执行。 带名称的响应路由，即onreplay_route[some_name]{}，需要用t_on_reply()方法来设置触发。 route{ t_on_reply(\"inspect_reply\"); } onreply_route{ xlog(\"$rm/$rs/$si/$ci: global onreply route\"); } onreply_route[inspect_reply]{ if ( t_check_status(\"1[0-9][0-9]\") ) { xlog(\"provisional reply $T_reply_code received\\n\"); } if ( t_check_status(\"2[0-9][0-9]\") ) { xlog(\"successful reply $T_reply_code received\\n\"); remove_hf(\"User-Agent\"); } else { xlog(\"non-2xx reply $T_reply_code received\\n\"); } } 本地路由 有些请求是opensips自己发的，这时候触发本地路由。使用场景：在多人会议时，opensips可以给多人发送bye消息。\nlocal_route { } 启动路由 可以让你在opensips启动时做些初始化操作\n注意启动路由里面一定要有语句，哪怕是写个xlog(“hello”), 否则opensips将会无法启动。\nstartup_route { } 计时器路由 在指定的周期，触发路由。可以用来更新本地缓存。\n注意计时器路由里面一定要有语句，哪怕是写个xlog(“hello”), 否则opensips将会无法启动。\n如：每隔120秒，做个事情\ntimer_route[gw_update, 120] { # update the local cache if signalized if ($shv(reload) == 1 ) { avp_db_query(\"select gwlist from routing where id=10\", \"$avp(list)\"); cache_store(\"local\",\"gwlist10\",\" $avp(list)\"); } } 事件路由 当收到某些事件是触发，例如日志，数据库操作，数据更新，某些\n在事件路由的内部，可以使用$param(key)的方式获取事件的某些属性。\nxlog(\"first parameters is $param(1)\\n\"); # 根据序号 xlog(\"Pike Blocking IP is $param(ip)\\n\"); # 根据key event_route[E_DISPATCHER_STATUS] { } event_route[E_PIKE_BLOCKED] { xlog(\"IP $param(ip) has been blocked\\n\"); } 更多可以参考： https://opensips.org/html/docs/modules/devel/event_route.html\n错误路由 用来捕获运行时错误，例如解析sip消息出错。\nerror_route { xlog(\"$rm from $si:$sp - error level=$(err.level), info=$(err.info)\\n\"); sl_send_reply(\"$err.rcode\", \"$err.rreason\"); exit; } ","wordCount":"291","inLanguage":"en","datePublished":"2019-06-16T10:46:44+08:00","dateModified":"2019-06-16T10:46:44+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/ch5/routing-type/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>路由分类</h1><div class=post-meta>&lt;span title='2019-06-16 10:46:44 +0800 CST'>2019-06-16 10:46:44&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Eddie Wang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%af%b7%e6%b1%82%e8%b7%af%e7%94%b1 aria-label=请求路由>请求路由</a></li><li><a href=#%e5%88%86%e6%94%af%e8%b7%af%e7%94%b1 aria-label=分支路由>分支路由</a></li><li><a href=#%e5%a4%b1%e8%b4%a5%e7%9a%84%e8%b7%af%e7%94%b1 aria-label=失败的路由>失败的路由</a></li><li><a href=#%e5%93%8d%e5%ba%94%e8%b7%af%e7%94%b1 aria-label=响应路由>响应路由</a></li><li><a href=#%e6%9c%ac%e5%9c%b0%e8%b7%af%e7%94%b1 aria-label=本地路由>本地路由</a></li><li><a href=#%e5%90%af%e5%8a%a8%e8%b7%af%e7%94%b1 aria-label=启动路由>启动路由</a></li><li><a href=#%e8%ae%a1%e6%97%b6%e5%99%a8%e8%b7%af%e7%94%b1 aria-label=计时器路由>计时器路由</a></li><li><a href=#%e4%ba%8b%e4%bb%b6%e8%b7%af%e7%94%b1 aria-label=事件路由>事件路由</a></li><li><a href=#%e9%94%99%e8%af%af%e8%b7%af%e7%94%b1 aria-label=错误路由>错误路由</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>opensips路由分为两类，主路由和子路由。<strong>主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。</strong></p><p><strong>所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>route<span style=color:#f92672>[</span>some_xxx<span style=color:#f92672>]{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>主路由分为几类</p><ol><li>请求路由</li><li>分支路由</li><li>失败路由</li><li>响应路由</li><li>本地路由</li><li>启动路由</li><li>定时器路由</li><li>事件路由</li><li>错误路由</li></ol><blockquote><p>inspect：查看sip消息内容
modifies: 修改sip消息内容，例如修改request url
drop: 丢弃sip请求
forking: 可以理解为发起一个invite, 然后可以拨打多个人
signaling: 信令层的操作，例如返回200ok之类的</p></blockquote><table><thead><tr><th>路由</th><th>是否必须</th><th>默认行为</th><th>可以做</th><th>不可以做</th><th>触发方向</th><th>触发次数</th></tr></thead><tbody><tr><td>请求路由</td><td>是</td><td>drop</td><td>inspect,modifies, drop, signaling</td><td></td><td>incoming, inbound</td><td></td></tr><tr><td>分支路由</td><td>否</td><td>send out</td><td>forking, modifies, drop, inspect</td><td>relaying, replying,signaling</td><td>outbound, outgoing, branch frok</td><td>一个请求/事务一次</td></tr><tr><td>失败路由</td><td>否</td><td>将错误返回给产生者</td><td>signaling，replying, inspect</td><td></td><td>incoming</td><td>一个请求/事务一次</td></tr><tr><td>响应路由</td><td>否</td><td>relay back</td><td>inspect, modifies</td><td>signaling</td><td>incoming, inbound</td><td>一个请求/事务一次</td></tr><tr><td>本地路由</td><td>否</td><td>send out</td><td></td><td>signaling</td><td>outbound</td><td>本地路由只能有一个</td></tr></tbody></table><p>剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。</p><h2 id=请求路由>请求路由<a hidden class=anchor aria-hidden=true href=#请求路由>#</a></h2><p>请求路由因为受到从外部网络来的请求而触发。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> <span style=color:#75715e># 主路由</span>
</span></span><span style=display:flex><span>route <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      ......
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>is_method<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;INVITE&#34;</span><span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  				route<span style=color:#f92672>(</span>check_hdrs,1<span style=color:#f92672>)</span>; <span style=color:#75715e># 调用子路由check_hdrs，1是传递给子路由的参数</span>
</span></span><span style=display:flex><span>  				<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>$rc&lt;0<span style=color:#f92672>)</span> <span style=color:#75715e># 使用$rc获取上个子路由的处理结果</span>
</span></span><span style=display:flex><span>         	exit;
</span></span><span style=display:flex><span>			<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e># sub-route</span>
</span></span><span style=display:flex><span>route<span style=color:#f92672>[</span>check_hdrs<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>     	<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>!is_present_hf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Content-Type&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>       	<span style=color:#66d9ef>return</span><span style=color:#f92672>(</span>-1<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>     	<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span> $param<span style=color:#f92672>(</span>1<span style=color:#f92672>)==</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> !has_body<span style=color:#f92672>()</span> <span style=color:#f92672>)</span> <span style=color:#75715e># 子路由使用$param(1), 获取传递的第一个参数</span>
</span></span><span style=display:flex><span>       	<span style=color:#66d9ef>return</span><span style=color:#f92672>(</span>-2<span style=color:#f92672>)</span>;  <span style=color:#75715e># 使用return() 返回子路由的处理结果</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span><span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>; 
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>$rc和$retcode都可以获取子路由的返回结果。</p><p>请求路由是必须的一个路由，所有从网络过来的请求，都会经过请求路由。</p><p>在请求路由中，可以做三个动作</p><ol><li>给出响应</li><li>向前传递</li><li>丢弃这个请求</li></ol><p><strong>注意事项：</strong></p><ol><li>request路由被到达的sip请求触发</li><li>默认的动作是丢弃这个请求</li></ol><h2 id=分支路由>分支路由<a hidden class=anchor aria-hidden=true href=#分支路由>#</a></h2><p><strong>注意事项：</strong></p><ol><li>request路由被到达的sip请求触发</li><li>默认的动作是发出这个请求</li><li>t_on_branch并不是立即执行分支路由，而是注册分支路由的处理事件</li><li>注意所有**t_on_**开头的函数都是注册钩子，而不是立即执行。注册钩子可以理解为不是现在执行，而是未来某个时间会被触发执行。</li><li>分支路由只能用来触发一次，多次触发将会重写</li><li>你可以在这个路由中修改sip request url, 但是不能执行reply等信令方面的操作</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>route<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>  t_on_branch<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;nat_filter&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>branch_route<span style=color:#f92672>[</span>nat_filter<span style=color:#f92672>]{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=失败的路由>失败的路由<a hidden class=anchor aria-hidden=true href=#失败的路由>#</a></h2><ol><li>当收到大于等于300的响应时触发失败路由</li><li></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>route<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>  t_on_failure<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;vm_redirect&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>failure_route<span style=color:#f92672>[</span>vm_redirects<span style=color:#f92672>]{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=响应路由>响应路由<a hidden class=anchor aria-hidden=true href=#响应路由>#</a></h2><p>当收到响应时触发，包括1xx-6xx的所有响应。</p><p>响应路由分为两类</p><ol><li>全局响应路由，即不带名称的onreply_route{}, 自动触发，在带名响应路由前执行。</li><li>带名称的响应路由，即onreplay_route[some_name]{}，需要用t_on_reply()方法来设置触发。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>route<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	t_on_reply<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;inspect_reply&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>onreply_route<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;</span>$rm<span style=color:#e6db74>/</span>$rs<span style=color:#e6db74>/</span>$si<span style=color:#e6db74>/</span>$ci<span style=color:#e6db74>: global onreply route&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>onreply_route<span style=color:#f92672>[</span>inspect_reply<span style=color:#f92672>]{</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span> t_check_status<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1[0-9][0-9]&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>       xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;provisional reply </span>$T_reply_code<span style=color:#e6db74> received\n&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>     <span style=color:#f92672>}</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span> t_check_status<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;2[0-9][0-9]&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>       xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;successful reply </span>$T_reply_code<span style=color:#e6db74> received\n&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>       remove_hf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;User-Agent&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>     <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>       xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;non-2xx reply </span>$T_reply_code<span style=color:#e6db74> received\n&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>     <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=本地路由>本地路由<a hidden class=anchor aria-hidden=true href=#本地路由>#</a></h2><p>有些请求是opensips自己发的，这时候触发本地路由。使用场景：在多人会议时，opensips可以给多人发送bye消息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>local_route <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=启动路由>启动路由<a hidden class=anchor aria-hidden=true href=#启动路由>#</a></h2><p>可以让你在opensips启动时做些初始化操作</p><p><strong>注意启动路由里面一定要有语句</strong>，哪怕是写个xlog(&ldquo;hello&rdquo;), 否则opensips将会无法启动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>startup_route <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=计时器路由>计时器路由<a hidden class=anchor aria-hidden=true href=#计时器路由>#</a></h2><p>在指定的周期，触发路由。可以用来更新本地缓存。</p><p><strong>注意计时器路由里面一定要有语句</strong>，哪怕是写个xlog(&ldquo;hello&rdquo;), 否则opensips将会无法启动。</p><p>如：每隔120秒，做个事情</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>timer_route<span style=color:#f92672>[</span>gw_update, 120<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>     <span style=color:#75715e># update the local cache if signalized</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>$shv<span style=color:#f92672>(</span>reload<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>       avp_db_query<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;select gwlist from routing where id=10&#34;</span>,
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;</span>$avp<span style=color:#e6db74>(list)&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>       cache_store<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;local&#34;</span>,<span style=color:#e6db74>&#34;gwlist10&#34;</span>,<span style=color:#e6db74>&#34; </span>$avp<span style=color:#e6db74>(list)&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>     <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=事件路由>事件路由<a hidden class=anchor aria-hidden=true href=#事件路由>#</a></h2><p>当收到某些事件是触发，例如日志，数据库操作，数据更新，某些</p><p>在事件路由的内部，可以使用$param(key)的方式获取事件的某些属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;first parameters is </span>$param<span style=color:#e6db74>(1)\n&#34;</span><span style=color:#f92672>)</span>; <span style=color:#75715e># 根据序号</span>
</span></span><span style=display:flex><span>xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Pike Blocking IP is </span>$param<span style=color:#e6db74>(ip)\n&#34;</span><span style=color:#f92672>)</span>; <span style=color:#75715e># 根据key</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>event_route<span style=color:#f92672>[</span>E_DISPATCHER_STATUS<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event_route<span style=color:#f92672>[</span>E_PIKE_BLOCKED<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;IP </span>$param<span style=color:#e6db74>(ip) has been blocked\n&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>更多可以参考： <a href=https://opensips.org/html/docs/modules/devel/event_route.html>https://opensips.org/html/docs/modules/devel/event_route.html</a></p><h2 id=错误路由>错误路由<a hidden class=anchor aria-hidden=true href=#错误路由>#</a></h2><p>用来捕获运行时错误，例如解析sip消息出错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>error_route <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>   xlog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;</span>$rm<span style=color:#e6db74> from </span>$si<span style=color:#e6db74>:</span>$sp<span style=color:#e6db74>  - error level=</span><span style=color:#66d9ef>$(</span>err.level<span style=color:#66d9ef>)</span><span style=color:#e6db74>,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     info=</span><span style=color:#66d9ef>$(</span>err.info<span style=color:#66d9ef>)</span><span style=color:#e6db74>\n&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>        sl_send_reply<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;</span>$err<span style=color:#e6db74>.rcode&#34;</span>, <span style=color:#e6db74>&#34;</span>$err<span style=color:#e6db74>.rreason&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>        exit;
</span></span><span style=display:flex><span> <span style=color:#f92672>}</span>
</span></span></code></pre></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>