<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WebRTC简介 | 洞香春</title><meta name=keywords content><meta name=description content="WebRTC 功能 音频视频通话 视频会议 数据传输 WebRTC 架构 对等实体之间通过信令服务传递信令 对等实体之间的媒体流可以直接传递，无需中间服务器 内部结构 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：
Voice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC 如何通信 getUserMedia用来捕获本地的语音流或者视频流 RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据 RTCDataChannel 用来传递各种数据 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API WebRTC 底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的 其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释 ICE：互动式连接建立（RFC 5245） STUN：用于NAT的会话遍历实用程序（RFC 5389） TURN：在NAT周围使用继电器进行遍历（RFC 5766） SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711） 浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。"><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/ch9/notes/><link crossorigin=anonymous href=/assets/css/stylesheet.6d3944e058d85363bbe8a792a9b5f40002bca80be859dc19c466dd8de223973e.css integrity="sha256-bTlE4FjYU2O76KeSqbX0AAK8qAvoWdwZxGbdjeIjlz4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="WebRTC简介"><meta property="og:description" content="WebRTC 功能 音频视频通话 视频会议 数据传输 WebRTC 架构 对等实体之间通过信令服务传递信令 对等实体之间的媒体流可以直接传递，无需中间服务器 内部结构 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：
Voice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC 如何通信 getUserMedia用来捕获本地的语音流或者视频流 RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据 RTCDataChannel 用来传递各种数据 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API WebRTC 底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的 其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释 ICE：互动式连接建立（RFC 5245） STUN：用于NAT的会话遍历实用程序（RFC 5389） TURN：在NAT周围使用继电器进行遍历（RFC 5766） SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711） 浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。"><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/ch9/notes/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2019-11-23T10:51:20+08:00"><meta property="article:modified_time" content="2019-11-23T10:51:20+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="WebRTC简介"><meta name=twitter:description content="WebRTC 功能 音频视频通话 视频会议 数据传输 WebRTC 架构 对等实体之间通过信令服务传递信令 对等实体之间的媒体流可以直接传递，无需中间服务器 内部结构 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：
Voice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC 如何通信 getUserMedia用来捕获本地的语音流或者视频流 RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据 RTCDataChannel 用来传递各种数据 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API WebRTC 底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的 其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释 ICE：互动式连接建立（RFC 5245） STUN：用于NAT的会话遍历实用程序（RFC 5389） TURN：在NAT周围使用继电器进行遍历（RFC 5766） SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711） 浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"WebRTC简介","item":"https://wdd.js.org/opensips/ch9/notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WebRTC简介","name":"WebRTC简介","description":"WebRTC 功能 音频视频通话 视频会议 数据传输 WebRTC 架构 对等实体之间通过信令服务传递信令 对等实体之间的媒体流可以直接传递，无需中间服务器 内部结构 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：\nVoice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC 如何通信 getUserMedia用来捕获本地的语音流或者视频流 RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据 RTCDataChannel 用来传递各种数据 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API WebRTC 底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的 其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释 ICE：互动式连接建立（RFC 5245） STUN：用于NAT的会话遍历实用程序（RFC 5389） TURN：在NAT周围使用继电器进行遍历（RFC 5766） SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711） 浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。","keywords":[],"articleBody":"WebRTC 功能 音频视频通话 视频会议 数据传输 WebRTC 架构 对等实体之间通过信令服务传递信令 对等实体之间的媒体流可以直接传递，无需中间服务器 内部结构 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：\nVoice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC 如何通信 getUserMedia用来捕获本地的语音流或者视频流 RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据 RTCDataChannel 用来传递各种数据 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API WebRTC 底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的 其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释 ICE：互动式连接建立（RFC 5245） STUN：用于NAT的会话遍历实用程序（RFC 5389） TURN：在NAT周围使用继电器进行遍历（RFC 5766） SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711） 浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。\nemit “peerconnection:setremotedescriptionfailed” [error**:DOMException:**** Failed to execute ‘setRemoteDescription’ on ‘RTCPeerConnection’:**** Failed to set remote offer sdp****:**** Called with SDP without DTLS fingerprint.**\n一个完整的SIP INVITE信令。其中a=fingerprint:sha-256字段表示DTLS指纹。\na=fingerprint:sha-256 74:CD:F4:A0:3B:46:01:1C:0C:5D:04:D0:17:E5:A4:A1:04:35:97:1C:34:A3:61:60:79:52:02:F3:05:9E:7D:FE\nSDP: Session Description Protocol SDP协议用来协商两个SIP UA之间能力，例如媒体编解码能力。sdp协议举例。sdp协议的详细介绍可以参考 RFC4566\nv=0 o=- 7158718066157017333 2 IN IP4 127.0.0.1 s=- t=0 0 a=group:BUNDLE 0 a=msid-semantic: WMS byn72RFJBCUzdSPhnaBU4vSz7LFwfwNaF2Sy m=audio 64030 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126 c=IN IP4 192.168.2.180 Protocol Version (“v=”) Origin (“o=”) Session Name (“s=”) Session Information (“i=”) URI (“u=”) Email Address and Phone Number (“e=” and “p=”) Connection Data (“c=”) Bandwidth (“b=”) Timing (“t=”) Repeat Times (“r=”) Time Zones (“z=”) Encryption Keys (“k=”) Attributes (“a=”) Media Descriptions (“m=”) 加密 WebRTC对安全性是要求非常高的。无论是信令还是与语音流，WebRTC要求信息传递必须加密。\n数据流使用DTLS协议 媒体流使用SRTP JavaScript API getUserMedia()：捕捉音频和视频 RTCPeerConnection：在用户之间流式传输音频和视频 RTCDataChannel：在用户之间传输数据 MediaRecorder：录制音频和视频 参考 WebRTC官网 WebRTC中文网 一步一步学习WebRTC A Study of WebRTC Security ","wordCount":"276","inLanguage":"en","datePublished":"2019-11-23T10:51:20+08:00","dateModified":"2019-11-23T10:51:20+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/ch9/notes/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/cowboy.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>WebRTC简介</h1><div class=post-meta><span title='2019-11-23 10:51:20 +0800 CST'>2019-11-23 10:51:20</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Eddie Wang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/opensips/ch9/notes/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#webrtc-%e5%8a%9f%e8%83%bd aria-label="WebRTC 功能">WebRTC 功能</a></li><li><a href=#webrtc-%e6%9e%b6%e6%9e%84 aria-label="WebRTC 架构">WebRTC 架构</a></li><li><a href=#%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84 aria-label=内部结构>内部结构</a></li><li><a href=#webrtc-%e5%a6%82%e4%bd%95%e9%80%9a%e4%bf%a1 aria-label="WebRTC 如何通信">WebRTC 如何通信</a></li><li><a href=#webrtc-%e7%9a%84%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6 aria-label="WebRTC 的核心组件">WebRTC 的核心组件</a></li><li><a href=#webrtc-%e9%9f%b3%e9%a2%91%e5%92%8c%e8%a7%86%e9%a2%91%e5%bc%95%e6%93%8e aria-label="WebRTC 音频和视频引擎">WebRTC 音频和视频引擎</a></li><li><a href=#webrtc-%e5%ba%95%e5%b1%82%e5%8d%8f%e8%ae%ae aria-label="WebRTC 底层协议">WebRTC 底层协议</a></li><li><a href=#sdp-session-description-protocol aria-label="SDP: Session Description Protocol">SDP: Session Description Protocol</a></li><li><a href=#%e5%8a%a0%e5%af%86 aria-label=加密>加密</a></li><li><a href=#javascript-api aria-label="JavaScript API">JavaScript API</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=webrtc-功能>WebRTC 功能<a hidden class=anchor aria-hidden=true href=#webrtc-功能>#</a></h1><ul><li>音频视频通话</li><li>视频会议</li><li>数据传输</li></ul><h1 id=webrtc-架构>WebRTC 架构<a hidden class=anchor aria-hidden=true href=#webrtc-架构>#</a></h1><ul><li>对等实体之间通过信令服务传递信令</li><li>对等实体之间的媒体流可以直接传递，无需中间服务器</li></ul><p><img loading=lazy src=2022-12-02-15-28-58.png alt></p><h1 id=内部结构>内部结构<a hidden class=anchor aria-hidden=true href=#内部结构>#</a></h1><p><img loading=lazy src=2022-12-02-15-29-17.png alt></p><ul><li>紫色部分是Web开发者API层</li><li>蓝色实线部分是面向浏览器厂商的API层</li><li>蓝色虚线部分浏览器厂商可以自定义实现</li></ul><p>WebRTC有三个模块：</p><ul><li>Voice Engine（音频引擎）<ul><li>Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带）</li><li>NetEQ for voice（处理网络抖动和语音包丢失）</li><li>Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制）</li></ul></li><li>Video Engine（视频引擎）<ul><li>VP8 Codec（视频图像编解码器）</li><li>Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失）</li><li>Image enhancements（图像质量增强）</li></ul></li><li>Transport<ul><li>SRTP（安全的实时传输协议，用以音视频流传输）</li><li>Multiplexing（多路复用）</li><li>P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的）</li><li>除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商</li><li>整个WebRTC通信是基于UDP的</li></ul></li></ul><h1 id=webrtc-如何通信>WebRTC 如何通信<a hidden class=anchor aria-hidden=true href=#webrtc-如何通信>#</a></h1><ul><li>getUserMedia用来捕获本地的语音流或者视频流</li><li>RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据</li><li>RTCDataChannel 用来传递各种数据</li></ul><h1 id=webrtc-的核心组件>WebRTC 的核心组件<a hidden class=anchor aria-hidden=true href=#webrtc-的核心组件>#</a></h1><ul><li>音视频引擎：OPUS、VP8 / VP9、H264</li><li>传输层协议：底层传输协议为 UDP</li><li>媒体协议：SRTP / SRTCP</li><li>数据协议：DTLS / SCTP</li><li>P2P 内网穿透：STUN / TURN / ICE / Trickle ICE</li><li>信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型</li></ul><h1 id=webrtc-音频和视频引擎>WebRTC 音频和视频引擎<a hidden class=anchor aria-hidden=true href=#webrtc-音频和视频引擎>#</a></h1><p><img loading=lazy src=2022-12-02-15-29-33.png alt></p><ul><li>最底层是硬件设备，上面是音频捕获模块和视频捕获模块</li><li>中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化</li><li>在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API 　　　　</li></ul><h1 id=webrtc-底层协议>WebRTC 底层协议<a hidden class=anchor aria-hidden=true href=#webrtc-底层协议>#</a></h1><p><a href=https://user-images.githubusercontent.com/16631306/54601706-a965d700-4a7a-11e9-9a91-9dd75f50cf92.png><img loading=lazy src="https://cdn.nlark.com/yuque/0/2019/png/280451/1574477501502-070e1405-09ad-4986-be9f-fc69a5056b8a.png#align=left&amp;display=inline&amp;height=748&amp;originHeight=748&amp;originWidth=1537&amp;size=0&amp;status=done&amp;width=1537" alt></a></p><ul><li><strong>WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的</strong></li><li>其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制</li><li>DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。<strong>由于 WebRTC 对安全比较重视，这一层是必须的</strong>。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。</li><li>SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议</li><li>SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上</li><li>RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输</li><li>RTCDataChannel 用来支持端到端的任意二进制数据传输</li><li>WebRTC 协议栈解释<ul><li>ICE：互动式连接建立（RFC 5245）</li><li>STUN：用于NAT的会话遍历实用程序（RFC 5389）</li><li>TURN：在NAT周围使用继电器进行遍历（RFC 5766）</li><li>SDP：会话描述协议（RFC 4566）</li><li>DTLS：数据报传输层安全性（RFC 6347）</li><li>SCTP：流控制传输协议（RFC 4960）</li><li>SRTP：安全实时传输协议（RFC 3711）</li></ul></li></ul><p>浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。</p><p><strong>emit <strong><strong>&ldquo;peerconnection:setremotedescriptionfailed&rdquo;</strong></strong> [error</strong>**:<strong><strong>DOMException</strong></strong>:**** Failed to execute <strong><strong>&lsquo;setRemoteDescription&rsquo;</strong></strong> on <strong><strong>&lsquo;RTCPeerConnection&rsquo;</strong></strong>:**** Failed to set remote offer sdp****:**** Called <strong><strong>with</strong></strong> <strong><strong>SDP</strong></strong> without <strong><strong>DTLS</strong></strong> fingerprint.**</p><p>一个完整的SIP INVITE信令。其中a=fingerprint:sha-256字段表示DTLS指纹。</p><p>a=fingerprint:sha-256 74:CD:F4:A0:3B:46:01:1C:0C:5D:04:D0:17:E5:A4:A1:04:35:97:1C:34:A3:61:60:79:52:02:F3:05:9E:7D:FE</p><h1 id=sdp-session-description-protocol>SDP: Session Description Protocol<a hidden class=anchor aria-hidden=true href=#sdp-session-description-protocol>#</a></h1><p>SDP协议用来协商两个SIP UA之间能力，例如媒体编解码能力。sdp协议举例。sdp协议的详细介绍可以参考 <a href=https://tools.ietf.org/html/rfc4566>RFC4566</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>v<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>o<span style=color:#f92672>=</span>- <span style=color:#ae81ff>7158718066157017333</span> <span style=color:#ae81ff>2</span> IN IP4 127.0.0.1
</span></span><span style=display:flex><span>s<span style=color:#f92672>=</span>-
</span></span><span style=display:flex><span>t<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>=</span>group:BUNDLE <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>=</span>msid-semantic: WMS byn72RFJBCUzdSPhnaBU4vSz7LFwfwNaF2Sy
</span></span><span style=display:flex><span>m<span style=color:#f92672>=</span>audio <span style=color:#ae81ff>64030</span> UDP/TLS/RTP/SAVPF <span style=color:#ae81ff>111</span> <span style=color:#ae81ff>103</span> <span style=color:#ae81ff>104</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>106</span> <span style=color:#ae81ff>105</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>110</span> <span style=color:#ae81ff>112</span> <span style=color:#ae81ff>113</span> <span style=color:#ae81ff>126</span>
</span></span><span style=display:flex><span>c<span style=color:#f92672>=</span>IN IP4 192.168.2.180
</span></span></code></pre></div><ul><li>Protocol Version (&ldquo;v=&rdquo;)</li><li>Origin (&ldquo;o=&rdquo;)</li><li>Session Name (&ldquo;s=&rdquo;)</li><li>Session Information (&ldquo;i=&rdquo;)</li><li>URI (&ldquo;u=&rdquo;)</li><li>Email Address and Phone Number (&ldquo;e=&rdquo; and &ldquo;p=&rdquo;)</li><li>Connection Data (&ldquo;c=&rdquo;)</li><li>Bandwidth (&ldquo;b=&rdquo;)</li><li>Timing (&ldquo;t=&rdquo;)</li><li>Repeat Times (&ldquo;r=&rdquo;)</li><li>Time Zones (&ldquo;z=&rdquo;)</li><li>Encryption Keys (&ldquo;k=&rdquo;)</li><li>Attributes (&ldquo;a=&rdquo;)</li><li>Media Descriptions (&ldquo;m=&rdquo;)</li></ul><h1 id=加密>加密<a hidden class=anchor aria-hidden=true href=#加密>#</a></h1><p>WebRTC对安全性是要求非常高的。无论是信令还是与语音流，WebRTC要求信息传递必须加密。</p><ul><li>数据流使用DTLS协议</li><li>媒体流使用SRTP</li></ul><h1 id=javascript-api>JavaScript API<a hidden class=anchor aria-hidden=true href=#javascript-api>#</a></h1><ul><li>getUserMedia()：捕捉音频和视频</li><li>RTCPeerConnection：在用户之间流式传输音频和视频</li><li>RTCDataChannel：在用户之间传输数据</li><li>MediaRecorder：录制音频和视频</li></ul><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><ul><li><a href=https://webrtc.org/>WebRTC官网</a></li><li><a href=http://webrtc.org.cn/>WebRTC中文网</a></li><li><a href=https://codelabs.developers.google.com/codelabs/webrtc-web/>一步一步学习WebRTC</a></li><li><a href=http://webrtc-security.github.io/>A Study of WebRTC Security</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>