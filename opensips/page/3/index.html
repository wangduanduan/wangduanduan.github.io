<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenSIPS2.4.X 中文实战系列 | 洞香春</title><meta name=keywords content><meta name=description content="OpenSIPS VOIP"><meta name=author content="王端端"><link rel=canonical href=https://wdd.js.org/opensips/><meta name=google-site-verification content="G-SGW660ZWKM"><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.107.0"><link rel=alternate type=application/rss+xml href=https://wdd.js.org/opensips/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-SGW660ZWKM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SGW660ZWKM",{anonymize_ip:!1})}</script><meta property="og:title" content="OpenSIPS2.4.X 中文实战系列"><meta property="og:description" content="OpenSIPS VOIP"><meta property="og:type" content="website"><meta property="og:url" content="https://wdd.js.org/opensips/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="OpenSIPS2.4.X 中文实战系列"><meta name=twitter:description content="OpenSIPS VOIP"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"}]}</script></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span class=active>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a></div><h1>OpenSIPS2.4.X 中文实战系列</h1><div class=post-description>OpenSIPS VOIP</div></header><div class=post-content><p>本系列文章是我在学习 OpenSIPS 过程中，慢慢总结出来的。虽说是实战，但是笔记的成分可能会多点，我也无法保证里面的内容是否完全正确。</p><p>VOIP 对我来说是个比较陌生的领域。进入这个领域可以说是一个意外。在学习过程和实战过程中，我发现了 VOIP 有很大的复杂性。生产环境也会有常常有怪异棘手的各种问题。在解决这些问题的过程中，有种升级打怪的感觉。</p><p>本知识库重点在于讲解 OpenSIPS，当然其中也涵盖了 SIP 协议，FreeSWITCH, rtpproxy, rtpengine，以及一些排查问题的工具。</p><p>推荐在学习的过程中，一定要啃一遍 RFC 3261 协议，这是 VOIP 的基石。</p><h1 id=文章目录>文章目录<a hidden class=anchor aria-hidden=true href=#文章目录>#</a></h1><ul><li><p>1: SIP 协议</p><ul><li><a href=/opensips/ch1/study-tips>1.1 学习建议</a></li><li><a href=/opensips/ch1/sip-overview>1.2 SIP 协议简介</a></li><li><a href=ch1/via-route-record-route>1.3 Via route Record-Route 的区别</a></li><li><a href=/opensips/ch1/sip-path>1.4 SIP Path 头</a></li><li><a href=/opensips/ch1/trunk-pbx-gateway>1.5 Trunk PBX Gateway</a></li><li><a href=/opensips/ch1/sip-notes>1.6 SIP 协议拾遗补缺</a></li><li><a href=/opensips/ch1/sip-with-sdp>1.7 SIP 与 SDP 的关系</a></li><li><a href=/opensips/ch1/nat-sip-rtp>1.8 SIP 信令和媒体都绕不开的 NAT 问题</a></li><li><a href=/opensips/ch1/stun-notes>1.9 STUN 协议笔记</a></li><li><a href=/opensips/ch1/sip-register>1.10 SIP 注册调研</a></li><li><a href=/opensips/ch1/sip-ack>1.11 深入 SIP ACK 消息</a></li><li><a href=/opensips/ch1/ua-answer-mode>1.12 UA 应答模式</a></li><li><a href=/opensips/ch1/deep-in-nat>1.13 NAT 深入学习</a></li><li><a href=/opensips/ch1/fix-nat>1.14 解决 NAT 问题</a></li><li><a href=/opensips/ch1/from-to-request-url>1.15 From To Request URL 之间的关系</a></li><li><a href=/opensips/ch1/sip-rfcs>1.16 SIP 相关 RFC 协议</a></li><li><a href=/opensips/ch1/story-of-nat>1.17 漫话 NAT 的历史</a></li><li><a href=/opensips/ch1/offer-answer>1.18 媒体协商 offer/answer 模型</a></li><li><a href=/opensips/ch1/sip-rtp-path>1.19 媒体路径与信令路径</a></li><li><a href=/opensips/ch1/csta-call-model>1.20 CSTA 呼叫模型简介</a></li></ul></li><li><ol start=2><li>常识</li></ol><ul><li><a href=/opensips/ch2/ox06wd>2.1 几种常用电话信号音的含义</a></li><li><a href=/opensips/ch2/xchqma>2.2 回铃音</a></li></ul></li><li><ol start=3><li>OpenSIPS安装与管理</li></ol><ul><li><a href=/opensips/ch3/about-opensips>3.1 opensips介绍</a></li><li><a href=/opensips/ch3/install-opensips>3.2 debian jessie opensips 2.4.7 安装</a></li><li><a href=/opensips/ch3/centos-install>3.3 centos7 安装opensips</a></li><li><a href=/opensips/ch3/log>3.4 设置独立日志文件</a></li><li><a href=/opensips/ch3/core-mi>3.5 核心MI命令</a></li><li><a href=/opensips/ch3/opensipsctl>3.6 opensips管理命令</a></li><li><a href=/opensips/ch3/centos7-2.4/>3.7 centos7 2.2 升级到2.4.6</a></li><li><a href=/opensips/ch3/opensips-monitor/>3.8 OpenSIPS监控</a></li><li><a href=/opensips/ch3/cache-reload/>3.9 模块缓存策略与reload方法</a></li><li><a href=/opensips/ch3/sip-crlf/>3.10 SIP消息格式CRLF</a></li><li><a href=/opensips/ch3/elk/>3.10 opensips日志写入elasticsearch</a></li><li><a href=/opensips/ch3/prd-warning/>3.10 生产环境监控告警</a></li></ul></li><li><ol start=4><li>媒体相关</li></ol><ul><li><a href=/opensips/ch4/rtp-timestamp/>4.1 RTP 不连续的timestamp和SSRC</a></li><li><a href=/opensips/ch4/media-codec/>4.2 常见媒体流编码及其特点</a></li><li><a href=/opensips/ch4/rtp-record/>4.2 rtpproxy录音</a></li><li><a href=/opensips/ch4/codec-table/>4.2 rtp编码表</a></li></ul></li><li><p>问题列表</p><ul><li><a href=/opensips/ch1/utime-task-scheduled>utimer task already scheduled</a></li><li><a href=/opensips/ch1/rtp-broken-connection>奥科网关 Rtp Broken Connection</a></li></ul></li></ul><h1 id=文章列表>文章列表<a hidden class=anchor aria-hidden=true href=#文章列表>#</a></h1></div><article class=post-entry><header class=entry-header><h2>rtp编码表</h2></header><section class=entry-content><p>v=0 o=WMSWMS 1562204406 1562204407 IN IP4 192.168.40.79 s=WMSWMS c=IN IP4 192.168.40.79 t=0 0 m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ptime:20 上面的SDP协议，我们只关注媒体编码部分，其中
m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 m字段audio说明是音频 31114是rtp的发送端口，一般rtp端口都是偶数，偶数后面的一个奇数端口是给rtcp端口的 0 8 9 101就是媒体编码，每个整数代表一个编码，其中96以下的是都是用IANA规定的，可以不用下面的rtpmap字段去指定，96以上的属于动态编码，需要用rtpmap去指定 上面是整个编码表，我们只需要记住几个就可以:
0 PCMU/8000 3 GSM/8000 8 PCMA/8000 9 G722/8000 18 G729/8000 102 DTMF/8000 a=rtpmap:101 telephone-event/8000a=fmtp:101 0-16上面的字段描述的是DTMP的支持。DTMF标准，所有SIP实体至少支持0-15的DTMF事件。
0-9是数字 10是* 11是# 12-15对应A,B,C,D 参考 https://www....</p></section><footer class=entry-footer><span title='2019-12-07 09:10:33 +0800 CST'>2019-12-07 09:10:33</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to rtp编码表" href=https://wdd.js.org/opensips/ch4/codec-table/></a></article><article class=post-entry><header class=entry-header><h2>opensips介绍</h2></header><section class=entry-content><p>1. OpenSIPS架构 OpenSIPS主要有两部分构成，
core: 提供底层工具、接口、资源 module：模块是一些共享的库，在启动时按需加载。有些模块是用于在opensips脚本中提供功能，而有些模块是作为底层，为其他模块提供功能。 2. OpenSIP 核心 2.1. 传输层 传输层提供了对于各种协议的支持，如TCP、UDP、TLS、WebSocket
2.2. SIP工厂层 SIP工厂层提供了对SIP协议的解析和构建。OpenSIPS实现了一种懒解析功能，懒解析的效率非常高。
懒解析：懒解析就是只去解析SIP头，并不解析SIP头的字段内容。而是在需要读取头字段内容时，才去解析。所以可以理解为按需解析。有点类似于一些文件系统的写时复制功能。
**惰性应用：**有一点非常重要，当你通过脚本提供的函数去改变SIP消息时，所作出的改变并不是实时作用到SIP消息上，而是在先存起来，而是当所有的SIP消息处理完成后才会去应用这些改变。举例来说，你首先通过函数给SIP消息添加了某个头，然后你通过函数去获取这个头的时，发现这个头并不存在，但是SIP消息再发送出去后，又携带了你添加的这个头。
2.3. 路由脚本解析与执行 OpenSIPS在启动后，会将opensips.cfg解析并加载到内存中。一旦OpenSIPS正常运行了，opensips.cfg文件即使删了也不会影响到OpenSIPS的运行了。
但是OpenSIPS并不支持热脚本更新，如果你改了脚本，让让运行的OpenSIPS具有添加的功能，那么必须将OpensSIPS重启。
OpenSIPS的脚本有点类似于C或者Shell语言，如果你Shell写的很溜，OpenSIPS的脚本理解起来也会非常容易。
2.4. 内存与锁管理 出于性能考虑，OpenSIPS自己内部实现了内存和锁的管理，这部分在内容在脚本中是不可见的。
2.5. 脚本变量和脚本函数 OpenSIPS核心提供的脚本变量和函数比较有限，外围的模块提供和很多的变量和函数。这些变量和函数的存在，都是为了让你易于获取SIP消息的某些字段，或者对SIP消息进行修改。
2.6. SQL接口类 OpenSIPS 核心实现了接口的定义，但是并没有实现接口。接口的实现由外部的模块提供，这样做的函数可以使用不同的数据库。
2.7. MI管理接口 mi接口用来管理OpenSIPS, 可以实现以下功能
向OpenSIPS 发送数据 从OpenSIPS 获取数据 触发OpenSIPS 的内部行为</p></section><footer class=entry-footer><span title='2019-11-19 18:37:40 +0800 CST'>2019-11-19 18:37:40</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to opensips介绍" href=https://wdd.js.org/opensips/ch3/about-opensips/></a></article><article class=post-entry><header class=entry-header><h2>深入NAT网络</h2></header><section class=entry-content><p>NAT的产生原因是IPv4的地址不够用，网络中的部分主机只能公用一个外网IP。 NAT工作在网络层和传输层，主要是对IP地址和端口号的改变 NAT的优点 节约公网IP 安全性更好，所有流量都需要经过入口的防火墙 NAT的缺点 对于UPD应用不够友好 NAT 工作原理 内部的设备X, 经过NAT设备后，NAT设备会改写源IP和端口 NAT 类型 1. 全锥型 每个内部主机都有一个静态绑定的外部ip:port 任何主机发往NAT设备上特定ip:port的包，都会被转发给绑定的主机 这种方式的缺点很明显，黑客可以使用端口扫描工具，扫描出暴露的端口，然后通过这个端口攻击内部主机 在内部主机没有往外发送流量时，外部流量也能够进入内部主机 -
2. 限制锥形 NAT上的ip:port与内部主机是动态绑定的 如果内部主机没有向某个主机先发送过包，那么NAT会拒绝外部主机进入的流量 3. 端口限制型 端口限制型除了有限制锥型的要求外，还增加了端口的限制 4. 对称型 对称型最难穿透，因为每次交互NAT都会使用不同的端口号，所以内外网端口映射根本无法预测 NAT对比表格 NAT类型 收数据前是否需要先发送数据 是否能够预测下一次的NAT打开的端口对 是否限制包的目的ip:port 全锥形 否 是 否 限制锥形 是 是 仅限制IP 端口限制型 是 是 是 对称型 是 否 是</p></section><footer class=entry-footer><span title='2019-11-05 16:29:43 +0800 CST'>2019-11-05 16:29:43</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to 深入NAT网络" href=https://wdd.js.org/opensips/ch1/deep-in-nat/></a></article><article class=post-entry><header class=entry-header><h2>CSTA 呼叫模型简介</h2></header><section class=entry-content><p>1. 内容概要 CSTA 协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA 协议标准 2.1. 什么是 CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications) 基本的呼叫模型在 1992 建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等 CSTA 是一个应用层接口，用来监控呼叫，设备和网络 CSTA 创建了一个通讯程序的抽象层: CSTA 并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA 并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式 第三方呼叫控制 一方呼叫控制 CSTA 的设计目标是为了提高各种 CSTA 实现之间的移植性 规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段 1 (发布于 June ’92) 40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段 2 (发布于 Dec. ’94) 77 特性, 145 页 (服务定义) I/O & 语音单元服务, 更多呼叫控制服务 阶段 3 - CSTA Phase II Features & versit CTI Technology 发布于 Dec....</p></section><footer class=entry-footer><span title='2019-10-15 21:43:41 +0800 CST'>2019-10-15 21:43:41</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to CSTA 呼叫模型简介" href=https://wdd.js.org/opensips/ch1/csta-call-model/></a></article><article class=post-entry><header class=entry-header><h2>UA应答模式的实现</h2></header><section class=entry-content><p>Notify 使用noify消息，通知分机应答，这个notify一般发送在分机回180响应之后
Answer-mode Answer-Mode一般有两个值 Auto: UA收到INVITE之后，立即回200OK，没有180的过程 Manual: UA收到INVITE之后，等待用户手工点击应答 通常Answer-Mode还会跟着require, 表示某个应答方式如果不被允许，应当回403 Forbidden 作为响应。
Answer-Mode: Auto;require 和Answer-mode头类似的有个SIP头叫做：Priv-Answer-Mode，这个功能和Answer-Mode类似，但是他有个特点。
如果UA设置了免打扰，Priv-Answer-Mode头会无视免打扰这个选项，强制让分机应答，这个头适合用于紧急呼叫。
结论 如果要实现分机的自动应答，显然Answer-Mode的应答速度回更快。但是对于依赖180响应的系统，可能要考虑这种没有180相应的情况。
要记住，在SIP消息里，对于UA来说，1xx的响应都是不必须的可以缺少的。</p></section><footer class=entry-footer><span title='2019-09-26 20:37:08 +0800 CST'>2019-09-26 20:37:08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to UA应答模式的实现" href=https://wdd.js.org/opensips/ch1/ua-answer-mode/></a></article><article class=post-entry><header class=entry-header><h2>opensips日志写入elasticsearch</h2></header><section class=entry-content><p>构造json $json(body) := "{}"; $json(body/time) = $time(%F %T-0300); $json(body/sipRequest) = “INVITE”; $json(body/ipIntruder) = $si; $json(body/destNum) = $rU; $json(body/userAgent) = $ua; $json(body/country)=$var(city); $json(body/location)=$var(latlon); $json(body/ipHost) = $Ri; 使用async rest_post写数据 async好像存在于2.1版本及其以上， 异步的好处是不会阻止脚本的继续执行 async(rest_post("http://user:password@w.x.y.z:9200/opensips/1", "$json(body)", "$var(ctype)", "$var(ct)", "$var(rcode)"),resume)</p></section><footer class=entry-footer><span title='2019-09-19 09:01:40 +0800 CST'>2019-09-19 09:01:40</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to opensips日志写入elasticsearch" href=https://wdd.js.org/opensips/ch3/elk/></a></article><article class=post-entry><header class=entry-header><h2>回铃音</h2></header><section class=entry-content><p>特点分析 回铃音有以下特点
回铃音是由运营商送给手机的，而不是由被叫送给主叫的。 回铃音的播放阶段是在被叫接听前播放，被叫一旦接听，回铃音则播放结束 回铃音一般是450Hz, 嘟一秒，停4秒，5秒一个周期 常见问题 听不到回铃音 【现象】打同一个号码，有些手机能听到回铃音，有些手机听不到回铃音【排查思路】
有些手机volte开启后，可能会导致无回铃音，所以可以关闭volte试试 被叫的运营商，主叫手机的运营商 参考资料 https://zh.wikipedia.org/wiki/%E5%9B%9E%E9%93%83%E9%9F%B3 https://baike.baidu.com/item/%E5%9B%9E%E9%93%83%E9%9F%B3/1014322 http://www.it9000.cn/tech/CTI/signal.html</p></section><footer class=entry-footer><span title='2019-09-18 09:53:22 +0800 CST'>2019-09-18 09:53:22</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to 回铃音" href=https://wdd.js.org/opensips/ch2/xchqma/></a></article><article class=post-entry><header class=entry-header><h2>几种常用电话信号音的含义</h2></header><section class=entry-content><p>几种常用电话信号音的含义 信号频率：（450±25）HZ：拨号音、回铃音、忙音、长途通知音、空号音（950±25）HZ：催挂音
拨号音 摘机后受话器中便有一种“嗡–”的连续音，这种声音就是拨号音，它表示自动交换机或对方呼叫中心系统已经做好了接续准备，允许用户拨号
回铃音 拨完被叫号，若听到“嘟–嘟–”的断续音（响1s，断4s），便是回铃音，表示被叫话机正在响铃，可静候接话；如果振铃超过10余次，仍无人讲话，说明对方无人接电话，应放好手柄稍后再拨。
忙音 当主叫用户在拨号过程中或拨完被叫电话号码后，若听到“嘟、嘟、嘟……”的短促音（响0.35s，断0.35s），这就是忙音，表示线路已经被占满或被叫电话机正在使用
长途通知音 当主叫用户和被叫用户正在进行市内通话时，听到“嘟、嘟、嘟……”的短促音（响0.2s，断0.2s，响0.2s，间歇0.6s），这便是长途电话通知音，表示有长途电话插入，提醒主被叫用户双方尽快结束市内通话，准备接听长途电话。
空号音 当用户拨完号码后听到不等间隔断续信号音（重复3次0.1s响，0.1s断后，0.4s响0.4s断），这便是空号音，表示通知主叫用户所呼叫的被叫号码为空号或受限制的号码。
催挂音 如果用户听到连续信号音，响度变化为5级，由低级逐步升高，则是催挂音。通知久不挂机的用户迅速挂机。
参考 http://www.it9000.cn/tech/CTI/signal.html</p></section><footer class=entry-footer><span title='2019-09-18 09:10:24 +0800 CST'>2019-09-18 09:10:24</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to 几种常用电话信号音的含义" href=https://wdd.js.org/opensips/ch2/ox06wd/></a></article><article class=post-entry><header class=entry-header><h2>NAT解决方法</h2></header><section class=entry-content><p>解决信令的过程 NAT检测 使用rport解决Via 在初始化请求和响应中修改Contact头 处理来自NAT内部的注册请求 Ping客户端使NAT映射保持打开 处理序列化请求 实现NAT检测 nat_uac_test 使用函数 nat_uac_test
1 搜索Contact头存在于RFC 1918 中的地址 2 检测Via头中的received参数和源地址是否相同 4 最顶部的Via出现在RFC1918 / RFC6598地址中 8 搜索SDP头出现RFC1918 / RFC6598地址 16 测试源端口是否和Via头中的端口不同 32 比较Contact中的地址和源信令的地址 64 比较Contact中的端口和源信令的端口 上边的测试都是可以组合的，并且任何一个测试通过，则返回true。
例如下面的测试19，实际上是1+2+16三项测试的组合
nat_uac_test("19") 使用rport和receive参数标记Via头 从NAT内部出去的呼叫，往往可能不知道自己的出口IP和端口，只有远端的SIP服务器收到请求后，才能知道UAC的真是出口IP和端口。出口IP用received=x.x.x.x，出口端口用rport=xx。当有消息发到UAC时，应当发到received和rport所指定的地址和端口。
# 原始的Via Via: SIP/2.0/UDP 192.168.4.48:5062;branch=z9hG4bK523223793;rport # 经过opensips处理后的Via Via: SIP/2.0/UDP 192.168.4.48:5062;received=192.168.4.48;branch=z9hG4bK523223793;rport=5062 修复Contact头 Via头和Contact头是比较容易混淆的概念，但是两者的功能完全不同。Via头使用来导航183和200响应应该如何按照原路返回。Contact用来给序列化请求，例如BYE和UPDATE导航。如果Contact头不正确，可能会导致呼叫无法挂断。那么就需要用fix_nated_contact()函数去修复Contact头。另外，对于183和200的响应也需要去修复Contact头。
处理注册请求 RFC 1918 地址组 10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) 参考 http://www.rfcreader.com/#rfc1918</p></section><footer class=entry-footer><span title='2019-09-17 08:58:52 +0800 CST'>2019-09-17 08:58:52</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to NAT解决方法" href=https://wdd.js.org/opensips/ch1/fix-nat/></a></article><article class=post-entry><header class=entry-header><h2>常见媒体流编码及其特点</h2></header><section class=entry-content><p>编码 带宽 MOS 环境 特点 说明 G.711 64 kbps 4.45 LAN/WAN 语音质量高，适合对接网关 G.711实际上就是PCM, 是最基本的编码方式。PCM又分为两类PCMA(g711a), PCMU(g711u)。中国使用的是PCMA G.729 8 kbps 4.04 WAN 带宽占用率很小，同时能保证不错的语音质量 分为G729a和G729b两种，G729之所以带宽占用是G711的1/8, 是因为G729的压缩算法不同。G729传输的不是真正的语音，而是语音压缩后的结果。G729的编解码是由专利的，也就说不免费。 G.722 64 kbps 4.5 LAN 语音质量高 HD hd语音 GSM 13.3 kbps 3.01 iLBA 13.3 15.2 抗丢包 OPUS 6-510 kbps - INTERNET OPUS的带宽范围跨度很广，适合语音和视屏 MOS值，Mean Opinion Score，用来定义语音质量。满分为5分，最低1分。
MOS 质量 5 极好的 4 不错的 3 还行吧 2 中等差 1 最差 通常的打包是20ms一个包，那么一秒就会传输1000/20=50个包。如果采样评率是8000Hz, 那么每个包的会携带 8000/50=160个采样数据。在PCMA或者PCMU中，每个采样数据占用1字节。因此20ms的一个包就携带160字节的数据。
在RTP包协议中，160字节还要加上12个自己的RTP头。 在fs上可以使用下面的命令查看fs支持的编码。
show codec</p></section><footer class=entry-footer><span title='2019-09-13 09:04:12 +0800 CST'>2019-09-13 09:04:12</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;王端端&nbsp;&nbsp;| 本文总阅读量<span id=busuanzi_value_page_pv></span>次</footer><a class=entry-link aria-label="post link to 常见媒体流编码及其特点" href=https://wdd.js.org/opensips/ch4/media-codec/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wdd.js.org/opensips/page/2/>« Prev Page</a>
<a class=next href=https://wdd.js.org/opensips/page/4/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
<span id=busuanzi_container_site_pv>本站访问量：<span id=busuanzi_value_site_pv></span>次</span>
&nbsp;
<span id=busuanzi_container_site_uv>您是本站第 <span id=busuanzi_value_site_uv></span> 位访问者</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>