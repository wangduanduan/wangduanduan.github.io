<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OpenSIPS2.4.X 中文实战系列 on 洞香春</title>
    <link>https://wdd.js.org/opensips/</link>
    <description>Recent content in OpenSIPS2.4.X 中文实战系列 on 洞香春</description>
    <image>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 30 Oct 2022 21:11:16 +0800</lastBuildDate><atom:link href="https://wdd.js.org/opensips/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SIP相关RFC协议</title>
      <link>https://wdd.js.org/opensips/ch1/sip-rfcs/</link>
      <pubDate>Sun, 30 Oct 2022 21:11:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-rfcs/</guid>
      <description>RFC 名称 https://tools.ietf.org/html/rfc3261 SIP: Session Initiation Protocol https://tools.ietf.org/html/rfc3665 Session Initiation Protocol (SIP) Basic Call Flow Examples https://tools.ietf.org/html/rfc6141 Re-INVITE and Target-Refresh Request Handling in the Session Initiation Protocol (SIP) https://tools.ietf.org/html/rfc4566 SDP: Session Description Protocol https://tools.ietf.org/html/rfc4028 Session Timers in the Session Initiation Protocol (SIP) https://tools.ietf.org/html/rfc1889 RTP: A Transport Protocol for Real-Time Applications https://tools.ietf.org/html/rfc2326 Real Time Streaming Protocol (RTSP) https://tools.ietf.org/html/rfc2327 SDP: Session Description Protocol https://tools.ietf.org/html/rfc3015 Megaco Protocol Version 1.0 https://tools.ietf.org/html/rfc1918 Address Allocation for Private Internets https://tools.</description>
    </item>
    
    <item>
      <title>STUN协议笔记</title>
      <link>https://wdd.js.org/opensips/ch1/stun-notes/</link>
      <pubDate>Sun, 30 Oct 2022 20:22:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/stun-notes/</guid>
      <description>title: &amp;ldquo;STUN协议笔记&amp;rdquo; date: &amp;ldquo;2022-01-06 17:54:10&amp;rdquo; draft: false STUN是Simple Traversal of User Datagram Protocol (UDP) through Network Address Translators (NAT’s)的缩写 传输层底层用的是UDP 主要用来NAT穿透 主要用来解决voip领域的单方向通话(one-way)的问题 目的是让NAT后面的设备能发现自己的公网IP以及NAT的类型 让外部设备能够找到合适的端口和内部设备通信 刷新NAT绑定，类似keep-alive机制。否则端口映射可能因为超时被释放 STUN是cs架构的协议 客户端端192.168.1.3，使用5060端口，发送stun请求到 64.25.58.65， 经过了192.168.1.1的网关之后 网关将源ip改为212.128.56.125， 端口改为15050 stun服务器将请求发送到 网关的外网端口15050，然后网关将请求转发给192.168.1.3:5060 stun message type which typically is one of the below: - 0x0001 : Binding Request - 0x0101 : Binding Response
0x0111 : Binding Error Response 0x0002 : Shared Secret Request 0x0102 : Shared Secret Response 0x0112 : Shared Secret Error Response **0x0001: MAPPED-ADDRESS - **This attribute contains an IP address and port.</description>
    </item>
    
    <item>
      <title>SIP信令和媒体都绕不开的NAT问题</title>
      <link>https://wdd.js.org/opensips/ch1/nat-sip-rtp/</link>
      <pubDate>Sun, 30 Oct 2022 19:37:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/nat-sip-rtp/</guid>
      <description>什么是NAT? NAT(网络地址转换)， 具体可以参考百科 https://baike.baidu.com/item/nat/320024。
NAT是用来解决IPv4的地址不够的问题。
例如上图，内网的主机，在访问外网时，源192.168的网址，会被改写成1.2.3.4。所以在server端看来，请求是从1.2.3.4发送过来的。
NAT一般会改写请求的源IP包的源IP地址，也可能会改写tcp或者udp的源端口地址。
NAT地址范围 互联网地址分配机构保留了三类网址只能由于私有地址，这些地址只能由于NAT内部，不能用于公网。
如果在sip消息中，Contact头中的地址是192.168开头，聪明的服务器应该知道，这个请求来自NAT内部。
10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) NAT 工作原理 NAT内部流量流出时，源IP和源端口都被改写，目标地址和端口不会改写。源ip和端口与被改写后的ip和端口存在一段时间的映射关系，当响应回来时，根据这个映射关系，NAT设备知道这个包应该发给内网的哪个设备。
NAT分类 静态NAT: 每个内部主机都永久映射一个外部公网IP 动态NAT: 每个内部主机都动态映射一个外部公网IP 网络地址端口转换: 内部主机映射到外部不同端口上 由于静态NAT和动态NAT并不能节省公网IP, 常用的都是网络地址端口转换，即NAPT。
NAPT 网络地址端口转换分类 全锥型NAT 限制锥型NAT： 限制主机 端口限制NAT：限制主机和端口 Full Cone NAT 全锥型NAT 打洞过程
来自nat内部ip1:port1地址在经过路由器时，路由器会打洞ip1&amp;rsquo;:port1&#39; 任何服务器只要把包发到ip1&amp;rsquo;:port1&amp;rsquo;，路由器都会把这个包发到ip1:port1。也就是说，即使刚开始打洞的包是发给server1的，如果server2知道这个洞的信息，那么server2也可以通过这洞，将消息发给ip1:port1 Restricted Cone NAT 限制锥型NAT 限制锥型打洞过程和全锥型差不多，只不过增加了限制。
如果内部主机是把包发到server1的，即使server2知道打洞的信息，它发的包也不会被转给内部主机。 Port Restricted Cone NAT 端口限制NAT 端口限制NAT要比上述两种NAT的限制更为严格
内部主机如果将消息发到server1的5080端口，那么这个端口只允许server1的5080端口发消息回来 server1的其他端口发消息到这个洞都会被拒绝 SIP信令NAT穿越 NAT内部消息发到fs时，会携带如下信息。假如fs对NAT一无所知，如果后续有呼叫，fs是无法将消息发到192.168.0.102的，因为192.168.0.102是内网地址。
但是fs足够聪明，它会从分析包的源ip和源端口，从而正确的将sip消息送到NAT设备上。
Via: SIP/2.0/UDP 192.168.1.160:11266;branch=z9hG4bK-d8754z-1f2cd509;rport Contact: &amp;lt;sip:flavio@192.</description>
    </item>
    
    <item>
      <title>奥科网关 Rtp Broken Connection</title>
      <link>https://wdd.js.org/opensips/ch1/rtp-broken-connection/</link>
      <pubDate>Sat, 29 Oct 2022 10:11:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/rtp-broken-connection/</guid>
      <description>通话10多秒后，fs对两个call leg发送bye消息。
Bye消息给的原因是 Reason: Q.850 ;cause=31 ;text=”local, RTP Broken Connection”
在通话的前10多秒，SIP信令正常，双方也能听到对方的声音。
首先排查了下fs日志，没发现什么异常。然后根据这个报错内容，在网上搜了下。
发现了这篇文章 https://www.wavecoreit.com/blog/serverconfig/call-drop-transfer-rtp-broken-connection/
这篇文章给出的解决办法是通过配置了奥科AudioCodes网关来解决的。
然后咨询了下客户，证实他们用的也是奥科网关。所以就参考教程，配制了一下。
主要是在两个地方进行配置
Click Setup -&amp;gt; Signaling&amp;amp;Media -&amp;gt; Expand Coders &amp;amp; Profiles -&amp;gt; Click IP Profiles -&amp;gt; Edityour SFB Profile -&amp;gt; Broken Connection Mode-&amp;gt; Select Ignore -&amp;gt; Click Apply
Expand SIP Definitions -&amp;gt; Click SIP Definitions General Settings -&amp;gt; Broken Connection Mode -&amp;gt; Select Ignore -&amp;gt; Click Apply -&amp;gt; Click Save
这两个地方，都是配置Broken Connection Mode，选择ignore来设置的。
关于RTP的connection mode，有时间再研究下。</description>
    </item>
    
    <item>
      <title>utimer task &lt;tm-utimer&gt; already scheduled</title>
      <link>https://wdd.js.org/opensips/ch1/utime-task-scheduled/</link>
      <pubDate>Tue, 25 Oct 2022 12:06:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/utime-task-scheduled/</guid>
      <description>可能和avp_db_query有关 https://opensips.org/pipermail/users/2018-October/040157.html What we found is that the warning go away if we comment out the single avp_db_query that is being used in our config.
_ The avp_db_query is not executed at the start, but only when specific header is present. Yet the fooding start immediately after opensips start. The mere presence of the avp_db_query function in config without execution is enough to have the issue._
可能和openssl库有关 https://github.com/OpenSIPS/opensips/issues/1771#issuecomment-517744489 ere are your results.</description>
    </item>
    
    <item>
      <title>SIP和SDP的关系</title>
      <link>https://wdd.js.org/opensips/ch1/sip-with-sdp/</link>
      <pubDate>Sat, 03 Sep 2022 20:36:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-with-sdp/</guid>
      <description>1. 什么是SDP? SDP是Session Description Protocol的缩写，翻译过来就是会话描述协议，这个协议通常存储各种和媒体相关的信息，例如支持哪些媒体编码, 媒体端口是多少？媒体IP地址是多少之类的。
SDP一般作为SIP消息的body部分。如下所示
INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 Max-Forwards: 70 From: Alice &amp;lt;sip:alice@atlanta.example.com&amp;gt;;tag=9fxced76sl To: Bob &amp;lt;sip:bob@biloxi.example.com&amp;gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: &amp;lt;sip:alice@client.atlanta.example.com;transport=tcp&amp;gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 刚开始我一直认为某些sip消息一定带有sdp，例如invite消息。某些sip请求一定没有携带sdp。
实际上sip消息和sdp并没有硬性的附属关系。sip是用来传输信令的，sdp是用来描述媒体流信息的。
如果信令不需要携带媒体流信息，就可以不用携带sdp。
一般情况下，invite请求都会带有sdp信息，但是某些时候也会没有。例如3PCC(third party call control), 第三方呼叫控制，是指由第三方负责协商媒体信息。
常见的一个场景
2. SDP字段介绍 2.1. v= 版本号 当前sdp的版本号是0，所以常见的都是v=0
2.2. o= 发起者id o=的格式</description>
    </item>
    
    <item>
      <title>SIP协议拾遗补缺</title>
      <link>https://wdd.js.org/opensips/ch1/sip-notes/</link>
      <pubDate>Sat, 03 Sep 2022 15:54:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-notes/</guid>
      <description>1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11.</description>
    </item>
    
    <item>
      <title>Trunk Pbx Gateway</title>
      <link>https://wdd.js.org/opensips/ch1/trunk-pbx-gateway/</link>
      <pubDate>Sat, 03 Sep 2022 15:24:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/trunk-pbx-gateway/</guid>
      <description>传统中继 sip trunk中继 安全可靠：SIP Trunk设备和ITSP之间只需建立唯一的、安全的、具有QoS保证的SIP Trunk链路。通过该链路来承载企业的多路并发呼叫，运营商只需对该链路进行鉴权，不再对承载于该链路上的每一路SIP呼叫进行鉴权。 节约硬件成本：企业内部通信由企业IP-PBX负责。企业所有外出通信都通过SIP Trunk交由ITSP，再由ITSP中的设备发送到PSTN网络，企业不再需要维护原有的传统PSTN中继链路，节省了硬件和维护成本。 节约话费成本：企业可以通过设置目的地址任意选择并连接到多个ITSP，充分利用遍布全球各地的ITSP，节省通话费用。 功能强大：部署SIP Trunk设备后，全网可以使用SIP协议，可以更好的支持语音、会议、即时消息等IP通信业务。 处理信令和媒体：SIP Trunk设备不同于SIP代理服务器。SIP Trunk设备接收到用户的呼叫请求后，会代表用户向ITSP发起新呼叫请求。在转发过程中，SIP Trunk设备不但要对信令消息进行中继转发，对RTP媒体消息也需要进行中继转发。在整个过程中，SIP Trunk设备两端的设备（企业内部和企业外部设备）均认为和其交互的是SIP Trunk设备本身。 参考 http://www.h3c.com/cn/d_201009/688762_30003_0.htm https://getvoip.com/blog/2013/01/24/differences-between-sip-trunking-and-hosted-pbx/ https://www.onsip.com/blog/hosted-pbx-vs-sip-trunking https://baike.baidu.com/item/sip%20trunk/1499860 </description>
    </item>
    
    <item>
      <title>Path头简史</title>
      <link>https://wdd.js.org/opensips/ch1/sip-path/</link>
      <pubDate>Sat, 03 Sep 2022 14:51:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-path/</guid>
      <description>RFC3261并没有介绍关于Path头的定义，因为这个头是在RFC3327中定义的，Path头作为一个SIP的扩展头。
RFC3327的标题是：Session Initiation Protocol (SIP) Extension Header Field for Registering Non-Adjacent Contacts。
从这个标题可以看出，Path头是作为Register请求的一个消息头，一般这个头只在注册消息上才有。
这个头的格式如下。
Path: &amp;lt;sip:P1.EXAMPLEVISITED.COM;lr&amp;gt; 从功能上说，Path头和record-route头的功能非常相似，但是也不同。
看下面的一个场景，uac通过p1和p2, 将注册请求发送到uas, 在某一时刻，uac作为被叫，INVITE请求要从uas发送到uac, 这时候，INVITE请求应该怎么走？
假如我们希望INVITE请求要经过p2,p2,然后再发送到uac, Path头的作用就是这个。
注册请求经过P1时，P1在注册消息上加上p1地址的path头 注册请求经过P2时，P2在注册消息上加上p2地址的path头 注册请求到达uas时，uas从Contact头上获取到uac的地址信息，然后从两个Path头上获取到如下信息：如果要打电话给uac, Path头会转变为route头，用来定义INVITE请求的路径。 简单定义：Path头用来一般在注册消息里，Path头定义了uac作为被叫时，INVITE请求的发送路径。
参考 </description>
    </item>
    
    <item>
      <title>Via route Record-Route的区别</title>
      <link>https://wdd.js.org/opensips/ch1/via-route-record-route/</link>
      <pubDate>Sat, 03 Sep 2022 02:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/via-route-record-route/</guid>
      <description>sequenceDiagram title French Words I Know autonumber participant a participant p1 participant p2 participant p3 participant b a-&gt;&gt;p1 : INVITE route: p1, via: a p1-&gt;&gt;p2: INVITE via: a,p1, rr: p1 p2-&gt;&gt;p3: INVITE via: a,p1,p2 rr: p1,p2 p3-&gt;&gt;b: INVITE via: a,p1,p2,p3 rr: p1,p2,p3 b--&gt;&gt;p3: 180 via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 180 via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 180 via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 180 via: a rr: p1,p2,p3 b--&gt;&gt;p3: 200 OK via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 200 Ok via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 200 Ok via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 200 Ok via: a rr: p1,p2,p3 a-&gt;&gt;p1 : ACK via: a, route: p1,p2,p3 p1-&gt;&gt;p2: ACK via: a,p1, route: p2,p3 p2-&gt;&gt;p3: ACK via: a,p1,p2 route: p3 p3-&gt;&gt;b: ACK via: a,p1,p2,p3 rr代表record-route头。</description>
    </item>
    
    <item>
      <title>SIP协议简介</title>
      <link>https://wdd.js.org/opensips/ch1/sip-overview/</link>
      <pubDate>Fri, 02 Sep 2022 01:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-overview/</guid>
      <description>SIP是VoIP的基石，相当于HTTP协议在Web服务器里的角色。如果你熟悉HTTP协议，那么你可以在SIP协议中找到许多和HTTP中熟悉的东西，例如请求头，请求体，响应码之类概念，这是因为SIP协议的设计，很大程度上参考了HTTP协议。
如果想要学习VoIP，那么SIP协议是你务必掌握敲门砖。
1. SIP组件 UAC: 例如sip终端，软电话，话机 UAS: sip服务器 UA: ua既可以当做uac也可以当做uas 代理服务器 重定向服务器 注册服务器 网关 PSTN 公共交换电话网 2. SBC 边界会话控制器 SBC是Session Border Controller的缩写，具有一下几个功能。
拓扑隐藏：隐藏所有内部网络的信息。 媒体流管理：设置语音流编码规则，转换等 增加能力：例如Refer, 3CPP 维护NAT映射： 访问控制 媒体加密：例如外部网络用SRTP, 内部网络用RTP 3. sip注册过程 下面简化注册逻辑，省略了验证和过期等字段：
对于分机来说，注册服务器的地址是需要设置的 分机向注册服务器发请求，说：你好，注册服务器，我是8005，我的地址是200.180.1.1，以后你可以用这个地址联系我。 注册服务器回复：好的，注册成功 4. sip服务器的类型 4.1. 代理服务器 4.2. 重定向服务器 4.3. 背靠背UA服务器 背靠背UA服务器有两个作用
隐藏网络拓扑结构 有些时候，路由无法到达，只能用背靠背UA服务器 5. 常用sip请求方法 比较常用的是下面的
常用的几个是：register, invite, ack, bye, cancel。除了cancel和ack不需要认证外，其余的请求都需要认证。 register自不必说，invite和bye是需要认证的。
对于我们不信任的ua，我们不允许他们呼叫。对于未认证的bye，也需要禁止。后者可以防止恶意的bye请求，挂断正常的呼叫。
invite除了re-invite的情况，其余的都属于初始化请求，需要着重关心的。而对于bye这种序列化请求，只需要按照record-route去路由。
6. sip响应状态码 7. sip对话流程图 从上图可以看出，从invite请求到200ok之间的信令，都经过了代理服务器。但是200ok之后的ack，确没有经过代理服务器，如果想要所有信令都经过代理服务器，需要在sip消息头record-routing 指定代理服务器的地址
8. 请求与响应报文 9. 事务与对话的区别 重点：
从INVITE请求到最终的响应（注意1xx不是最终响应，非1xx的都是最终响应）之间，称为事务。一个事务可以带有多个消息组成，并经过多个ua。 ack请求比较特殊，但是ack不是事务。如果被叫接通后，超时未收到主叫方的ack, 会怎样？是否会再次发送200OK tcp三次握手建立连接，sip：invite-&amp;gt;200ok-&amp;gt;ack，可以理解为三次握手建立对话。 bye请求和200ok算作一个事务 dialog建立的前提是呼叫接通，如果呼叫没有接通，则没有dialog。 dialog可以由三个元素唯一确定。callId, from字段中的tag, to字段中的tag。 10.</description>
    </item>
    
    <item>
      <title>学习建议</title>
      <link>https://wdd.js.org/opensips/ch1/study-tips/</link>
      <pubDate>Fri, 02 Sep 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/study-tips/</guid>
      <description>1. 概念理解 务必要能理解SIP的重要概念，特别是事务、Dialog。参考https://www.yuque.com/wangdd/opensips/fx5pyy 概念是非常重要的东西，不理解概念，越学就会越吃力 2. 时序图 时序图是非常重要的，培训时，一般我会要求学员务必能够手工绘制时序图。因为只有能够手工绘制时序图了，在排查问题时，才能够从抓包工具给出的时序图中分析出问题所在。
RFC3665 https://datatracker.ietf.org/doc/html/rfc3665 中提供了很多经典的时序图，建议可以去临摹。</description>
    </item>
    
    <item>
      <title>mysql建表语句</title>
      <link>https://wdd.js.org/opensips/ch5/sql-table/</link>
      <pubDate>Thu, 24 Feb 2022 10:47:23 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/sql-table/</guid>
      <description>OpenSIPS需要用数据库持久化数据，常用的是mysql。
可以参考这个官方的教程去初始化数据库的数据 https://www.opensips.org/Documentation/Install-DBDeployment-2-4
如果你想自己创建语句，也是可以的，实际上建表语句在OpenSIPS安装之后，已经被保存在你的电脑上。
一般位于 /usr/local/share/opensips/mysql 目录中
cd /usr/local/share/opensips/mysql ls acc-create.sql call_center-create.sql dispatcher-create.sql group-create.sql rls-create.sql uri_db-create.sql alias_db-create.sql carrierroute-create.sql domain-create.sql imc-create.sql rtpengine-create.sql userblacklist-create.sql auth_db-create.sql closeddial-create.sql domainpolicy-create.sql load_balancer-create.sql rtpproxy-create.sql usrloc-create.sql avpops-create.sql clusterer-create.sql drouting-create.sql msilo-create.sql siptrace-create.sql b2b-create.sql cpl-create.sql emergency-create.sql permissions-create.sql speeddial-create.sql b2b_sca-create.sql dialog-create.sql fraud_detection-create.sql presence-create.sql standard-create.sql cachedb_sql-create.sql dialplan-create.sql freeswitch_scripting-create.sql registrant-create.sql tls_mgm-create.sql </description>
    </item>
    
    <item>
      <title>RTP 不连续的timestamp和SSRC</title>
      <link>https://wdd.js.org/opensips/ch4/rtp-timestamp/</link>
      <pubDate>Mon, 10 Jan 2022 22:05:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/rtp-timestamp/</guid>
      <description>最近遇到一些和媒体流相关的问题，使用wireshark分析之后，总算有些眉目。然而我深感对RTP协议的理解，还是趋于表面。所以我决定，深入的学习一下RTP协议。
和rtp相关的协议有两个rfc, 分别是
1996的的 RFC 1889 2003年的 RFC 3550 RFC 3550是对RFC 1889的稍微改进，然而大体上是没什么改变的。所以我们可以直接看RFC 3550。
RTP 底层用的是UDP协议 RTP 的使用场景是传输实时数据，例如语音，视频，模拟数据等等 RTP 并不保证QoS Synchronization source (SSRC): The source of a stream of RTP packets, identified by a 32-bit numeric SSRC identifier carried in the RTP header so as not to be dependent upon the network address. All packets from a synchronization source form part of the same timing and sequence number space, so a receiver groups packets by synchronization source for playback.</description>
    </item>
    
    <item>
      <title>avp_db_query数值null值比较</title>
      <link>https://wdd.js.org/opensips/ch5/avp-db-query/</link>
      <pubDate>Wed, 29 Sep 2021 19:13:26 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/avp-db-query/</guid>
      <description>avp_db_query是用来做数据库查询的，如果查到某列的值是NULL, 那么对应到脚本里应该如何比较呢？
可以用avp的值与&amp;quot;&amp;quot;， 进行比较
if ($avp(status) == &amp;#34;&amp;lt;null&amp;gt;&amp;#34;) 参考 https://stackoverflow.com/questions/52675803/opensips-avp-db-query-cant-compare-null-value </description>
    </item>
    
    <item>
      <title>生产环境监控告警</title>
      <link>https://wdd.js.org/opensips/ch3/prd-warning/</link>
      <pubDate>Thu, 19 Aug 2021 20:08:28 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/prd-warning/</guid>
      <description>日志监控 务必监控opensips日志，如果其中出现了CRITICAL关键字, 很可能马上opensips就要崩溃。
第一要发出告警信息。第二要有主动的自动重启策略，例如使用systemd启动的话，服务崩溃会会立马被重启。或者用docker或者k8s，这些虚拟化技术，可以让容器崩溃后自动重启。
指标监控 opensips有内部的统计模块，可以很方便的通过opensipsctl或者相关的http的mi接口获取到内部的统计数据。
以下给出几个关键的统计指标：
&amp;rsquo;total_size&amp;rsquo;, 全部内存 &amp;lsquo;used_size&amp;rsquo;, 使用的内存 &amp;lsquo;real_used_size&amp;rsquo;, 真是使用的内存 &amp;lsquo;max_used_size&amp;rsquo;, 最大使用的内存 &amp;lsquo;free_size&amp;rsquo;, 空闲内存 &amp;lsquo;fragments&amp;rsquo;, &amp;lsquo;active_dialogs&amp;rsquo;, 接通状态的通话 &amp;rsquo;early_dialogs&amp;rsquo;, 振铃状态的通话 &amp;lsquo;inuse_transactions&amp;rsquo;, 正在使用的事务 &amp;lsquo;waiting_udp&amp;rsquo;, 堆积的udp消息 &amp;lsquo;waiting_tcp&amp;rsquo; 堆积的tcp消息 当然还有很多的一些指标，可以使用：opensipsctl fifo get_statistics all来获取。</description>
    </item>
    
    <item>
      <title>cachedb的相关问题</title>
      <link>https://wdd.js.org/opensips/ch6/cachedb/</link>
      <pubDate>Wed, 21 Apr 2021 18:08:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/cachedb/</guid>
      <description>底层可用 local 缓存存在本地，速度快，但是多实例无法共享，重启后消失 redis 缓存存在redis, 多实例可以共享，重启后不消失 接口 store -cache_store() 存储 fetch -cache_fetch() 获取 remove -cache_remove() 删除 add -cache_add() 递增 sub -cache_sub() 递减 cache_counter_fetch 获取某个key的值 关于过期的单位 虽然文档上没有明说，但是过期的单位都是秒。
cachedb_local过期 loadmodule &amp;#34;cachedb_local.so&amp;#34; modparam(&amp;#34;cachedb_local&amp;#34;, &amp;#34;cachedb_url&amp;#34;, &amp;#34;local://&amp;#34;) modparam(&amp;#34;cachedb_local&amp;#34;, &amp;#34;cache_clean_period&amp;#34;, 600) route[xxx]{ cache_add(&amp;#34;local&amp;#34;, &amp;#34;$fu&amp;#34;, 100, 5); } 假如说：在5秒之内，同一个$fu来了多个请求，在设置这个$fu值的时候，计时器是不会重置的。过期的计时器还是第一次的设置的那个时间点开始计时。
参考 https://www.opensips.org/Documentation/Tutorials-KeyValueInterface </description>
    </item>
    
    <item>
      <title>常用语句</title>
      <link>https://wdd.js.org/opensips/ch5/statement/</link>
      <pubDate>Tue, 23 Mar 2021 15:05:06 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/statement/</guid>
      <description>if if (expr) { actions } else { actions; } if (expr) { actions } else if (expr) { actions; } 表达式操作符号 常用的用黄色标记。
== 等于 != 不等于 =~ 正则匹配 $rU =~ &#39;^1800*&#39; is &amp;ldquo;$rU begins with 1800&amp;rdquo; !~ 正则不匹配 大于
= 大于等于
&amp;lt; 小于 &amp;lt;= 小于等于 &amp;amp;&amp;amp; 逻辑与 **|| **逻辑或 **! **逻辑非 [ &amp;hellip; ] - test operator - inside can be any arithmetic expression 其他 出了常见的if语句，opensips还支持switch, while, for each, 因为用的比较少。各位可以看官方文档说明。</description>
    </item>
    
    <item>
      <title>使用return语句减少逻辑嵌套</title>
      <link>https://wdd.js.org/opensips/ch5/return/</link>
      <pubDate>Tue, 23 Mar 2021 14:54:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/return/</guid>
      <description>使用return(int)语句可以返回整数值。
return(0) 相当于exit(), 后续的路由都不在执行 return(正整数) 后续的路由还会继续执行，if测试为true return(负整数) 后续的路由还会继续执行, if测试为false 可以使用 $rc 或者 $retcode 获取上一个路由的返回值 # 请求路由 route{ route(check_is_feature_code); xlog(&amp;#34;check_is_feature_code return code is $rc&amp;#34;); ... ... route(some_other_check); } route[check_is_feature_code]{ if ($rU !~ &amp;#34;^\*[0-9]+&amp;#34;) { xlog(&amp;#34;check_is_feature_code: is not feature code $rU&amp;#34;); # 非feature code, 提前返回 return(1); } # 下面就是feature code的处理 ...... } route[some_other_check]{ ... } </description>
    </item>
    
    <item>
      <title>核心变量说明</title>
      <link>https://wdd.js.org/opensips/ch5/core-var/</link>
      <pubDate>Tue, 23 Mar 2021 14:47:07 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/core-var/</guid>
      <description>$ru $rU 可读可写以下面的sip URL举例
sip:8001@test.cc;a=1;b=2 $ru 代表整个sip url就是 sip:8001@test.cc;a=1;b=2 $rU代表用户部分，就是8001 **
$du 可读可写
$du = &amp;#34;sip:192.468.2.40&amp;#34;; $du可以理解为外呼代理，我们想让这个请求发到下一个sip服务器，就把$du设置为下一跳的地址。</description>
    </item>
    
    <item>
      <title>SIP消息格式CRLF</title>
      <link>https://wdd.js.org/opensips/ch3/sip-crlf/</link>
      <pubDate>Fri, 25 Dec 2020 17:44:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/sip-crlf/</guid>
      <description> generic-message = start-line *message-header CRLF [ message-body ] start-line = Request-Line / Status-Line 其中在rfc2543中规定
CR = %d13 ; US-ASCII CR, carriage return character LF = %d10 ; US-ASCII LF, line feed character 项目 十进制 字符串表示 CR 13 \r LF 10 \n 也就是说在一个SIP消息中
headline\r\n key:v\r\n \r\n some_body\r\n 所以CRLF就是 \r\n 参考 https://tools.ietf.org/html/rfc3261 https://tools.ietf.org/html/rfc2543 </description>
    </item>
    
    <item>
      <title>[todo] db_mode调优</title>
      <link>https://wdd.js.org/opensips/ch5/db-mode/</link>
      <pubDate>Wed, 22 Jul 2020 14:25:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/db-mode/</guid>
      <description>opensips在多实例时，会有一些数据同步策略的问题。
～</description>
    </item>
    
    <item>
      <title>使用m4增强opensips.cfg脚本预处理能力</title>
      <link>https://wdd.js.org/opensips/ch5/m4/</link>
      <pubDate>Wed, 22 Jul 2020 14:16:17 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/m4/</guid>
      <description>相比于kamailo的脚本的预处理能力，opensips的脚本略显单薄。OpenSIPS官方也认识到了这一点，但是也并未准备如何提高这部分能力。因为OpenSIPS是想将预处理交给这方面的专家，也就是大名鼎鼎的m4(当然，你可能根本不知道m4是啥)。
举例来说 我们看一下opensips自带脚本的中的一小块。 里面就有三个要配置的地方
这个listen的地址： listen=udp:127.0.0.1:5060 数据库地址的配置：modparam(&amp;ldquo;usrloc&amp;rdquo;, &amp;ldquo;db_url&amp;rdquo;, &amp;ldquo;dbdriver://username:password@dbhost/dbname&amp;rdquo;) 数据库地址的配置：modparam(&amp;ldquo;acc&amp;rdquo;, &amp;ldquo;db_url&amp;rdquo;, &amp;ldquo;mysql://user:password@localhost/opensips&amp;rdquo;) auto_aliases=no listen=udp:127.0.0.1:5060 # CUSTOMIZE ME mpath=&amp;#34;/usr/local//lib/opensips/modules/&amp;#34; loadmodule &amp;#34;usrloc.so&amp;#34; modparam(&amp;#34;usrloc&amp;#34;, &amp;#34;db_url&amp;#34;, &amp;#34;dbdriver://username:password@dbhost/dbname&amp;#34;) modparam(&amp;#34;acc&amp;#34;, &amp;#34;early_media&amp;#34;, 0) modparam(&amp;#34;acc&amp;#34;, &amp;#34;report_cancels&amp;#34;, 0) modparam(&amp;#34;acc&amp;#34;, &amp;#34;detect_direction&amp;#34;, 0) modparam(&amp;#34;acc&amp;#34;, &amp;#34;db_url&amp;#34;, &amp;#34;mysql://user:password@localhost/opensips&amp;#34;) 随着脚本代码的增多，各种配置往往越来越多。真是脚本里，配置的地方远远不止三处！
你开发了OpenSIPS的脚本，但是真正部署的服务的可能是其他人。那么其他拿到你的脚本的时候，他们怎么知道要改哪些地方呢，难道要搜索一下，所有出现#CUSTOMIZE ME的地方就是需要配置的？ 难道他们每次部署一个服务，就要改一遍脚本的内容？ 改错了谁负责？
如果你不想被运维人员在背后骂娘，就不要把配置性的数据写死到脚本里！
如果你不想在打游戏的时候被运维人员点电话问这个配置出错应该怎么解决，就不要把配置型数据写死到脚本里！
** 那么，你就需要用到M4**
什么是M4？ M4是一种宏语言，如果你不清楚什么是宏，你就可以把M4想想成一种字符串替换的工具。
如何安装M4? 大部分Linux上都已经默认安装了m4, 你可以用m4 --version检查一下m4是否已经存在。
m4 --version Copyright © 2021 Free Software Foundation, Inc. GPLv3+ 许可证: GNU 通用公共许可证第三版或更高版本 &amp;lt;https://gnu.org/licenses/gpl.html&amp;gt;。 这是自由软件: 您可自由更改并重新分发它。 在法律所允许的范围内，不附带任何担保条款。 如果不存在的话，可以用对应常用的包管理工具来安装，例如
apt-get install m4 能否举个m4例子？ hello-world.</description>
    </item>
    
    <item>
      <title>媒体路径与信令路径</title>
      <link>https://wdd.js.org/opensips/ch1/sip-rtp-path/</link>
      <pubDate>Wed, 24 Jun 2020 09:11:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-rtp-path/</guid>
      <description>一般的sip网关同时具有信令和媒体处理的能力，如下图。
但是也有信令和媒体分开的网关。在和网关信令交互过程中，网关会将媒体地址放到sdp中。
难点就来了，在nat存在的场景下，你并不知道sdp里的媒体地址是否是真实的地址。
那么你就要选择，是相信sdp中的媒体地址，还是把sip信令的源ip作为媒体地址呢？</description>
    </item>
    
    <item>
      <title>媒体协商 offer/answer模型</title>
      <link>https://wdd.js.org/opensips/ch1/offer-answer/</link>
      <pubDate>Wed, 24 Jun 2020 08:51:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/offer-answer/</guid>
      <description>1. 简介 媒体协商用来交换呼叫双方的媒体能力。如
支持的编码类型有哪些 采样频率是多少 媒体端口，ip 信息 &amp;hellip; 媒体协商使用的是请求和应答模型。即一方向另一方发送含有 sdp 信息的消息，然后另一方更具对方提供的编码以及自己支持的编码，如果协商成功，则将协商后的消息 sdp 再次发送给对方。
2. 常见的几个协商方式 2.1 在 INVITE 中 offer 2.2 在 200 OK 中 offer 2.3 在 UPDATE 中 offer 2.4 在 PRACK 中 offer 3. 常见的几个问题 一般呼叫到中继测时，中继回的 183 信令是会携带 sdp 信息的 一般打到分机时，分机回的 180 信令是没有 sdp 信息的 不要先入为主的认为，某些请求一定带有 sdp，某些请求一定没有 sdp。而应当去测试请求或者响应消息上有没有携带 sdp 信息。
携带 sdp 信息的 sip 消息会出现下面的头
Content-Type: application/sdp </description>
    </item>
    
    <item>
      <title>acc呼叫记录模块</title>
      <link>https://wdd.js.org/opensips/ch6/acc/</link>
      <pubDate>Fri, 29 May 2020 09:35:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/acc/</guid>
      <description>opensips 1.x 使用各种flag去设置一个呼叫是否需要记录。从opensips 2.2开始，不再使用flag的方式，而使用 do_accounting() 函数去标记是否需要记录呼叫。
注意 do_accounting()函数并不是收到SIP消息后立即写呼叫记录，也仅仅是做一个标记。实际的写数据库或者写日志发生在事务或者dialog完成的时候。</description>
    </item>
    
    <item>
      <title>负载均衡模块load_balance</title>
      <link>https://wdd.js.org/opensips/ch6/load-balance/</link>
      <pubDate>Tue, 19 May 2020 09:42:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/load-balance/</guid>
      <description> 负载均衡只能均衡INVITE, 不能均衡REGISTER请求。因为load_blance底层是使用dialog模块去跟踪目标地址的负载情况。 load_balance方法会改变INVITE的$du, 而不会修改SIP URL 呼叫结束的时候，目标地址的负载会自动释放 选择逻辑 网关A 网关B 通道数 30 60 正在使用的通道数 20 55 空闲通道数 10 5 load_balance是会先选择最大可用资源的目标地址。假如A网关的最大并发呼叫是30， B网关最大并发呼叫是60。在某个时刻，A网关上已经有20和呼叫了, B网关上已经有55个呼叫。 此时load_balance会优先选择网关A。
参考 https://opensips.org/Documentation/Tutorials-LoadBalancing-1-9 </description>
    </item>
    
    <item>
      <title>rtpproxy录音</title>
      <link>https://wdd.js.org/opensips/ch4/rtp-record/</link>
      <pubDate>Thu, 14 May 2020 16:13:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/rtp-record/</guid>
      <description>-a -R -r /recording -S spool -P -a 所有的通话都录音 -R 不要把RTCP也写文件 -r 指定录音文件的位置 -S 临时文件的位置，注意不要和录音文件位置相同 -P 录成pcap文件的格式，而不要录成默认的 Ad-hoc的模式 </description>
    </item>
    
    <item>
      <title>漫话NAT的历史todo</title>
      <link>https://wdd.js.org/opensips/ch1/story-of-nat/</link>
      <pubDate>Fri, 10 Apr 2020 13:18:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/story-of-nat/</guid>
      <description>设想一下，如果国家规定，给孩子起名字的时候，不能和已经使用过的活着的人名字相同，会发生什么事情？
除非把名字起得越来越长，否则名字很快就不够用了。
在 1993 年的时候，有人就遇到类似的问题，因为 IP 地址快被用完了。
他们想出两个方案：
短期方案：CIDR(Classless InterDomain Routing) 长期方案：开发新的具有更大地址空间的互联网协议。可以认为是目前的 IPv6 当然了长期方案不是一蹴而就的，短期方案才是解决眼前问题的方案。
a very small percentage of hosts in a stub domain are communicating outside of the domain at any given time
短期的方案基于一个逻辑事实：在一个网络中，只有非常少的几个主机需要跟外部网络交流。也就是说，大部分的主机都在内部交流。那么内部交流的这些主机，实际上并不需要给设置公网 IP。（但是这个只是 1993 年的那个时期的事实）**可以类比于，班级内部之间的学生交流很多。班级与班级之间的交流，估计只有班长之间交流。
参考 https://tools.ietf.org/html/rfc1631 https://tools.ietf.org/html/rfc1996 https://tools.ietf.org/html/rfc2663 https://tools.ietf.org/html/rfc2993 </description>
    </item>
    
    <item>
      <title>深入理解SIP ACK 方法</title>
      <link>https://wdd.js.org/opensips/ch1/sip-ack/</link>
      <pubDate>Wed, 19 Feb 2020 19:17:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-ack/</guid>
      <description>ACK的特点 ACK仅用于对INVITE消息的最终响应进行确认 ACK的CSeq的号码必须和INVITE的CSeq号码相同，这是用来保证ACK对对哪一个INVITE进行确认的唯一标志。另外CSeq的方法会改为ACK ACK分为两种 失败请求的确认；例如对4XX, 5XX请求的确认。在对失败的请求进行确认时，ACK是逐跳的。 成功的请求的确认；对200的确认，此时ACK是端到端的。 ACK一般不会带有SDP信息。如果INVITE消息没有带有SDP，那么ACK消息中一般会带有ACK ACK与事务的关系 如果请求成功，那么后续的ACK消息是单独的事物 如果请求失败，那么后续的ACK消息和之前的INVITE是属于相同的事务 逐跳ACK VS 端到端ACK 逐跳在英文中叫做: hop-by-hop端到端在英文中叫做：end-to-end
ACK如何路由 ack是序列化请求，所谓序列化请求，是指sip to 字段中已经有tag。有to tag是到达对端的唯一标志。
没有to tag请求称为初始化请求，有totag称为序列化请求。
初始化请求做路径发现，往往需要做一些数据库查询，DNS查询。而序列化请求不需要查询数据库，因为路径已经发现过了。
实战场景：分机A, SIP服务器S, 分机B, A呼叫B，详细介绍一下到ACK的过程。
分机A向SIP服务器S发送请求：INVITE B SIP服务器 首先在数据库中查找B的实际注册地址 修改Contact头为分机A的外网地址和端口。因为由于存在NAT, 分机A一般不知道自己的公网地址。 record_route 将消息发送给B 分机B: 收到来自SIP服务器的INVITE消息 从INVITE中取出Contact, 获取对端的，其实也就是分机A的实际地址 如果所有条件都满足，分机B会向SIP服务器发送180响应，然后发送200响应 由于180响应和200响应和INVITE都属于一个事务，响应会按照Via的地址，先发送给SIP服务器 SIP服务器： SIP服务器会首先修改180响应的Contac头，把分机B的内网地址改为外网地址 SIP服务器根据Via头，将消息发送给分机A 对于200 OK的消息，和180的处理是相同的 分机A: 分机收到180消息后，从Contact头中能够获取分机B的外网地址 分机A在发送ACK时，request url地址是分机B的地址，但是由于sip服务器的record_route动作首先会将消息发送给SIP服务器，SIP服务器会按照request url的地址，将ack发送给分机B。 ACK的路由不需要做数据库查询，ACK的request url一般是对端UAC的地址。在存在route头时，ACK会按照route字段去路由。
ACK丢失了会怎样？ 如果被叫在一定时间内没有收到ACK, 那么被叫会周期性的重发200OK。如果在超时的时候，还没有收到ACK, 就发发送BYE消息来挂断呼叫。很多呼叫在30秒自动挂断，往往就是因为丢失了ACK。
那么ACK为什么会丢失呢？可能有以下的原因，大部分原因和NAT有关！
SIP服务器没有做fix_nat_contact, 导致主叫可能不知道实际被叫的外网地址 ACK与媒体流的关系 并不是说被叫收到ACK后，媒体流才开始。往往在180或者183时，双方已经能够听到对方的声音了。</description>
    </item>
    
    <item>
      <title>rtp编码表</title>
      <link>https://wdd.js.org/opensips/ch4/codec-table/</link>
      <pubDate>Sat, 07 Dec 2019 09:10:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/codec-table/</guid>
      <description>v=0 o=WMSWMS 1562204406 1562204407 IN IP4 192.168.40.79 s=WMSWMS c=IN IP4 192.168.40.79 t=0 0 m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ptime:20 上面的SDP协议，我们只关注媒体编码部分，其中
m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 m字段audio说明是音频 31114是rtp的发送端口，一般rtp端口都是偶数，偶数后面的一个奇数端口是给rtcp端口的 0 8 9 101就是媒体编码，每个整数代表一个编码，其中96以下的是都是用IANA规定的，可以不用下面的rtpmap字段去指定，96以上的属于动态编码，需要用rtpmap去指定 上面是整个编码表，我们只需要记住几个就可以:
0 PCMU/8000 3 GSM/8000 8 PCMA/8000 9 G722/8000 18 G729/8000 102 DTMF/8000 a=rtpmap:101 telephone-event/8000a=fmtp:101 0-16上面的字段描述的是DTMP的支持。DTMF标准，所有SIP实体至少支持0-15的DTMF事件。
0-9是数字 10是* 11是# 12-15对应A,B,C,D 参考 https://www.</description>
    </item>
    
    <item>
      <title>opensips介绍</title>
      <link>https://wdd.js.org/opensips/ch3/about-opensips/</link>
      <pubDate>Tue, 19 Nov 2019 18:37:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/about-opensips/</guid>
      <description>1. OpenSIPS架构 OpenSIPS主要有两部分构成，
core: 提供底层工具、接口、资源 module：模块是一些共享的库，在启动时按需加载。有些模块是用于在opensips脚本中提供功能，而有些模块是作为底层，为其他模块提供功能。 2. OpenSIP 核心 2.1. 传输层 传输层提供了对于各种协议的支持，如TCP、UDP、TLS、WebSocket
2.2. SIP工厂层 SIP工厂层提供了对SIP协议的解析和构建。OpenSIPS实现了一种懒解析功能，懒解析的效率非常高。
懒解析：懒解析就是只去解析SIP头，并不解析SIP头的字段内容。而是在需要读取头字段内容时，才去解析。所以可以理解为按需解析。有点类似于一些文件系统的写时复制功能。
**惰性应用：**有一点非常重要，当你通过脚本提供的函数去改变SIP消息时，所作出的改变并不是实时作用到SIP消息上，而是在先存起来，而是当所有的SIP消息处理完成后才会去应用这些改变。举例来说，你首先通过函数给SIP消息添加了某个头，然后你通过函数去获取这个头的时，发现这个头并不存在，但是SIP消息再发送出去后，又携带了你添加的这个头。
2.3. 路由脚本解析与执行 OpenSIPS在启动后，会将opensips.cfg解析并加载到内存中。一旦OpenSIPS正常运行了，opensips.cfg文件即使删了也不会影响到OpenSIPS的运行了。
但是OpenSIPS并不支持热脚本更新，如果你改了脚本，让让运行的OpenSIPS具有添加的功能，那么必须将OpensSIPS重启。
OpenSIPS的脚本有点类似于C或者Shell语言，如果你Shell写的很溜，OpenSIPS的脚本理解起来也会非常容易。
2.4. 内存与锁管理 出于性能考虑，OpenSIPS自己内部实现了内存和锁的管理，这部分在内容在脚本中是不可见的。
2.5. 脚本变量和脚本函数 OpenSIPS核心提供的脚本变量和函数比较有限，外围的模块提供和很多的变量和函数。这些变量和函数的存在，都是为了让你易于获取SIP消息的某些字段，或者对SIP消息进行修改。
2.6. SQL接口类 OpenSIPS 核心实现了接口的定义，但是并没有实现接口。接口的实现由外部的模块提供，这样做的函数可以使用不同的数据库。
2.7. MI管理接口 mi接口用来管理OpenSIPS, 可以实现以下功能
向OpenSIPS 发送数据 从OpenSIPS 获取数据 触发OpenSIPS 的内部行为 </description>
    </item>
    
    <item>
      <title>深入NAT网络</title>
      <link>https://wdd.js.org/opensips/ch1/deep-in-nat/</link>
      <pubDate>Tue, 05 Nov 2019 16:29:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/deep-in-nat/</guid>
      <description> NAT的产生原因是IPv4的地址不够用，网络中的部分主机只能公用一个外网IP。 NAT工作在网络层和传输层，主要是对IP地址和端口号的改变 NAT的优点 节约公网IP 安全性更好，所有流量都需要经过入口的防火墙 NAT的缺点 对于UPD应用不够友好 NAT 工作原理 内部的设备X, 经过NAT设备后，NAT设备会改写源IP和端口 NAT 类型 1. 全锥型 每个内部主机都有一个静态绑定的外部ip:port 任何主机发往NAT设备上特定ip:port的包，都会被转发给绑定的主机 这种方式的缺点很明显，黑客可以使用端口扫描工具，扫描出暴露的端口，然后通过这个端口攻击内部主机 在内部主机没有往外发送流量时，外部流量也能够进入内部主机 -
2. 限制锥形 NAT上的ip:port与内部主机是动态绑定的 如果内部主机没有向某个主机先发送过包，那么NAT会拒绝外部主机进入的流量 3. 端口限制型 端口限制型除了有限制锥型的要求外，还增加了端口的限制 4. 对称型 对称型最难穿透，因为每次交互NAT都会使用不同的端口号，所以内外网端口映射根本无法预测 NAT对比表格 NAT类型 收数据前是否需要先发送数据 是否能够预测下一次的NAT打开的端口对 是否限制包的目的ip:port 全锥形 否 是 否 限制锥形 是 是 仅限制IP 端口限制型 是 是 是 对称型 是 否 是 </description>
    </item>
    
    <item>
      <title>【必读】深入对外公布地址</title>
      <link>https://wdd.js.org/opensips/ch5/adv-address/</link>
      <pubDate>Mon, 04 Nov 2019 13:11:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/adv-address/</guid>
      <description>如果你仅仅是本地运行OpenSIPS, 你可以不用管什么对外公布地址。但是如果你的SIP服务器想在公网环境提供服务，则必然要深刻的理解对外公布地址。
在一个集群中，可能有多台SIP服务器，例如如下图的网络架构中
register 负责注册相关的业务 192.168.1.100(内网) uas 负责呼叫相关的业务 192.168.1.101(内网) entry 负责接入 192.168.1.102(内网)，1.2.3.4(公网地址) 一般情况下，register和uas只有内外地址，没有公网地址。而entry既有内网地址，也有公网地址。公网地址一般是由云服务提供商分配的。
我们希望内部网络register和uas以及entry必须使用内网通信，而entry和互联网使用公网通信。
有时候经常遇到的问题就是某个请求，例如INVITE, uas从内网地址发送到了entry的公网地址上，这时候就可能产生一些列的奇葩问题。
如何设置公布地址 listen as listen = udp:192.168.1.102:5060 as 1.2.3.4:5060 在listen 的参数上直接配置公布地址。好处的方便，后续如果调用record_route()或者add_path_received(), OpenSIPS会自动帮你选择对外公布地址。
但是，OpenSIPS选择可能并不是我们想要的。
例如： INVITE请求从内部发送到互联网，这时OpenSIPS能正常设置对外公布地址。但是如果请求从外表进入内部，OpenSIPS可能还是会用公网地址作为对外公布地址。
所以，listen as虽然方便，但不够灵活。
set_advertised_address() 和 set_advertised_port(int) set_advertised_address和set_advertised_port属于OpenSIPS和核心函数部分，可以在脚本里根据不同条件，灵活的设置公布地址。
例如:
if 请求发生到公网 { set_advertised_address(&amp;#34;1.2.3.4&amp;#34;); } ⚠️ 如果你选择用set_advertised_address和set_advertised_port来手动设置，就千万不要用as了。
几个注意点SIP头 record_route头 Path头 上面的两个头，在OpenSIPS里可以用下面的函数去设置。设置的时候，务必要主义选择合适的网络地址。否者请求将会不回按照你期望方式发送。
record_route record_route_preset add_path add_path_received </description>
    </item>
    
    <item>
      <title>CSTA 呼叫模型简介</title>
      <link>https://wdd.js.org/opensips/ch1/csta-call-model/</link>
      <pubDate>Tue, 15 Oct 2019 21:43:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/csta-call-model/</guid>
      <description>1. 内容概要 CSTA 协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA 协议标准 2.1. 什么是 CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications) 基本的呼叫模型在 1992 建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等 CSTA 是一个应用层接口，用来监控呼叫，设备和网络 CSTA 创建了一个通讯程序的抽象层: CSTA 并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA 并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式 第三方呼叫控制 一方呼叫控制 CSTA 的设计目标是为了提高各种 CSTA 实现之间的移植性 规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段 1 (发布于 June ’92) 40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段 2 (发布于 Dec. ’94) 77 特性, 145 页 (服务定义) I/O &amp;amp; 语音单元服务, 更多呼叫控制服务 阶段 3 - CSTA Phase II Features &amp;amp; versit CTI Technology 发布于 Dec.</description>
    </item>
    
    <item>
      <title>UA应答模式的实现</title>
      <link>https://wdd.js.org/opensips/ch1/ua-answer-mode/</link>
      <pubDate>Thu, 26 Sep 2019 20:37:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/ua-answer-mode/</guid>
      <description>Notify 使用noify消息，通知分机应答，这个notify一般发送在分机回180响应之后
Answer-mode Answer-Mode一般有两个值 Auto: UA收到INVITE之后，立即回200OK，没有180的过程 Manual: UA收到INVITE之后，等待用户手工点击应答 通常Answer-Mode还会跟着require, 表示某个应答方式如果不被允许，应当回403 Forbidden 作为响应。
Answer-Mode: Auto;require 和Answer-mode头类似的有个SIP头叫做：Priv-Answer-Mode，这个功能和Answer-Mode类似，但是他有个特点。
如果UA设置了免打扰，Priv-Answer-Mode头会无视免打扰这个选项，强制让分机应答，这个头适合用于紧急呼叫。
结论 如果要实现分机的自动应答，显然Answer-Mode的应答速度回更快。但是对于依赖180响应的系统，可能要考虑这种没有180相应的情况。
要记住，在SIP消息里，对于UA来说，1xx的响应都是不必须的可以缺少的。</description>
    </item>
    
    <item>
      <title>opensips日志写入elasticsearch</title>
      <link>https://wdd.js.org/opensips/ch3/elk/</link>
      <pubDate>Thu, 19 Sep 2019 09:01:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/elk/</guid>
      <description>构造json $json(body) := &amp;#34;{}&amp;#34;; $json(body/time) = $time(%F %T-0300); $json(body/sipRequest) = “INVITE”; $json(body/ipIntruder) = $si; $json(body/destNum) = $rU; $json(body/userAgent) = $ua; $json(body/country)=$var(city); $json(body/location)=$var(latlon); $json(body/ipHost) = $Ri; 使用async rest_post写数据 async好像存在于2.1版本及其以上， 异步的好处是不会阻止脚本的继续执行 async(rest_post(&amp;#34;http://user:password@w.x.y.z:9200/opensips/1&amp;#34;, &amp;#34;$json(body)&amp;#34;, &amp;#34;$var(ctype)&amp;#34;, &amp;#34;$var(ct)&amp;#34;, &amp;#34;$var(rcode)&amp;#34;),resume) </description>
    </item>
    
    <item>
      <title>回铃音</title>
      <link>https://wdd.js.org/opensips/ch2/early-media/</link>
      <pubDate>Wed, 18 Sep 2019 09:53:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/early-media/</guid>
      <description>特点分析 回铃音有以下特点
回铃音是由运营商送给手机的，而不是由被叫送给主叫的。 回铃音的播放阶段是在被叫接听前播放，被叫一旦接听，回铃音则播放结束 回铃音一般是450Hz, 嘟一秒，停4秒，5秒一个周期 常见问题 听不到回铃音 【现象】打同一个号码，有些手机能听到回铃音，有些手机听不到回铃音【排查思路】
有些手机volte开启后，可能会导致无回铃音，所以可以关闭volte试试 被叫的运营商，主叫手机的运营商 参考资料 https://zh.wikipedia.org/wiki/%E5%9B%9E%E9%93%83%E9%9F%B3 https://baike.baidu.com/item/%E5%9B%9E%E9%93%83%E9%9F%B3/1014322 http://www.it9000.cn/tech/CTI/signal.html </description>
    </item>
    
    <item>
      <title>几种常用电话信号音的含义</title>
      <link>https://wdd.js.org/opensips/ch2/early-media-type/</link>
      <pubDate>Wed, 18 Sep 2019 09:10:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/early-media-type/</guid>
      <description>几种常用电话信号音的含义 信号频率：（450±25）HZ：拨号音、回铃音、忙音、长途通知音、空号音（950±25）HZ：催挂音
拨号音 摘机后受话器中便有一种“嗡&amp;ndash;”的连续音，这种声音就是拨号音，它表示自动交换机或对方呼叫中心系统已经做好了接续准备，允许用户拨号
回铃音 拨完被叫号，若听到“嘟&amp;ndash;嘟&amp;ndash;”的断续音（响1s，断4s），便是回铃音，表示被叫话机正在响铃，可静候接话；如果振铃超过10余次，仍无人讲话，说明对方无人接电话，应放好手柄稍后再拨。
忙音 当主叫用户在拨号过程中或拨完被叫电话号码后，若听到“嘟、嘟、嘟……”的短促音（响0.35s，断0.35s），这就是忙音，表示线路已经被占满或被叫电话机正在使用
长途通知音 当主叫用户和被叫用户正在进行市内通话时，听到“嘟、嘟、嘟……”的短促音（响0.2s，断0.2s，响0.2s，间歇0.6s），这便是长途电话通知音，表示有长途电话插入，提醒主被叫用户双方尽快结束市内通话，准备接听长途电话。
空号音 当用户拨完号码后听到不等间隔断续信号音（重复3次0.1s响，0.1s断后，0.4s响0.4s断），这便是空号音，表示通知主叫用户所呼叫的被叫号码为空号或受限制的号码。
催挂音 如果用户听到连续信号音，响度变化为5级，由低级逐步升高，则是催挂音。通知久不挂机的用户迅速挂机。
参考 http://www.it9000.cn/tech/CTI/signal.html </description>
    </item>
    
    <item>
      <title>NAT解决方法</title>
      <link>https://wdd.js.org/opensips/ch1/fix-nat/</link>
      <pubDate>Tue, 17 Sep 2019 08:58:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/fix-nat/</guid>
      <description>解决信令的过程 NAT检测 使用rport解决Via 在初始化请求和响应中修改Contact头 处理来自NAT内部的注册请求 Ping客户端使NAT映射保持打开 处理序列化请求 实现NAT检测 nat_uac_test 使用函数 nat_uac_test
1 搜索Contact头存在于RFC 1918 中的地址 2 检测Via头中的received参数和源地址是否相同 4 最顶部的Via出现在RFC1918 / RFC6598地址中 8 搜索SDP头出现RFC1918 / RFC6598地址 16 测试源端口是否和Via头中的端口不同 32 比较Contact中的地址和源信令的地址 64 比较Contact中的端口和源信令的端口 上边的测试都是可以组合的，并且任何一个测试通过，则返回true。
例如下面的测试19，实际上是1+2+16三项测试的组合
nat_uac_test(&amp;#34;19&amp;#34;) 使用rport和receive参数标记Via头 从NAT内部出去的呼叫，往往可能不知道自己的出口IP和端口，只有远端的SIP服务器收到请求后，才能知道UAC的真是出口IP和端口。出口IP用received=x.x.x.x，出口端口用rport=xx。当有消息发到UAC时，应当发到received和rport所指定的地址和端口。
# 原始的Via Via: SIP/2.0/UDP 192.168.4.48:5062;branch=z9hG4bK523223793;rport # 经过opensips处理后的Via Via: SIP/2.0/UDP 192.168.4.48:5062;received=192.168.4.48;branch=z9hG4bK523223793;rport=5062 修复Contact头 Via头和Contact头是比较容易混淆的概念，但是两者的功能完全不同。Via头使用来导航183和200响应应该如何按照原路返回。Contact用来给序列化请求，例如BYE和UPDATE导航。如果Contact头不正确，可能会导致呼叫无法挂断。那么就需要用fix_nated_contact()函数去修复Contact头。另外，对于183和200的响应也需要去修复Contact头。
处理注册请求 RFC 1918 地址组 10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) 参考 http://www.rfcreader.com/#rfc1918 </description>
    </item>
    
    <item>
      <title>常见媒体流编码及其特点</title>
      <link>https://wdd.js.org/opensips/ch4/media-codec/</link>
      <pubDate>Fri, 13 Sep 2019 09:04:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/media-codec/</guid>
      <description> 编码 带宽 MOS 环境 特点 说明 G.711 64 kbps 4.45 LAN/WAN 语音质量高，适合对接网关 G.711实际上就是PCM, 是最基本的编码方式。PCM又分为两类PCMA(g711a), PCMU(g711u)。中国使用的是PCMA G.729 8 kbps 4.04 WAN 带宽占用率很小，同时能保证不错的语音质量 分为G729a和G729b两种，G729之所以带宽占用是G711的1/8, 是因为G729的压缩算法不同。G729传输的不是真正的语音，而是语音压缩后的结果。G729的编解码是由专利的，也就说不免费。 G.722 64 kbps 4.5 LAN 语音质量高 HD hd语音 GSM 13.3 kbps 3.01 iLBA 13.3 15.2 抗丢包 OPUS 6-510 kbps - INTERNET OPUS的带宽范围跨度很广，适合语音和视屏 MOS值，Mean Opinion Score，用来定义语音质量。满分为5分，最低1分。
MOS 质量 5 极好的 4 不错的 3 还行吧 2 中等差 1 最差 通常的打包是20ms一个包，那么一秒就会传输1000/20=50个包。如果采样评率是8000Hz, 那么每个包的会携带 8000/50=160个采样数据。在PCMA或者PCMU中，每个采样数据占用1字节。因此20ms的一个包就携带160字节的数据。
在RTP包协议中，160字节还要加上12个自己的RTP头。 在fs上可以使用下面的命令查看fs支持的编码。
show codec </description>
    </item>
    
    <item>
      <title>centos7 安装opensips</title>
      <link>https://wdd.js.org/opensips/ch3/centos-install/</link>
      <pubDate>Thu, 05 Sep 2019 12:09:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/centos-install/</guid>
      <description>安装依赖 yum update &amp;amp;&amp;amp; yum install epel-release yum install openssl-devel mariadb-devel libmicrohttpd-devel \ libcurl-devel libconfuse-devel ncurses-devel 编译 下面的脚本，默认将opensips安装在/usr/local/etc/目录下
&amp;gt; cd opensips-2.4.6 # 编译 &amp;gt; make all -j4 include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; # 安装 &amp;gt; make install include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; 如果想要指定安装位置，可以使用prefix参数指定，例如指定安装在/usr/aaa目录
&amp;gt; cd opensips-2.4.6 # 编译 &amp;gt; make all -j4 prefix=/usr/aaa include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; # 安装 &amp;gt; make install prefix=/usr/aaa include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; </description>
    </item>
    
    <item>
      <title>opensips 集成 homer6</title>
      <link>https://wdd.js.org/opensips/ch5/homer6/</link>
      <pubDate>Tue, 20 Aug 2019 11:40:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/homer6/</guid>
      <description> 参考 https://blog.opensips.org/2017/03/22/capturing-beyond-sip/ http://www.sipcapture.org/ https://github.com/sipcapture/homer/wiki </description>
    </item>
    
    <item>
      <title>模块缓存策略与reload方法</title>
      <link>https://wdd.js.org/opensips/ch3/cache-reload/</link>
      <pubDate>Tue, 20 Aug 2019 09:11:21 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/cache-reload/</guid>
      <description>常见的问题 有时候如果你直接在数据库中改动某些值，但是opensips并没有按照预设的值去执行，那么你就要尝试使用mi命令去reload相关模块。
有缓存模块 opensips在启动时，会将某些模块所使用的表一次性全部加载到数据库，状态变化时，再回写到数据库。有一下模块列表：
dispather load_balancer carrierroute dialplan &amp;hellip; 判断一个模块是否是一次性加载到内存的，有个简便方法，看这个模块是否提供类似于 xx_reload的mi接口，有reload的mi接口，就说明这个模块是使用一次性读取，变化回写的方式读写数据库。
将模块一次性加载到内存的好处时不用每次都查数据库，运行速度会大大提升。
以dispather为例子，opensips在启动时会从数据库总加载一系列的目标到内存中，然后按照设定值，周期性的向目标发送options包，如果目标挂掉，三次未响应，opensips将会将该目标的状态设置为非0值，表示该地址不可用，同时将该状态回写到数据库。
无缓存模块 无缓存的模块每次都会向数据库查询数据。常见的模块有alias_db，该模块的说明
ALIAS_DB module can be used as an alternative for user aliases via usrloc. The main feature is that it does not store all adjacent data as for user location and always uses database for search (no memory caching).
ALIAS_DB一般用于呼入时接入号的查询，在多租户的情况下，如果大多数租户都是使用呼入的场景，那么ALIAS_DB模块可能会是一个性能瓶颈，建议将该模块使用一些内存数据库替代。
从浏览器reload模块 opensips在加载了httpd和mi_http模块之后，可以在opensips主机的8888端口访问到管理页面，具体地址如：http://opensips_host:8888/mi
这个页面可以看到opensips所加载的模块，然后我们点击carrierroute, 可以看到该模块所支持的管理命令列表，如下图左侧列表所示，其中cr_reload_routes就是一个管理命令。
然后我们点击cr_reload_routes连接，跳转到下图所示页面。参数可以不用填写，直接点击submit就可以。正常情况下回返回 200 : OK，就说明reload模块成功。
使用curl命令reload模块 如果因为某些原因，无法访问web界面，那么可以使用curl等http命令行工具执行curl命令，例如
curl http://192.168.40.98:8888/mi/carrierroute/cr_reload_routes?arg= </description>
    </item>
    
    <item>
      <title>SIP注册调研</title>
      <link>https://wdd.js.org/opensips/ch1/sip-register/</link>
      <pubDate>Mon, 19 Aug 2019 21:30:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-register/</guid>
      <description>sequenceDiagram autonumber participant a as 192.168.0.123:55647 participant b as 1.2.3.4:5060 participant c as 172.10.10.3:49543 a-&gt;&gt;b: register cseq=1, callId=1 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=2, callid=1 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=3, callId=1 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=4, callid=1 b--&gt;&gt;a: 200 c-&gt;&gt;b: register cseq=5, callid=1 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=6, callid=1 b--&gt;&gt;c: 500 Service Unavailable c-&gt;&gt;b: register cseq=7, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=8, callid=2 b--&gt;&gt;c: 200 c-&gt;&gt;b: register cseq=9, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=10, callid=2 b--&gt;&gt;c: 200 c-&gt;&gt;b: register cseq=11, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=12, callid=2 b--&gt;&gt;c: 500 Service Unavailable a-&gt;&gt;b: register cseq=13, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=14, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=15, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=16, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=17, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=18, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=19, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=20, callid=3 b--&gt;&gt;a: 200 服务端设置的过期时间是120s 客户端每隔115s注册一次, callid和之前的保持不变 当网络变了之后，由于ip地址改变，客户端的在115秒注册，此时服务端还未超时，所以给客户端响应报错500 客户端在等了8秒之后，等待服务端超时，然后再次注册，再次注册时，callid改变 因为服务端已经超时，所以能够注册成功 需要注意的是，在一个注册周期内，客户端的注册信息包括IP、端口、协议、CallID都不能变，一旦改变了。如果服务端的记录还没有失效，新的注册就会失败。</description>
    </item>
    
    <item>
      <title>SIP路由头</title>
      <link>https://wdd.js.org/opensips/ch5/via-route/</link>
      <pubDate>Fri, 16 Aug 2019 22:00:39 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/via-route/</guid>
      <description>两种头 via headers 响应按照Via字段向前走 route headers 请求按照route字段向前走 Via头 当uac发送请求时, 每个ua都会加上自己的via头, via都的顺序很重要，每个节点都需要将自己的Via头加在最上面 响应消息按照via头记录的地址返回，每次经过自己的node时候，要去掉自己的via头 via用来指明消息应该按照什么 Route头 路由模块 模块 CARRIERROUTE DISPATCHER DROUTING LOAD_BALANCER </description>
    </item>
    
    <item>
      <title>条件语句特点</title>
      <link>https://wdd.js.org/opensips/ch5/condition/</link>
      <pubDate>Mon, 05 Aug 2019 09:57:20 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/condition/</guid>
      <description>if语句中的真和假值 假值
负数: -1, -2, -3, -4 null: hdr(not_exist) 然而这个not_exist头并不存在 &amp;ldquo;&amp;rdquo;: 空字符串 0 真值：
非空字符串: &amp;ldquo;acb&amp;rdquo; 正数: 1,2,3 </description>
    </item>
    
    <item>
      <title>核心MI命令</title>
      <link>https://wdd.js.org/opensips/ch3/core-mi/</link>
      <pubDate>Thu, 18 Jul 2019 13:54:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/core-mi/</guid>
      <description>在所有的fifo命令中，which命令比较重要，因为它可以列出所有的其他命令。
有些mi命令是存在于各个模块之中，所以加载的模块不通。opensipsctl fifo which输出的命令也不通。
获取执行参数 opensipsctl fifo arg 列出TCP连接数量 opensipsctl fifo list_tcp_conns 查看进程信息 opensipsctl fifo ps 查看opensips运行时长 opensipsctl fifo uptime 查看所有支持的指令 opensipsctl fifo which 获取统计数据 opensipsctl fifo get_statistics rcv_requests 重置统计数据 opensipsctl fifo get_statistics received_replies get_statistics reset_statistics uptime version pwd arg which ps kill debug cache_store cache_fetch cache_remove event_subscribe events_list subscribers_list list_tcp_conns help list_blacklists regex_reload t_uac_dlg t_uac_cancel t_hash t_reply ul_rm ul_rm_contact ul_dump ul_flush ul_add ul_show_contact ul_sync domain_reload domain_dump dlg_list dlg_list_ctx dlg_end_dlg dlg_db_sync dlg_restore_db profile_get_size profile_list_dlgs profile_get_values list_all_profiles nh_enable_ping cr_reload_routes cr_dump_routes cr_replace_host cr_deactivate_host cr_activate_host cr_add_host cr_delete_host dp_reload dp_translate address_reload address_dump subnet_dump allow_uri dr_reload dr_gw_status dr_carrier_status lb_reload lb_resize lb_list lb_status httpd_list_root_path sip_trace rtpengine_enable rtpengine_show rtpengine_reload teardown </description>
    </item>
    
    <item>
      <title>from vs to vs request-url之间的关系</title>
      <link>https://wdd.js.org/opensips/ch1/from-to-request-url/</link>
      <pubDate>Thu, 11 Jul 2019 07:38:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/from-to-request-url/</guid>
      <description>from字段用来标记请求的发起者ID to字段用来标记请求接受者的ID to字段并不能用于路由，request-url可以用来路由 一般情况下，sip消息再传输过程中，from和to字段都不会改，而request-url很可能会因为路由而改变 对于最初的请求，除了注册请求之外，request-url和to字段中的url一致 from字段：The From header field is a required header field that indicates the originator of the request. It is one of two addresses used to identify the dialog. The From header field contains a URI, but it may not contain the transport, maddr, or ttl URI parameters. A From header field may contain a tag used to identify a particular call. A From header field may contain a display name, in which case the URI is enclosed in &amp;lt; &amp;gt;.</description>
    </item>
    
    <item>
      <title>日志xlog</title>
      <link>https://wdd.js.org/opensips/ch5/xlog-level/</link>
      <pubDate>Tue, 09 Jul 2019 17:52:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/xlog-level/</guid>
      <description>建议日志格式 xlog(&amp;#34;$rm $fu-&amp;gt;$tu:$cfg_line some msg&amp;#34;) 日志级别 L_ALERT (-3) L_CRIT (-2) L_ERR (-1) - this is used by default if log_level is omitted L_WARN (1) L_NOTICE (2) L_INFO (3) L_DBG (4) 日志级别如果设置为2， 那么只会打印小于等于2的日志。默认使用xlog(&amp;ldquo;hello&amp;rdquo;), 那么日志级别就会是L_ERR
生产环境建议将日志界别调整到-1
1.x的opensips使用 debug=3 设置日志级别2.x的opensips使用 log_level=3 设置日志级别
动态设置日志级别 在程序运行时，可以通过opensipctl 命令动态设置日志级别
opensipsctl fifo log_level -2 最好使用日志级别 不要为了简便，都用 xlog(&amp;#34;msg&amp;#34;) 如果msg是信息级别，用xlog(&amp;#34;L_INFO&amp;#34;, &amp;#34;msg&amp;#34;) 如果msg是错误信息，则使用xlog(&amp;#34;msg&amp;#34;) </description>
    </item>
    
    <item>
      <title>opensips监控</title>
      <link>https://wdd.js.org/opensips/ch3/opensips-monitor/</link>
      <pubDate>Tue, 02 Jul 2019 22:09:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/opensips-monitor/</guid>
      <description>**opensipsctl fifo get_statistics all **命令可以获取所有统计数据，在所有统计数据中，我们只关心内存，事务和回话的数量。然后将数据使用curl工具写入到influxdb中。
opensipsctl fifo reset_statistics all 重置统计数据
常用指令 命令 描述 opensipsctl fifo which 显示所有可用命令 opensipsctl fifo ps 显示所有进程 opensipsctl fifo get_statistics all 获取所有统计信息 opensipsctl fifo get_statistics core: 获取内核统计信息 opensipsctl fifo get_statistics net: 获取网路统计信息 opensipsctl fifo get_statistics pkmem: 获取私有内存相关信息 opensipsctl fifo get_statistics tm: 获取事务模块统计信息 opensipsctl fifo get_statistics sl: 获取sl模块统计信息 opensipsctl fifo get statistics shmem: 获取共享内存相关信息 opensipsctl fifo get statistics usrloc: 获取 opensipsctl fifo get statistics registrar: 获取注册统计信息 opensipsctl fifo get statistics uri: 获取uri统计信息 opensipsctl fifo get statistics load: 获取负载信息 opensipsctl fifo reset_statistics all 重置所有统计信息 shmem:total_size:: 6467616768 shmem:used_size:: 4578374040 shmem:real_used_size:: 4728909408 shmem:max_used_size:: 4728909408 shmem:free_size:: 1738707360 shmem:fragments:: 1 # 事务 tm:UAS_transactions:: 296337 tm:UAC_transactions:: 30 tm:2xx_transactions:: 174737 tm:3xx_transactions:: 0 tm:4xx_transactions:: 110571 tm:5xx_transactions:: 2170 tm:6xx_transactions:: 0 tm:inuse_transactions:: 289651 dialog:active_dialogs:: 156 dialog:early_dialogs:: 680 dialog:processed_dialogs:: 104061 dialog:expired_dialogs:: 964 dialog:failed_dialogs:: 78457 dialog:create_sent:: 0 dialog:update_sent:: 0 dialog:delete_sent:: 0 dialog:create_recv:: 0 dialog:update_recv:: 0 dialog:delete_recv:: 0 CONF_DB_URL=&amp;#34;ip:port&amp;#34; # influxdb地址 CONF_DB_NAME=&amp;#34;dbname&amp;#34; # influxdb数据库名 CONF_OPENSIPS_ROLE=&amp;#34;a&amp;#34; # 角色，随便写个字符串 PATH=&amp;#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin&amp;#34; LOCAL_IP=`ip route get 8.</description>
    </item>
    
    <item>
      <title>opensips centos7 安装与升级</title>
      <link>https://wdd.js.org/opensips/ch3/centos7-2.4/</link>
      <pubDate>Tue, 02 Jul 2019 19:42:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/centos7-2.4/</guid>
      <description>环境声明 系统 centos7 已经安装opensips 2.2 需要升级目标 opensips 2.4.6 要求：当前系统上没有部署mysql服务端程序 升级步骤 升级分为两步
opensips 应用升级，包括源码的下载，编译等等 opensips 数据库升级，使用opensipsdbctl工具迁移老的数据 Edge: opensips应用升级 升级过程以Makefile交付，可以先新建一个空的目录，如 /root/opensips-update/
# file: /root/opensips-update/Makefile VERSION=2.4.6 download: wget https://opensips.org/pub/opensips/$(VERSION)/opensips-$(VERSION).tar.gz; tar -zxvf opensips-$(VERSION).tar.gz; build: cd opensips-$(VERSION); make all -j4 include_modules=&amp;#34;db_mysql httpd db_http siprec&amp;#34;; # siprec是可选的 make install include_modules=&amp;#34;db_mysql httpd db_http siprec&amp;#34;; # siprec是可选的 新建空目录/root/opensips-update/ 在新目录中创建名为 Makefile的文件, 内容如上面所示 执行 make download 执行 make build Core: opensips应用升级 make all -j4 include_modules=&amp;#34;db_mysql httpd&amp;#34; make install include_modules=&amp;#34;db_mysql httpd&amp;#34; 可能遇到的报错以及解决方案 主要的问题可能是某些包冲突，或者某些库没有安装依赖。在解决问题后，需要重新编译。</description>
    </item>
    
    <item>
      <title>有状态和无状态路由</title>
      <link>https://wdd.js.org/opensips/ch5/stateful-stateless/</link>
      <pubDate>Wed, 19 Jun 2019 23:40:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/stateful-stateless/</guid>
      <description> 操作 无状态 有状态 SIP forward forward() t_relay() SIP replying sl_send_reply() t_reply() Create transaction t_newtran() Match transcation t_check_trans() </description>
    </item>
    
    <item>
      <title>严格路由和松散路由</title>
      <link>https://wdd.js.org/opensips/ch5/strict-loose-routing/</link>
      <pubDate>Tue, 18 Jun 2019 11:11:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/strict-loose-routing/</guid>
      <description>松散路由是sip 2版本的新的路由方法。严格路由是老的路由方法。
如何从sip消息中区分严格路由和松散路由 下图sip消息中Route字段中带有**lr, **则说明这是松散路由。
REGISTER sip:127.0.0.1 SIP/2.0 Via: SIP/2.0/UDP 127.0.0.1:58979;rport;branch=z9hG4bKPjMRzNdeTKn9rHNDtyJuVoyrDb84.cPtL8 Route: &amp;lt;sip:127.0.0.1;lr&amp;gt; Max-Forwards: 70 From: &amp;#34;1001&amp;#34; &amp;lt;sip:1001@172.17.0.2&amp;gt;;tag=oqkOzbQYd9cx5vXFjUnB1WufgWUZZxtZ To: &amp;#34;1001&amp;#34; &amp;lt;sip:1001@172.17.0.2&amp;gt; 功能上的区别 严格路由，sip请求经过uas后，invite url每次都会被重写。
松散路由，sip请求经过uas后，invite url不变。
#1 invite INVITE sip:callee@domain.com SIP/2.0 Contact: sip:caller@u1.example.com #2 invite INVITE sip:callee@domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: &amp;lt;sip:p1.example.com;lr&amp;gt; #3 invite INVITE sip:callee@u2.domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: &amp;lt;sip:p2.domain.com;lr&amp;gt; Record-Route: &amp;lt;sip:p1.example.com;lr&amp;gt; #4 200 ok SIP/2.0 200 OK Contact: sip:callee@u2.domain.com Record-Route: &amp;lt;sip:p2.domain.com;lr&amp;gt; Record-Route: &amp;lt;sip:p1.example.com;lr&amp;gt; #7 bye BYE sip:callee@u2.domain.com SIP/2.0 Route: &amp;lt;sip:p1.</description>
    </item>
    
    <item>
      <title>sip消息分发之dispatcher模块</title>
      <link>https://wdd.js.org/opensips/ch6/dispatcher/</link>
      <pubDate>Tue, 18 Jun 2019 10:51:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/dispatcher/</guid>
      <description>dispatcher模块用来分发sip消息。
dispatcher如何记录目的地状态 dispatcher会使用一张表。
需要关注两个字段destionations， state。
destionations表示sip消息要发往的目的地 state表示对目的地的状态检测结果 0 可用 1 不可用 2 表示正在检测 opensips只会想可用的目的地转发sip消息
id setid destionations state 1 1 sip:p1:5060 0 2 1 sip:p2:5060 1 3 1 sip:p2:5061 2 dispatcher如何检测目的地的状态 本地的opensips会周期性的向目的地发送options包，如果对方立即返回200ok, 就说明目的地可用。
在达到一定阈值后，目的地一直无响应，则opensips将其设置为不可用状态，或者正在检测状态。如下图所示
代码例子 ds_select_dst()函数会去选择可用的目的地，并且设置当前sip消息的转发地址。如果发现无用可转发地址，则进入504 服务不可用的逻辑。
如果sip终端注册时返回504，则可以从dispatcher模块，排查看看是不是所有的目的地都处于不可用状态。
if (!ds_select_dst(&amp;#34;1&amp;#34;, &amp;#34;0&amp;#34;)) { send_reply(&amp;#34;504&amp;#34;,&amp;#34;Service Unavailable&amp;#34;); exit; } </description>
    </item>
    
    <item>
      <title>变量的使用</title>
      <link>https://wdd.js.org/opensips/ch5/var/</link>
      <pubDate>Sun, 16 Jun 2019 17:18:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/var/</guid>
      <description>变量的使用方式 $(&amp;lt;context&amp;gt;type(name)[index]{transformation}) 变量都以$符号开头 type表示变量的类型：核心变量，自定义变量，键值对变量 name表示变量名：如$var(name), $avp(age) index表示需要，有些变量类似于数组，可以使用需要来指定。需要可以用正数和负数，如-1表示最后一个元素 transformations表示类型转换，如获取一个字符串值的长度，大小写转换等操作 context表示变量存在的作用域，opensips有请求的作用域和响应的作用域 # by type $ru # type type and name $hdr(Contact) # bye type and index $(ct[0]) # by type name and index $(avp(gw_ip)[2]) # by context $(&amp;lt;request&amp;gt;ru) $(&amp;lt;reply&amp;gt;hdr(Contact)) 引用变量 所有的引用变量都是可读的，但是只有部分变量可以修改。引用变量一般都是英文含义的首字母缩写，刚开始接触opensips的同学可能很不习惯。实际上通过首字母大概是可以猜出变量的含义的。
必须记住变量的用黄色标记。
变量名 英文含义 中文解释 是否可修改 $ru request url 请求url 是 $rU Username in SIP Request&amp;rsquo;s URI 是 $ci call id callId $hdr(from) request headers from 请求头中的from字段 是 $Ts current time unix Timestamp 当前时间的unix时间戳 $branch Branch $cl Content-Length $cs CSeq number $cT Content-Type $dd Domain of destination URI 目标地址的域名 是 $di Diversion header URI $dp Port of destination URI 目标地址的端口 是 $dP Transport protocol of destination URI 传输协议 $du Destination URI 目标地址 是 $fd From URI domain $fn From display name $ft From tag $fu From URI $fU From URI username $mb SIP message buffer $mf Message Flags $mi SIP message ID $ml SIP message length $od Domain in SIP Request&amp;rsquo;s original URI $op Port of SIP request&amp;rsquo;s original URI $oP Transport protocol of SIP request original URI $ou SIP Request&amp;rsquo;s original URI $oU Username in SIP Request&amp;rsquo;s original URI $param(idx) Route parameter $pp Process id $rd Domain in SIP Request&amp;rsquo;s URI $rb Body of request/reply 是 $rc Returned code $re Remote-Party-ID header URI $rm SIP request&amp;rsquo;s method $rp SIP request&amp;rsquo;s port 是 $rP Transport protocol of SIP request URI $rr SIP reply&amp;rsquo;s reason $rs SIP reply&amp;rsquo;s status $rt reference to URI of refer-to header $Ri Received IP address $Rp Received port $sf Script flags $si IP source address $sp Source port $td To URI Domain $tn To display name $tt To tag $tu To URI $tU To URI Username $TF String formatted time $TS Startup unix time stamp $ua User agent header 更多变量可以参考：https://www.</description>
    </item>
    
    <item>
      <title>路由的触发时机</title>
      <link>https://wdd.js.org/opensips/ch5/triger-time/</link>
      <pubDate>Sun, 16 Jun 2019 17:16:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/triger-time/</guid>
      <description> 掌握路由触发时机的关键是以下几点
消息是请求还是响应 消息是进入opensips的(incoming)，还是离开opensips的(outgoing) 从opensips发出去的ack请求，不会触发任何路由 **进入opensips(**incoming) 离开opensips(outgoing) 请求 触发请求路由：例如invite, register, ack 触发分支路由。如invite的转发 响应 触发响应路由。如果是大于等于300的响应，还会触发失败路由。 不会触发任何路由 </description>
    </item>
    
    <item>
      <title>【重点】初始化请求和序列化请求</title>
      <link>https://wdd.js.org/opensips/ch5/init-seque/</link>
      <pubDate>Sun, 16 Jun 2019 12:50:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/init-seque/</guid>
      <description>在说这两种路由前，先说一个故事。蚂蚁找食物。
蚁群里有一种蚂蚁负责搜寻食物叫做侦察兵，侦察兵得到消息，不远处可能有食物。于是侦察兵开始搜索食物的位置，并沿途留下自己的气味。翻过几座山之后，侦察兵发现了食物。然后又沿着气味回到了部落。然后通知搬运兵，沿着自己留下的气味，就可以找到食物。
在上面的故事中，侦查兵可以看成是初始化请求，搬运并可以看做是序列化请求。在学习opensips的路由过程中，能够区分初始化请求和序列化请求，是非常重要的。
一般路由处理，查数据库，查dns等都在初始化请求中做处理，序列化请求只需要简单的更具sip route字段去路由就可以了。
类型 功能 message 如何区分 特点 初始化请求 创建session或者dialog invite has_totag()是false 1. 发现被叫：初始化请求经过不同的服务器，DNS服务器，前缀路由等各种复杂的路由方法，找到被叫2. **记录路径: **记录到达被叫的路径，给后续的序列请求提供导航 序列化请求 修改或者终止session ack, bye, re-ivite, notify has_totag()是true 1. 只需要根据初始化请求提供的导航路径，来到达路径，不需要复杂的路由逻辑。 区分初始化请求和序列化请求，是用header字段中的to字段是否含有tag标签。
tag参数被用于to和from字段。使用callid，fromtag和totag三个字段可以来唯一识别一个dialog。每个tag来自一个ua。
当一个ua发出一个不在对话中的请求时，fromtag提供一半的对话标识，当对话完成时，另一方参与者提供totag标识。
举例来说，对于一个invite请求，例如Alice-&amp;gt;Proxy
invite请求to字段无tag参数 当alice回ack请求时，已经含有了to tag。这就是一个序列化请求了。因为通过之前的200ok, alice已经知道到达bob的路径。 INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b43 Max-Forwards: 70 Route: &amp;lt;sip:ss1.atlanta.example.com;lr&amp;gt; From: Alice &amp;lt;sip:alice@atlanta.example.com&amp;gt;;tag=9fxced76sl # 有from tag To: Bob &amp;lt;sip:bob@biloxi.example.com&amp;gt; # 无to tag Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: &amp;lt;sip:alice@client.atlanta.example.com;transport=tcp&amp;gt; Content-Type: application/sdp Content-Length: 151 ACK sip:bob@client.biloxi.example.com SIP/2.</description>
    </item>
    
    <item>
      <title>脚本路由模块化</title>
      <link>https://wdd.js.org/opensips/ch5/module/</link>
      <pubDate>Sun, 16 Jun 2019 11:22:56 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/module/</guid>
      <description>当你的代码一个屏幕无法展示完时，你就需要考虑模块化的事情了。
维护一个上千行的代码，是很辛苦，也是很恐怖的事情。
我们应当把自己的关注点放在某个具体的点上。
方法1 include_file 具体方法是使用include_file参数。
如果你的opensips.cfg文件到达上千行，你可以考虑使用一下include_file指令。
include_file &amp;#34;global.cfg&amp;#34; include_file &amp;#34;moudule.cfg&amp;#34; include_file &amp;#34;routing.cfg&amp;#34; 方法2 m4 宏编译 参考：https://github.com/wangduanduan/m4-opensips.cfg</description>
    </item>
    
    <item>
      <title>优雅的使用xlog输出日志行</title>
      <link>https://wdd.js.org/opensips/ch5/xlog/</link>
      <pubDate>Sun, 16 Jun 2019 11:16:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/xlog/</guid>
      <description>在opensips 2.2中加入新的全局配置cfg_line, 用来返回当前日志在整个文件中的行数。
注意，低于2.2的版本不能使用cfg_line。
使用方法如下：
... xlog(&amp;#34;$cfg_line enter_ack_deal&amp;#34;) ... xlog(&amp;#34;$cfg_line enter_ack_deal&amp;#34;) ... 如果没有cfg_line这个参数，你在日志中看到enter_ack_deal后，根本无法区分是哪一行打印了这个关键词。
使用了cfg_line后，可以在日志中看到类似如下的日志输出方式，很容易区分哪一行日志执行了。
23 enter_ack_deal 823 enter_ack_deal </description>
    </item>
    
    <item>
      <title>全局参数配置</title>
      <link>https://wdd.js.org/opensips/ch5/global-params/</link>
      <pubDate>Sun, 16 Jun 2019 11:03:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/global-params/</guid>
      <description>本全局参数基于opensips 2.4介绍。
opensips的全局参数有很多，具体可以参考。https://www.opensips.org/Documentation/Script-CoreParameters-2-4#toc37
下面介绍几个常用的参数
log_level=3 log_facility=LOG_LOCAL0 listen=172.16.200.228:4400 log_level log_level的值配置的越大，输出的日志越详细。log_level的值的范围是[-3, 4]
-3 - Alert level -2 - Critical level -1 - Error level 1 - Warning level 2 - Notice level 3 - Info level 4 - Debug level log_facility log_facility用来设置独立的opensips日志文件，参考https://www.yuque.com/wangdd/opensips/log
listen listen用来设置opensips监听的端口和协议, 由于opensips底层支持的协议很多，所以你可以监听很多不同协议。
注意一点：不要监听本地环回地址127.0.0.1, 而要监听etho0的ip地址。
listen:udp:172.16.200.228:5060 listen:tcp:172.16.200.228:5061 listen:ws:172.16.200.228:5062 </description>
    </item>
    
    <item>
      <title>函数特点</title>
      <link>https://wdd.js.org/opensips/ch5/function/</link>
      <pubDate>Sun, 16 Jun 2019 10:48:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/function/</guid>
      <description>opensips脚本中没有类似function这样的关键字来定义函数，它的函数主要有两个来源。
opensips核心提供的函数: 模块提供的函数: lb_is_destination(), consume_credentials() 函数特点 opensips函数的特点
最多支持6个参数 所有的参数都是字符串，即使写成数字，解析时也按照字符串解析 函数的返回值只能是整数 所有函数不能返回0，返回0会导致路由停止执行，return(0)相当于exit() 函数返回的正数可以翻译成true 函数返回的负数会翻译成false 使用return(9)返回结果 使用$rc获取上个函数的返回值 虽然opensips脚本中无法自定义函数，但是可以把route关键字作为函数来使用。
可以给
# 定义enter_log函数 route[enter_log]{ xlog(&amp;#34;$ci $fu $tu $param(1)&amp;#34;) # $param(1) 是指调用enter_log函数的第一个参数，即wangdd return(1) } route{ # 调用enter_log函数 route(enter_log, &amp;#34;wangdd&amp;#34;) # 获取enter_log的返回值 $rc xlog(&amp;#34;$rc&amp;#34;) } 如何传参 某个函数可以支持6个参数，全部都是的可选的，但是我只想传第一个和第6个，应该怎么传？
不想传参的话，需要使用逗号隔开
siprec_start_recording(srs,,,,,media_ip) </description>
    </item>
    
    <item>
      <title>路由分类</title>
      <link>https://wdd.js.org/opensips/ch5/routing-type/</link>
      <pubDate>Sun, 16 Jun 2019 10:46:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/routing-type/</guid>
      <description>opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。
所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面
route[some_xxx]{ } 主路由分为几类
请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的
路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。</description>
    </item>
    
    <item>
      <title>设置独立日志文件</title>
      <link>https://wdd.js.org/opensips/ch3/log/</link>
      <pubDate>Sun, 16 Jun 2019 10:33:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/log/</guid>
      <description>设置独立日志 默认情况下，opensips的日志会写在系统日志文件/var/log/message中，为了避免难以查阅日志，我们可以将opensips的日志写到单独的日志文件中。
环境说明
debian buster
这个需要做两步。
第一步，配置opensips.cfg文件
log_facility=LOG_LOCAL0 第二步, 创建日志配置文件
echo &amp;#34;local0.* -/var/log/opensips.log&amp;#34; &amp;gt; /etc/rsyslog.d/opensips.conf 第三步，创建日志文件
touch /var/log/opensips.log 第四步，重启rsyslog和opensips
service rsyslog restart opensipsctl restart 第五步，验证结果
tail /var/log/opensips.log 日志回滚 为了避免日志文件占用过多磁盘空间，需要做日志回滚。
安装logrotate apt install logrotate -y 日志回滚配置文件 /etc/logrotate.d/opensips
/var/log/opensips.log { noolddir size 10M rotate 100 copytruncate compress sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true /bin/kill -HUP `cat /var/run/rsyslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true endscript } 配置定时任务</description>
    </item>
    
    <item>
      <title>配置文件</title>
      <link>https://wdd.js.org/opensips/ch5/routing-script/</link>
      <pubDate>Thu, 13 Jun 2019 22:10:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/routing-script/</guid>
      <description>脚本预处理 如果你的opensips.cfg文件不大，可以写成一个文件。否则建议使用include_file引入配置文件。
include_file &amp;#34;global.cfg&amp;#34; 有些配置，建议使用m4宏处理。
脚本结构 ####### Global Parameters ######### debug=3 log_stderror=no fork=yes children=4 listen=udp:127.0.0.1:5060 ####### Modules Section ######## mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;signaling.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;rr.so&amp;#34; loadmodule &amp;#34;uri.so&amp;#34; loadmodule &amp;#34;sipmsgops.so&amp;#34; modparam(&amp;#34;rr&amp;#34;, &amp;#34;append_fromtag&amp;#34;, 0) ####### Routing Logic ######## route{ if ( has_totag() ) { loose_route(); route(relay); } if ( from_uri!=myself &amp;amp;&amp;amp; uri!=myself ) { send_reply(&amp;#34;403&amp;#34;,&amp;#34;Rely forbidden&amp;#34;); exit; } record_route(); route(relay); } route[relay] { if (is_method(&amp;#34;INVITE&amp;#34;)) t_on_failure(&amp;#34;missed_call&amp;#34;); t_relay(); exit; } failure_route[missed_call] { if (t_check_status(&amp;#34;486&amp;#34;)) { $rd = &amp;#34;127.</description>
    </item>
    
    <item>
      <title>opensips管理命令</title>
      <link>https://wdd.js.org/opensips/ch3/opensipsctl/</link>
      <pubDate>Thu, 13 Jun 2019 22:03:19 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/opensipsctl/</guid>
      <description>可以使用一下命令查找opensips的相关文件夹
find / -name opensips -type d 一般来说，重要的是opensips.cfg文件，这个文件一般位于/usr/local/etc/opensips/或者/usr/etc/opensips中。主要还是要看安装时选择的默认路径。
其中1.x版本的配置文件一般位于/usr/etc/opensips目录中，2.x版本的配置一般位于/usr/local/etc/opensips目录中。
下面主要讲解几个命令。
配置文件校验 校验opensips.cfg脚本是否合法, 如果有问题，会提示那行代码有问题，但是报错位置好像一直不准确。很多时候可能是忘记写分好了。
opensips -C opensips.cfg 启动关闭与重启 使用opensipsctl命令做数据库操作前，需要先配置opensipsctlrc文件
opensips start|stop|restart opensipsctl start|stop|restart 资源创建 opensipsdbctl create # 创建数据库 opensipsctl domain add abc.cc #创建域名 opensipsctl add 1001@test.cc 12346 # 新增用户 opensipsctl rm 1001@test.cc # 删除用户 opensipsctl passwdd 1001@test.cc 09879 # 修改密码 opensipsctl -h 显示所有可用命令
/usr/local/sbin/opensipsctl $Revision: 4448 $ Existing commands: -- command &amp;#39;start|stop|restart|trap&amp;#39; trap ............................... trap with gdb OpenSIPS processes restart ............................ restart OpenSIPS start .</description>
    </item>
    
    <item>
      <title>debian jessie opensips 2.4.7 安装</title>
      <link>https://wdd.js.org/opensips/ch3/install-opensips/</link>
      <pubDate>Thu, 13 Jun 2019 21:53:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/install-opensips/</guid>
      <description>1. 安装依赖 apt-get update -qq &amp;amp;&amp;amp; apt-get install -y build-essential net-tools \ bison flex m4 pkg-config libncurses5-dev rsyslog libmysqlclient-dev \ libssl-dev mysql-client libmicrohttpd-dev libcurl4-openssl-dev uuid-dev \ libpcre3-dev libconfuse-dev libxml2-dev libhiredis-dev wget lsof 2. 编译 下载opensips-2.4.7的源码，然后解压。
include_moduls可以按需指定，你可以只写你需要的模块。
cd /usr/local/src/opensips-2.4.7 make all -j4 include_modules=&amp;#34;db_mysql httpd db_http siprec regex rest_client carrierroute dialplan b2b_logic cachedb_redis proto_tls proto_wss tls_mgm&amp;#34; make install include_modules=&amp;#34;db_mysql httpd db_http siprec regex rest_client carrierroute dialplan b2b_logic cachedb_redis proto_tls proto_wss tls_mgm&amp;#34; </description>
    </item>
    
  </channel>
</rss>
