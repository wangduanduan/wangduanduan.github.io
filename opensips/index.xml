<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OpenSIPS2.4.X 中文实战系列 on 洞香春</title>
    <link>https://wdd.js.org/opensips/</link>
    <description>Recent content in OpenSIPS2.4.X 中文实战系列 on 洞香春</description>
    <image>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 30 Oct 2022 21:11:16 +0800</lastBuildDate><atom:link href="https://wdd.js.org/opensips/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SIP相关RFC协议</title>
      <link>https://wdd.js.org/opensips/ch1/sip-rfcs/</link>
      <pubDate>Sun, 30 Oct 2022 21:11:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-rfcs/</guid>
      <description>RFC 名称 https://tools.ietf.org/html/rfc3261 SIP: Session Initiation Protocol https://tools.ietf.org/html/rfc3665 Session Initiation Protocol (SIP) Basic Call Flow Examples https://tools.ietf.org/html/rfc6141 Re-INVITE and Target-Refresh Request Handling in the Session Initiation Protocol (SIP) https://tools.ietf.org/html/rfc4566 SDP: Session Description Protocol https://tools.ietf.org/html/rfc4028 Session Timers in the Session Initiation Protocol (SIP) https://tools.ietf.org/html/rfc1889 RTP: A Transport Protocol for Real-Time Applications https://tools.ietf.org/html/rfc2326 Real Time Streaming Protocol (RTSP) https://tools.ietf.org/html/rfc2327 SDP: Session Description Protocol https://tools.ietf.org/html/rfc3015 Megaco Protocol Version 1.0 https://tools.ietf.org/html/rfc1918 Address Allocation for Private Internets https://tools.</description>
    </item>
    
    <item>
      <title>STUN协议笔记</title>
      <link>https://wdd.js.org/opensips/ch1/stun-notes/</link>
      <pubDate>Sun, 30 Oct 2022 20:22:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/stun-notes/</guid>
      <description>title: &amp;ldquo;STUN协议笔记&amp;rdquo; date: &amp;ldquo;2022-01-06 17:54:10&amp;rdquo; draft: false STUN是Simple Traversal of User Datagram Protocol (UDP) through Network Address Translators (NAT’s)的缩写 传输层底层用的是UDP 主要用来NAT穿透 主要用来解决voip领域的单方向通话(one-way)的问题 目的是让NAT后面的设备能发现自己的公网IP以及NAT的类型 让外部设备能够找到合适的端口和内部设备通信 刷新NAT绑定，类似keep-alive机制。否则端口映射可能因为超时被释放 STUN是cs架构的协议 客户端端192.168.1.3，使用5060端口，发送stun请求到 64.25.58.65， 经过了192.168.1.1的网关之后 网关将源ip改为212.128.56.125， 端口改为15050 stun服务器将请求发送到 网关的外网端口15050，然后网关将请求转发给192.168.1.3:5060 stun message type which typically is one of the below: - 0x0001 : Binding Request - 0x0101 : Binding Response
0x0111 : Binding Error Response 0x0002 : Shared Secret Request 0x0102 : Shared Secret Response 0x0112 : Shared Secret Error Response **0x0001: MAPPED-ADDRESS - **This attribute contains an IP address and port.</description>
    </item>
    
    <item>
      <title>SIP信令和媒体都绕不开的NAT问题</title>
      <link>https://wdd.js.org/opensips/ch1/nat-sip-rtp/</link>
      <pubDate>Sun, 30 Oct 2022 19:37:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/nat-sip-rtp/</guid>
      <description>什么是NAT? NAT(网络地址转换)， 具体可以参考百科 https://baike.baidu.com/item/nat/320024。
NAT是用来解决IPv4的地址不够的问题。
例如上图，内网的主机，在访问外网时，源192.168的网址，会被改写成1.2.3.4。所以在server端看来，请求是从1.2.3.4发送过来的。
NAT一般会改写请求的源IP包的源IP地址，也可能会改写tcp或者udp的源端口地址。
NAT地址范围 互联网地址分配机构保留了三类网址只能由于私有地址，这些地址只能由于NAT内部，不能用于公网。
如果在sip消息中，Contact头中的地址是192.168开头，聪明的服务器应该知道，这个请求来自NAT内部。
10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) NAT 工作原理 NAT内部流量流出时，源IP和源端口都被改写，目标地址和端口不会改写。源ip和端口与被改写后的ip和端口存在一段时间的映射关系，当响应回来时，根据这个映射关系，NAT设备知道这个包应该发给内网的哪个设备。
NAT分类 静态NAT: 每个内部主机都永久映射一个外部公网IP 动态NAT: 每个内部主机都动态映射一个外部公网IP 网络地址端口转换: 内部主机映射到外部不同端口上 由于静态NAT和动态NAT并不能节省公网IP, 常用的都是网络地址端口转换，即NAPT。
NAPT 网络地址端口转换分类 全锥型NAT 限制锥型NAT： 限制主机 端口限制NAT：限制主机和端口 Full Cone NAT 全锥型NAT 打洞过程
来自nat内部ip1:port1地址在经过路由器时，路由器会打洞ip1&amp;rsquo;:port1&#39; 任何服务器只要把包发到ip1&amp;rsquo;:port1&amp;rsquo;，路由器都会把这个包发到ip1:port1。也就是说，即使刚开始打洞的包是发给server1的，如果server2知道这个洞的信息，那么server2也可以通过这洞，将消息发给ip1:port1 Restricted Cone NAT 限制锥型NAT 限制锥型打洞过程和全锥型差不多，只不过增加了限制。
如果内部主机是把包发到server1的，即使server2知道打洞的信息，它发的包也不会被转给内部主机。 Port Restricted Cone NAT 端口限制NAT 端口限制NAT要比上述两种NAT的限制更为严格
内部主机如果将消息发到server1的5080端口，那么这个端口只允许server1的5080端口发消息回来 server1的其他端口发消息到这个洞都会被拒绝 SIP信令NAT穿越 NAT内部消息发到fs时，会携带如下信息。假如fs对NAT一无所知，如果后续有呼叫，fs是无法将消息发到192.168.0.102的，因为192.168.0.102是内网地址。
但是fs足够聪明，它会从分析包的源ip和源端口，从而正确的将sip消息送到NAT设备上。
Via: SIP/2.0/UDP 192.168.1.160:11266;branch=z9hG4bK-d8754z-1f2cd509;rport Contact: &amp;lt;sip:flavio@192.</description>
    </item>
    
    <item>
      <title>奥科网关 Rtp Broken Connection</title>
      <link>https://wdd.js.org/opensips/ch1/rtp-broken-connection/</link>
      <pubDate>Sat, 29 Oct 2022 10:11:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/rtp-broken-connection/</guid>
      <description>通话10多秒后，fs对两个call leg发送bye消息。
Bye消息给的原因是 Reason: Q.850 ;cause=31 ;text=”local, RTP Broken Connection”
在通话的前10多秒，SIP信令正常，双方也能听到对方的声音。
首先排查了下fs日志，没发现什么异常。然后根据这个报错内容，在网上搜了下。
发现了这篇文章 https://www.wavecoreit.com/blog/serverconfig/call-drop-transfer-rtp-broken-connection/
这篇文章给出的解决办法是通过配置了奥科AudioCodes网关来解决的。
然后咨询了下客户，证实他们用的也是奥科网关。所以就参考教程，配制了一下。
主要是在两个地方进行配置
Click Setup -&amp;gt; Signaling&amp;amp;Media -&amp;gt; Expand Coders &amp;amp; Profiles -&amp;gt; Click IP Profiles -&amp;gt; Edityour SFB Profile -&amp;gt; Broken Connection Mode-&amp;gt; Select Ignore -&amp;gt; Click Apply
Expand SIP Definitions -&amp;gt; Click SIP Definitions General Settings -&amp;gt; Broken Connection Mode -&amp;gt; Select Ignore -&amp;gt; Click Apply -&amp;gt; Click Save
这两个地方，都是配置Broken Connection Mode，选择ignore来设置的。
关于RTP的connection mode，有时间再研究下。</description>
    </item>
    
    <item>
      <title>utimer task &lt;tm-utimer&gt; already scheduled</title>
      <link>https://wdd.js.org/opensips/ch1/utime-task-scheduled/</link>
      <pubDate>Tue, 25 Oct 2022 12:06:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/utime-task-scheduled/</guid>
      <description>可能和avp_db_query有关 https://opensips.org/pipermail/users/2018-October/040157.html What we found is that the warning go away if we comment out the single avp_db_query that is being used in our config.
_ The avp_db_query is not executed at the start, but only when specific header is present. Yet the fooding start immediately after opensips start. The mere presence of the avp_db_query function in config without execution is enough to have the issue._
可能和openssl库有关 https://github.com/OpenSIPS/opensips/issues/1771#issuecomment-517744489 ere are your results.</description>
    </item>
    
    <item>
      <title>SIP和SDP的关系</title>
      <link>https://wdd.js.org/opensips/ch1/sip-with-sdp/</link>
      <pubDate>Sat, 03 Sep 2022 20:36:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-with-sdp/</guid>
      <description>1. 什么是SDP? SDP是Session Description Protocol的缩写，翻译过来就是会话描述协议，这个协议通常存储各种和媒体相关的信息，例如支持哪些媒体编码, 媒体端口是多少？媒体IP地址是多少之类的。
SDP一般作为SIP消息的body部分。如下所示
INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 Max-Forwards: 70 From: Alice &amp;lt;sip:alice@atlanta.example.com&amp;gt;;tag=9fxced76sl To: Bob &amp;lt;sip:bob@biloxi.example.com&amp;gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: &amp;lt;sip:alice@client.atlanta.example.com;transport=tcp&amp;gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 刚开始我一直认为某些sip消息一定带有sdp，例如invite消息。某些sip请求一定没有携带sdp。
实际上sip消息和sdp并没有硬性的附属关系。sip是用来传输信令的，sdp是用来描述媒体流信息的。
如果信令不需要携带媒体流信息，就可以不用携带sdp。
一般情况下，invite请求都会带有sdp信息，但是某些时候也会没有。例如3PCC(third party call control), 第三方呼叫控制，是指由第三方负责协商媒体信息。
常见的一个场景
2. SDP字段介绍 2.1. v= 版本号 当前sdp的版本号是0，所以常见的都是v=0
2.2. o= 发起者id o=的格式</description>
    </item>
    
    <item>
      <title>SIP协议拾遗补缺</title>
      <link>https://wdd.js.org/opensips/ch1/sip-notes/</link>
      <pubDate>Sat, 03 Sep 2022 15:54:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-notes/</guid>
      <description>1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11.</description>
    </item>
    
    <item>
      <title>Trunk Pbx Gateway</title>
      <link>https://wdd.js.org/opensips/ch1/trunk-pbx-gateway/</link>
      <pubDate>Sat, 03 Sep 2022 15:24:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/trunk-pbx-gateway/</guid>
      <description>传统中继 sip trunk中继 安全可靠：SIP Trunk设备和ITSP之间只需建立唯一的、安全的、具有QoS保证的SIP Trunk链路。通过该链路来承载企业的多路并发呼叫，运营商只需对该链路进行鉴权，不再对承载于该链路上的每一路SIP呼叫进行鉴权。 节约硬件成本：企业内部通信由企业IP-PBX负责。企业所有外出通信都通过SIP Trunk交由ITSP，再由ITSP中的设备发送到PSTN网络，企业不再需要维护原有的传统PSTN中继链路，节省了硬件和维护成本。 节约话费成本：企业可以通过设置目的地址任意选择并连接到多个ITSP，充分利用遍布全球各地的ITSP，节省通话费用。 功能强大：部署SIP Trunk设备后，全网可以使用SIP协议，可以更好的支持语音、会议、即时消息等IP通信业务。 处理信令和媒体：SIP Trunk设备不同于SIP代理服务器。SIP Trunk设备接收到用户的呼叫请求后，会代表用户向ITSP发起新呼叫请求。在转发过程中，SIP Trunk设备不但要对信令消息进行中继转发，对RTP媒体消息也需要进行中继转发。在整个过程中，SIP Trunk设备两端的设备（企业内部和企业外部设备）均认为和其交互的是SIP Trunk设备本身。 参考 http://www.h3c.com/cn/d_201009/688762_30003_0.htm https://getvoip.com/blog/2013/01/24/differences-between-sip-trunking-and-hosted-pbx/ https://www.onsip.com/blog/hosted-pbx-vs-sip-trunking https://baike.baidu.com/item/sip%20trunk/1499860 </description>
    </item>
    
    <item>
      <title>Path头简史</title>
      <link>https://wdd.js.org/opensips/ch1/sip-path/</link>
      <pubDate>Sat, 03 Sep 2022 14:51:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-path/</guid>
      <description>RFC3261并没有介绍关于Path头的定义，因为这个头是在RFC3327中定义的，Path头作为一个SIP的扩展头。
RFC3327的标题是：Session Initiation Protocol (SIP) Extension Header Field for Registering Non-Adjacent Contacts。
从这个标题可以看出，Path头是作为Register请求的一个消息头，一般这个头只在注册消息上才有。
这个头的格式如下。
Path: &amp;lt;sip:P1.EXAMPLEVISITED.COM;lr&amp;gt; 从功能上说，Path头和record-route头的功能非常相似，但是也不同。
看下面的一个场景，uac通过p1和p2, 将注册请求发送到uas, 在某一时刻，uac作为被叫，INVITE请求要从uas发送到uac, 这时候，INVITE请求应该怎么走？
假如我们希望INVITE请求要经过p2,p2,然后再发送到uac, Path头的作用就是这个。
注册请求经过P1时，P1在注册消息上加上p1地址的path头 注册请求经过P2时，P2在注册消息上加上p2地址的path头 注册请求到达uas时，uas从Contact头上获取到uac的地址信息，然后从两个Path头上获取到如下信息：如果要打电话给uac, Path头会转变为route头，用来定义INVITE请求的路径。 简单定义：Path头用来一般在注册消息里，Path头定义了uac作为被叫时，INVITE请求的发送路径。
参考 </description>
    </item>
    
    <item>
      <title>Via route Record-Route的区别</title>
      <link>https://wdd.js.org/opensips/ch1/via-route-record-route/</link>
      <pubDate>Sat, 03 Sep 2022 02:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/via-route-record-route/</guid>
      <description>sequenceDiagram title French Words I Know autonumber participant a participant p1 participant p2 participant p3 participant b a-&gt;&gt;p1 : INVITE route: p1, via: a p1-&gt;&gt;p2: INVITE via: a,p1, rr: p1 p2-&gt;&gt;p3: INVITE via: a,p1,p2 rr: p1,p2 p3-&gt;&gt;b: INVITE via: a,p1,p2,p3 rr: p1,p2,p3 b--&gt;&gt;p3: 180 via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 180 via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 180 via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 180 via: a rr: p1,p2,p3 b--&gt;&gt;p3: 200 OK via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 200 Ok via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 200 Ok via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 200 Ok via: a rr: p1,p2,p3 a-&gt;&gt;p1 : ACK via: a, route: p1,p2,p3 p1-&gt;&gt;p2: ACK via: a,p1, route: p2,p3 p2-&gt;&gt;p3: ACK via: a,p1,p2 route: p3 p3-&gt;&gt;b: ACK via: a,p1,p2,p3 rr代表record-route头。</description>
    </item>
    
    <item>
      <title>SIP协议简介</title>
      <link>https://wdd.js.org/opensips/ch1/sip-overview/</link>
      <pubDate>Fri, 02 Sep 2022 01:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-overview/</guid>
      <description>SIP是VoIP的基石，相当于HTTP协议在Web服务器里的角色。如果你熟悉HTTP协议，那么你可以在SIP协议中找到许多和HTTP中熟悉的东西，例如请求头，请求体，响应码之类概念，这是因为SIP协议的设计，很大程度上参考了HTTP协议。
如果想要学习VoIP，那么SIP协议是你务必掌握敲门砖。
1. SIP组件 UAC: 例如sip终端，软电话，话机 UAS: sip服务器 UA: ua既可以当做uac也可以当做uas 代理服务器 重定向服务器 注册服务器 网关 PSTN 公共交换电话网 2. SBC 边界会话控制器 SBC是Session Border Controller的缩写，具有一下几个功能。
拓扑隐藏：隐藏所有内部网络的信息。 媒体流管理：设置语音流编码规则，转换等 增加能力：例如Refer, 3CPP 维护NAT映射： 访问控制 媒体加密：例如外部网络用SRTP, 内部网络用RTP 3. sip注册过程 下面简化注册逻辑，省略了验证和过期等字段：
对于分机来说，注册服务器的地址是需要设置的 分机向注册服务器发请求，说：你好，注册服务器，我是8005，我的地址是200.180.1.1，以后你可以用这个地址联系我。 注册服务器回复：好的，注册成功 4. sip服务器的类型 4.1. 代理服务器 4.2. 重定向服务器 4.3. 背靠背UA服务器 背靠背UA服务器有两个作用
隐藏网络拓扑结构 有些时候，路由无法到达，只能用背靠背UA服务器 5. 常用sip请求方法 比较常用的是下面的
常用的几个是：register, invite, ack, bye, cancel。除了cancel和ack不需要认证外，其余的请求都需要认证。 register自不必说，invite和bye是需要认证的。
对于我们不信任的ua，我们不允许他们呼叫。对于未认证的bye，也需要禁止。后者可以防止恶意的bye请求，挂断正常的呼叫。
invite除了re-invite的情况，其余的都属于初始化请求，需要着重关心的。而对于bye这种序列化请求，只需要按照record-route去路由。
6. sip响应状态码 7. sip对话流程图 从上图可以看出，从invite请求到200ok之间的信令，都经过了代理服务器。但是200ok之后的ack，确没有经过代理服务器，如果想要所有信令都经过代理服务器，需要在sip消息头record-routing 指定代理服务器的地址
8. 请求与响应报文 9. 事务与对话的区别 重点：
从INVITE请求到最终的响应（注意1xx不是最终响应，非1xx的都是最终响应）之间，称为事务。一个事务可以带有多个消息组成，并经过多个ua。 ack请求比较特殊，但是ack不是事务。如果被叫接通后，超时未收到主叫方的ack, 会怎样？是否会再次发送200OK tcp三次握手建立连接，sip：invite-&amp;gt;200ok-&amp;gt;ack，可以理解为三次握手建立对话。 bye请求和200ok算作一个事务 dialog建立的前提是呼叫接通，如果呼叫没有接通，则没有dialog。 dialog可以由三个元素唯一确定。callId, from字段中的tag, to字段中的tag。 10.</description>
    </item>
    
    <item>
      <title>学习建议</title>
      <link>https://wdd.js.org/opensips/ch1/study-tips/</link>
      <pubDate>Fri, 02 Sep 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/study-tips/</guid>
      <description>1. 概念理解 务必要能理解SIP的重要概念，特别是事务、Dialog。参考https://www.yuque.com/wangdd/opensips/fx5pyy 概念是非常重要的东西，不理解概念，越学就会越吃力 2. 时序图 时序图是非常重要的，培训时，一般我会要求学员务必能够手工绘制时序图。因为只有能够手工绘制时序图了，在排查问题时，才能够从抓包工具给出的时序图中分析出问题所在。
RFC3665 https://datatracker.ietf.org/doc/html/rfc3665 中提供了很多经典的时序图，建议可以去临摹。</description>
    </item>
    
    <item>
      <title>RTP 不连续的timestamp和SSRC</title>
      <link>https://wdd.js.org/opensips/ch4/rtp-timestamp/</link>
      <pubDate>Mon, 10 Jan 2022 22:05:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/rtp-timestamp/</guid>
      <description>最近遇到一些和媒体流相关的问题，使用wireshark分析之后，总算有些眉目。然而我深感对RTP协议的理解，还是趋于表面。所以我决定，深入的学习一下RTP协议。
和rtp相关的协议有两个rfc, 分别是
1996的的 RFC 1889 2003年的 RFC 3550 RFC 3550是对RFC 1889的稍微改进，然而大体上是没什么改变的。所以我们可以直接看RFC 3550。
RTP 底层用的是UDP协议 RTP 的使用场景是传输实时数据，例如语音，视频，模拟数据等等 RTP 并不保证QoS Synchronization source (SSRC): The source of a stream of RTP packets, identified by a 32-bit numeric SSRC identifier carried in the RTP header so as not to be dependent upon the network address. All packets from a synchronization source form part of the same timing and sequence number space, so a receiver groups packets by synchronization source for playback.</description>
    </item>
    
    <item>
      <title>生产环境监控告警</title>
      <link>https://wdd.js.org/opensips/ch3/prd-warning/</link>
      <pubDate>Thu, 19 Aug 2021 20:08:28 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/prd-warning/</guid>
      <description>日志监控 务必监控opensips日志，如果其中出现了CRITICAL关键字, 很可能马上opensips就要崩溃。
第一要发出告警信息。第二要有主动的自动重启策略，例如使用systemd启动的话，服务崩溃会会立马被重启。或者用docker或者k8s，这些虚拟化技术，可以让容器崩溃后自动重启。
指标监控 opensips有内部的统计模块，可以很方便的通过opensipsctl或者相关的http的mi接口获取到内部的统计数据。
以下给出几个关键的统计指标：
&amp;rsquo;total_size&amp;rsquo;, 全部内存 &amp;lsquo;used_size&amp;rsquo;, 使用的内存 &amp;lsquo;real_used_size&amp;rsquo;, 真是使用的内存 &amp;lsquo;max_used_size&amp;rsquo;, 最大使用的内存 &amp;lsquo;free_size&amp;rsquo;, 空闲内存 &amp;lsquo;fragments&amp;rsquo;, &amp;lsquo;active_dialogs&amp;rsquo;, 接通状态的通话 &amp;rsquo;early_dialogs&amp;rsquo;, 振铃状态的通话 &amp;lsquo;inuse_transactions&amp;rsquo;, 正在使用的事务 &amp;lsquo;waiting_udp&amp;rsquo;, 堆积的udp消息 &amp;lsquo;waiting_tcp&amp;rsquo; 堆积的tcp消息 当然还有很多的一些指标，可以使用：opensipsctl fifo get_statistics all来获取。</description>
    </item>
    
    <item>
      <title>SIP消息格式CRLF</title>
      <link>https://wdd.js.org/opensips/ch3/sip-crlf/</link>
      <pubDate>Fri, 25 Dec 2020 17:44:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/sip-crlf/</guid>
      <description> generic-message = start-line *message-header CRLF [ message-body ] start-line = Request-Line / Status-Line 其中在rfc2543中规定
CR = %d13 ; US-ASCII CR, carriage return character LF = %d10 ; US-ASCII LF, line feed character 项目 十进制 字符串表示 CR 13 \r LF 10 \n 也就是说在一个SIP消息中
headline\r\n key:v\r\n \r\n some_body\r\n 所以CRLF就是 \r\n 参考 https://tools.ietf.org/html/rfc3261 https://tools.ietf.org/html/rfc2543 </description>
    </item>
    
    <item>
      <title>媒体路径与信令路径</title>
      <link>https://wdd.js.org/opensips/ch1/sip-rtp-path/</link>
      <pubDate>Wed, 24 Jun 2020 09:11:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-rtp-path/</guid>
      <description>一般的sip网关同时具有信令和媒体处理的能力，如下图。
但是也有信令和媒体分开的网关。在和网关信令交互过程中，网关会将媒体地址放到sdp中。
难点就来了，在nat存在的场景下，你并不知道sdp里的媒体地址是否是真实的地址。
那么你就要选择，是相信sdp中的媒体地址，还是把sip信令的源ip作为媒体地址呢？</description>
    </item>
    
    <item>
      <title>媒体协商 offer/answer模型</title>
      <link>https://wdd.js.org/opensips/ch1/offer-answer/</link>
      <pubDate>Wed, 24 Jun 2020 08:51:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/offer-answer/</guid>
      <description>1. 简介 媒体协商用来交换呼叫双方的媒体能力。如
支持的编码类型有哪些 采样频率是多少 媒体端口，ip 信息 &amp;hellip; 媒体协商使用的是请求和应答模型。即一方向另一方发送含有 sdp 信息的消息，然后另一方更具对方提供的编码以及自己支持的编码，如果协商成功，则将协商后的消息 sdp 再次发送给对方。
2. 常见的几个协商方式 2.1 在 INVITE 中 offer 2.2 在 200 OK 中 offer 2.3 在 UPDATE 中 offer 2.4 在 PRACK 中 offer 3. 常见的几个问题 一般呼叫到中继测时，中继回的 183 信令是会携带 sdp 信息的 一般打到分机时，分机回的 180 信令是没有 sdp 信息的 不要先入为主的认为，某些请求一定带有 sdp，某些请求一定没有 sdp。而应当去测试请求或者响应消息上有没有携带 sdp 信息。
携带 sdp 信息的 sip 消息会出现下面的头
Content-Type: application/sdp </description>
    </item>
    
    <item>
      <title>rtpproxy录音</title>
      <link>https://wdd.js.org/opensips/ch4/rtp-record/</link>
      <pubDate>Thu, 14 May 2020 16:13:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/rtp-record/</guid>
      <description>-a -R -r /recording -S spool -P -a 所有的通话都录音 -R 不要把RTCP也写文件 -r 指定录音文件的位置 -S 临时文件的位置，注意不要和录音文件位置相同 -P 录成pcap文件的格式，而不要录成默认的 Ad-hoc的模式 </description>
    </item>
    
    <item>
      <title>漫话NAT的历史todo</title>
      <link>https://wdd.js.org/opensips/ch1/story-of-nat/</link>
      <pubDate>Fri, 10 Apr 2020 13:18:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/story-of-nat/</guid>
      <description>设想一下，如果国家规定，给孩子起名字的时候，不能和已经使用过的活着的人名字相同，会发生什么事情？
除非把名字起得越来越长，否则名字很快就不够用了。
在 1993 年的时候，有人就遇到类似的问题，因为 IP 地址快被用完了。
他们想出两个方案：
短期方案：CIDR(Classless InterDomain Routing) 长期方案：开发新的具有更大地址空间的互联网协议。可以认为是目前的 IPv6 当然了长期方案不是一蹴而就的，短期方案才是解决眼前问题的方案。
a very small percentage of hosts in a stub domain are communicating outside of the domain at any given time
短期的方案基于一个逻辑事实：在一个网络中，只有非常少的几个主机需要跟外部网络交流。也就是说，大部分的主机都在内部交流。那么内部交流的这些主机，实际上并不需要给设置公网 IP。（但是这个只是 1993 年的那个时期的事实）**可以类比于，班级内部之间的学生交流很多。班级与班级之间的交流，估计只有班长之间交流。
参考 https://tools.ietf.org/html/rfc1631 https://tools.ietf.org/html/rfc1996 https://tools.ietf.org/html/rfc2663 https://tools.ietf.org/html/rfc2993 </description>
    </item>
    
    <item>
      <title>深入理解SIP ACK 方法</title>
      <link>https://wdd.js.org/opensips/ch1/sip-ack/</link>
      <pubDate>Wed, 19 Feb 2020 19:17:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-ack/</guid>
      <description>ACK的特点 ACK仅用于对INVITE消息的最终响应进行确认 ACK的CSeq的号码必须和INVITE的CSeq号码相同，这是用来保证ACK对对哪一个INVITE进行确认的唯一标志。另外CSeq的方法会改为ACK ACK分为两种 失败请求的确认；例如对4XX, 5XX请求的确认。在对失败的请求进行确认时，ACK是逐跳的。 成功的请求的确认；对200的确认，此时ACK是端到端的。 ACK一般不会带有SDP信息。如果INVITE消息没有带有SDP，那么ACK消息中一般会带有ACK ACK与事务的关系 如果请求成功，那么后续的ACK消息是单独的事物 如果请求失败，那么后续的ACK消息和之前的INVITE是属于相同的事务 逐跳ACK VS 端到端ACK 逐跳在英文中叫做: hop-by-hop端到端在英文中叫做：end-to-end
ACK如何路由 ack是序列化请求，所谓序列化请求，是指sip to 字段中已经有tag。有to tag是到达对端的唯一标志。
没有to tag请求称为初始化请求，有totag称为序列化请求。
初始化请求做路径发现，往往需要做一些数据库查询，DNS查询。而序列化请求不需要查询数据库，因为路径已经发现过了。
实战场景：分机A, SIP服务器S, 分机B, A呼叫B，详细介绍一下到ACK的过程。
分机A向SIP服务器S发送请求：INVITE B SIP服务器 首先在数据库中查找B的实际注册地址 修改Contact头为分机A的外网地址和端口。因为由于存在NAT, 分机A一般不知道自己的公网地址。 record_route 将消息发送给B 分机B: 收到来自SIP服务器的INVITE消息 从INVITE中取出Contact, 获取对端的，其实也就是分机A的实际地址 如果所有条件都满足，分机B会向SIP服务器发送180响应，然后发送200响应 由于180响应和200响应和INVITE都属于一个事务，响应会按照Via的地址，先发送给SIP服务器 SIP服务器： SIP服务器会首先修改180响应的Contac头，把分机B的内网地址改为外网地址 SIP服务器根据Via头，将消息发送给分机A 对于200 OK的消息，和180的处理是相同的 分机A: 分机收到180消息后，从Contact头中能够获取分机B的外网地址 分机A在发送ACK时，request url地址是分机B的地址，但是由于sip服务器的record_route动作首先会将消息发送给SIP服务器，SIP服务器会按照request url的地址，将ack发送给分机B。 ACK的路由不需要做数据库查询，ACK的request url一般是对端UAC的地址。在存在route头时，ACK会按照route字段去路由。
ACK丢失了会怎样？ 如果被叫在一定时间内没有收到ACK, 那么被叫会周期性的重发200OK。如果在超时的时候，还没有收到ACK, 就发发送BYE消息来挂断呼叫。很多呼叫在30秒自动挂断，往往就是因为丢失了ACK。
那么ACK为什么会丢失呢？可能有以下的原因，大部分原因和NAT有关！
SIP服务器没有做fix_nat_contact, 导致主叫可能不知道实际被叫的外网地址 ACK与媒体流的关系 并不是说被叫收到ACK后，媒体流才开始。往往在180或者183时，双方已经能够听到对方的声音了。</description>
    </item>
    
    <item>
      <title>rtp编码表</title>
      <link>https://wdd.js.org/opensips/ch4/codec-table/</link>
      <pubDate>Sat, 07 Dec 2019 09:10:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/codec-table/</guid>
      <description>v=0 o=WMSWMS 1562204406 1562204407 IN IP4 192.168.40.79 s=WMSWMS c=IN IP4 192.168.40.79 t=0 0 m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ptime:20 上面的SDP协议，我们只关注媒体编码部分，其中
m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 m字段audio说明是音频 31114是rtp的发送端口，一般rtp端口都是偶数，偶数后面的一个奇数端口是给rtcp端口的 0 8 9 101就是媒体编码，每个整数代表一个编码，其中96以下的是都是用IANA规定的，可以不用下面的rtpmap字段去指定，96以上的属于动态编码，需要用rtpmap去指定 上面是整个编码表，我们只需要记住几个就可以:
0 PCMU/8000 3 GSM/8000 8 PCMA/8000 9 G722/8000 18 G729/8000 102 DTMF/8000 a=rtpmap:101 telephone-event/8000a=fmtp:101 0-16上面的字段描述的是DTMP的支持。DTMF标准，所有SIP实体至少支持0-15的DTMF事件。
0-9是数字 10是* 11是# 12-15对应A,B,C,D 参考 https://www.</description>
    </item>
    
    <item>
      <title>opensips介绍</title>
      <link>https://wdd.js.org/opensips/ch3/about-opensips/</link>
      <pubDate>Tue, 19 Nov 2019 18:37:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/about-opensips/</guid>
      <description>
1. OpenSIPS架构 OpenSIPS主要有两部分构成，
core: 提供底层工具、接口、资源 module：模块是一些共享的库，在启动时按需加载。有些模块是用于在opensips脚本中提供功能，而有些模块是作为底层，为其他模块提供功能。 2. OpenSIP 核心 2.1. 传输层 传输层提供了对于各种协议的支持，如TCP、UDP、TLS、WebSocket
2.2. SIP工厂层 SIP工厂层提供了对SIP协议的解析和构建。OpenSIPS实现了一种懒解析功能，懒解析的效率非常高。
懒解析：懒解析就是只去解析SIP头，并不解析SIP头的字段内容。而是在需要读取头字段内容时，才去解析。所以可以理解为按需解析。有点类似于一些文件系统的写时复制功能。
**惰性应用：**有一点非常重要，当你通过脚本提供的函数去改变SIP消息时，所作出的改变并不是实时作用到SIP消息上，而是在先存起来，而是当所有的SIP消息处理完成后才会去应用这些改变。举例来说，你首先通过函数给SIP消息添加了某个头，然后你通过函数去获取这个头的时，发现这个头并不存在，但是SIP消息再发送出去后，又携带了你添加的这个头。
2.3. 路由脚本解析与执行 OpenSIPS在启动后，会将opensips.cfg解析并加载到内存中。一旦OpenSIPS正常运行了，opensips.cfg文件即使删了也不会影响到OpenSIPS的运行了。
但是OpenSIPS并不支持热脚本更新，如果你改了脚本，让让运行的OpenSIPS具有添加的功能，那么必须将OpensSIPS重启。
OpenSIPS的脚本有点类似于C或者Shell语言，如果你Shell写的很溜，OpenSIPS的脚本理解起来也会非常容易。
2.4. 内存与锁管理 出于性能考虑，OpenSIPS自己内部实现了内存和锁的管理，这部分在内容在脚本中是不可见的。
2.5. 脚本变量和脚本函数 OpenSIPS核心提供的脚本变量和函数比较有限，外围的模块提供和很多的变量和函数。这些变量和函数的存在，都是为了让你易于获取SIP消息的某些字段，或者对SIP消息进行修改。
2.6. SQL接口类 OpenSIPS 核心实现了接口的定义，但是并没有实现接口。接口的实现由外部的模块提供，这样做的函数可以使用不同的数据库。
2.7. MI管理接口 mi接口用来管理OpenSIPS, 可以实现以下功能
向OpenSIPS 发送数据 从OpenSIPS 获取数据 触发OpenSIPS 的内部行为 </description>
    </item>
    
    <item>
      <title>深入NAT网络</title>
      <link>https://wdd.js.org/opensips/ch1/deep-in-nat/</link>
      <pubDate>Tue, 05 Nov 2019 16:29:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/deep-in-nat/</guid>
      <description> NAT的产生原因是IPv4的地址不够用，网络中的部分主机只能公用一个外网IP。 NAT工作在网络层和传输层，主要是对IP地址和端口号的改变 NAT的优点 节约公网IP 安全性更好，所有流量都需要经过入口的防火墙 NAT的缺点 对于UPD应用不够友好 NAT 工作原理 内部的设备X, 经过NAT设备后，NAT设备会改写源IP和端口 NAT 类型 1. 全锥型 每个内部主机都有一个静态绑定的外部ip:port 任何主机发往NAT设备上特定ip:port的包，都会被转发给绑定的主机 这种方式的缺点很明显，黑客可以使用端口扫描工具，扫描出暴露的端口，然后通过这个端口攻击内部主机 在内部主机没有往外发送流量时，外部流量也能够进入内部主机 -
2. 限制锥形 NAT上的ip:port与内部主机是动态绑定的 如果内部主机没有向某个主机先发送过包，那么NAT会拒绝外部主机进入的流量 3. 端口限制型 端口限制型除了有限制锥型的要求外，还增加了端口的限制 4. 对称型 对称型最难穿透，因为每次交互NAT都会使用不同的端口号，所以内外网端口映射根本无法预测 NAT对比表格 NAT类型 收数据前是否需要先发送数据 是否能够预测下一次的NAT打开的端口对 是否限制包的目的ip:port 全锥形 否 是 否 限制锥形 是 是 仅限制IP 端口限制型 是 是 是 对称型 是 否 是 </description>
    </item>
    
    <item>
      <title>CSTA 呼叫模型简介</title>
      <link>https://wdd.js.org/opensips/ch1/csta-call-model/</link>
      <pubDate>Tue, 15 Oct 2019 21:43:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/csta-call-model/</guid>
      <description>1. 内容概要 CSTA 协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA 协议标准 2.1. 什么是 CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications) 基本的呼叫模型在 1992 建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等 CSTA 是一个应用层接口，用来监控呼叫，设备和网络 CSTA 创建了一个通讯程序的抽象层: CSTA 并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA 并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式 第三方呼叫控制 一方呼叫控制 CSTA 的设计目标是为了提高各种 CSTA 实现之间的移植性 规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段 1 (发布于 June ’92) 40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段 2 (发布于 Dec. ’94) 77 特性, 145 页 (服务定义) I/O &amp;amp; 语音单元服务, 更多呼叫控制服务 阶段 3 - CSTA Phase II Features &amp;amp; versit CTI Technology 发布于 Dec.</description>
    </item>
    
    <item>
      <title>UA应答模式的实现</title>
      <link>https://wdd.js.org/opensips/ch1/ua-answer-mode/</link>
      <pubDate>Thu, 26 Sep 2019 20:37:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/ua-answer-mode/</guid>
      <description>Notify 使用noify消息，通知分机应答，这个notify一般发送在分机回180响应之后
Answer-mode Answer-Mode一般有两个值 Auto: UA收到INVITE之后，立即回200OK，没有180的过程 Manual: UA收到INVITE之后，等待用户手工点击应答 通常Answer-Mode还会跟着require, 表示某个应答方式如果不被允许，应当回403 Forbidden 作为响应。
Answer-Mode: Auto;require 和Answer-mode头类似的有个SIP头叫做：Priv-Answer-Mode，这个功能和Answer-Mode类似，但是他有个特点。
如果UA设置了免打扰，Priv-Answer-Mode头会无视免打扰这个选项，强制让分机应答，这个头适合用于紧急呼叫。
结论 如果要实现分机的自动应答，显然Answer-Mode的应答速度回更快。但是对于依赖180响应的系统，可能要考虑这种没有180相应的情况。
要记住，在SIP消息里，对于UA来说，1xx的响应都是不必须的可以缺少的。</description>
    </item>
    
    <item>
      <title>opensips日志写入elasticsearch</title>
      <link>https://wdd.js.org/opensips/ch3/elk/</link>
      <pubDate>Thu, 19 Sep 2019 09:01:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/elk/</guid>
      <description>
构造json $json(body) := &amp;#34;{}&amp;#34;; $json(body/time) = $time(%F %T-0300); $json(body/sipRequest) = “INVITE”; $json(body/ipIntruder) = $si; $json(body/destNum) = $rU; $json(body/userAgent) = $ua; $json(body/country)=$var(city); $json(body/location)=$var(latlon); $json(body/ipHost) = $Ri; 使用async rest_post写数据 async好像存在于2.1版本及其以上， 异步的好处是不会阻止脚本的继续执行 async(rest_post(&amp;#34;http://user:password@w.x.y.z:9200/opensips/1&amp;#34;, &amp;#34;$json(body)&amp;#34;, &amp;#34;$var(ctype)&amp;#34;, &amp;#34;$var(ct)&amp;#34;, &amp;#34;$var(rcode)&amp;#34;),resume) </description>
    </item>
    
    <item>
      <title>回铃音</title>
      <link>https://wdd.js.org/opensips/ch2/xchqma/</link>
      <pubDate>Wed, 18 Sep 2019 09:53:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/xchqma/</guid>
      <description>
特点分析 回铃音有以下特点
回铃音是由运营商送给手机的，而不是由被叫送给主叫的。 回铃音的播放阶段是在被叫接听前播放，被叫一旦接听，回铃音则播放结束 回铃音一般是450Hz, 嘟一秒，停4秒，5秒一个周期 常见问题 听不到回铃音 【现象】打同一个号码，有些手机能听到回铃音，有些手机听不到回铃音【排查思路】
有些手机volte开启后，可能会导致无回铃音，所以可以关闭volte试试 被叫的运营商，主叫手机的运营商 参考资料 https://zh.wikipedia.org/wiki/%E5%9B%9E%E9%93%83%E9%9F%B3 https://baike.baidu.com/item/%E5%9B%9E%E9%93%83%E9%9F%B3/1014322 http://www.it9000.cn/tech/CTI/signal.html </description>
    </item>
    
    <item>
      <title>几种常用电话信号音的含义</title>
      <link>https://wdd.js.org/opensips/ch2/ox06wd/</link>
      <pubDate>Wed, 18 Sep 2019 09:10:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/ox06wd/</guid>
      <description>
几种常用电话信号音的含义 信号频率：（450±25）HZ：拨号音、回铃音、忙音、长途通知音、空号音（950±25）HZ：催挂音
拨号音 摘机后受话器中便有一种“嗡&amp;ndash;”的连续音，这种声音就是拨号音，它表示自动交换机或对方呼叫中心系统已经做好了接续准备，允许用户拨号
回铃音 拨完被叫号，若听到“嘟&amp;ndash;嘟&amp;ndash;”的断续音（响1s，断4s），便是回铃音，表示被叫话机正在响铃，可静候接话；如果振铃超过10余次，仍无人讲话，说明对方无人接电话，应放好手柄稍后再拨。
忙音 当主叫用户在拨号过程中或拨完被叫电话号码后，若听到“嘟、嘟、嘟……”的短促音（响0.35s，断0.35s），这就是忙音，表示线路已经被占满或被叫电话机正在使用
长途通知音 当主叫用户和被叫用户正在进行市内通话时，听到“嘟、嘟、嘟……”的短促音（响0.2s，断0.2s，响0.2s，间歇0.6s），这便是长途电话通知音，表示有长途电话插入，提醒主被叫用户双方尽快结束市内通话，准备接听长途电话。
空号音 当用户拨完号码后听到不等间隔断续信号音（重复3次0.1s响，0.1s断后，0.4s响0.4s断），这便是空号音，表示通知主叫用户所呼叫的被叫号码为空号或受限制的号码。
催挂音 如果用户听到连续信号音，响度变化为5级，由低级逐步升高，则是催挂音。通知久不挂机的用户迅速挂机。
参考 http://www.it9000.cn/tech/CTI/signal.html </description>
    </item>
    
    <item>
      <title>NAT解决方法</title>
      <link>https://wdd.js.org/opensips/ch1/fix-nat/</link>
      <pubDate>Tue, 17 Sep 2019 08:58:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/fix-nat/</guid>
      <description>解决信令的过程 NAT检测 使用rport解决Via 在初始化请求和响应中修改Contact头 处理来自NAT内部的注册请求 Ping客户端使NAT映射保持打开 处理序列化请求 实现NAT检测 nat_uac_test 使用函数 nat_uac_test
1 搜索Contact头存在于RFC 1918 中的地址 2 检测Via头中的received参数和源地址是否相同 4 最顶部的Via出现在RFC1918 / RFC6598地址中 8 搜索SDP头出现RFC1918 / RFC6598地址 16 测试源端口是否和Via头中的端口不同 32 比较Contact中的地址和源信令的地址 64 比较Contact中的端口和源信令的端口 上边的测试都是可以组合的，并且任何一个测试通过，则返回true。
例如下面的测试19，实际上是1+2+16三项测试的组合
nat_uac_test(&amp;#34;19&amp;#34;) 使用rport和receive参数标记Via头 从NAT内部出去的呼叫，往往可能不知道自己的出口IP和端口，只有远端的SIP服务器收到请求后，才能知道UAC的真是出口IP和端口。出口IP用received=x.x.x.x，出口端口用rport=xx。当有消息发到UAC时，应当发到received和rport所指定的地址和端口。
# 原始的Via Via: SIP/2.0/UDP 192.168.4.48:5062;branch=z9hG4bK523223793;rport # 经过opensips处理后的Via Via: SIP/2.0/UDP 192.168.4.48:5062;received=192.168.4.48;branch=z9hG4bK523223793;rport=5062 修复Contact头 Via头和Contact头是比较容易混淆的概念，但是两者的功能完全不同。Via头使用来导航183和200响应应该如何按照原路返回。Contact用来给序列化请求，例如BYE和UPDATE导航。如果Contact头不正确，可能会导致呼叫无法挂断。那么就需要用fix_nated_contact()函数去修复Contact头。另外，对于183和200的响应也需要去修复Contact头。
处理注册请求 RFC 1918 地址组 10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) 参考 http://www.rfcreader.com/#rfc1918 </description>
    </item>
    
    <item>
      <title>常见媒体流编码及其特点</title>
      <link>https://wdd.js.org/opensips/ch4/media-codec/</link>
      <pubDate>Fri, 13 Sep 2019 09:04:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/media-codec/</guid>
      <description> 编码 带宽 MOS 环境 特点 说明 G.711 64 kbps 4.45 LAN/WAN 语音质量高，适合对接网关 G.711实际上就是PCM, 是最基本的编码方式。PCM又分为两类PCMA(g711a), PCMU(g711u)。中国使用的是PCMA G.729 8 kbps 4.04 WAN 带宽占用率很小，同时能保证不错的语音质量 分为G729a和G729b两种，G729之所以带宽占用是G711的1/8, 是因为G729的压缩算法不同。G729传输的不是真正的语音，而是语音压缩后的结果。G729的编解码是由专利的，也就说不免费。 G.722 64 kbps 4.5 LAN 语音质量高 HD hd语音 GSM 13.3 kbps 3.01 iLBA 13.3 15.2 抗丢包 OPUS 6-510 kbps - INTERNET OPUS的带宽范围跨度很广，适合语音和视屏 MOS值，Mean Opinion Score，用来定义语音质量。满分为5分，最低1分。
MOS 质量 5 极好的 4 不错的 3 还行吧 2 中等差 1 最差 通常的打包是20ms一个包，那么一秒就会传输1000/20=50个包。如果采样评率是8000Hz, 那么每个包的会携带 8000/50=160个采样数据。在PCMA或者PCMU中，每个采样数据占用1字节。因此20ms的一个包就携带160字节的数据。
在RTP包协议中，160字节还要加上12个自己的RTP头。 在fs上可以使用下面的命令查看fs支持的编码。
show codec </description>
    </item>
    
    <item>
      <title>centos7 安装opensips</title>
      <link>https://wdd.js.org/opensips/ch3/centos-install/</link>
      <pubDate>Thu, 05 Sep 2019 12:09:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/centos-install/</guid>
      <description>
安装依赖 yum update &amp;amp;&amp;amp; yum install epel-release yum install openssl-devel mariadb-devel libmicrohttpd-devel \ libcurl-devel libconfuse-devel ncurses-devel 编译 下面的脚本，默认将opensips安装在/usr/local/etc/目录下
&amp;gt; cd opensips-2.4.6 # 编译 &amp;gt; make all -j4 include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; # 安装 &amp;gt; make install include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; 如果想要指定安装位置，可以使用prefix参数指定，例如指定安装在/usr/aaa目录
&amp;gt; cd opensips-2.4.6 # 编译 &amp;gt; make all -j4 prefix=/usr/aaa include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; # 安装 &amp;gt; make install prefix=/usr/aaa include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; </description>
    </item>
    
    <item>
      <title>模块缓存策略与reload方法</title>
      <link>https://wdd.js.org/opensips/ch3/cache-reload/</link>
      <pubDate>Tue, 20 Aug 2019 09:11:21 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/cache-reload/</guid>
      <description>
常见的问题 有时候如果你直接在数据库中改动某些值，但是opensips并没有按照预设的值去执行，那么你就要尝试使用mi命令去reload相关模块。
有缓存模块 opensips在启动时，会将某些模块所使用的表一次性全部加载到数据库，状态变化时，再回写到数据库。有一下模块列表：
dispather load_balancer carrierroute dialplan &amp;hellip; 判断一个模块是否是一次性加载到内存的，有个简便方法，看这个模块是否提供类似于 xx_reload的mi接口，有reload的mi接口，就说明这个模块是使用一次性读取，变化回写的方式读写数据库。
将模块一次性加载到内存的好处时不用每次都查数据库，运行速度会大大提升。
以dispather为例子，opensips在启动时会从数据库总加载一系列的目标到内存中，然后按照设定值，周期性的向目标发送options包，如果目标挂掉，三次未响应，opensips将会将该目标的状态设置为非0值，表示该地址不可用，同时将该状态回写到数据库。
无缓存模块 无缓存的模块每次都会向数据库查询数据。常见的模块有alias_db，该模块的说明
ALIAS_DB module can be used as an alternative for user aliases via usrloc. The main feature is that it does not store all adjacent data as for user location and always uses database for search (no memory caching).
ALIAS_DB一般用于呼入时接入号的查询，在多租户的情况下，如果大多数租户都是使用呼入的场景，那么ALIAS_DB模块可能会是一个性能瓶颈，建议将该模块使用一些内存数据库替代。
从浏览器reload模块 opensips在加载了httpd和mi_http模块之后，可以在opensips主机的8888端口访问到管理页面，具体地址如：http://opensips_host:8888/mi
这个页面可以看到opensips所加载的模块，然后我们点击carrierroute, 可以看到该模块所支持的管理命令列表，如下图左侧列表所示，其中cr_reload_routes就是一个管理命令。
然后我们点击cr_reload_routes连接，跳转到下图所示页面。参数可以不用填写，直接点击submit就可以。正常情况下回返回 200 : OK，就说明reload模块成功。
使用curl命令reload模块 如果因为某些原因，无法访问web界面，那么可以使用curl等http命令行工具执行curl命令，例如
curl http://192.168.40.98:8888/mi/carrierroute/cr_reload_routes?arg= </description>
    </item>
    
    <item>
      <title>SIP注册调研</title>
      <link>https://wdd.js.org/opensips/ch1/sip-register/</link>
      <pubDate>Mon, 19 Aug 2019 21:30:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-register/</guid>
      <description>sequenceDiagram autonumber participant a as 192.168.0.123:55647 participant b as 1.2.3.4:5060 participant c as 172.10.10.3:49543 a-&gt;&gt;b: register cseq=1, callId=1 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=2, callid=1 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=3, callId=1 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=4, callid=1 b--&gt;&gt;a: 200 c-&gt;&gt;b: register cseq=5, callid=1 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=6, callid=1 b--&gt;&gt;c: 500 Service Unavailable c-&gt;&gt;b: register cseq=7, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=8, callid=2 b--&gt;&gt;c: 200 c-&gt;&gt;b: register cseq=9, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=10, callid=2 b--&gt;&gt;c: 200 c-&gt;&gt;b: register cseq=11, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=12, callid=2 b--&gt;&gt;c: 500 Service Unavailable a-&gt;&gt;b: register cseq=13, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=14, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=15, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=16, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=17, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=18, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=19, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=20, callid=3 b--&gt;&gt;a: 200 服务端设置的过期时间是120s 客户端每隔115s注册一次, callid和之前的保持不变 当网络变了之后，由于ip地址改变，客户端的在115秒注册，此时服务端还未超时，所以给客户端响应报错500 客户端在等了8秒之后，等待服务端超时，然后再次注册，再次注册时，callid改变 因为服务端已经超时，所以能够注册成功 需要注意的是，在一个注册周期内，客户端的注册信息包括IP、端口、协议、CallID都不能变，一旦改变了。如果服务端的记录还没有失效，新的注册就会失败。</description>
    </item>
    
    <item>
      <title>核心MI命令</title>
      <link>https://wdd.js.org/opensips/ch3/core-mi/</link>
      <pubDate>Thu, 18 Jul 2019 13:54:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/core-mi/</guid>
      <description>在所有的fifo命令中，which命令比较重要，因为它可以列出所有的其他命令。
有些mi命令是存在于各个模块之中，所以加载的模块不通。opensipsctl fifo which输出的命令也不通。
获取执行参数 opensipsctl fifo arg 列出TCP连接数量 opensipsctl fifo list_tcp_conns 查看进程信息 opensipsctl fifo ps 查看opensips运行时长 opensipsctl fifo uptime 查看所有支持的指令 opensipsctl fifo which 获取统计数据 opensipsctl fifo get_statistics rcv_requests 重置统计数据 opensipsctl fifo get_statistics received_replies get_statistics reset_statistics uptime version pwd arg which ps kill debug cache_store cache_fetch cache_remove event_subscribe events_list subscribers_list list_tcp_conns help list_blacklists regex_reload t_uac_dlg t_uac_cancel t_hash t_reply ul_rm ul_rm_contact ul_dump ul_flush ul_add ul_show_contact ul_sync domain_reload domain_dump dlg_list dlg_list_ctx dlg_end_dlg dlg_db_sync dlg_restore_db profile_get_size profile_list_dlgs profile_get_values list_all_profiles nh_enable_ping cr_reload_routes cr_dump_routes cr_replace_host cr_deactivate_host cr_activate_host cr_add_host cr_delete_host dp_reload dp_translate address_reload address_dump subnet_dump allow_uri dr_reload dr_gw_status dr_carrier_status lb_reload lb_resize lb_list lb_status httpd_list_root_path sip_trace rtpengine_enable rtpengine_show rtpengine_reload teardown </description>
    </item>
    
    <item>
      <title>from vs to vs request-url之间的关系</title>
      <link>https://wdd.js.org/opensips/ch1/from-to-request-url/</link>
      <pubDate>Thu, 11 Jul 2019 07:38:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/from-to-request-url/</guid>
      <description>from字段用来标记请求的发起者ID to字段用来标记请求接受者的ID to字段并不能用于路由，request-url可以用来路由 一般情况下，sip消息再传输过程中，from和to字段都不会改，而request-url很可能会因为路由而改变 对于最初的请求，除了注册请求之外，request-url和to字段中的url一致 from字段：The From header field is a required header field that indicates the originator of the request. It is one of two addresses used to identify the dialog. The From header field contains a URI, but it may not contain the transport, maddr, or ttl URI parameters. A From header field may contain a tag used to identify a particular call. A From header field may contain a display name, in which case the URI is enclosed in &amp;lt; &amp;gt;.</description>
    </item>
    
    <item>
      <title>opensips监控</title>
      <link>https://wdd.js.org/opensips/ch3/opensips-monitor/</link>
      <pubDate>Tue, 02 Jul 2019 22:09:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/opensips-monitor/</guid>
      <description>**opensipsctl fifo get_statistics all **命令可以获取所有统计数据，在所有统计数据中，我们只关心内存，事务和回话的数量。然后将数据使用curl工具写入到influxdb中。
opensipsctl fifo reset_statistics all 重置统计数据
常用指令 命令 描述 opensipsctl fifo which 显示所有可用命令 opensipsctl fifo ps 显示所有进程 opensipsctl fifo get_statistics all 获取所有统计信息 opensipsctl fifo get_statistics core: 获取内核统计信息 opensipsctl fifo get_statistics net: 获取网路统计信息 opensipsctl fifo get_statistics pkmem: 获取私有内存相关信息 opensipsctl fifo get_statistics tm: 获取事务模块统计信息 opensipsctl fifo get_statistics sl: 获取sl模块统计信息 opensipsctl fifo get statistics shmem: 获取共享内存相关信息 opensipsctl fifo get statistics usrloc: 获取 opensipsctl fifo get statistics registrar: 获取注册统计信息 opensipsctl fifo get statistics uri: 获取uri统计信息 opensipsctl fifo get statistics load: 获取负载信息 opensipsctl fifo reset_statistics all 重置所有统计信息 shmem:total_size:: 6467616768 shmem:used_size:: 4578374040 shmem:real_used_size:: 4728909408 shmem:max_used_size:: 4728909408 shmem:free_size:: 1738707360 shmem:fragments:: 1 # 事务 tm:UAS_transactions:: 296337 tm:UAC_transactions:: 30 tm:2xx_transactions:: 174737 tm:3xx_transactions:: 0 tm:4xx_transactions:: 110571 tm:5xx_transactions:: 2170 tm:6xx_transactions:: 0 tm:inuse_transactions:: 289651 dialog:active_dialogs:: 156 dialog:early_dialogs:: 680 dialog:processed_dialogs:: 104061 dialog:expired_dialogs:: 964 dialog:failed_dialogs:: 78457 dialog:create_sent:: 0 dialog:update_sent:: 0 dialog:delete_sent:: 0 dialog:create_recv:: 0 dialog:update_recv:: 0 dialog:delete_recv:: 0 CONF_DB_URL=&amp;#34;ip:port&amp;#34; # influxdb地址 CONF_DB_NAME=&amp;#34;dbname&amp;#34; # influxdb数据库名 CONF_OPENSIPS_ROLE=&amp;#34;a&amp;#34; # 角色，随便写个字符串 PATH=&amp;#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin&amp;#34; LOCAL_IP=`ip route get 8.</description>
    </item>
    
    <item>
      <title>opensips centos7 安装与升级</title>
      <link>https://wdd.js.org/opensips/ch3/centos7-2.4/</link>
      <pubDate>Tue, 02 Jul 2019 19:42:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/centos7-2.4/</guid>
      <description>环境声明 系统 centos7 已经安装opensips 2.2 需要升级目标 opensips 2.4.6 要求：当前系统上没有部署mysql服务端程序 升级步骤 升级分为两步
opensips 应用升级，包括源码的下载，编译等等 opensips 数据库升级，使用opensipsdbctl工具迁移老的数据 Edge: opensips应用升级 升级过程以Makefile交付，可以先新建一个空的目录，如 /root/opensips-update/
# file: /root/opensips-update/Makefile VERSION=2.4.6 download: wget https://opensips.org/pub/opensips/$(VERSION)/opensips-$(VERSION).tar.gz; tar -zxvf opensips-$(VERSION).tar.gz; build: cd opensips-$(VERSION); make all -j4 include_modules=&amp;#34;db_mysql httpd db_http siprec&amp;#34;; # siprec是可选的 make install include_modules=&amp;#34;db_mysql httpd db_http siprec&amp;#34;; # siprec是可选的 新建空目录/root/opensips-update/ 在新目录中创建名为 Makefile的文件, 内容如上面所示 执行 make download 执行 make build Core: opensips应用升级 make all -j4 include_modules=&amp;#34;db_mysql httpd&amp;#34; make install include_modules=&amp;#34;db_mysql httpd&amp;#34; 可能遇到的报错以及解决方案 主要的问题可能是某些包冲突，或者某些库没有安装依赖。在解决问题后，需要重新编译。</description>
    </item>
    
    <item>
      <title>设置独立日志文件</title>
      <link>https://wdd.js.org/opensips/ch3/log/</link>
      <pubDate>Sun, 16 Jun 2019 10:33:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/log/</guid>
      <description>设置独立日志 默认情况下，opensips的日志会写在系统日志文件/var/log/message中，为了避免难以查阅日志，我们可以将opensips的日志写到单独的日志文件中。
环境说明
debian buster
这个需要做两步。
第一步，配置opensips.cfg文件
log_facility=LOG_LOCAL0 第二步, 创建日志配置文件
echo &amp;#34;local0.* -/var/log/opensips.log&amp;#34; &amp;gt; /etc/rsyslog.d/opensips.conf 第三步，创建日志文件
touch /var/log/opensips.log 第四步，重启rsyslog和opensips
service rsyslog restart opensipsctl restart 第五步，验证结果
tail /var/log/opensips.log 日志回滚 为了避免日志文件占用过多磁盘空间，需要做日志回滚。
安装logrotate apt install logrotate -y 日志回滚配置文件 /etc/logrotate.d/opensips
/var/log/opensips.log { noolddir size 10M rotate 100 copytruncate compress sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true /bin/kill -HUP `cat /var/run/rsyslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true endscript } 配置定时任务</description>
    </item>
    
    <item>
      <title>opensips管理命令</title>
      <link>https://wdd.js.org/opensips/ch3/opensipsctl/</link>
      <pubDate>Thu, 13 Jun 2019 22:03:19 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/opensipsctl/</guid>
      <description>可以使用一下命令查找opensips的相关文件夹
find / -name opensips -type d 一般来说，重要的是opensips.cfg文件，这个文件一般位于/usr/local/etc/opensips/或者/usr/etc/opensips中。主要还是要看安装时选择的默认路径。
其中1.x版本的配置文件一般位于/usr/etc/opensips目录中，2.x版本的配置一般位于/usr/local/etc/opensips目录中。
下面主要讲解几个命令。
配置文件校验 校验opensips.cfg脚本是否合法, 如果有问题，会提示那行代码有问题，但是报错位置好像一直不准确。很多时候可能是忘记写分好了。
opensips -C opensips.cfg 启动关闭与重启 使用opensipsctl命令做数据库操作前，需要先配置opensipsctlrc文件
opensips start|stop|restart opensipsctl start|stop|restart 资源创建 opensipsdbctl create # 创建数据库 opensipsctl domain add abc.cc #创建域名 opensipsctl add 1001@test.cc 12346 # 新增用户 opensipsctl rm 1001@test.cc # 删除用户 opensipsctl passwdd 1001@test.cc 09879 # 修改密码 opensipsctl -h 显示所有可用命令
/usr/local/sbin/opensipsctl $Revision: 4448 $ Existing commands: -- command &amp;#39;start|stop|restart|trap&amp;#39; trap ............................... trap with gdb OpenSIPS processes restart ............................ restart OpenSIPS start .</description>
    </item>
    
    <item>
      <title>debian jessie opensips 2.4.7 安装</title>
      <link>https://wdd.js.org/opensips/ch3/install-opensips/</link>
      <pubDate>Thu, 13 Jun 2019 21:53:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/install-opensips/</guid>
      <description>
1. 安装依赖 apt-get update -qq &amp;amp;&amp;amp; apt-get install -y build-essential net-tools \ bison flex m4 pkg-config libncurses5-dev rsyslog libmysqlclient-dev \ libssl-dev mysql-client libmicrohttpd-dev libcurl4-openssl-dev uuid-dev \ libpcre3-dev libconfuse-dev libxml2-dev libhiredis-dev wget lsof 2. 编译 下载opensips-2.4.7的源码，然后解压。
include_moduls可以按需指定，你可以只写你需要的模块。
cd /usr/local/src/opensips-2.4.7 make all -j4 include_modules=&amp;#34;db_mysql httpd db_http siprec regex rest_client carrierroute dialplan b2b_logic cachedb_redis proto_tls proto_wss tls_mgm&amp;#34; make install include_modules=&amp;#34;db_mysql httpd db_http siprec regex rest_client carrierroute dialplan b2b_logic cachedb_redis proto_tls proto_wss tls_mgm&amp;#34; </description>
    </item>
    
  </channel>
</rss>
