<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OpenSIPS2.4.X 中文实战系列 on 洞香春</title>
    <link>https://wdd.js.org/opensips/</link>
    <description>Recent content in OpenSIPS2.4.X 中文实战系列 on 洞香春</description>
    <image>
      <title>洞香春</title>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 18 Nov 2024 19:58:38 +0800</lastBuildDate><atom:link href="https://wdd.js.org/opensips/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AXB的玩法说明</title>
      <link>https://wdd.js.org/opensips/ch2/axb/</link>
      <pubDate>Mon, 18 Nov 2024 19:58:38 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/axb/</guid>
      <description></description>
    </item>
    
    <item>
      <title>模块传参的重构</title>
      <link>https://wdd.js.org/opensips/3x/module-args/</link>
      <pubDate>Sat, 03 Dec 2022 21:01:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/3x/module-args/</guid>
      <description>写过opensips脚本的同学，往往对函数的传参感到困惑。
例如：
ds_select_dst()可以接受整数或者值为正数的变量作为第一个参数，但是nat_uac_test()的第一个参数就只能是整数，而不能是变量 为什么rl_check()可以接受格式化的字符串，而save()只能接受字符串。 为什么ds_select_dst(&amp;quot;1&amp;quot;, &amp;quot;4&amp;quot;) 作为整数也要加上双引号？ 为什么变量要加上双引号？ ds_select_dst(&amp;quot;$var(aa)&amp;quot;, &amp;quot;4&amp;quot;) 为什么t_on_branch(&amp;quot;1&amp;quot;)路由的钩子要加上双引号？ 为什么route(go_to_something);这里又不需要加上引号？ ds_select_dst(&amp;#34;1&amp;#34;, &amp;#34;0&amp;#34;); $var(aa)=1; ds_select_dst(&amp;#34;$var(aa)&amp;#34;, &amp;#34;0&amp;#34;); rl_check(&amp;#34;gw_$ru&amp;#34;, &amp;#34;$var(limit)&amp;#34;); #格式化的gw_$ru save(&amp;#34;location&amp;#34;); #单纯的字符串作为参数 从3.0开始，传参可以更加自然。
整数可以直接传参，不用加双引号 do_something(1, 1); 输入或者输出的$var(), 不用加双引号，加了反而会报错 do_something($var(a), $var(b)); 格式化字符串，需要加双引号 do_something(1, &amp;#34;$var(bb)_$var(b)&amp;#34;); 参考 https://blog.opensips.org/2019/11/05/the-module-function-interface-rework-in-opensips-3-0/ https://www.opensips.org/Documentation/Script-Syntax-3-0# </description>
    </item>
    
    <item>
      <title>Pdf学习资料</title>
      <link>https://wdd.js.org/opensips/pdf/</link>
      <pubDate>Sat, 03 Dec 2022 16:02:18 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/pdf/</guid>
      <description> TelNYX.pdf OpenSIPS 2.3 mediasoup Cutting Edge WebRTC Video COnferencing FreeSWITCH-driven routing in OpenSIPS Voicenter: Contact center on Steroids Vlad_Paiu-Distributed_OpenSIPS_Systems_Cluecon14.pdf Vlad_Paiu-OpenSIPS_Summit_Austin_2015-Async.pdf Ionut_Ionita-OpenSIPS_Summit2017-Capturing_beyond_SIP FLAVIO_GONCALVES-Fraud_in_VoIP_Today.pdf Alexandr_Dubovikov-OpenSIPS_Summit2017-RTC_Threat_Intelligence_Exchange.pdf OpenSIPS_LoadBalancing.pdf Vlad_Paiu-OpenSIPS_Summit_2104-OpenSIPS_End_User_Services.pdf Razvan_Crainea-OpenSIPS_Summit2017-From_SIPI_Trunks_to_End_Users.pdf Razvan_Crainea-OpenSIPS_Summit-Scaling_Asterisk.pdf Vlad_Paiu-OpenSIPS_Summit-Service_Enabling_for_Asterisk.pdf Jonas_Borjesson-OpenSIPS_Summit_Austin_2015.pdf Michele_Pinasi-OpenSIPS_Summit2017-How_we_did_VoIP.pdf Bogdan_Iancu-OpenSIPS_Summit_Keynotes.pdf Giovanni_Maruzselli-OpenSIPS_Summit2017-Scaling_FreeSWITCHes.pdf Maksym_Sobolyev-OpenSIPS_Summit2017-Sippy_Labs_update.pdf docker-cluster.pdf voip malware attack tool .pdf Bogdan_Iancu-OpenSIPS_Summit-OpenSIPS_2_1.pdf Pete_Kelly-OpenSIPS_Workshop_Chicago_2015-Calling_Cards_B2BUA.pdf Bogdan_Iancu-OpenSIPS_Summit-keynotes.pdf Alex_Goulis-Opensips_CNAME.pdf OpenSIPS_2.0_Framework.pdf Norman_Brandinger-OpenSIPS_Summit_2014-Advanced_SIP_Routing_with_OpenSIPS_modules.pdf </description>
    </item>
    
    <item>
      <title>SIP相关RFC协议</title>
      <link>https://wdd.js.org/opensips/ch1/sip-rfcs/</link>
      <pubDate>Sun, 30 Oct 2022 21:11:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-rfcs/</guid>
      <description>RFC 名称 https://tools.ietf.org/html/rfc3261 SIP: Session Initiation Protocol https://tools.ietf.org/html/rfc3665 Session Initiation Protocol (SIP) Basic Call Flow Examples https://tools.ietf.org/html/rfc6141 Re-INVITE and Target-Refresh Request Handling in the Session Initiation Protocol (SIP) https://tools.ietf.org/html/rfc4566 SDP: Session Description Protocol https://tools.ietf.org/html/rfc4028 Session Timers in the Session Initiation Protocol (SIP) https://tools.ietf.org/html/rfc1889 RTP: A Transport Protocol for Real-Time Applications https://tools.ietf.org/html/rfc2326 Real Time Streaming Protocol (RTSP) https://tools.ietf.org/html/rfc2327 SDP: Session Description Protocol https://tools.ietf.org/html/rfc3015 Megaco Protocol Version 1.0 https://tools.ietf.org/html/rfc1918 Address Allocation for Private Internets https://tools.</description>
    </item>
    
    <item>
      <title>STUN协议笔记</title>
      <link>https://wdd.js.org/opensips/ch1/stun-notes/</link>
      <pubDate>Sun, 30 Oct 2022 20:22:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/stun-notes/</guid>
      <description>title: &amp;ldquo;STUN协议笔记&amp;rdquo; date: &amp;ldquo;2022-01-06 17:54:10&amp;rdquo; draft: false STUN是Simple Traversal of User Datagram Protocol (UDP) through Network Address Translators (NAT’s)的缩写 传输层底层用的是UDP 主要用来NAT穿透 主要用来解决voip领域的单方向通话(one-way)的问题 目的是让NAT后面的设备能发现自己的公网IP以及NAT的类型 让外部设备能够找到合适的端口和内部设备通信 刷新NAT绑定，类似keep-alive机制。否则端口映射可能因为超时被释放 STUN是cs架构的协议 客户端端192.168.1.3，使用5060端口，发送stun请求到 64.25.58.65， 经过了192.168.1.1的网关之后 网关将源ip改为212.128.56.125， 端口改为15050 stun服务器将请求发送到 网关的外网端口15050，然后网关将请求转发给192.168.1.3:5060 stun message type which typically is one of the below: - 0x0001 : Binding Request - 0x0101 : Binding Response
0x0111 : Binding Error Response 0x0002 : Shared Secret Request 0x0102 : Shared Secret Response 0x0112 : Shared Secret Error Response **0x0001: MAPPED-ADDRESS - **This attribute contains an IP address and port.</description>
    </item>
    
    <item>
      <title>SIP信令和媒体都绕不开的NAT问题</title>
      <link>https://wdd.js.org/opensips/ch1/nat-sip-rtp/</link>
      <pubDate>Sun, 30 Oct 2022 19:37:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/nat-sip-rtp/</guid>
      <description>什么是NAT? NAT(网络地址转换)， 具体可以参考百科 https://baike.baidu.com/item/nat/320024。
NAT是用来解决IPv4的地址不够的问题。
例如上图，内网的主机，在访问外网时，源192.168的网址，会被改写成1.2.3.4。所以在server端看来，请求是从1.2.3.4发送过来的。
NAT一般会改写请求的源IP包的源IP地址，也可能会改写tcp或者udp的源端口地址。
NAT地址范围 互联网地址分配机构保留了三类网址只能由于私有地址，这些地址只能由于NAT内部，不能用于公网。
如果在sip消息中，Contact头中的地址是192.168开头，聪明的服务器应该知道，这个请求来自NAT内部。
10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) NAT 工作原理 NAT内部流量流出时，源IP和源端口都被改写，目标地址和端口不会改写。源ip和端口与被改写后的ip和端口存在一段时间的映射关系，当响应回来时，根据这个映射关系，NAT设备知道这个包应该发给内网的哪个设备。
NAT分类 静态NAT: 每个内部主机都永久映射一个外部公网IP 动态NAT: 每个内部主机都动态映射一个外部公网IP 网络地址端口转换: 内部主机映射到外部不同端口上 由于静态NAT和动态NAT并不能节省公网IP, 常用的都是网络地址端口转换，即NAPT。
NAPT 网络地址端口转换分类 全锥型NAT 限制锥型NAT： 限制主机 端口限制NAT：限制主机和端口 Full Cone NAT 全锥型NAT 打洞过程
来自nat内部ip1:port1地址在经过路由器时，路由器会打洞ip1&amp;rsquo;:port1&#39; 任何服务器只要把包发到ip1&amp;rsquo;:port1&amp;rsquo;，路由器都会把这个包发到ip1:port1。也就是说，即使刚开始打洞的包是发给server1的，如果server2知道这个洞的信息，那么server2也可以通过这洞，将消息发给ip1:port1 Restricted Cone NAT 限制锥型NAT 限制锥型打洞过程和全锥型差不多，只不过增加了限制。
如果内部主机是把包发到server1的，即使server2知道打洞的信息，它发的包也不会被转给内部主机。 Port Restricted Cone NAT 端口限制NAT 端口限制NAT要比上述两种NAT的限制更为严格
内部主机如果将消息发到server1的5080端口，那么这个端口只允许server1的5080端口发消息回来 server1的其他端口发消息到这个洞都会被拒绝 SIP信令NAT穿越 NAT内部消息发到fs时，会携带如下信息。假如fs对NAT一无所知，如果后续有呼叫，fs是无法将消息发到192.168.0.102的，因为192.168.0.102是内网地址。
但是fs足够聪明，它会从分析包的源ip和源端口，从而正确的将sip消息送到NAT设备上。
Via: SIP/2.0/UDP 192.168.1.160:11266;branch=z9hG4bK-d8754z-1f2cd509;rport Contact: &amp;lt;sip:flavio@192.</description>
    </item>
    
    <item>
      <title>奥科网关 Rtp Broken Connection</title>
      <link>https://wdd.js.org/opensips/ch7/rtp-broken-connection/</link>
      <pubDate>Sat, 29 Oct 2022 10:11:59 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/rtp-broken-connection/</guid>
      <description>通话10多秒后，fs对两个call leg发送bye消息。
Bye消息给的原因是 Reason: Q.850 ;cause=31 ;text=”local, RTP Broken Connection”
在通话的前10多秒，SIP信令正常，双方也能听到对方的声音。
首先排查了下fs日志，没发现什么异常。然后根据这个报错内容，在网上搜了下。
发现了这篇文章 https://www.wavecoreit.com/blog/serverconfig/call-drop-transfer-rtp-broken-connection/
这篇文章给出的解决办法是通过配置了奥科AudioCodes网关来解决的。
然后咨询了下客户，证实他们用的也是奥科网关。所以就参考教程，配制了一下。
主要是在两个地方进行配置
Click Setup -&amp;gt; Signaling&amp;amp;Media -&amp;gt; Expand Coders &amp;amp; Profiles -&amp;gt; Click IP Profiles -&amp;gt; Edityour SFB Profile -&amp;gt; Broken Connection Mode-&amp;gt; Select Ignore -&amp;gt; Click Apply
Expand SIP Definitions -&amp;gt; Click SIP Definitions General Settings -&amp;gt; Broken Connection Mode -&amp;gt; Select Ignore -&amp;gt; Click Apply -&amp;gt; Click Save
这两个地方，都是配置Broken Connection Mode，选择ignore来设置的。
关于RTP的connection mode，有时间再研究下。</description>
    </item>
    
    <item>
      <title>utimer task &lt;tm-utimer&gt; already scheduled</title>
      <link>https://wdd.js.org/opensips/ch1/utime-task-scheduled/</link>
      <pubDate>Tue, 25 Oct 2022 12:06:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/utime-task-scheduled/</guid>
      <description>可能和avp_db_query有关 https://opensips.org/pipermail/users/2018-October/040157.html What we found is that the warning go away if we comment out the single avp_db_query that is being used in our config.
_ The avp_db_query is not executed at the start, but only when specific header is present. Yet the fooding start immediately after opensips start. The mere presence of the avp_db_query function in config without execution is enough to have the issue._
可能和openssl库有关 https://github.com/OpenSIPS/opensips/issues/1771#issuecomment-517744489 ere are your results.</description>
    </item>
    
    <item>
      <title>SIP和SDP的关系</title>
      <link>https://wdd.js.org/opensips/ch1/sip-with-sdp/</link>
      <pubDate>Sat, 03 Sep 2022 20:36:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-with-sdp/</guid>
      <description>1. 什么是SDP? SDP是Session Description Protocol的缩写，翻译过来就是会话描述协议，这个协议通常存储各种和媒体相关的信息，例如支持哪些媒体编码, 媒体端口是多少？媒体IP地址是多少之类的。
SDP一般作为SIP消息的body部分。如下所示
INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 Max-Forwards: 70 From: Alice &amp;lt;sip:alice@atlanta.example.com&amp;gt;;tag=9fxced76sl To: Bob &amp;lt;sip:bob@biloxi.example.com&amp;gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: &amp;lt;sip:alice@client.atlanta.example.com;transport=tcp&amp;gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 刚开始我一直认为某些sip消息一定带有sdp，例如invite消息。某些sip请求一定没有携带sdp。
实际上sip消息和sdp并没有硬性的附属关系。sip是用来传输信令的，sdp是用来描述媒体流信息的。
如果信令不需要携带媒体流信息，就可以不用携带sdp。
一般情况下，invite请求都会带有sdp信息，但是某些时候也会没有。例如3PCC(third party call control), 第三方呼叫控制，是指由第三方负责协商媒体信息。
常见的一个场景
2. SDP字段介绍 2.1. v= 版本号 当前sdp的版本号是0，所以常见的都是v=0
2.2. o= 发起者id o=的格式</description>
    </item>
    
    <item>
      <title>SIP协议拾遗补缺</title>
      <link>https://wdd.js.org/opensips/ch1/sip-notes/</link>
      <pubDate>Sat, 03 Sep 2022 15:54:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-notes/</guid>
      <description>1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11.</description>
    </item>
    
    <item>
      <title>Trunk Pbx Gateway</title>
      <link>https://wdd.js.org/opensips/ch1/trunk-pbx-gateway/</link>
      <pubDate>Sat, 03 Sep 2022 15:24:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/trunk-pbx-gateway/</guid>
      <description>传统中继 sip trunk中继 安全可靠：SIP Trunk设备和ITSP之间只需建立唯一的、安全的、具有QoS保证的SIP Trunk链路。通过该链路来承载企业的多路并发呼叫，运营商只需对该链路进行鉴权，不再对承载于该链路上的每一路SIP呼叫进行鉴权。 节约硬件成本：企业内部通信由企业IP-PBX负责。企业所有外出通信都通过SIP Trunk交由ITSP，再由ITSP中的设备发送到PSTN网络，企业不再需要维护原有的传统PSTN中继链路，节省了硬件和维护成本。 节约话费成本：企业可以通过设置目的地址任意选择并连接到多个ITSP，充分利用遍布全球各地的ITSP，节省通话费用。 功能强大：部署SIP Trunk设备后，全网可以使用SIP协议，可以更好的支持语音、会议、即时消息等IP通信业务。 处理信令和媒体：SIP Trunk设备不同于SIP代理服务器。SIP Trunk设备接收到用户的呼叫请求后，会代表用户向ITSP发起新呼叫请求。在转发过程中，SIP Trunk设备不但要对信令消息进行中继转发，对RTP媒体消息也需要进行中继转发。在整个过程中，SIP Trunk设备两端的设备（企业内部和企业外部设备）均认为和其交互的是SIP Trunk设备本身。 参考 http://www.h3c.com/cn/d_201009/688762_30003_0.htm https://getvoip.com/blog/2013/01/24/differences-between-sip-trunking-and-hosted-pbx/ https://www.onsip.com/blog/hosted-pbx-vs-sip-trunking https://baike.baidu.com/item/sip%20trunk/1499860 </description>
    </item>
    
    <item>
      <title>Path头简史</title>
      <link>https://wdd.js.org/opensips/ch1/sip-path/</link>
      <pubDate>Sat, 03 Sep 2022 14:51:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-path/</guid>
      <description>RFC3261并没有介绍关于Path头的定义，因为这个头是在RFC3327中定义的，Path头作为一个SIP的扩展头。
RFC3327的标题是：Session Initiation Protocol (SIP) Extension Header Field for Registering Non-Adjacent Contacts。
从这个标题可以看出，Path头是作为Register请求的一个消息头，一般这个头只在注册消息上才有。
这个头的格式如下。
Path: &amp;lt;sip:P1.EXAMPLEVISITED.COM;lr&amp;gt; 从功能上说，Path头和record-route头的功能非常相似，但是也不同。
看下面的一个场景，uac通过p1和p2, 将注册请求发送到uas, 在某一时刻，uac作为被叫，INVITE请求要从uas发送到uac, 这时候，INVITE请求应该怎么走？
假如我们希望INVITE请求要经过p2,p2,然后再发送到uac, Path头的作用就是这个。
注册请求经过P1时，P1在注册消息上加上p1地址的path头 注册请求经过P2时，P2在注册消息上加上p2地址的path头 注册请求到达uas时，uas从Contact头上获取到uac的地址信息，然后从两个Path头上获取到如下信息：如果要打电话给uac, Path头会转变为route头，用来定义INVITE请求的路径。 简单定义：Path头用来一般在注册消息里，Path头定义了uac作为被叫时，INVITE请求的发送路径。
参考 </description>
    </item>
    
    <item>
      <title>Via route Record-Route的区别</title>
      <link>https://wdd.js.org/opensips/ch1/via-route-record-route/</link>
      <pubDate>Sat, 03 Sep 2022 02:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/via-route-record-route/</guid>
      <description>sequenceDiagram title French Words I Know autonumber participant a participant p1 participant p2 participant p3 participant b a-&gt;&gt;p1 : INVITE route: p1, via: a p1-&gt;&gt;p2: INVITE via: a,p1, rr: p1 p2-&gt;&gt;p3: INVITE via: a,p1,p2 rr: p1,p2 p3-&gt;&gt;b: INVITE via: a,p1,p2,p3 rr: p1,p2,p3 b--&gt;&gt;p3: 180 via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 180 via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 180 via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 180 via: a rr: p1,p2,p3 b--&gt;&gt;p3: 200 OK via: a,p1,p2,p3 rr: p1,p2,p3 p3--&gt;&gt;p2: 200 Ok via: a,p1,p2 rr: p1,p2,p3 p2--&gt;&gt;p1: 200 Ok via: a,p1 rr: p1,p2,p3 p1--&gt;&gt;a: 200 Ok via: a rr: p1,p2,p3 a-&gt;&gt;p1 : ACK via: a, route: p1,p2,p3 p1-&gt;&gt;p2: ACK via: a,p1, route: p2,p3 p2-&gt;&gt;p3: ACK via: a,p1,p2 route: p3 p3-&gt;&gt;b: ACK via: a,p1,p2,p3 rr代表record-route头。</description>
    </item>
    
    <item>
      <title>SIP协议简介</title>
      <link>https://wdd.js.org/opensips/ch1/sip-overview/</link>
      <pubDate>Fri, 02 Sep 2022 01:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-overview/</guid>
      <description>SIP是VoIP的基石，相当于HTTP协议在Web服务器里的角色。如果你熟悉HTTP协议，那么你可以在SIP协议中找到许多和HTTP中熟悉的东西，例如请求头，请求体，响应码之类概念，这是因为SIP协议的设计，很大程度上参考了HTTP协议。
如果想要学习VoIP，那么SIP协议是你务必掌握敲门砖。
1. SIP组件 UAC: 例如sip终端，软电话，话机 UAS: sip服务器 UA: ua既可以当做uac也可以当做uas 代理服务器 重定向服务器 注册服务器 网关 PSTN 公共交换电话网 2. SBC 边界会话控制器 SBC是Session Border Controller的缩写，具有一下几个功能。
拓扑隐藏：隐藏所有内部网络的信息。 媒体流管理：设置语音流编码规则，转换等 增加能力：例如Refer, 3CPP 维护NAT映射： 访问控制 媒体加密：例如外部网络用SRTP, 内部网络用RTP 3. sip注册过程 下面简化注册逻辑，省略了验证和过期等字段：
对于分机来说，注册服务器的地址是需要设置的 分机向注册服务器发请求，说：你好，注册服务器，我是8005，我的地址是200.180.1.1，以后你可以用这个地址联系我。 注册服务器回复：好的，注册成功 4. sip服务器的类型 4.1. 代理服务器 4.2. 重定向服务器 4.3. 背靠背UA服务器 背靠背UA服务器有两个作用
隐藏网络拓扑结构 有些时候，路由无法到达，只能用背靠背UA服务器 5. 常用sip请求方法 比较常用的是下面的
常用的几个是：register, invite, ack, bye, cancel。除了cancel和ack不需要认证外，其余的请求都需要认证。 register自不必说，invite和bye是需要认证的。
对于我们不信任的ua，我们不允许他们呼叫。对于未认证的bye，也需要禁止。后者可以防止恶意的bye请求，挂断正常的呼叫。
invite除了re-invite的情况，其余的都属于初始化请求，需要着重关心的。而对于bye这种序列化请求，只需要按照record-route去路由。
6. sip响应状态码 7. sip对话流程图 从上图可以看出，从invite请求到200ok之间的信令，都经过了代理服务器。但是200ok之后的ack，确没有经过代理服务器，如果想要所有信令都经过代理服务器，需要在sip消息头record-routing 指定代理服务器的地址
8. 请求与响应报文 9. 事务与对话的区别 重点：
从INVITE请求到最终的响应（注意1xx不是最终响应，非1xx的都是最终响应）之间，称为事务。一个事务可以带有多个消息组成，并经过多个ua。 ack请求比较特殊，但是ack不是事务。如果被叫接通后，超时未收到主叫方的ack, 会怎样？是否会再次发送200OK tcp三次握手建立连接，sip：invite-&amp;gt;200ok-&amp;gt;ack，可以理解为三次握手建立对话。 bye请求和200ok算作一个事务 dialog建立的前提是呼叫接通，如果呼叫没有接通，则没有dialog。 dialog可以由三个元素唯一确定。callId, from字段中的tag, to字段中的tag。 10.</description>
    </item>
    
    <item>
      <title>学习建议</title>
      <link>https://wdd.js.org/opensips/ch1/study-tips/</link>
      <pubDate>Fri, 02 Sep 2022 00:00:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/study-tips/</guid>
      <description>1. 概念理解 务必要能理解SIP的重要概念，特别是事务、Dialog。参考https://www.yuque.com/wangdd/opensips/fx5pyy 概念是非常重要的东西，不理解概念，越学就会越吃力 2. 时序图 时序图是非常重要的，培训时，一般我会要求学员务必能够手工绘制时序图。因为只有能够手工绘制时序图了，在排查问题时，才能够从抓包工具给出的时序图中分析出问题所在。
RFC3665 https://datatracker.ietf.org/doc/html/rfc3665 中提供了很多经典的时序图，建议可以去临摹。</description>
    </item>
    
    <item>
      <title>NAT场景下的信令处理 - 单网卡</title>
      <link>https://wdd.js.org/opensips/ch9/nat-single-interface/</link>
      <pubDate>Fri, 10 Jun 2022 20:27:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/nat-single-interface/</guid>
      <description> OPS &amp;lt;&amp;lt;&amp;lt;----------------------------- ingress 内网 | 公网 ｜ | 192.168.2.11 | 1.2.3.4 INNER_IP | OUTER_IP | | ------------------------------&amp;gt;&amp;gt;&amp;gt; egress 常见共有云的提供的云服务器，一般都有一个内网地址如192.16.2.11和一个公网地址如1.2.3.4。 内网地址是配置在网卡上的；公网地址则只是一个映射，并未在网卡上配置。
我们称从公网到内网的方向为ingress，从内网到公网的方向为egress。
对于内网来说OpenSIPS的广播地址应该是INNER_IP, 所以对ingress方向的SIP请求，Via应该是INNER_IP。对于公网来说OpenSIPS的广播地址应该是OUT_IP, 随意对于egress方向的SIP请求，Via应该是OUTER_IP。
我们模拟一下，假如设置了错误的Via的地址会怎样呢？
例如从公网到内网的一个INVITE, 如果Via头加上的是OUTER_IP， 那么这个请求的响应也会被送到OPS的公网地址。但是由于网络策略和防火墙等原因，这个来自内网的响应很可能无法被送到OPS的公网地址。
一般情况下，我们可以使用listen的as参数来设置对外的广告地址。
listen = udp:192.168.2.11:5060 as 1.2.3.4:5060 这样的情况下，从内网发送到公网请求，携带的Via就被被设置成1.2.3.4。
但是也不是as设置的广告地址一定正确。这时候我们就可以用OpenSIPS提供的核心函数set_advertised_address或者set_advertised_port()来在脚本里自定义对外地址。
例如：
if (请求来自外网) { set_advertised_address(&amp;#34;192.168.2.11&amp;#34;); } else { set_advertised_address(&amp;#34;1.2.3.4&amp;#34;); } </description>
    </item>
    
    <item>
      <title>集群共享分机注册信息</title>
      <link>https://wdd.js.org/opensips/ch9/cluster-share-location/</link>
      <pubDate>Fri, 20 May 2022 11:52:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/cluster-share-location/</guid>
      <description>共享分机注册信息有两种方式
集群使用相同的数据库，多个节点实时读取数据 优点：使用简单，即使所有节点重启，也能立即从数据库中恢复分机注册数据 缺点：对数据库过于依赖，一旦数据库出现性能瓶颈，则会立即影响所有的呼叫 是用cluster模块，不使用数据库，通过opensips自带的二进制同步方式 优点：不用数据库，消息处理速度快，减少对数据库的压力 缺点：一旦所有节点挂掉，所有的分机注册信息都会损失。但是挂掉所有节点的概率还是比较小的。 今天要讲的方式就是通过cluster的方式进行共享注册信息的方案。
假设有三个节点：
在其中一个节点上注册的分机信息会同步给其他的节点 假设其中节点a重启了，节点a会自动选择b或者c来拉取第一次初始化的分机信息 举例来说：
8001分机在b上注册成功 b把8001的注册信息通过cluster模块通知给a和c 8002分机在a上注册成功 a把8002的注册信息通过cluster模块通知给b和c 此时整个集群有两个分机8001和8002 节点c突然崩溃重启 节点c重启之后，向b发出请求，获取所有注册的分机 节点b像节点c推送全量的分机注册信息 此时三个节点又恢复同步状态 cluster表设计:
空的字段我就没写了，flags字段必须设置为seed, 这样节点重启后，才知道要像哪个节点同步全量数据 id,cluster_id,node_id,url,state,flags 1,1,1,bin:a:5000,1,seed 2,1,2,bin:b:5000,1,seed 3,1,3,bin:c:5000,1,seed 脚本修改：
# 增加 bin的listen, 对应cluster表的url listen=bin:192.168.2.130:5000 # 加载proto_bin和clusterer模块 loadmodule &amp;#34;proto_bin.so&amp;#34; loadmodule &amp;#34;clusterer.so&amp;#34; modparam(&amp;#34;clusterer&amp;#34;, &amp;#34;db_url&amp;#34;, &amp;#34;mysql:xxxx&amp;#34;) # 设置数据库地址 modparam(&amp;#34;clusterer&amp;#34;, &amp;#34;current_id&amp;#34;, 1) # 设置当前node_id modparam(&amp;#34;usrloc&amp;#34;, &amp;#34;working_mode_preset&amp;#34;, &amp;#34;full-sharing-cluster&amp;#34;) modparam(&amp;#34;usrloc&amp;#34;, &amp;#34;location_cluster&amp;#34;, 1) # 设置当前的集群id 其他操作保持原样，opensips就会自动同步分机数据了。</description>
    </item>
    
    <item>
      <title>opensips 477 Send failed (477/TM)</title>
      <link>https://wdd.js.org/opensips/ch7/tm-send-failed/</link>
      <pubDate>Fri, 08 Apr 2022 22:32:27 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/tm-send-failed/</guid>
      <description>这个报错比较容易出现在tcp转udp的场景，可以看以下的时序图
ab之间用tcp通信，bc之间用udp通信。在通话建立后，c给b发送了bye请求，但是b发送给了c 477。正常来说b应该把bye转发给a.
那么问题出在哪里呢？
问题就出在update请求的响应上，update的响应200ok中带有Contact头，如果是Contact是个nat的地址，没有经过fixed nat, 那么b是无法直接给nat内部的地址发送请求的。
处理的办法也很简单，就是在收到a返回的200ok时，执行fix_nated_contact()
遇到这种问题，往往进入一种思维误区，就是在INVITE请求成功后，fix了nat Contact后，Contact头是不会变的。
但是实际上，很多SIP请求，例如NOTIFY, UPDATE都会携带请求和响应都会携带Contact, 如果只处理了INVITE的Contact头，没有处理其他携带Contact的sip请求或者响应，就必然也会遇到类似的问题。
我们知道SIP的Contact后，决定了序列化请求的request url。如果Contact处理的有问题，必然在按照request url转发的时候出现问题。
综上所述：无论请求还是响应，都要考虑这个消息是否携带了Contact头，以及是否需要fix nat Contact。</description>
    </item>
    
    <item>
      <title>拓扑隐藏学习以及实践</title>
      <link>https://wdd.js.org/opensips/ch8/topology-hiding/</link>
      <pubDate>Thu, 31 Mar 2022 20:34:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/topology-hiding/</guid>
      <description>1. 拓扑隐藏功能 删除Via头 删除Route 删除Record-Route 修改Contact 可选隐藏Call-ID 如下图所示，根据SIP的Via, Route, Record-Route的头，往往可以推测服务内部的网络结构。
我们不希望别人知道的我们的内部网络结构。我们只希望只能看到C这个sip server。经过拓扑隐藏过后
用户看不到关于a、b的via, route, record-route头 用户看到的Contact头被修改成C的IP地址 可以选择把原始的Call-ID也修改 当然，拓扑隐藏除了可以隐藏一些信息，也有一个其他的好处：减少SIP消息包的长度。如果SIP消息用UDP传输，减少包的体积，可以大大降低UDP分片的可能性。
所以，综上所述：拓扑隐藏有以下好处
隐藏服务内部网络结构 减少SIP包的体积 2. 脚本例子 拓扑隐藏的实现并不复杂。首先要加载拓扑隐藏的模块
loadmodule &amp;#34;topology_hiding.so&amp;#34; 2.1 初始化路由的处理 在初始化路由里，只需要调用topology_hiding()
U 表示不隐藏Contact的用户名信息 C 表示隐藏Call-ID # if it&amp;#39;s an INVITE dialog, we can create the dialog now, will lead to cleaner SIP messages if (is_method(&amp;#34;INVITE&amp;#34;)) create_dialog(); # we do topology hiding, preserving the Contact Username and also hiding the Call-ID topology_hiding(&amp;#34;UC&amp;#34;); t_relay(); exit; 2.</description>
    </item>
    
    <item>
      <title>tshark 快速分析语音流问题</title>
      <link>https://wdd.js.org/opensips/tools/tshark/</link>
      <pubDate>Tue, 08 Mar 2022 11:02:18 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/tshark/</guid>
      <description>wireshark安装之后，tshark也会自动安装。tshark也可以单独安装。
如果我们想快速的分析语音刘相关的问题，可以参考下面的一个命令。
语音卡顿，常见的原因就是网络丢包，tshark在命令行中快速输出语音流的丢包率。
如下所示，rtp的丢包率分别是2.5%和4.6%。
tshark -r abc.pcap -q -z rtp,streams ========================= RTP Streams ======================== Start time End time Src IP addr Port Dest IP addr Port SSRC Payload Pkts Lost Min Delta(ms) Mean Delta(ms) Max Delta(ms) Min Jitter(ms) Mean Jitter(ms) Max Jitter(ms) Problems? 2.666034 60.446026 192.168.69.12 18892 192.168.68.111 26772 0x76EFFF66 g711A 2807 72 (2.5%) 0.011 20.592 120.002 0.001 0.074 2.430 X 0.548952 60.467686 192.168.68.111 26772 192.168.69.12 18892 0xA655E7B6 g711A 2215 106 (4.</description>
    </item>
    
    <item>
      <title>mysql建表语句</title>
      <link>https://wdd.js.org/opensips/ch5/sql-table/</link>
      <pubDate>Thu, 24 Feb 2022 10:47:23 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/sql-table/</guid>
      <description>OpenSIPS需要用数据库持久化数据，常用的是mysql。
可以参考这个官方的教程去初始化数据库的数据 https://www.opensips.org/Documentation/Install-DBDeployment-2-4
如果你想自己创建语句，也是可以的，实际上建表语句在OpenSIPS安装之后，已经被保存在你的电脑上。
一般位于 /usr/local/share/opensips/mysql 目录中
cd /usr/local/share/opensips/mysql ls acc-create.sql call_center-create.sql dispatcher-create.sql group-create.sql rls-create.sql uri_db-create.sql alias_db-create.sql carrierroute-create.sql domain-create.sql imc-create.sql rtpengine-create.sql userblacklist-create.sql auth_db-create.sql closeddial-create.sql domainpolicy-create.sql load_balancer-create.sql rtpproxy-create.sql usrloc-create.sql avpops-create.sql clusterer-create.sql drouting-create.sql msilo-create.sql siptrace-create.sql b2b-create.sql cpl-create.sql emergency-create.sql permissions-create.sql speeddial-create.sql b2b_sca-create.sql dialog-create.sql fraud_detection-create.sql presence-create.sql standard-create.sql cachedb_sql-create.sql dialplan-create.sql freeswitch_scripting-create.sql registrant-create.sql tls_mgm-create.sql </description>
    </item>
    
    <item>
      <title>RTP 不连续的timestamp和SSRC</title>
      <link>https://wdd.js.org/opensips/ch4/rtp-timestamp/</link>
      <pubDate>Mon, 10 Jan 2022 22:05:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/rtp-timestamp/</guid>
      <description>最近遇到一些和媒体流相关的问题，使用wireshark分析之后，总算有些眉目。然而我深感对RTP协议的理解，还是趋于表面。所以我决定，深入的学习一下RTP协议。
和rtp相关的协议有两个rfc, 分别是
1996的的 RFC 1889 2003年的 RFC 3550 RFC 3550是对RFC 1889的稍微改进，然而大体上是没什么改变的。所以我们可以直接看RFC 3550。
RTP 底层用的是UDP协议 RTP 的使用场景是传输实时数据，例如语音，视频，模拟数据等等 RTP 并不保证QoS Synchronization source (SSRC): The source of a stream of RTP packets, identified by a 32-bit numeric SSRC identifier carried in the RTP header so as not to be dependent upon the network address. All packets from a synchronization source form part of the same timing and sequence number space, so a receiver groups packets by synchronization source for playback.</description>
    </item>
    
    <item>
      <title>avp_db_query数值null值比较</title>
      <link>https://wdd.js.org/opensips/ch5/avp-db-query/</link>
      <pubDate>Wed, 29 Sep 2021 19:13:26 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/avp-db-query/</guid>
      <description>avp_db_query是用来做数据库查询的，如果查到某列的值是NULL, 那么对应到脚本里应该如何比较呢？
可以用avp的值与&amp;quot;&amp;quot;， 进行比较
if ($avp(status) == &amp;#34;&amp;lt;null&amp;gt;&amp;#34;) 参考 https://stackoverflow.com/questions/52675803/opensips-avp-db-query-cant-compare-null-value </description>
    </item>
    
    <item>
      <title>sendmsg failed on 0: Socket operation on non-socket</title>
      <link>https://wdd.js.org/opensips/ch7/sendmsg-failed/</link>
      <pubDate>Thu, 16 Sep 2021 10:04:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/sendmsg-failed/</guid>
      <description>ERROR:core:tcp_init_listener: could not get TCP protocol number CRITICAL:core:send_fd: sendmsg failed on 0: Socket operation on non-socket ERROR:core:send2child: send_fd failed 不要将tcp_child设置为0</description>
    </item>
    
    <item>
      <title>信令路径逃逸分析</title>
      <link>https://wdd.js.org/opensips/ch7/escape-msg/</link>
      <pubDate>Wed, 15 Sep 2021 19:18:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/escape-msg/</guid>
      <description>问题表现 在经过初始化请求之后，路径发现完成。在这个dialog中所有的请求，正常来ua1和ua2之间的所有请求，都应该经过us1和us2。
如下图所示：
某些时候，ua1可能直接把BYE消息直接发送给ua2, 但是一般ua1和ua2是存在uat网络的，所以这个BYE消息，ua2很可能收不到。
问题的表现就是电话无法正常挂断。
问题分析 可能原因1: us1和us2没有做record-route, 导致请求直接根据某个请求的响应消息的Contact头，直接发送了。 可能原因2: 某些请求的拓扑隐藏没有做好 拓扑隐藏问题具体分析 假如我们在us1上正确的做了拓扑隐藏，那么ua1的所有收到的响应，它的Contact头的地址都会改成us1的地址。那么ua1是无论如何都获取不到ua2的直接地址的。
但是，假如某个消息处理的不对呢？
注意180响应5到6, 其中us1正确的修改了Contact头 ua1收到180后，立即发送了notify消息 如果us1没有正确处理notify的响应的Contact头，us1就会把ua2的Contact信息发送给ua1。有些notify的响应带有Contact头，有些没带有。 但是这里会出现一个竞争条件，invite的200ok和notify的200ok，消息到达的顺序，将影响ua2的Contact信息 如果ua1后收到invite的200ok, 此时ua1获取ua2的地址是us1 如果ua2后收到notify的200ok, 此时ua2获取的ua2的地址就是ua2 所以问题的表现可能是有偶现的，这种问题处理其实是比较棘手的 当然也是有解决方案的 方案1， us1对notify正确处理响应消息Contact, 将其修改成us1 方案2，us1直接删除notify响应消息的Contact头 </description>
    </item>
    
    <item>
      <title>heplify SIP信令抓包客户端</title>
      <link>https://wdd.js.org/opensips/tools/heplify/</link>
      <pubDate>Sun, 12 Sep 2021 20:49:51 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/heplify/</guid>
      <description>hepfily是个独立的抓包程序，类似于tcpdump之类的，网络抓包程序，可以把抓到的sip包，编码为hep格式。然后送到hep server上，由hepserver负责包的整理和存储。
heplify安装非常简单，在仓库的release页面，可以下载二进程程序。二进程程序赋予可执行权限后，可以直接在x86架构的机器上运行。
因为heplify是go语言写的，你也可以基于源码，编译其他架构的二进制程序。
https://github.com/sipcapture/heplify
-i 设定抓包的网卡 -m 设置抓包模式为SIP -hs 设置hep server的地址 -p 设置日志文件的日志 -dim 设置过滤一些不关心的sip包 -pr 设置抓包的端口范围 nohup ./heplify \ -i eno1 \ -m SIP \ -hs 192.168.1.2:9060 \ -p &amp;#34;/var/log/&amp;#34; \ -dim OPTIONS,REGISTER \ -pr &amp;#34;18627-18628&amp;#34; &amp;amp; opensips模块本身就有proto_hep模块支持hep抓包，为什么我还要用heplify来抓包呢？
低于2.2版本的opensips不支持hep抓包 opensips的hep抓包还是不太稳定。我曾遇到过因为hep抓包导致opensips崩溃的事故。如果用外部的抓包程序，即使抓包有问题，还是不会影响到opensips。 </description>
    </item>
    
    <item>
      <title>核心变量解读-100%</title>
      <link>https://wdd.js.org/opensips/ch5/core-var-2/</link>
      <pubDate>Thu, 09 Sep 2021 09:04:21 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/core-var-2/</guid>
      <description>简介 OpenSIPS的路由脚本提供了几种不同类型的变量。不同类型的变量有以下几个方面的差异。
变量的可见性 变量引用的值 变量的读写性质：有些变量是只读的，有些变量可读可写 变量是否有多个值：有些变量只有一个值，有些变量有多个值 语法 $(&amp;lt;context&amp;gt;name(subname)[index]{tramsformation}) 除了name以外 ，其他都是可选的值。
name(必传)：变量名的类型，例如pvar, avp, ru, DLG_status等等 subname: 变量名称，例如hdr(From), avp(name) index: 索引，某些变量可以有多个值，类似于数组。可以用索引去引用对应的元素。从0开始，也可以是负值如-1, 表示倒数第一个。 transformation: 转换。做一些格式转换，字符串截取等等操作 context: 上下文。OpenSIP有两个上下午，请求request、相应reply。想想一个场景，你在一个相应路由里如何拿到请求路由的某个值呢？ 可以使用$(ru). 或者在一个失败路由里获取一个Concact的信息$(hdr(Contact)) 举例：
仅仅通过类型来引用：$ru 通过类型和名称来引用：$hrd(Contact), 引用某个SIP header的值 通过类型和索引来引用：$(ct[0]) 通过类型、名称、索引来引用：$(avp(addr)[0]) 变量的类型 脚本变量 脚本变量只有一个值 脚本变量可读可写 脚本变量在路由及其子路由中都是可见的 脚本变量使用前务必先初始化，否则可能会引用到之前的值 脚本变量的值可以是字符串，也可以是整数类型 脚本变量读写比avp变量快 脚本变量会持久存在一个OpenSIPS进程中 将脚本变量设置为NULL, 实际上是将变量的值设置为&#39;0&amp;rsquo;, 脚本变量没有NULL值。 脚本变量之存在与一个路由中 使用举例
route{ $var(a) = 19 $var(a) = &amp;#34;wdd&amp;#34; $var(a) = &amp;#34;wdd&amp;#34; + &amp;#34;@&amp;#34; + $td; if(route(check_out, 1)){ xlog(&amp;#34;check error&amp;#34;); } } route[check_out]{ # 注意，这里$var(a)的值就不存在了 xlog(&amp;#34;$var(a)&amp;#34;); if ($param(1) &amp;gt; 1) { return (-1); } return(1); } avp变量 avp变量一般会关联到一个sip消息或者SIP事务上.</description>
    </item>
    
    <item>
      <title>生产环境监控告警</title>
      <link>https://wdd.js.org/opensips/ch3/prd-warning/</link>
      <pubDate>Thu, 19 Aug 2021 20:08:28 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/prd-warning/</guid>
      <description>日志监控 务必监控opensips日志，如果其中出现了CRITICAL关键字, 很可能马上opensips就要崩溃。
第一要发出告警信息。第二要有主动的自动重启策略，例如使用systemd启动的话，服务崩溃会会立马被重启。或者用docker或者k8s，这些虚拟化技术，可以让容器崩溃后自动重启。
指标监控 opensips有内部的统计模块，可以很方便的通过opensipsctl或者相关的http的mi接口获取到内部的统计数据。
以下给出几个关键的统计指标：
&amp;rsquo;total_size&amp;rsquo;, 全部内存 &amp;lsquo;used_size&amp;rsquo;, 使用的内存 &amp;lsquo;real_used_size&amp;rsquo;, 真是使用的内存 &amp;lsquo;max_used_size&amp;rsquo;, 最大使用的内存 &amp;lsquo;free_size&amp;rsquo;, 空闲内存 &amp;lsquo;fragments&amp;rsquo;, &amp;lsquo;active_dialogs&amp;rsquo;, 接通状态的通话 &amp;rsquo;early_dialogs&amp;rsquo;, 振铃状态的通话 &amp;lsquo;inuse_transactions&amp;rsquo;, 正在使用的事务 &amp;lsquo;waiting_udp&amp;rsquo;, 堆积的udp消息 &amp;lsquo;waiting_tcp&amp;rsquo; 堆积的tcp消息 当然还有很多的一些指标，可以使用：opensipsctl fifo get_statistics all来获取。</description>
    </item>
    
    <item>
      <title>opensips崩溃分析</title>
      <link>https://wdd.js.org/opensips/ch7/crash/</link>
      <pubDate>Thu, 19 Aug 2021 19:30:14 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/crash/</guid>
      <description>core dump文件在哪里？ 一般情况下，opensips在崩溃的时候，会产生core dump文件。这个文件一般位于跟目录下，名字如core.xxxx等的。
core dump文件一般大约有1G左右，所以当产生core dump的时候，要保证系统的磁盘空间是否足够。
如何开启core dump？ 第一，opensips脚本中有个参数叫做disable_core_dump， 这个参数默认为no, 也就是启用core dump, 可以将这个参数设置为no, 来禁用core dump。但是生产环境一般建议还是开启core dump, 否则服务崩溃了，就只能看日志，无法定位到具体的崩溃代码的位置。
disable_core_dump=yes 第二，还需要在opensips启动之前，运行：ulimit -c unlimited, 这个命令会让opensips core dump的时候，不会限制core dump文件的大小。一般来说core dump文件的大小是共享内存 + 私有内存。
第三，opensips进程的用户如果不是root, 那么可能没有权限将core dump文件写到/目录下。有两个解决办法，
用root用户启动opensips进程 使用-w 参数配置opensips的工作目录，core dump文件将会写到对应的目录中。例如：opensips -w /var/log 如果core dump失败是因为权限的问题， opensips的日志文件中将会打印：
Can&amp;#39;t open &amp;#39;core.xxxx&amp;#39; at &amp;#39;/&amp;#39;: Permission denied 如何分析core dump文件？ 使用gdb
gdb $(which opensips) core.12333 # 进入gdb调试之后, 输入bt full, 会打印详细的错误栈信息 bt full 没有产生core dump文件，如何分析崩溃原因？ 使用objdump。
一般来说opensips崩溃后，日志文件中一般会出现下面的信息
kernel: opensips[8954]: segfault at 1ea72b5 ip 00000000004be532 sp 00007ffe9e1e6df0 error 4 in opensips[400000+203000] 我们从中取出几个关键词</description>
    </item>
    
    <item>
      <title>opensips无法启动</title>
      <link>https://wdd.js.org/opensips/ch7/can-not-run/</link>
      <pubDate>Thu, 19 Aug 2021 19:19:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/can-not-run/</guid>
      <description>排查日志 opensips的log_stderror参数决定写日志的位置，
yes 写日志到标准错误 no 写日志到syslog服务(默认) 如果使用默认的syslog服务，那么日志将会可能写到以下两个文件中。
/var/log/messages /var/log/syslog 一般情况下，分析/var/log/messages日志，可以定位到无法启动的原因。
如果日志文件中无法定位到具体原因，那么就可以将log_stderror设置为yes。
注意：往标准错误中打印的日志，往往比网日志文件中打印的更详细。而且有些时候，我发现这个错误在标准错误中打印了，但是却不会输出到日志文件中。
所以，看标准错误的日志，往往更容易定位到问题。</description>
    </item>
    
    <item>
      <title>baresip 非常好用的终端SIP UA</title>
      <link>https://wdd.js.org/opensips/tools/baresip/</link>
      <pubDate>Tue, 08 Jun 2021 16:27:36 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/baresip/</guid>
      <description>安装 安装前要先安装依赖
https://github.com/baresip/re https://github.com/baresip/rem openssl git clone https://github.com/baresip/baresip cd baresip make sudo make install 指令 /about About box/accept Accept incoming call/answermode Set answer mode/apistate User Agent state/auloop Start audio-loop /auloop_stop Stop audio-loop/auplay Switch audio player/ausrc Switch audio source/callstat Call status/conf_reload Reload config file/config Print configuration/contact_next Set next contact/contact_prev Set previous contact/contacts List contacts/dial .. Dial/dialcontact Dial current contact/hangup Hangup call/help Help menu/insmod Load module/listcalls List active calls/loglevel Log level toggle/main Main loop debug/memstat Memory status/message Message current contact/modules Module debug/netstat Network debug/options Options/play Play audio file/quit Quit/reginfo Registration info/rmmod Unload module/sipstat SIP debug/sysinfo System info/timers Timer debug/uadel Delete User-Agent/uafind Find User-Agent /uanew Create User-Agent/uanext Toggle UAs/uastat UA debug/uuid Print UUID/vidloop Start video-loop /vidloop stop Stop video-loop/vidsrc Switch video source</description>
    </item>
    
    <item>
      <title>模块传参的重构</title>
      <link>https://wdd.js.org/opensips/ch8/fork/</link>
      <pubDate>Tue, 27 Apr 2021 13:36:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/fork/</guid>
      <description>写过opensips脚本的同学，往往对函数的传参感到困惑。
例如：
ds_select_dst()可以接受整数或者值为正数的变量作为第一个参数，但是nat_uac_test()的第一个参数就只能是整数，而不能是变量 为什么rl_check()可以接受格式化的字符串，而save()只能接受字符串。 为什么ds_select_dst(&amp;quot;1&amp;quot;, &amp;quot;4&amp;quot;) 作为整数也要加上双引号？ 为什么变量要加上双引号？ ds_select_dst(&amp;quot;$var(aa)&amp;quot;, &amp;quot;4&amp;quot;) 为什么t_on_branch(&amp;quot;1&amp;quot;)路由的钩子要加上双引号？ 为什么route(go_to_something);这里又不需要加上引号？ ds_select_dst(&amp;#34;1&amp;#34;, &amp;#34;0&amp;#34;); $var(aa)=1; ds_select_dst(&amp;#34;$var(aa)&amp;#34;, &amp;#34;0&amp;#34;); rl_check(&amp;#34;gw_$ru&amp;#34;, &amp;#34;$var(limit)&amp;#34;); #格式化的gw_$ru save(&amp;#34;location&amp;#34;); #单纯的字符串作为参数 从3.0开始，传参可以更加自然。
整数可以直接传参，不用加双引号 do_something(1, 1); 输入或者输出的$var(), 不用加双引号，加了反而会报错 do_something($var(a), $var(b)); 格式化字符串，需要加双引号 do_something(1, &amp;#34;$var(bb)_$var(b)&amp;#34;); 参考 https://blog.opensips.org/2019/11/05/the-module-function-interface-rework-in-opensips-3-0/ https://www.opensips.org/Documentation/Script-Syntax-3-0# </description>
    </item>
    
    <item>
      <title>sbc 100rel</title>
      <link>https://wdd.js.org/opensips/ch9/100-rel/</link>
      <pubDate>Mon, 26 Apr 2021 09:56:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/100-rel/</guid>
      <description>sbc_100rel.pdf
在fs中配置：
enable-100rel 设置为true ➜ fs-conf ack 100rel sip_profiles/internal.xml 112: There are known issues (asserts and segfaults) when 100rel is enabled. 113: It is not recommended to enable 100rel at this time. 115: &amp;lt;!--&amp;lt;param name=&amp;#34;enable-100rel&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt;--&amp;gt; sip_profiles/external-ipv6.xml 36: &amp;lt;!--&amp;lt;param name=&amp;#34;enable-100rel&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt;--&amp;gt; sip_profiles/internal-ipv6.xml 27: &amp;lt;!--&amp;lt;param name=&amp;#34;enable-100rel&amp;#34; value=&amp;#34;false&amp;#34;/&amp;gt;--&amp;gt; sip_profiles/external.xml 36: &amp;lt;!--&amp;lt;param name=&amp;#34;enable-100rel&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt;--&amp;gt; enable-100rel This enable support for 100rel (100% reliability - PRACK message as defined inRFC3262) This fixes a problem with SIP where provisional messages like &amp;ldquo;180 Ringing&amp;rdquo; are not ACK&amp;rsquo;d and therefore could be dropped over a poor connection without retransmission.</description>
    </item>
    
    <item>
      <title>cachedb的相关问题</title>
      <link>https://wdd.js.org/opensips/ch6/cachedb/</link>
      <pubDate>Wed, 21 Apr 2021 18:08:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/cachedb/</guid>
      <description>底层可用 local 缓存存在本地，速度快，但是多实例无法共享，重启后消失 redis 缓存存在redis, 多实例可以共享，重启后不消失 接口 store -cache_store() 存储 fetch -cache_fetch() 获取 remove -cache_remove() 删除 add -cache_add() 递增 sub -cache_sub() 递减 cache_counter_fetch 获取某个key的值 关于过期的单位 虽然文档上没有明说，但是过期的单位都是秒。
cachedb_local过期 loadmodule &amp;#34;cachedb_local.so&amp;#34; modparam(&amp;#34;cachedb_local&amp;#34;, &amp;#34;cachedb_url&amp;#34;, &amp;#34;local://&amp;#34;) modparam(&amp;#34;cachedb_local&amp;#34;, &amp;#34;cache_clean_period&amp;#34;, 600) route[xxx]{ cache_add(&amp;#34;local&amp;#34;, &amp;#34;$fu&amp;#34;, 100, 5); } 假如说：在5秒之内，同一个$fu来了多个请求，在设置这个$fu值的时候，计时器是不会重置的。过期的计时器还是第一次的设置的那个时间点开始计时。
参考 https://www.opensips.org/Documentation/Tutorials-KeyValueInterface </description>
    </item>
    
    <item>
      <title>rtpengine 增加对ilbc编解码的支持</title>
      <link>https://wdd.js.org/opensips/ch9/rtpengine-ilbc/</link>
      <pubDate>Sun, 18 Apr 2021 21:28:20 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/rtpengine-ilbc/</guid>
      <description>ilbc的编码特定是占用带宽小，并且抗丢表。但是rtpengine是不支持ilbc编码的，可以参考的资料有以下两个
https://github.com/sipwise/rtpengine/issues/897 https://sr-users.sip-router.narkive.com/f3jhDeyU/rtpengine-and-ilbc-support 使用rtpengine --codecs可以打印出rtpengine支持的编解码
rtpengine --codecs PCMA: fully supported PCMU: fully supported G723: fully supported G722: fully supported QCELP: supported for decoding only G729: supported for decoding only speex: fully supported GSM: fully supported iLBC: not supported opus: fully supported vorbis: fully supported ac3: fully supported eac3: fully supported ATRAC3: supported for decoding only ATRAC-X: supported for decoding only AMR: fully supported AMR-WB: fully supported PCM-S16LE: fully supported MP3: fully supported 下面的操作基于debian:9-slim的基础镜像构建的，在构建rtpengine之前，我们先编译ilbc的依赖库</description>
    </item>
    
    <item>
      <title>UDP分片导致SIP消息丢失</title>
      <link>https://wdd.js.org/opensips/ch7/big-udp-msg/</link>
      <pubDate>Thu, 08 Apr 2021 14:33:49 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/big-udp-msg/</guid>
      <description>现象 有了开源的框架，我们可以很方便的运行一个VOIP系统。但是维护一个VOIP系统并非那么简单。特别是如果经常出现一些偶发的问题，需要用经验丰富的运维人员来从不同层面分析。
其中UDP分片，也可能是原因之一。
简介 以太网的最大MTU一般是1500字节，减去20字节的IP首部，8字节的UDP首部，UDP能承载的数据最大是1472字节。
如果一个SIP消息的报文超过1472就会分片。（实际上，如果网络的MTU比1500更小，那么达到分片的尺寸也会变小）
如下图，发送方通过以太网发送了4个报文，ABCD。其中D报文太了，而被分割成了三个报文。在传输过程中，D的一个分片丢失，接收方由于无法重新组装D报文，所以就将D报文的所有分片都丢弃。
这将会导致一下问题
发送方因接收不到响应，所以产生了重传 丢弃的分片导致其他的分片浪费了带宽 IP分片是对发送者来说是简单的，但是对于接收者来说，分片的组装将会占用更多的资源 RFC 3261中给出建议，某些情况下可以使用TCP来传输。
当MTU是未知的情况下，如果消息超过1300字节，则选择使用TCP传输 当MTU是已知情况下，SIP的消息的大小如果大于MTU-200, 则需要使用TCP传输。留下200字节的余量，是因为SIP消息的响应可能大于SIP消息的请求，为了避免响应消息超过MTU，所以要留下200字节的余量。 If a request is within 200 bytes of the path MTU, or if it is larger than 1300 bytes and the path MTU is unknown, the request MUST be sent
using an RFC 2914 [43] congestion controlled transport protocol, such
as TCP. If this causes a change in the transport protocol from the</description>
    </item>
    
    <item>
      <title>subscribe场景测试</title>
      <link>https://wdd.js.org/opensips/tools/sipp-subscriber/</link>
      <pubDate>Thu, 08 Apr 2021 12:32:49 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/sipp-subscriber/</guid>
      <description>时序图 场景解释 step1: SUBSCRIBE 客户端想要订阅某个分机的状态 step2: 200 Ok 服务端接受了这个订阅消息 step3: NOTIFY 服务端向客户端返回他的订阅目标的状态 step4: 200 Ok 客户端返回表示接受 场景文件 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;iso-8859-2&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE scenario SYSTEM &amp;#34;sipp.dtd&amp;#34;&amp;gt; &amp;lt;scenario name=&amp;#34;subscibe wait notify&amp;#34;&amp;gt; &amp;lt;send retrans=&amp;#34;500&amp;#34;&amp;gt; &amp;lt;![CDATA[ SUBSCRIBE sip:[my_monitor]@[my_domain] SIP/2.0 Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] From: sipp &amp;lt;sip:[my_ext]@[my_domain]&amp;gt;;tag=[call_number] To: &amp;lt;sip:[my_monitor]@[my_domain]:[remote_port]&amp;gt; Call-ID: [call_id] CSeq: [cseq] SUBSCRIBE Contact: sip:[my_ext]@[local_ip]:[local_port] Max-Forwards: 10 Event: dialog Expires: 120 User-Agent: SIPp/Win32 Accept: application/dialog-info+xml, multipart/related, application/rlmi+xml Content-Length: 0 ]]&amp;gt; &amp;lt;/send&amp;gt; &amp;lt;recv response=&amp;#34;200&amp;#34; rtd=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;/recv&amp;gt; &amp;lt;recv request=&amp;#34;NOTIFY&amp;#34; crlf=&amp;#34;true&amp;#34; rrs=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;/recv&amp;gt; &amp;lt;send&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>常用语句</title>
      <link>https://wdd.js.org/opensips/ch5/statement/</link>
      <pubDate>Tue, 23 Mar 2021 15:05:06 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/statement/</guid>
      <description>if if (expr) { actions } else { actions; } if (expr) { actions } else if (expr) { actions; } 表达式操作符号 常用的用黄色标记。
== 等于 != 不等于 =~ 正则匹配 $rU =~ &#39;^1800*&#39; is &amp;ldquo;$rU begins with 1800&amp;rdquo; !~ 正则不匹配 大于
= 大于等于
&amp;lt; 小于 &amp;lt;= 小于等于 &amp;amp;&amp;amp; 逻辑与 **|| **逻辑或 **! **逻辑非 [ &amp;hellip; ] - test operator - inside can be any arithmetic expression 其他 出了常见的if语句，opensips还支持switch, while, for each, 因为用的比较少。各位可以看官方文档说明。</description>
    </item>
    
    <item>
      <title>使用return语句减少逻辑嵌套</title>
      <link>https://wdd.js.org/opensips/ch5/return/</link>
      <pubDate>Tue, 23 Mar 2021 14:54:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/return/</guid>
      <description>使用return(int)语句可以返回整数值。
return(0) 相当于exit(), 后续的路由都不在执行 return(正整数) 后续的路由还会继续执行，if测试为true return(负整数) 后续的路由还会继续执行, if测试为false 可以使用 $rc 或者 $retcode 获取上一个路由的返回值 # 请求路由 route{ route(check_is_feature_code); xlog(&amp;#34;check_is_feature_code return code is $rc&amp;#34;); ... ... route(some_other_check); } route[check_is_feature_code]{ if ($rU !~ &amp;#34;^\*[0-9]+&amp;#34;) { xlog(&amp;#34;check_is_feature_code: is not feature code $rU&amp;#34;); # 非feature code, 提前返回 return(1); } # 下面就是feature code的处理 ...... } route[some_other_check]{ ... } </description>
    </item>
    
    <item>
      <title>核心变量说明</title>
      <link>https://wdd.js.org/opensips/ch5/core-var/</link>
      <pubDate>Tue, 23 Mar 2021 14:47:07 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/core-var/</guid>
      <description>$ru $rU 可读可写以下面的sip URL举例
sip:8001@test.cc;a=1;b=2 $ru 代表整个sip url就是 sip:8001@test.cc;a=1;b=2 $rU代表用户部分，就是8001 **
$du 可读可写
$du = &amp;#34;sip:192.468.2.40&amp;#34;; $du可以理解为外呼代理，我们想让这个请求发到下一个sip服务器，就把$du设置为下一跳的地址。</description>
    </item>
    
    <item>
      <title>SIP feature codes SIP功能码</title>
      <link>https://wdd.js.org/opensips/ch9/feature-code/</link>
      <pubDate>Wed, 17 Mar 2021 10:57:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/feature-code/</guid>
      <description>功能描述 用户可以拨打一个特殊的号码，用来触发特定的功能。常见的功能码一般以 * 开头，例如
*1 组内代接 *1(EXT) 代接指定的分机 *2 呼叫转移 **87 请勿打扰 &amp;hellip; 上面的栗子，具体的功能码，对应的业务逻辑是可配置的。
场景举例 我的分机是8001，我看到8008的分机正在振铃，此时我需要把电话接起来。但是我不能走到8008的工位上去接电话，我必须要在自己的工位上接电话。
那么我在自己的分机上输入*18008 这时SIP服务端就知道你想代8008接听正在振铃的电话。
说起来功能码就是一种使用话机上按键的一组暗号。
话机上一般只有0-9*#，一共12个按键。没法办用其他的编码告诉服务端自己想做什么，所以只能用功能码。
参考 https://www.ipcomms.net/support/myoffice-pbx/feature-codes https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cucme/admin/configuration/manual/cmeadm/cmefacs.pdf https://help.yeastar.com/en/s-series/topic/feature_code.html?hl=feature%2Ccode&amp;amp;_ga=2.76562834.622619423.1615949948-1155631884.1615949948 </description>
    </item>
    
    <item>
      <title>BLF功能笔记</title>
      <link>https://wdd.js.org/opensips/ch9/blf-note/</link>
      <pubDate>Wed, 10 Mar 2021 13:15:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/blf-note/</guid>
      <description>BLF功能简介 BLF是busy lamp field的缩写。一句话介绍就是，一个分机可以监控另一个分机的呼叫状态，状态可以通过分机上的指示灯来表示。
例如：分机A通过配置过后，监控了分机B。
如果分机B没有通话，那么分机A上的指示灯显示绿色 如果分机B上有一个呼叫正在振铃，那么分机A指示灯红色灯闪烁 如果分机B正在打电话，那么分机A的指示灯显示红色 这个功能的使用场景往往时例如秘书B监控了老板A的话机，在秘书把电话转给老板之前，可以通过自己电话上的指示灯，来判断老板有没有在打电话，如果没有再打电话，才可以把电话转过去。
信令实现逻辑 信令分析 空闲通知 NOTIFY sip:8003@192.168.2.109:5060 SIP/2.0 Via: SIP/2.0/UDP 192.168.2.109:18627;branch=z9hG4bKfef7.27d86e6.0 To: &amp;lt;sip:8003@wdd.cc&amp;gt;;tag=1 From: &amp;lt;sip:9999@wdd.cc&amp;gt;;tag=d009-12c2f272e7622c1cd9b6aa285a7b9736 CSeq: 1 NOTIFY Call-ID: 1-774753@127.0.1.1 Route: &amp;lt;sip:192.168.2.109:19666;ftag=1;lr&amp;gt; Max-Forwards: 70 Content-Length: 140 User-Agent:WMS Event: dialog Contact: &amp;lt;sip:core@192.168.2.109:18627&amp;gt; Subscription-State: active;expires=120 Content-Type: application/dialog-info+xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;dialog-info xmlns=&amp;#34;urn:ietf:params:xml:ns:dialog-info&amp;#34; version=&amp;#34;0&amp;#34; state=&amp;#34;full&amp;#34; entity=&amp;#34;sip:9999@wdd.cc&amp;#34;/&amp;gt; &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;dialog-info xmlns=&amp;#34;urn:ietf:params:xml:ns:dialog-info&amp;#34; version=&amp;#34;0&amp;#34; state=&amp;#34;full&amp;#34; entity=&amp;#34;sip:9999@wdd.cc&amp;#34;&amp;gt;&amp;lt;/dialog-info&amp;gt; 通话通知 NOTIFY sip:8003@192.168.2.109:5060 SIP/2.0 Via: SIP/2.0/UDP 192.168.2.109:18627;branch=z9hG4bKcef7.91c1e716.0 To: &amp;lt;sip:8003@wdd.cc&amp;gt;;tag=1 From: &amp;lt;sip:9999@wdd.cc&amp;gt;;tag=d009-12c2f272e7622c1cd9b6aa285a7b9736 CSeq: 2 NOTIFY Call-ID: 1-774753@127.</description>
    </item>
    
    <item>
      <title>Load Balancing in OpenSIPS</title>
      <link>https://wdd.js.org/opensips/blog/load-balance/</link>
      <pubDate>Tue, 09 Mar 2021 17:52:04 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/load-balance/</guid>
      <description>https://opensips.org/Documentation/Tutorials-LoadBalancing-1-9
1. Load Balancing in OpenSIPS The &amp;ldquo;load-balancing&amp;rdquo; module comes to provide traffic routing based on load. Shortly, when OpenSIPS routes calls to a set of destinations, it is able to keep the load status (as number of ongoing calls) of each destination and to choose to route to the less loaded destination (at that moment). OpenSIPS is aware of the capacity of each destination - it is pre-configured with the maximum load accepted by the destinations.</description>
    </item>
    
    <item>
      <title>ACK 无法正常送到FS</title>
      <link>https://wdd.js.org/opensips/ch7/miss-ack/</link>
      <pubDate>Tue, 09 Mar 2021 17:10:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/miss-ack/</guid>
      <description>通过sngrep抓包发现，通话正常，ACK无法送到FS。导致通话一段时间后，FS因为没有收到ACK，就发送了BYE来挂断呼叫。
sngrep定位到问题可能出在OpenSIPS上，然后分析opensips的日志。
Mar 9 16:58:00 dd opensips[84]: ERROR:dialog:dlg_validate_dialog: failed to validate remote contact: dlg=[sip:9999@192.168.2.161:5080;transport=udp] , req =[sip:192.168.2.109:18627;lr;ftag=CX3CDinLARXn1ZRNIlPaFexgirQczdr7;did=4c1.a9657441] 上面的日志，提示问题出在dialog验证上，dialog验证失败的原因可能与contact头有关。
然后我有仔细的分析了一下SIP转包。发现contact中的ip地址192.168.2.161并不是fs的地址。但是它为什么会出现在fs回的200ok中呢？
这是我就想起了fs vars.xml，其中有几个参数是用来配置服务器的ip地址的。
由于我的fs是个树莓派，ip是自动分配的，重启之后，可能获取了新的ip。但是老的ip地址，还是存在于vars.xml中。
然后我就去排查了一下fs的var.xml， 发现下面三个参数都是192.168.2.161， 但是实际上树莓派的地址已经不是这个了。
bind_server_ip external_rtp_ip external_sip_ip 解决方案：改变fs vars.xml中的地址配置信息，然后重启fs。
除了fs的原因，还有一部分原因可能是错误的使用了fix_nated_contact。**务必记住：对于位于边界的SIP服务器来说，对于进入的SIP请求，一般需要fix_nated_contaced。对于这个请求的响应，则不需要进行nat处理。
深入思考一下，为什么concact头修改的错了，往往ack就会有问题呢？ 实际上ack请求的url部分，就是由响应消息的contact头的ulr部分。</description>
    </item>
    
    <item>
      <title>Cross-dialog data accessing</title>
      <link>https://wdd.js.org/opensips/blog/cross-dialog-data/</link>
      <pubDate>Thu, 11 Feb 2021 20:24:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/cross-dialog-data/</guid>
      <description>原文：https://blog.opensips.org/2020/05/18/cross-dialog-data-accessing/
There are several calling scenarios – typical Class V – where multiple SIP dialogs may be involved. And to make it work, you need, from one dialog, to access the data that belongs to another dialog. By data we mean here dialog specific data, like dialog variables, profiles or flags, and, even more, accounting data (yes, the accounting engine is so powerful that it ended be used for storing a lot of information during the calls).</description>
    </item>
    
    <item>
      <title>Dialog triggers, or how to control the calls from script</title>
      <link>https://wdd.js.org/opensips/blog/dialog-trigers/</link>
      <pubDate>Thu, 11 Feb 2021 20:23:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/dialog-trigers/</guid>
      <description>原文：https://blog.opensips.org/2020/05/26/dialog-triggers-or-how-to-control-the-calls-from-script/
The OpenSIPS script is a very powerful tool, both in terms of capabilities (statements, variables, transformations) and in terms of integration (support for DB, REST, Events and more).So why not using the OpenSIPS script (or the script routes) to interact and control your call, in order to build more complex services on top of the dialog support?For this purpose, OpenSIPS 3.1 introduces three new per-dialog triggers:
on_answer route, triggered when the dialog is answered; on_timeout route, triggered when the dialog is about to timeout; on_hangup route, triggered after the dialog was terminated.</description>
    </item>
    
    <item>
      <title>Calls management using the new Call API tool</title>
      <link>https://wdd.js.org/opensips/blog/calls-manager/</link>
      <pubDate>Thu, 11 Feb 2021 20:20:29 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/calls-manager/</guid>
      <description>看来OpenSIPS的目标已经不仅仅局限于做代理了，而是想做呼叫控制。
原文：https://blog.opensips.org/2020/06/11/calls-management-using-the-new-call-api-tool/
The new Call API project consists of a standalone server able to serve a set of API commands that can be used to control SIP calls (such as start a new call, put a call on hold, transfer it to a different destination, etc.). In order to provide high performance throughput, the server has been developed in Go programming language, and provides a WebSocket interface that is able to handle Json-RPC 2.</description>
    </item>
    
    <item>
      <title>Improved series-based call statistics using OpenSIPS 3.2</title>
      <link>https://wdd.js.org/opensips/blog/call-stat/</link>
      <pubDate>Thu, 11 Feb 2021 20:11:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/call-stat/</guid>
      <description>早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。
原文：https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/
Real-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use interface that exposes simple primitives for creating, updating, and displaying various statistics, both well defined as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read.</description>
    </item>
    
    <item>
      <title>Exploring SSL/TLS libraries for OpenSIPS 3.2</title>
      <link>https://wdd.js.org/opensips/blog/opensips3-tls/</link>
      <pubDate>Thu, 11 Feb 2021 20:04:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/opensips3-tls/</guid>
      <description>OpenSIPS和OpenSSL之间的集成总是存在各种个样的问题。我之前就遇到死锁的问题，opensips CPU cpu占用很高。但是不再处理SIP消息。最终排查下来，是和OpenSSL有关。 深层次的原因，是因为OpenSIPS是个多进程的程序，而OpenSSL主要是面向多线程的程序。 在OpenSIPS3.2版本上，官方团队列出了几个OpenSSL的替代品，并进行优劣对比，最终选择一个比较好的方案。 我们一起来看看吧。
For the purpose of providing secure SIP communication over the TLS protocol, OpenSIPS uses the OpenSSL library, the most popular TLS implementation across the Internet. However, integrating OpenSSL with OpenSIPS has posed a series of challenges starting with OpenSSL version 1.1.0, and has caused quite a few bugs and crashes since then, as presented in more detail in this article.As such, for the new OpenSIPS 3.</description>
    </item>
    
    <item>
      <title>SIP消息格式CRLF</title>
      <link>https://wdd.js.org/opensips/ch3/sip-crlf/</link>
      <pubDate>Fri, 25 Dec 2020 17:44:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/sip-crlf/</guid>
      <description> generic-message = start-line *message-header CRLF [ message-body ] start-line = Request-Line / Status-Line 其中在rfc2543中规定
CR = %d13 ; US-ASCII CR, carriage return character LF = %d10 ; US-ASCII LF, line feed character 项目 十进制 字符串表示 CR 13 \r LF 10 \n 也就是说在一个SIP消息中
headline\r\n key:v\r\n \r\n some_body\r\n 所以CRLF就是 \r\n 参考 https://tools.ietf.org/html/rfc3261 https://tools.ietf.org/html/rfc2543 </description>
    </item>
    
    <item>
      <title>The OpenSIPS and OpenSSL journey</title>
      <link>https://wdd.js.org/opensips/blog/openssl-opensips/</link>
      <pubDate>Mon, 21 Dec 2020 15:44:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/openssl-opensips/</guid>
      <description>In order to provide secure SIP communication over TLS connections, OpenSIPS uses the OpenSSL library, probably the most widely used open-source TLS &amp;amp; SSL library across the Internet. The fact that it is so popular and largely used makes it more robust, therefore a great choice to enforce security in a system! That was the reason it was chosen to be used in OpenSIPS in the first place. However, being designed as a multi-threaded library, while OpenSIPS is a multi-process application, integrating it was not an easy task.</description>
    </item>
    
    <item>
      <title>BLF指示灯</title>
      <link>https://wdd.js.org/opensips/ch9/blf/</link>
      <pubDate>Fri, 20 Nov 2020 15:45:56 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/blf/</guid>
      <description>What Is a Busy Lamp Field (BLF) and Why Do You Need It? Busy lamp field is a presence indicator that allows you to see who in your organization is available (or not) for a phone call at any given time.
The term “busy lamp field” sounds a bit more involved than it really is. Put simply, it just means the ability to see who in your organization is available or not for a phone call at any given time.</description>
    </item>
    
    <item>
      <title>siphub 轻量级实时SIP信令收包的服务</title>
      <link>https://wdd.js.org/opensips/tools/siphub/</link>
      <pubDate>Thu, 06 Aug 2020 11:19:01 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/siphub/</guid>
      <description>o我写siphub的原因是homer太难用了！！经常查不到想查的数据，查询的速度也很慢。
项目地址：https://github.com/wangduanduan/siphub
架构 SIP服务器例如OpenSIPS或者FS可以通过hep协议将数据写到siphub, siphub将数据规整之后写入MySql, siphub同时也提供Web页面来查询和展示SIP消息。 功能介绍 sip-hub是一个专注sip信令的搜索以及时序图可视化展示的服务。
相比于Homer, sip-hub做了大量的功能简化。同时也提供了一些个性化的查询，例如被叫后缀查询，仅域名查询等。
sip-hub服务仅有3个页面
sip消息搜索页面，用于按照主被叫、域名和时间范围搜索呼叫记录 时序图展示页面，用于展示SIP时序图和原始SIP消息 可以导入导出SIP消息 可以查找A-Leg 监控功能 大量简化搜索结果页面。siphub的搜索结果页面，每个callId相同的消息，只展示一条。 相关截图 搜索页面 siphub的搜索结果仅仅展示callId相同的最早的一条记录，这样就避免了像homer那种，看起来很多个消息，实际上都是属于一个INVITE的。 From字段和To字段都支持域名查询：@test.cc From字段也支持后缀查询，例如1234这种号码，可以只输入234就能查到，但是后缀要写完整，只查23是查不到的。 To字段仅仅支持精确查询 信令展示页面 点击对应的消息，详情也会自动跳转出来。 安装 首先需要安装MySql数据库，并在其中建立一个名为siphub的数据库 运行 dbHost 数据库地址 dbUser 数据库用户 dbName 数据库名 dataKeepDays 抓包保存天数 3000端口是web页面端口 9060是hep消息收取端口 docker run -d -p 3000:3000 -p 9060:9060/udp \ --env NODE_ENV=production \ --env dbHost=1.2.3.4 \ --env dbUser=root \ --env dbPwd=123456 \ --env dbName=siphub \ --env dataKeepDays=3 \ --name siphub wangduanduan/siphub 集成 OpenSIPS集成 test witch OpenSIPS 2.</description>
    </item>
    
    <item>
      <title>sipsak</title>
      <link>https://wdd.js.org/opensips/tools/sipsak/</link>
      <pubDate>Fri, 31 Jul 2020 19:16:36 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/sipsak/</guid>
      <description>sipsak is a command line tool which can send simple requests to a SIP server. It can run additional tests on a SIP server which are usefull for admins and developers of SIP enviroments.
https://github.com/nils-ohlmeier/sipsak
安装 apt-get install sipsak 发送options sipsak -vv -p 192.168.2.63:5060 -s sip:8001@test.cc man SIPSAK(1) User Manuals SIPSAK(1) NAME sipsak - a utility for various tests on sip servers and user agents SYNOPSIS sipsak [-dFGhiILnNMRSTUVvwz] [-a PASSWORD ] [-b NUMBER ] [-c SIPURI ] [-C SIPURI ] [-D NUMBER ] [-e NUMBER ] [-E STRING ] [-f FILE ] [-g STRING ] [-H HOSTNAME ] [-j STRING ] [-J STRING ] [-l PORT ] [-m NUMBER ] [-o NUMBER ] [-p HOSTNAME ] [-P NUMBER ] [-q REGEXP ] [-r PORT ] [-t NUMBER ] [-u STRING ] [-W NUMBER ] [-x NUMBER ] -s SIPURI DESCRIPTION sipsak is a SIP stress and diagnostics utility.</description>
    </item>
    
    <item>
      <title>[todo] db_mode调优</title>
      <link>https://wdd.js.org/opensips/ch5/db-mode/</link>
      <pubDate>Wed, 22 Jul 2020 14:25:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/db-mode/</guid>
      <description>opensips在多实例时，会有一些数据同步策略的问题。
～</description>
    </item>
    
    <item>
      <title>使用m4增强opensips.cfg脚本预处理能力</title>
      <link>https://wdd.js.org/opensips/ch5/m4/</link>
      <pubDate>Wed, 22 Jul 2020 14:16:17 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/m4/</guid>
      <description>相比于kamailo的脚本的预处理能力，opensips的脚本略显单薄。OpenSIPS官方也认识到了这一点，但是也并未准备如何提高这部分能力。因为OpenSIPS是想将预处理交给这方面的专家，也就是大名鼎鼎的m4(当然，你可能根本不知道m4是啥)。
举例来说 我们看一下opensips自带脚本的中的一小块。 里面就有三个要配置的地方
这个listen的地址： listen=udp:127.0.0.1:5060 数据库地址的配置：modparam(&amp;ldquo;usrloc&amp;rdquo;, &amp;ldquo;db_url&amp;rdquo;, &amp;ldquo;dbdriver://username:password@dbhost/dbname&amp;rdquo;) 数据库地址的配置：modparam(&amp;ldquo;acc&amp;rdquo;, &amp;ldquo;db_url&amp;rdquo;, &amp;ldquo;mysql://user:password@localhost/opensips&amp;rdquo;) auto_aliases=no listen=udp:127.0.0.1:5060 # CUSTOMIZE ME mpath=&amp;#34;/usr/local//lib/opensips/modules/&amp;#34; loadmodule &amp;#34;usrloc.so&amp;#34; modparam(&amp;#34;usrloc&amp;#34;, &amp;#34;db_url&amp;#34;, &amp;#34;dbdriver://username:password@dbhost/dbname&amp;#34;) modparam(&amp;#34;acc&amp;#34;, &amp;#34;early_media&amp;#34;, 0) modparam(&amp;#34;acc&amp;#34;, &amp;#34;report_cancels&amp;#34;, 0) modparam(&amp;#34;acc&amp;#34;, &amp;#34;detect_direction&amp;#34;, 0) modparam(&amp;#34;acc&amp;#34;, &amp;#34;db_url&amp;#34;, &amp;#34;mysql://user:password@localhost/opensips&amp;#34;) 随着脚本代码的增多，各种配置往往越来越多。真是脚本里，配置的地方远远不止三处！
你开发了OpenSIPS的脚本，但是真正部署的服务的可能是其他人。那么其他拿到你的脚本的时候，他们怎么知道要改哪些地方呢，难道要搜索一下，所有出现#CUSTOMIZE ME的地方就是需要配置的？ 难道他们每次部署一个服务，就要改一遍脚本的内容？ 改错了谁负责？
如果你不想被运维人员在背后骂娘，就不要把配置性的数据写死到脚本里！
如果你不想在打游戏的时候被运维人员点电话问这个配置出错应该怎么解决，就不要把配置型数据写死到脚本里！
** 那么，你就需要用到M4**
什么是M4？ M4是一种宏语言，如果你不清楚什么是宏，你就可以把M4想想成一种字符串替换的工具。
如何安装M4? 大部分Linux上都已经默认安装了m4, 你可以用m4 --version检查一下m4是否已经存在。
m4 --version Copyright © 2021 Free Software Foundation, Inc. GPLv3+ 许可证: GNU 通用公共许可证第三版或更高版本 &amp;lt;https://gnu.org/licenses/gpl.html&amp;gt;。 这是自由软件: 您可自由更改并重新分发它。 在法律所允许的范围内，不附带任何担保条款。 如果不存在的话，可以用对应常用的包管理工具来安装，例如
apt-get install m4 能否举个m4例子？ hello-world.</description>
    </item>
    
    <item>
      <title>SIP bridging over multiple interfaces</title>
      <link>https://wdd.js.org/opensips/blog/mutltiple-interface/</link>
      <pubDate>Thu, 16 Jul 2020 14:20:50 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/mutltiple-interface/</guid>
      <description>There are scenarios where you need OpenSIPS to route SIP traffic across more than one IP interface. Such a typical scenario is where OpenSIPS is required to perform bridging. The bridging may be between different IP networks (like public versus private, IPv4 versus IPv6) or between different transport protocols for SIP (like UDP versus TCP versus TLS).So, how do we switch to a different outbound interface in OpenSIPS ?
Auto detection OpenSIPS has a built in automatic way of picking up the right outbound interface, the so called “Multi homed” support or shortly “mhomed”, controlled by the mhomed core parameter.</description>
    </item>
    
    <item>
      <title>通话质量差</title>
      <link>https://wdd.js.org/opensips/ch7/poor-quality/</link>
      <pubDate>Wed, 08 Jul 2020 18:50:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/poor-quality/</guid>
      <description>通话质量差，一般可能以下因素有关。
媒体服务器或者媒体代理服务器CPU, 内存异常 通信网络差 中继或者网关送过来的本来音质就不好。 解决思路：
这个需要监控媒体服务器或者媒体代理CPU，内存是否正常 也可以在媒体代理上用tupdump抓包，然后用wireshark分析 调听服务端的录音，看看服务端录音是否也存在音质差的问题 </description>
    </item>
    
    <item>
      <title>一方听不到另外一方的声音</title>
      <link>https://wdd.js.org/opensips/ch7/one-leg-audio/</link>
      <pubDate>Wed, 08 Jul 2020 18:49:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/one-leg-audio/</guid>
      <description> 这个问题很大可能和和SDP没有正确修改有关。需要排查SIP信令的sdp地址是否正确。 防火墙策略问题：有的网络允许udp出去，但是不允许udp进来。需要设置防火墙策略。 udp端口范围太小。一般一个通话需要占用4个udp端口。如果开放的udp端口太少，在通话达到一定数量后，就会出现一部分呼叫没有可用端口。 用户设备的问题。例如用户的电脑声卡或者扬声器出现问题。 由于网络的复杂性，还有很多可能 一般遇到这个问题，可以按照如下的思路排查：
服务端有录音功能的，可以先在服务端听录音，看看服务端录音里是否正常。一般来说有四种情况。 两方的录音都没有 主叫方有，被叫方没有 被叫方有，主叫方没有 主被叫都有。但是就是一方听不到另一方。 通过排查服务端的录音，就可以大致知道到底是AB两个leg, 每个leg上的语音流收发的情况。
从信令的的sdp中分析，这个需要一定的SIP协议的分析能力。有些时候，sdp里面的媒体地址不正确，也会导致媒体流无法正常首发。 NAT策略。NAT一般有四种，用的比较多的是端口限制型。这种NAT要求外网流量在进入NAT内部时，必需先有内部的流量出去。当内部流量出去之后，这个NAT洞才会出现，外部的流量才能从这个洞进入。如果NAT内部设备一直不发送rtp包，那么外部的流量即使进来，也会被防火墙拦截掉。 无论是运维人员还是开发人员，在遇到媒体流问题时，一定要先搞清楚整个软交换的网络拓扑架构。否则只能南辕北辙。 sngrep -cr, 加上r这个参数，可以实时观察媒体流的流动情况。是个非常好的功能。但是对于那种加密的媒体流，sngrep是抓不到的，这点要注意。常见的WebRTC的媒体流就是加密的。 最终如果还是解决不了，那么只能祭出最后的杀器：tcpdump + wireshark。服务端抓包的话，虽然sngrep可以抓包，但是比较浪费内存还可能会出现丢包。最好用tcpdump抓包成文件，然后在wireshark上分析。 </description>
    </item>
    
    <item>
      <title>30秒自动挂断</title>
      <link>https://wdd.js.org/opensips/ch7/30-seconds-drop/</link>
      <pubDate>Wed, 08 Jul 2020 18:47:06 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/30-seconds-drop/</guid>
      <description>在通话接近30秒时，呼叫自动挂断。
有很大的可能和丢失了ACK有关。这个需要用sngrep去抓包看SIP时序图来确定是否是ACK丢失。
丢失ACK的原因很大可能是NAT没有处理好，或者是网络协议不匹配等等。</description>
    </item>
    
    <item>
      <title>媒体路径与信令路径</title>
      <link>https://wdd.js.org/opensips/ch1/sip-rtp-path/</link>
      <pubDate>Wed, 24 Jun 2020 09:11:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-rtp-path/</guid>
      <description>一般的sip网关同时具有信令和媒体处理的能力，如下图。
但是也有信令和媒体分开的网关。在和网关信令交互过程中，网关会将媒体地址放到sdp中。
难点就来了，在nat存在的场景下，你并不知道sdp里的媒体地址是否是真实的地址。
那么你就要选择，是相信sdp中的媒体地址，还是把sip信令的源ip作为媒体地址呢？</description>
    </item>
    
    <item>
      <title>媒体协商 offer/answer模型</title>
      <link>https://wdd.js.org/opensips/ch1/offer-answer/</link>
      <pubDate>Wed, 24 Jun 2020 08:51:48 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/offer-answer/</guid>
      <description>1. 简介 媒体协商用来交换呼叫双方的媒体能力。如
支持的编码类型有哪些 采样频率是多少 媒体端口，ip 信息 &amp;hellip; 媒体协商使用的是请求和应答模型。即一方向另一方发送含有 sdp 信息的消息，然后另一方更具对方提供的编码以及自己支持的编码，如果协商成功，则将协商后的消息 sdp 再次发送给对方。
2. 常见的几个协商方式 2.1 在 INVITE 中 offer 2.2 在 200 OK 中 offer 2.3 在 UPDATE 中 offer 2.4 在 PRACK 中 offer 3. 常见的几个问题 一般呼叫到中继测时，中继回的 183 信令是会携带 sdp 信息的 一般打到分机时，分机回的 180 信令是没有 sdp 信息的 不要先入为主的认为，某些请求一定带有 sdp，某些请求一定没有 sdp。而应当去测试请求或者响应消息上有没有携带 sdp 信息。
携带 sdp 信息的 sip 消息会出现下面的头
Content-Type: application/sdp </description>
    </item>
    
    <item>
      <title>wireshark 播放抓包文件</title>
      <link>https://wdd.js.org/opensips/tools/wireshark-player-pcap/</link>
      <pubDate>Tue, 23 Jun 2020 18:00:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/wireshark-player-pcap/</guid>
      <description>Decode As Udp wireshark 有时候并不能把udp包识别为rtp包，所以这边可能需要手动设置解码方式</description>
    </item>
    
    <item>
      <title>acc呼叫记录模块</title>
      <link>https://wdd.js.org/opensips/ch6/acc/</link>
      <pubDate>Fri, 29 May 2020 09:35:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/acc/</guid>
      <description>opensips 1.x 使用各种flag去设置一个呼叫是否需要记录。从opensips 2.2开始，不再使用flag的方式，而使用 do_accounting() 函数去标记是否需要记录呼叫。
注意 do_accounting()函数并不是收到SIP消息后立即写呼叫记录，也仅仅是做一个标记。实际的写数据库或者写日志发生在事务或者dialog完成的时候。</description>
    </item>
    
    <item>
      <title>serial_183</title>
      <link>https://wdd.js.org/opensips/ch8/serial-183/</link>
      <pubDate>Thu, 28 May 2020 10:01:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/serial-183/</guid>
      <description># # this example shows how to use forking on failure # log_level=3 log_stderror=1 listen=192.168.2.16 # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; # Uncomment this if you want to use SQL database loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;maxfwd.so&amp;#34; # ------------------------- request routing logic ------------------- # main routing logic route{ # initial sanity checks -- messages with # max_forwards==0, or excessively long requests if (!mf_process_maxfwd_header(&amp;#34;10&amp;#34;)) { sl_send_reply(&amp;#34;483&amp;#34;,&amp;#34;Too Many Hops&amp;#34;); exit; }; if ($ml &amp;gt;= 2048 ) { sl_send_reply(&amp;#34;513&amp;#34;, &amp;#34;Message too big&amp;#34;); exit; }; # skip register for testing purposes if (is_methos(&amp;#34;REGISTER&amp;#34;)) { sl_send_reply(&amp;#34;200&amp;#34;, &amp;#34;ok&amp;#34;); exit; }; if (is_method(&amp;#34;INVITE&amp;#34;)) { seturi(&amp;#34;sip:xxx@192.</description>
    </item>
    
    <item>
      <title>replicate</title>
      <link>https://wdd.js.org/opensips/ch8/replicate/</link>
      <pubDate>Thu, 28 May 2020 10:01:28 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/replicate/</guid>
      <description># # demo script showing how to set-up usrloc replication # # ----------- global configuration parameters ------------------------ log_level=3 # logging level (cmd line: -dddddddddd) log_stderror=yes # (cmd line: -E) # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;db_mysql.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;maxfwd.so&amp;#34; loadmodule &amp;#34;usrloc.so&amp;#34; loadmodule &amp;#34;registrar.so&amp;#34; loadmodule &amp;#34;auth.so&amp;#34; loadmodule &amp;#34;auth_db.so&amp;#34; # ----------------- setting module-specific parameters --------------- # digest generation secret; use the same in backup server; # also, make sure that the backup server has sync&amp;#39;ed time modparam(&amp;#34;auth&amp;#34;, &amp;#34;secret&amp;#34;, &amp;#34;alsdkhglaksdhfkloiwr&amp;#34;) # ------------------------- request routing logic ------------------- # main routing logic route{ # initial sanity checks -- messages with # max_forwars==0, or excessively long requests if (!</description>
    </item>
    
    <item>
      <title>redirect</title>
      <link>https://wdd.js.org/opensips/ch8/redirect/</link>
      <pubDate>Thu, 28 May 2020 10:01:07 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/redirect/</guid>
      <description># # $Id$ # # this example shows use of ser as stateless redirect server # # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; # ------------------------- request routing logic ------------------- # main routing logic route{ # for testing purposes, simply okay all REGISTERs if ($rm==&amp;#34;REGISTER&amp;#34;) { log(&amp;#34;REGISTER&amp;#34;); sl_send_reply(&amp;#34;200&amp;#34;, &amp;#34;ok&amp;#34;); return; }; # rewrite current URI, which is always part of destination ser rewriteuri(&amp;#34;sip:parallel@siphub.net:9&amp;#34;); # append one more URI to the destination ser append_branch(&amp;#34;sip:redirect@siphub.</description>
    </item>
    
    <item>
      <title>pstn</title>
      <link>https://wdd.js.org/opensips/ch8/pstn/</link>
      <pubDate>Thu, 28 May 2020 10:00:46 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/pstn/</guid>
      <description># # $Id$ # # example: ser configured as PSTN gateway guard; PSTN gateway is located # at 192.168.0.10 # # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;acc.so&amp;#34; loadmodule &amp;#34;rr.so&amp;#34; loadmodule &amp;#34;maxfwd.so&amp;#34; loadmodule &amp;#34;db_mysql.so&amp;#34; loadmodule &amp;#34;auth.so&amp;#34; loadmodule &amp;#34;auth_db.so&amp;#34; loadmodule &amp;#34;group.so&amp;#34; loadmodule &amp;#34;uri.so&amp;#34; # ----------------- setting module-specific parameters --------------- modparam(&amp;#34;auth_db&amp;#34;, &amp;#34;db_url&amp;#34;,&amp;#34;mysql://opensips:opensipsrw@localhost/opensips&amp;#34;) modparam(&amp;#34;auth_db&amp;#34;, &amp;#34;calculate_ha1&amp;#34;, yes) modparam(&amp;#34;auth_db&amp;#34;, &amp;#34;password_column&amp;#34;, &amp;#34;password&amp;#34;) # -- acc params -- modparam(&amp;#34;acc&amp;#34;, &amp;#34;log_level&amp;#34;, 1) # that is the flag for which we will account -- don&amp;#39;t forget to # set the same one :-) modparam(&amp;#34;acc&amp;#34;, &amp;#34;log_flag&amp;#34;, 1 ) # ------------------------- request routing logic ------------------- # main routing logic route{ /* ********* ROUTINE CHECKS ********************************** */ # filter too old messages if (!</description>
    </item>
    
    <item>
      <title>nathelper</title>
      <link>https://wdd.js.org/opensips/ch8/nathelper/</link>
      <pubDate>Thu, 28 May 2020 10:00:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/nathelper/</guid>
      <description># # simple quick-start config script including nathelper support # This default script includes nathelper support. To make it work # you will also have to install Maxim&amp;#39;s RTP proxy. The proxy is enforced # if one of the parties is behind a NAT. # # If you have an endpoing in the public internet which is known to # support symmetric RTP (Cisco PSTN gateway or voicemail, for example), # then you don&amp;#39;t have to force RTP proxy.</description>
    </item>
    
    <item>
      <title>msilo</title>
      <link>https://wdd.js.org/opensips/ch8/msilo/</link>
      <pubDate>Thu, 28 May 2020 10:00:04 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/msilo/</guid>
      <description># # MSILO usage example # # $ID: daniel $ # children=2 check_via=no # (cmd. line: -v) dns=off # (cmd. line: -r) rev_dns=off # (cmd. line: -R) # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;textops.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;db_mysql.so&amp;#34; loadmodule &amp;#34;maxfwd.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;usrloc.so&amp;#34; loadmodule &amp;#34;registrar.so&amp;#34; loadmodule &amp;#34;msilo.so&amp;#34; # ----------------- setting module-specific parameters --------------- # -- registrar params -- modparam(&amp;#34;registrar&amp;#34;, &amp;#34;default_expires&amp;#34;, 120) # -- usrloc params -- modparam(&amp;#34;usrloc&amp;#34;, &amp;#34;db_mode&amp;#34;, 0) # -- msilo params -- modparam(&amp;#34;msilo&amp;#34;, &amp;#34;db_url&amp;#34;, &amp;#34;mysql://opensips:opensipsrw@localhost/opensips&amp;#34;) # -- tm params -- modparam(&amp;#34;tm&amp;#34;, &amp;#34;fr_timer&amp;#34;, 10 ) modparam(&amp;#34;tm&amp;#34;, &amp;#34;fr_inv_timer&amp;#34;, 15 ) modparam(&amp;#34;tm&amp;#34;, &amp;#34;wt_timer&amp;#34;, 10 ) route{ if ( !</description>
    </item>
    
    <item>
      <title>loggin</title>
      <link>https://wdd.js.org/opensips/ch8/logging/</link>
      <pubDate>Thu, 28 May 2020 09:59:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/logging/</guid>
      <description># # logging example # # ------------------ module loading ---------------------------------- port=5060 log_stderror=yes log_level=3 # ------------------------- request routing logic ------------------- # main routing logic route{ # for testing purposes, simply okay all REGISTERs if (is_method(&amp;#34;REGISTER&amp;#34;)) { log(1, &amp;#34;REGISTER received\n&amp;#34;); } else { log(1, &amp;#34;non-REGISTER received\n&amp;#34;); }; if ($ru=~&amp;#34;sip:.*[@:]siphub.net&amp;#34;) { xlog(&amp;#34;request for siphub.net received\n&amp;#34;); } else { xlog(&amp;#34;request for other domain [$rd] received\n&amp;#34;); }; } </description>
    </item>
    
    <item>
      <title>httpd</title>
      <link>https://wdd.js.org/opensips/ch8/httpd/</link>
      <pubDate>Thu, 28 May 2020 09:59:25 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/httpd/</guid>
      <description># # $Id$ # # this example shows use of opensips&amp;#39;s provisioning interface # # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib64/opensips/modules/&amp;#34; loadmodule &amp;#34;db_mysql.so&amp;#34; loadmodule &amp;#34;httpd.so&amp;#34; modparam(&amp;#34;httpd&amp;#34;, &amp;#34;port&amp;#34;, 8888) loadmodule &amp;#34;mi_http.so&amp;#34; loadmodule &amp;#34;pi_http.so&amp;#34; modparam(&amp;#34;pi_http&amp;#34;, &amp;#34;framework&amp;#34;, &amp;#34;/usr/local/src/opensips/examples/pi_framework.xml&amp;#34;) loadmodule &amp;#34;mi_xmlrpc_ng.so&amp;#34; # ------------------------- request routing logic ------------------- # main routing logic route{ exit; } </description>
    </item>
    
    <item>
      <title>flag_reply</title>
      <link>https://wdd.js.org/opensips/ch8/flag-reply/</link>
      <pubDate>Thu, 28 May 2020 09:58:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/flag-reply/</guid>
      <description># # simple quick-start config script # # ----------- global configuration parameters ------------------------ log_level=3 # logging level (cmd line: -dddddddddd) log_stderror=no # (cmd line: -E) check_via=no	# (cmd. line: -v) dns=no # (cmd. line: -r) rev_dns=no # (cmd. line: -R) children=4 port=5060 # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; # Uncomment this if you want to use SQL database #loadmodule &amp;#34;db_mysql.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;rr.so&amp;#34; loadmodule &amp;#34;maxfwd.</description>
    </item>
    
    <item>
      <title>exec</title>
      <link>https://wdd.js.org/opensips/ch8/exec/</link>
      <pubDate>Thu, 28 May 2020 09:58:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/exec/</guid>
      <description># # $Id$ # # simple quick-start config script # # ----------- global configuration parameters ------------------------ #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;usrloc.so&amp;#34; loadmodule &amp;#34;registrar.so&amp;#34; loadmodule &amp;#34;exec.so&amp;#34; # ----------------- setting module-specific parameters --------------- route{ # uri for my domain ? if (is_myself(&amp;#34;$rd&amp;#34;)) { if ($rm==&amp;#34;REGISTER&amp;#34;) { save(&amp;#34;location&amp;#34;); return; }; # native SIP destinations are handled using our USRLOC DB if (!lookup(&amp;#34;location&amp;#34;)) { # proceed to email notification if ($rm==&amp;#34;INVITE&amp;#34;) route(1) else sl_send_reply(&amp;#34;404&amp;#34;, &amp;#34;Not Found&amp;#34;); exit; }; }; # user found, forward to his current uri now if (!</description>
    </item>
    
    <item>
      <title>acc</title>
      <link>https://wdd.js.org/opensips/ch8/acc/</link>
      <pubDate>Thu, 28 May 2020 09:57:46 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/acc/</guid>
      <description># # $Id$ # # example: accounting calls to nummerical destinations # # ------------------ module loading ---------------------------------- #set module path mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;acc.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;maxfwd.so&amp;#34; loadmodule &amp;#34;rr.so&amp;#34; # ----------------- setting module-specific parameters --------------- # -- acc params -- # set the reporting log level modparam(&amp;#34;acc&amp;#34;, &amp;#34;log_level&amp;#34;, 1) # number of flag, which will be used for accounting; if a message is # labeled with this flag, its completion status will be reported modparam(&amp;#34;acc&amp;#34;, &amp;#34;log_flag&amp;#34;, 1 ) # ------------------------- request routing logic ------------------- # main routing logic route{ /* ********* ROUTINE CHECKS ********************************** */ # filter too old messages if (!</description>
    </item>
    
    <item>
      <title>acc-mysql</title>
      <link>https://wdd.js.org/opensips/ch8/acc-mysql/</link>
      <pubDate>Thu, 28 May 2020 09:57:04 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/acc-mysql/</guid>
      <description># # Sample config for MySQL accouting with OpenSIPS # # - db_mysql module must be compiled and installed # # - new columns have to be added since by default only few are recorded # - here are full SQL statements to create acc and missed_calls tables # # CREATE TABLE `acc` ( # `id` int(10) unsigned NOT NULL auto_increment, # `method` varchar(16) NOT NULL default &amp;#39;&amp;#39;, # `from_tag` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `to_tag` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `callid` varchar(128) NOT NULL default &amp;#39;&amp;#39;, # `sip_code` char(3) NOT NULL default &amp;#39;&amp;#39;, # `sip_reason` varchar(32) NOT NULL default &amp;#39;&amp;#39;, # `time` datetime NOT NULL default &amp;#39;0000-00-00 00:00:00&amp;#39;, # `src_ip` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `dst_user` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `dst_domain` varchar(128) NOT NULL default &amp;#39;&amp;#39;, # `src_user` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `src_domain` varchar(128) NOT NULL default &amp;#39;&amp;#39;, # INDEX acc_callid (`callid`), # PRIMARY KEY (`id`) # ); # # CREATE TABLE `missed_calls` ( # `id` int(10) unsigned NOT NULL auto_increment, # `method` varchar(16) NOT NULL default &amp;#39;&amp;#39;, # `from_tag` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `to_tag` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `callid` varchar(128) NOT NULL default &amp;#39;&amp;#39;, # `sip_code` char(3) NOT NULL default &amp;#39;&amp;#39;, # `sip_reason` varchar(32) NOT NULL default &amp;#39;&amp;#39;, # `time` datetime NOT NULL default &amp;#39;0000-00-00 00:00:00&amp;#39;, # `src_ip` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `dst_user` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `dst_domain` varchar(128) NOT NULL default &amp;#39;&amp;#39;, # `src_user` varchar(64) NOT NULL default &amp;#39;&amp;#39;, # `src_domain` varchar(128) NOT NULL default &amp;#39;&amp;#39;, # INDEX acc_callid (`callid`), # PRIMARY KEY (`id`) # ); # # # ----------- global configuration parameters ------------------------ log_level=3 # debug level (cmd line: -dddddddddd) log_stderror=no # (cmd line: -E) /* Uncomment these lines to enter debugging mode */ #debug_mode=yes check_via=no	# (cmd.</description>
    </item>
    
    <item>
      <title>script_trace 打印opensips的脚本执行过程</title>
      <link>https://wdd.js.org/opensips/ch7/cfg-trace/</link>
      <pubDate>Wed, 27 May 2020 16:54:47 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/cfg-trace/</guid>
      <description>script_trace是核心函数，不需要引入模块。
script_trace([log_level, pv_format_string[, info_string]]) This function start the script tracing - this helps to better understand the flow of execution in the OpenSIPS script, like what function is executed, what line it is, etc. Moreover, you can also trace the values of pseudo-variables, as script execution progresses. The blocks of the script where script tracing is enabled will print a line for each individual action that is done (e.g. assignments, conditional tests, module functions, core functions, etc.</description>
    </item>
    
    <item>
      <title>负载均衡模块load_balance</title>
      <link>https://wdd.js.org/opensips/ch6/load-balance/</link>
      <pubDate>Tue, 19 May 2020 09:42:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/load-balance/</guid>
      <description> 负载均衡只能均衡INVITE, 不能均衡REGISTER请求。因为load_blance底层是使用dialog模块去跟踪目标地址的负载情况。 load_balance方法会改变INVITE的$du, 而不会修改SIP URL 呼叫结束的时候，目标地址的负载会自动释放 选择逻辑 网关A 网关B 通道数 30 60 正在使用的通道数 20 55 空闲通道数 10 5 load_balance是会先选择最大可用资源的目标地址。假如A网关的最大并发呼叫是30， B网关最大并发呼叫是60。在某个时刻，A网关上已经有20和呼叫了, B网关上已经有55个呼叫。 此时load_balance会优先选择网关A。
参考 https://opensips.org/Documentation/Tutorials-LoadBalancing-1-9 </description>
    </item>
    
    <item>
      <title>rtpproxy录音</title>
      <link>https://wdd.js.org/opensips/ch4/rtp-record/</link>
      <pubDate>Thu, 14 May 2020 16:13:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/rtp-record/</guid>
      <description>-a -R -r /recording -S spool -P -a 所有的通话都录音 -R 不要把RTCP也写文件 -r 指定录音文件的位置 -S 临时文件的位置，注意不要和录音文件位置相同 -P 录成pcap文件的格式，而不要录成默认的 Ad-hoc的模式 </description>
    </item>
    
    <item>
      <title>另一个功能强大的sip server: kamailio</title>
      <link>https://wdd.js.org/opensips/tools/kamailio/</link>
      <pubDate>Tue, 12 May 2020 15:43:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/kamailio/</guid>
      <description>之前我写过OpenSIPS的文章，所以在学习Kamailio是，会尝试和OpenSIPS做对比。
从下图可以看出，Kamailio和Opensips算是同根同源了。很多语法、伪变量、模块使用方式，两者都极为相似。
不一样的点 然而总体来说，kamailio相比OpenSIPS，更加灵活。 如果有机会，尝试下kamailio也未尝不可。而且kamailio的git start数量比OpenSIPS多很多，而且issue也比OpenSIPS少。
Kamailio 有wiki社区，注册之后，可以来编辑文档，相比于OpenSIPS只有官方文档，kamailio显得更容易让人亲近，提高了用户的参与度。 脚本上 kamailio支持三种不同的注释风格，opensips只支持一种 kamailio支持类似c语言的宏定义的方式写脚本，因而kamailio的脚本可以不借助外部工具的情况下，写的非常灵活。可以参考 https://www.kamailio.org/wiki/cookbooks/5.5.x/core 的define部分 代码质量上 我觉得也是kaimailio也是更胜一筹，至少kamailioo还做了c的单元测试 总体而言，如果你要是第一次来选择，我更希望你用kamailio作为sip服务器。我之所以用OpenSIPS只不过是路径依赖而已。
但是如果你学会了OpenSIPS, 那你学习kamailio就会非常轻松。
参考 https://weekly-geekly.github.io/articles/150280/index.html https://github.com/kamailio/kamailio https://www.kamailio.org/wiki/ </description>
    </item>
    
    <item>
      <title>回音问题调研</title>
      <link>https://wdd.js.org/opensips/ch7/echo-back/</link>
      <pubDate>Wed, 22 Apr 2020 15:12:11 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/echo-back/</guid>
      <description> 回音现象 说话人能在麦克风中听到自己的说话声。
回音的可能原因 有的开发，喜欢用分机打自己的号码，你分机和你的手机离得太近，自然回产生回音的。 参考资料 http://www.voiptroubleshooter.com/problems/echo.html https://www.lifewire.com/how-to-stop-producing-echo-3426515 https://www.voipmechanic.com/voip-top-5-complaints.htm https://getvoip.com/blog/2012/12/18/the-biggest-causes-behind-echo-in-voip/ https://blog.csdn.net/huoppo/article/details/6643066 </description>
    </item>
    
    <item>
      <title>漫话NAT的历史todo</title>
      <link>https://wdd.js.org/opensips/ch1/story-of-nat/</link>
      <pubDate>Fri, 10 Apr 2020 13:18:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/story-of-nat/</guid>
      <description>设想一下，如果国家规定，给孩子起名字的时候，不能和已经使用过的活着的人名字相同，会发生什么事情？
除非把名字起得越来越长，否则名字很快就不够用了。
在 1993 年的时候，有人就遇到类似的问题，因为 IP 地址快被用完了。
他们想出两个方案：
短期方案：CIDR(Classless InterDomain Routing) 长期方案：开发新的具有更大地址空间的互联网协议。可以认为是目前的 IPv6 当然了长期方案不是一蹴而就的，短期方案才是解决眼前问题的方案。
a very small percentage of hosts in a stub domain are communicating outside of the domain at any given time
短期的方案基于一个逻辑事实：在一个网络中，只有非常少的几个主机需要跟外部网络交流。也就是说，大部分的主机都在内部交流。那么内部交流的这些主机，实际上并不需要给设置公网 IP。（但是这个只是 1993 年的那个时期的事实）**可以类比于，班级内部之间的学生交流很多。班级与班级之间的交流，估计只有班长之间交流。
参考 https://tools.ietf.org/html/rfc1631 https://tools.ietf.org/html/rfc1996 https://tools.ietf.org/html/rfc2663 https://tools.ietf.org/html/rfc2993 </description>
    </item>
    
    <item>
      <title>CANCEL请求和Reason头</title>
      <link>https://wdd.js.org/opensips/blog/cancel-reason/</link>
      <pubDate>Fri, 10 Apr 2020 10:21:36 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/cancel-reason/</guid>
      <description>原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/
Call canceling may look like a trivial mechanism, but it plays an important role in complex scenarios like simultaneous ringing (parallel forking), call pickup, call redirect and many others. So, aside proper routing of CANCEL requests, reporting the right cancelling reason is equally important.
如何正确的处理cancel请求？ According to RFC 3261,** a CANCEL must be route to the exact same destination (IP, port, protocol) and with the same exact Request-URI as the INVITE it is canceling**.</description>
    </item>
    
    <item>
      <title>默认脚本</title>
      <link>https://wdd.js.org/opensips/ch8/default/</link>
      <pubDate>Tue, 07 Apr 2020 13:18:04 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/default/</guid>
      <description># # OpenSIPS residential configuration script # by OpenSIPS Solutions &amp;lt;team@opensips-solutions.com&amp;gt; # # This script was generated via &amp;#34;make menuconfig&amp;#34;, from # the &amp;#34;Residential&amp;#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # http://www.opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### log_level=3 log_stderror=no log_facility=LOG_LOCAL0 children=4 /* uncomment the following lines to enable debugging */ #debug_mode=yes /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes /* comment the next line to enable the auto discovery of local aliases based on reverse DNS on IPs */ auto_aliases=no listen=udp:127.</description>
    </item>
    
    <item>
      <title>Wireshark SIP 抓包</title>
      <link>https://wdd.js.org/opensips/tools/wireshark-sip/</link>
      <pubDate>Mon, 09 Mar 2020 12:19:37 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/wireshark-sip/</guid>
      <description>1. 打开wireshark，并选择网卡 在过滤条件中输入sip 2. 选择电话-&amp;gt; VoIP Calls 3. 选中一条呼叫记录-&amp;gt;然后点击 Flow Sequence 4. 查看消息的详情 </description>
    </item>
    
    <item>
      <title>ISUP SIP ISDN对照码表</title>
      <link>https://wdd.js.org/opensips/ch9/isup-sip-isdn/</link>
      <pubDate>Thu, 20 Feb 2020 22:34:47 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/isup-sip-isdn/</guid>
      <description>ISUP to SIP ISUP Cause Value SIP Response Normal event 1 – unallocated number 404 Not Found 2 – no route to network 404 Not Found 3 – no route to destination 404 Not Found 16 – normal call clearing &amp;mdash; (*) 17 – user busy 486 Busy here 18 – no user responding 408 Request Timeout 19 – no answer from the user 480 Temporarily unavailable 20 – subscriber absent 480 Temporarily unavailable 21 – call rejected 403 Forbidden (+) 22 – number changed (s/o diagnostic) 410 Gone 23 – redirection to new destination 410 Gone 26 – non-selected user clearing 404 Not Found (=) 27 – destination out of order 502 Bad Gateway 28 – address incomplete 484 Address incomplete 29 – facility rejected 510 Not implemented 31 – normal unspecified 480 Temporarily unavailable Resource unavailable 34 – no circuit available 503 Service unavailable 38 – network out of order 503 Service unavailable 41 – temporary failure 503 Service unavailable 42 – switching equipment congestion 503 Service unavailable 47 – resource unavailable 503 Service unavailable Service or option not available 55 – incoming calls barred within CUG 403 Forbidden 57 – bearer capability not authorized 403 Forbidden 58 – bearer capability not presently available 503 Service unavailable 65 – bearer capability not implemented 488 Not Acceptable here 70 – Only restricted digital information bearer capability is available (National use) 488 Not Acceptable here 79 – service or option not implemented 501 Not implemented Invalid message 87 – user not member of CUG 403 Forbidden 88 – incompatible destination 503 Service unavailable 102 – Call Setup Time-out Failure 504 Gateway timeout 111 – Protocol Error Unspecified 500 Server internal error Interworking 127 – Internal Error - interworking unspecified 500 Server internal error (*) ISDN Cause 16 will usually result in a BYE or CANCEL(+) If the cause location is user then the 6xx code could be given rather than the 4xx code.</description>
    </item>
    
    <item>
      <title>rtpengine</title>
      <link>https://wdd.js.org/opensips/ch9/rtpengine-manu/</link>
      <pubDate>Thu, 20 Feb 2020 10:28:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/rtpengine-manu/</guid>
      <description>帮助文档 Usage: rtpengine [OPTION...] - next-generation media proxy Application Options: -v, &amp;ndash;version Print build time and exit &amp;ndash;config-file=FILE Load config from this file &amp;ndash;config-section=STRING Config file section to use &amp;ndash;log-facility=daemon|local0|&amp;hellip;|local7 Syslog facility to use for logging **-L, &amp;ndash;log-level=INT ** Mask log priorities above this level 取值从0-7， 7 debug 6 info 5 notice **-E, &amp;ndash;log-stderr ** Log on stderr instead of syslog &amp;ndash;no-log-timestamps Drop timestamps from log lines to stderr &amp;ndash;log-mark-prefix Prefix for sensitive log info &amp;ndash;log-mark-suffix Suffix for sensitive log info **-p, &amp;ndash;pidfile=FILE ** Write PID to file **-f, &amp;ndash;foreground ** Don&amp;rsquo;t fork to background -t, &amp;ndash;table=INT Kernel table to use -F, &amp;ndash;no-fallback Only start when kernel module is available **-i, &amp;ndash;interface=[NAME/]IP[!</description>
    </item>
    
    <item>
      <title>深入理解SIP ACK 方法</title>
      <link>https://wdd.js.org/opensips/ch1/sip-ack/</link>
      <pubDate>Wed, 19 Feb 2020 19:17:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-ack/</guid>
      <description>ACK的特点 ACK仅用于对INVITE消息的最终响应进行确认 ACK的CSeq的号码必须和INVITE的CSeq号码相同，这是用来保证ACK对对哪一个INVITE进行确认的唯一标志。另外CSeq的方法会改为ACK ACK分为两种 失败请求的确认；例如对4XX, 5XX请求的确认。在对失败的请求进行确认时，ACK是逐跳的。 成功的请求的确认；对200的确认，此时ACK是端到端的。 ACK一般不会带有SDP信息。如果INVITE消息没有带有SDP，那么ACK消息中一般会带有ACK ACK与事务的关系 如果请求成功，那么后续的ACK消息是单独的事物 如果请求失败，那么后续的ACK消息和之前的INVITE是属于相同的事务 逐跳ACK VS 端到端ACK 逐跳在英文中叫做: hop-by-hop端到端在英文中叫做：end-to-end
ACK如何路由 ack是序列化请求，所谓序列化请求，是指sip to 字段中已经有tag。有to tag是到达对端的唯一标志。
没有to tag请求称为初始化请求，有totag称为序列化请求。
初始化请求做路径发现，往往需要做一些数据库查询，DNS查询。而序列化请求不需要查询数据库，因为路径已经发现过了。
实战场景：分机A, SIP服务器S, 分机B, A呼叫B，详细介绍一下到ACK的过程。
分机A向SIP服务器S发送请求：INVITE B SIP服务器 首先在数据库中查找B的实际注册地址 修改Contact头为分机A的外网地址和端口。因为由于存在NAT, 分机A一般不知道自己的公网地址。 record_route 将消息发送给B 分机B: 收到来自SIP服务器的INVITE消息 从INVITE中取出Contact, 获取对端的，其实也就是分机A的实际地址 如果所有条件都满足，分机B会向SIP服务器发送180响应，然后发送200响应 由于180响应和200响应和INVITE都属于一个事务，响应会按照Via的地址，先发送给SIP服务器 SIP服务器： SIP服务器会首先修改180响应的Contac头，把分机B的内网地址改为外网地址 SIP服务器根据Via头，将消息发送给分机A 对于200 OK的消息，和180的处理是相同的 分机A: 分机收到180消息后，从Contact头中能够获取分机B的外网地址 分机A在发送ACK时，request url地址是分机B的地址，但是由于sip服务器的record_route动作首先会将消息发送给SIP服务器，SIP服务器会按照request url的地址，将ack发送给分机B。 ACK的路由不需要做数据库查询，ACK的request url一般是对端UAC的地址。在存在route头时，ACK会按照route字段去路由。
ACK丢失了会怎样？ 如果被叫在一定时间内没有收到ACK, 那么被叫会周期性的重发200OK。如果在超时的时候，还没有收到ACK, 就发发送BYE消息来挂断呼叫。很多呼叫在30秒自动挂断，往往就是因为丢失了ACK。
那么ACK为什么会丢失呢？可能有以下的原因，大部分原因和NAT有关！
SIP服务器没有做fix_nat_contact, 导致主叫可能不知道实际被叫的外网地址 ACK与媒体流的关系 并不是说被叫收到ACK后，媒体流才开始。往往在180或者183时，双方已经能够听到对方的声音了。</description>
    </item>
    
    <item>
      <title>opensips 与 webrtc资料整理</title>
      <link>https://wdd.js.org/opensips/ch9/webrtc-pdf/</link>
      <pubDate>Tue, 31 Dec 2019 09:25:42 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/webrtc-pdf/</guid>
      <description>参考 https://www.opensips.org/Documentation/Tutorials-WebSocket-2-2 https://opensips.org/pub/events/2016-05-10_OpenSIPS-Summit_Amsterdam/Pete_Kelly-OpenSIPS_Summit2016-OpenSIPSandWebRTC.pdf pdf附件 Eric_Tamme-OpenSIPS_Summit_Austin_2015-WebRTC_with_OpenSIPS.pdf Pete_Kelly-OpenSIPS_Summit2016-OpenSIPSandWebRTC.pdf </description>
    </item>
    
    <item>
      <title>rtp编码表</title>
      <link>https://wdd.js.org/opensips/ch4/codec-table/</link>
      <pubDate>Sat, 07 Dec 2019 09:10:33 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/codec-table/</guid>
      <description>v=0 o=WMSWMS 1562204406 1562204407 IN IP4 192.168.40.79 s=WMSWMS c=IN IP4 192.168.40.79 t=0 0 m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ptime:20 上面的SDP协议，我们只关注媒体编码部分，其中
m=audio 31114 RTP/AVP 0 8 9 101 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:9 G722/8000 m字段audio说明是音频 31114是rtp的发送端口，一般rtp端口都是偶数，偶数后面的一个奇数端口是给rtcp端口的 0 8 9 101就是媒体编码，每个整数代表一个编码，其中96以下的是都是用IANA规定的，可以不用下面的rtpmap字段去指定，96以上的属于动态编码，需要用rtpmap去指定 上面是整个编码表，我们只需要记住几个就可以:
0 PCMU/8000 3 GSM/8000 8 PCMA/8000 9 G722/8000 18 G729/8000 102 DTMF/8000 a=rtpmap:101 telephone-event/8000a=fmtp:101 0-16上面的字段描述的是DTMP的支持。DTMF标准，所有SIP实体至少支持0-15的DTMF事件。
0-9是数字 10是* 11是# 12-15对应A,B,C,D 参考 https://www.</description>
    </item>
    
    <item>
      <title>tcp-dump</title>
      <link>https://wdd.js.org/opensips/tools/tcp-dump/</link>
      <pubDate>Wed, 04 Dec 2019 11:08:27 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/tcp-dump/</guid>
      <description>sngrep长时间抓包会导致内存堆积，所以sngrep只适合短时间分析抓包，长时间抓包需要用tcp-dump</description>
    </item>
    
    <item>
      <title>homer: 统一的sip包集中处理工具</title>
      <link>https://wdd.js.org/opensips/tools/homer/</link>
      <pubDate>Tue, 26 Nov 2019 19:58:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/homer/</guid>
      <description>相比于sngrep, Homer能够保存从历史记录中搜索SIP包信息。除此以外，Homer可以很方便的与OpenSIPS或FS进行集成。
最精简版本的Homer部署需要三个服务。
postgres 数据库，用来存储SIP信息 heplify-server 用来处理Hep消息，存储到数据库 homer-app 前端搜索查询界面 这三个服务都可以用docker镜像的方式部署，非常方便。
说实话：homer实际上并不好用。你可以对比一下siphub就知道了。
参考资料 https://blog.opensips.org/2017/03/22/capturing-beyond-sip/https://www.opensips.org/Documentation/Tutorials-Tracing</description>
    </item>
    
    <item>
      <title>WebRTC简介</title>
      <link>https://wdd.js.org/opensips/ch9/notes/</link>
      <pubDate>Sat, 23 Nov 2019 10:51:20 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/notes/</guid>
      <description>WebRTC 功能 音频视频通话 视频会议 数据传输 WebRTC 架构 对等实体之间通过信令服务传递信令 对等实体之间的媒体流可以直接传递，无需中间服务器 内部结构 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块：
Voice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 WebRTC 如何通信 getUserMedia用来捕获本地的语音流或者视频流 RTCPeerConnection用来代表WebRTC链接，用来处理对等实体之间的流数据 RTCDataChannel 用来传递各种数据 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API WebRTC 底层协议 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的 其中，ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输 RTCDataChannel 用来支持端到端的任意二进制数据传输 WebRTC 协议栈解释 ICE：互动式连接建立（RFC 5245） STUN：用于NAT的会话遍历实用程序（RFC 5389） TURN：在NAT周围使用继电器进行遍历（RFC 5766） SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711） 浏览器和某些非浏览器之间的呼叫，有些时候以为没有DTLS指纹，而导致呼叫失败。如下图使用JsSIP, 一个sipPhone和WebRTC之间的呼叫，因为没有携带DTLS指纹而导致呼叫失败。</description>
    </item>
    
    <item>
      <title>WebRTC学习资料分享</title>
      <link>https://wdd.js.org/opensips/ch9/webrtc-ref/</link>
      <pubDate>Sat, 23 Nov 2019 10:49:56 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/webrtc-ref/</guid>
      <description>目前在做基于WebRTC的语音和视频终端，语音和视频通话的质量都不错。感谢WebRTC，站在巨人的肩膀上，我们可以看得更远。
WebRTC浏览器兼容性 github demos 下面两个都是github项目，项目中有各种WebRTC的demo。除了demo之外，这两个项目的issuese也是非常值得看的，可以解决常见的问题
https://webrtc.github.io/samples/ https://github.com/muaz-khan/WebRTC-Experiment 相关资料网站 webrtc官网： https://webrtc.org/ webrtchacks： https://webrtchacks.com/ webrtc官网： https://webrtc.org.cn/ webrtc安全相关： http://webrtc-security.github.io/ webrtc谷歌开发者教程： https://codelabs.developers.google.com/codelabs/webrtc-web/ sdp for webrtc https://tools.ietf.org/id/draft-nandakumar-rtcweb-sdp-01.html 各种资料 https://webrtc.org/start/ https://www.w3.org/TR/webrtc/ 浏览器内核 webkit官网：https://webkit.org/ WebRTC相关库 webrtc-adapter https://github.com/webrtchacks/adapter WebRTC周边js库 库 地址 Addlive http://www.addlive.com/platform-overview/ Apidaze https://developers.apidaze.io/webrtc Bistri http://developers.bistri.com/webrtc-sdk/#js-sdk Crocodile https://www.crocodilertc.net/documentation/javascript/ EasyRTC http://www.easyrtc.com/docs/ Janus http://janus.conf.meetecho.com/docs/JS.html JsSIP http://jssip.net/documentation/ Openclove http://developer.openclove.com/docs/read/ovxjs_api_doc Oracle http://docs.oracle.com/cd/E40972_01/doc.70/e49239/index.html Peerjs http://peerjs.com/docs/#api Phono http://phono.com/docs Plivo https://plivo.com/docs/sdk/web/ Pubnub http://www.pubnub.com/docs/javascript/javascript-sdk.html Quobis https://quobis.atlassian.net/wiki/display/QoffeeSIP/API SimpleWebRTC from &amp;amp;Yet http://simplewebrtc.com/ SIPML5 http://sipml5.org/docgen/symbols/SIPml.html TenHands https://www.tenhands.net/developer/docs.htm TokBox http://tokbox.</description>
    </item>
    
    <item>
      <title>opensips介绍</title>
      <link>https://wdd.js.org/opensips/ch3/about-opensips/</link>
      <pubDate>Tue, 19 Nov 2019 18:37:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/about-opensips/</guid>
      <description>1. OpenSIPS架构 OpenSIPS主要有两部分构成，
core: 提供底层工具、接口、资源 module：模块是一些共享的库，在启动时按需加载。有些模块是用于在opensips脚本中提供功能，而有些模块是作为底层，为其他模块提供功能。 2. OpenSIP 核心 2.1. 传输层 传输层提供了对于各种协议的支持，如TCP、UDP、TLS、WebSocket
2.2. SIP工厂层 SIP工厂层提供了对SIP协议的解析和构建。OpenSIPS实现了一种懒解析功能，懒解析的效率非常高。
懒解析：懒解析就是只去解析SIP头，并不解析SIP头的字段内容。而是在需要读取头字段内容时，才去解析。所以可以理解为按需解析。有点类似于一些文件系统的写时复制功能。
**惰性应用：**有一点非常重要，当你通过脚本提供的函数去改变SIP消息时，所作出的改变并不是实时作用到SIP消息上，而是在先存起来，而是当所有的SIP消息处理完成后才会去应用这些改变。举例来说，你首先通过函数给SIP消息添加了某个头，然后你通过函数去获取这个头的时，发现这个头并不存在，但是SIP消息再发送出去后，又携带了你添加的这个头。
2.3. 路由脚本解析与执行 OpenSIPS在启动后，会将opensips.cfg解析并加载到内存中。一旦OpenSIPS正常运行了，opensips.cfg文件即使删了也不会影响到OpenSIPS的运行了。
但是OpenSIPS并不支持热脚本更新，如果你改了脚本，让让运行的OpenSIPS具有添加的功能，那么必须将OpensSIPS重启。
OpenSIPS的脚本有点类似于C或者Shell语言，如果你Shell写的很溜，OpenSIPS的脚本理解起来也会非常容易。
2.4. 内存与锁管理 出于性能考虑，OpenSIPS自己内部实现了内存和锁的管理，这部分在内容在脚本中是不可见的。
2.5. 脚本变量和脚本函数 OpenSIPS核心提供的脚本变量和函数比较有限，外围的模块提供和很多的变量和函数。这些变量和函数的存在，都是为了让你易于获取SIP消息的某些字段，或者对SIP消息进行修改。
2.6. SQL接口类 OpenSIPS 核心实现了接口的定义，但是并没有实现接口。接口的实现由外部的模块提供，这样做的函数可以使用不同的数据库。
2.7. MI管理接口 mi接口用来管理OpenSIPS, 可以实现以下功能
向OpenSIPS 发送数据 从OpenSIPS 获取数据 触发OpenSIPS 的内部行为 </description>
    </item>
    
    <item>
      <title>深入NAT网络</title>
      <link>https://wdd.js.org/opensips/ch1/deep-in-nat/</link>
      <pubDate>Tue, 05 Nov 2019 16:29:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/deep-in-nat/</guid>
      <description> NAT的产生原因是IPv4的地址不够用，网络中的部分主机只能公用一个外网IP。 NAT工作在网络层和传输层，主要是对IP地址和端口号的改变 NAT的优点 节约公网IP 安全性更好，所有流量都需要经过入口的防火墙 NAT的缺点 对于UPD应用不够友好 NAT 工作原理 内部的设备X, 经过NAT设备后，NAT设备会改写源IP和端口 NAT 类型 1. 全锥型 每个内部主机都有一个静态绑定的外部ip:port 任何主机发往NAT设备上特定ip:port的包，都会被转发给绑定的主机 这种方式的缺点很明显，黑客可以使用端口扫描工具，扫描出暴露的端口，然后通过这个端口攻击内部主机 在内部主机没有往外发送流量时，外部流量也能够进入内部主机 -
2. 限制锥形 NAT上的ip:port与内部主机是动态绑定的 如果内部主机没有向某个主机先发送过包，那么NAT会拒绝外部主机进入的流量 3. 端口限制型 端口限制型除了有限制锥型的要求外，还增加了端口的限制 4. 对称型 对称型最难穿透，因为每次交互NAT都会使用不同的端口号，所以内外网端口映射根本无法预测 NAT对比表格 NAT类型 收数据前是否需要先发送数据 是否能够预测下一次的NAT打开的端口对 是否限制包的目的ip:port 全锥形 否 是 否 限制锥形 是 是 仅限制IP 端口限制型 是 是 是 对称型 是 否 是 </description>
    </item>
    
    <item>
      <title>【必读】深入对外公布地址</title>
      <link>https://wdd.js.org/opensips/ch5/adv-address/</link>
      <pubDate>Mon, 04 Nov 2019 13:11:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/adv-address/</guid>
      <description>如果你仅仅是本地运行OpenSIPS, 你可以不用管什么对外公布地址。但是如果你的SIP服务器想在公网环境提供服务，则必然要深刻的理解对外公布地址。
在一个集群中，可能有多台SIP服务器，例如如下图的网络架构中
register 负责注册相关的业务 192.168.1.100(内网) uas 负责呼叫相关的业务 192.168.1.101(内网) entry 负责接入 192.168.1.102(内网)，1.2.3.4(公网地址) 一般情况下，register和uas只有内外地址，没有公网地址。而entry既有内网地址，也有公网地址。公网地址一般是由云服务提供商分配的。
我们希望内部网络register和uas以及entry必须使用内网通信，而entry和互联网使用公网通信。
有时候经常遇到的问题就是某个请求，例如INVITE, uas从内网地址发送到了entry的公网地址上，这时候就可能产生一些列的奇葩问题。
如何设置公布地址 listen as listen = udp:192.168.1.102:5060 as 1.2.3.4:5060 在listen 的参数上直接配置公布地址。好处的方便，后续如果调用record_route()或者add_path_received(), OpenSIPS会自动帮你选择对外公布地址。
但是，OpenSIPS选择可能并不是我们想要的。
例如： INVITE请求从内部发送到互联网，这时OpenSIPS能正常设置对外公布地址。但是如果请求从外表进入内部，OpenSIPS可能还是会用公网地址作为对外公布地址。
所以，listen as虽然方便，但不够灵活。
set_advertised_address() 和 set_advertised_port(int) set_advertised_address和set_advertised_port属于OpenSIPS和核心函数部分，可以在脚本里根据不同条件，灵活的设置公布地址。
例如:
if 请求发生到公网 { set_advertised_address(&amp;#34;1.2.3.4&amp;#34;); } ⚠️ 如果你选择用set_advertised_address和set_advertised_port来手动设置，就千万不要用as了。
几个注意点SIP头 record_route头 Path头 上面的两个头，在OpenSIPS里可以用下面的函数去设置。设置的时候，务必要主义选择合适的网络地址。否者请求将会不回按照你期望方式发送。
record_route record_route_preset add_path add_path_received </description>
    </item>
    
    <item>
      <title>CSTA 呼叫模型简介</title>
      <link>https://wdd.js.org/opensips/ch1/csta-call-model/</link>
      <pubDate>Tue, 15 Oct 2019 21:43:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/csta-call-model/</guid>
      <description>1. 内容概要 CSTA 协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA 协议标准 2.1. 什么是 CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications) 基本的呼叫模型在 1992 建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等 CSTA 是一个应用层接口，用来监控呼叫，设备和网络 CSTA 创建了一个通讯程序的抽象层: CSTA 并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA 并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式 第三方呼叫控制 一方呼叫控制 CSTA 的设计目标是为了提高各种 CSTA 实现之间的移植性 规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段 1 (发布于 June ’92) 40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段 2 (发布于 Dec. ’94) 77 特性, 145 页 (服务定义) I/O &amp;amp; 语音单元服务, 更多呼叫控制服务 阶段 3 - CSTA Phase II Features &amp;amp; versit CTI Technology 发布于 Dec.</description>
    </item>
    
    <item>
      <title>ERROR:carrierroute:carrier_tree_fixup: default_carrier not found</title>
      <link>https://wdd.js.org/opensips/ch7/without-default-carrier/</link>
      <pubDate>Sat, 12 Oct 2019 12:17:27 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/without-default-carrier/</guid>
      <description>route_tree表中需要增加carrier
id carrier 0 default </description>
    </item>
    
    <item>
      <title>UA应答模式的实现</title>
      <link>https://wdd.js.org/opensips/ch1/ua-answer-mode/</link>
      <pubDate>Thu, 26 Sep 2019 20:37:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/ua-answer-mode/</guid>
      <description>Notify 使用noify消息，通知分机应答，这个notify一般发送在分机回180响应之后
Answer-mode Answer-Mode一般有两个值 Auto: UA收到INVITE之后，立即回200OK，没有180的过程 Manual: UA收到INVITE之后，等待用户手工点击应答 通常Answer-Mode还会跟着require, 表示某个应答方式如果不被允许，应当回403 Forbidden 作为响应。
Answer-Mode: Auto;require 和Answer-mode头类似的有个SIP头叫做：Priv-Answer-Mode，这个功能和Answer-Mode类似，但是他有个特点。
如果UA设置了免打扰，Priv-Answer-Mode头会无视免打扰这个选项，强制让分机应答，这个头适合用于紧急呼叫。
结论 如果要实现分机的自动应答，显然Answer-Mode的应答速度回更快。但是对于依赖180响应的系统，可能要考虑这种没有180相应的情况。
要记住，在SIP消息里，对于UA来说，1xx的响应都是不必须的可以缺少的。</description>
    </item>
    
    <item>
      <title>opensips日志写入elasticsearch</title>
      <link>https://wdd.js.org/opensips/ch3/elk/</link>
      <pubDate>Thu, 19 Sep 2019 09:01:40 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/elk/</guid>
      <description>构造json $json(body) := &amp;#34;{}&amp;#34;; $json(body/time) = $time(%F %T-0300); $json(body/sipRequest) = “INVITE”; $json(body/ipIntruder) = $si; $json(body/destNum) = $rU; $json(body/userAgent) = $ua; $json(body/country)=$var(city); $json(body/location)=$var(latlon); $json(body/ipHost) = $Ri; 使用async rest_post写数据 async好像存在于2.1版本及其以上， 异步的好处是不会阻止脚本的继续执行 async(rest_post(&amp;#34;http://user:password@w.x.y.z:9200/opensips/1&amp;#34;, &amp;#34;$json(body)&amp;#34;, &amp;#34;$var(ctype)&amp;#34;, &amp;#34;$var(ct)&amp;#34;, &amp;#34;$var(rcode)&amp;#34;),resume) </description>
    </item>
    
    <item>
      <title>回铃音</title>
      <link>https://wdd.js.org/opensips/ch2/early-media/</link>
      <pubDate>Wed, 18 Sep 2019 09:53:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/early-media/</guid>
      <description>特点分析 回铃音有以下特点
回铃音是由运营商送给手机的，而不是由被叫送给主叫的。 回铃音的播放阶段是在被叫接听前播放，被叫一旦接听，回铃音则播放结束 回铃音一般是450Hz, 嘟一秒，停4秒，5秒一个周期 常见问题 听不到回铃音 【现象】打同一个号码，有些手机能听到回铃音，有些手机听不到回铃音【排查思路】
有些手机volte开启后，可能会导致无回铃音，所以可以关闭volte试试 被叫的运营商，主叫手机的运营商 参考资料 https://zh.wikipedia.org/wiki/%E5%9B%9E%E9%93%83%E9%9F%B3 https://baike.baidu.com/item/%E5%9B%9E%E9%93%83%E9%9F%B3/1014322 http://www.it9000.cn/tech/CTI/signal.html </description>
    </item>
    
    <item>
      <title>几种常用电话信号音的含义</title>
      <link>https://wdd.js.org/opensips/ch2/early-media-type/</link>
      <pubDate>Wed, 18 Sep 2019 09:10:24 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch2/early-media-type/</guid>
      <description>几种常用电话信号音的含义 信号频率：（450±25）HZ：拨号音、回铃音、忙音、长途通知音、空号音（950±25）HZ：催挂音
拨号音 摘机后受话器中便有一种“嗡&amp;ndash;”的连续音，这种声音就是拨号音，它表示自动交换机或对方呼叫中心系统已经做好了接续准备，允许用户拨号
回铃音 拨完被叫号，若听到“嘟&amp;ndash;嘟&amp;ndash;”的断续音（响1s，断4s），便是回铃音，表示被叫话机正在响铃，可静候接话；如果振铃超过10余次，仍无人讲话，说明对方无人接电话，应放好手柄稍后再拨。
忙音 当主叫用户在拨号过程中或拨完被叫电话号码后，若听到“嘟、嘟、嘟……”的短促音（响0.35s，断0.35s），这就是忙音，表示线路已经被占满或被叫电话机正在使用
长途通知音 当主叫用户和被叫用户正在进行市内通话时，听到“嘟、嘟、嘟……”的短促音（响0.2s，断0.2s，响0.2s，间歇0.6s），这便是长途电话通知音，表示有长途电话插入，提醒主被叫用户双方尽快结束市内通话，准备接听长途电话。
空号音 当用户拨完号码后听到不等间隔断续信号音（重复3次0.1s响，0.1s断后，0.4s响0.4s断），这便是空号音，表示通知主叫用户所呼叫的被叫号码为空号或受限制的号码。
催挂音 如果用户听到连续信号音，响度变化为5级，由低级逐步升高，则是催挂音。通知久不挂机的用户迅速挂机。
参考 http://www.it9000.cn/tech/CTI/signal.html </description>
    </item>
    
    <item>
      <title>NAT解决方法</title>
      <link>https://wdd.js.org/opensips/ch1/fix-nat/</link>
      <pubDate>Tue, 17 Sep 2019 08:58:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/fix-nat/</guid>
      <description>解决信令的过程 NAT检测 使用rport解决Via 在初始化请求和响应中修改Contact头 处理来自NAT内部的注册请求 Ping客户端使NAT映射保持打开 处理序列化请求 实现NAT检测 nat_uac_test 使用函数 nat_uac_test
1 搜索Contact头存在于RFC 1918 中的地址 2 检测Via头中的received参数和源地址是否相同 4 最顶部的Via出现在RFC1918 / RFC6598地址中 8 搜索SDP头出现RFC1918 / RFC6598地址 16 测试源端口是否和Via头中的端口不同 32 比较Contact中的地址和源信令的地址 64 比较Contact中的端口和源信令的端口 上边的测试都是可以组合的，并且任何一个测试通过，则返回true。
例如下面的测试19，实际上是1+2+16三项测试的组合
nat_uac_test(&amp;#34;19&amp;#34;) 使用rport和receive参数标记Via头 从NAT内部出去的呼叫，往往可能不知道自己的出口IP和端口，只有远端的SIP服务器收到请求后，才能知道UAC的真是出口IP和端口。出口IP用received=x.x.x.x，出口端口用rport=xx。当有消息发到UAC时，应当发到received和rport所指定的地址和端口。
# 原始的Via Via: SIP/2.0/UDP 192.168.4.48:5062;branch=z9hG4bK523223793;rport # 经过opensips处理后的Via Via: SIP/2.0/UDP 192.168.4.48:5062;received=192.168.4.48;branch=z9hG4bK523223793;rport=5062 修复Contact头 Via头和Contact头是比较容易混淆的概念，但是两者的功能完全不同。Via头使用来导航183和200响应应该如何按照原路返回。Contact用来给序列化请求，例如BYE和UPDATE导航。如果Contact头不正确，可能会导致呼叫无法挂断。那么就需要用fix_nated_contact()函数去修复Contact头。另外，对于183和200的响应也需要去修复Contact头。
处理注册请求 RFC 1918 地址组 10.0.0.0 - 10.255.255.255 (10/8 prefix) 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) 参考 http://www.rfcreader.com/#rfc1918 </description>
    </item>
    
    <item>
      <title>常见媒体流编码及其特点</title>
      <link>https://wdd.js.org/opensips/ch4/media-codec/</link>
      <pubDate>Fri, 13 Sep 2019 09:04:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch4/media-codec/</guid>
      <description> 编码 带宽 MOS 环境 特点 说明 G.711 64 kbps 4.45 LAN/WAN 语音质量高，适合对接网关 G.711实际上就是PCM, 是最基本的编码方式。PCM又分为两类PCMA(g711a), PCMU(g711u)。中国使用的是PCMA G.729 8 kbps 4.04 WAN 带宽占用率很小，同时能保证不错的语音质量 分为G729a和G729b两种，G729之所以带宽占用是G711的1/8, 是因为G729的压缩算法不同。G729传输的不是真正的语音，而是语音压缩后的结果。G729的编解码是由专利的，也就说不免费。 G.722 64 kbps 4.5 LAN 语音质量高 HD hd语音 GSM 13.3 kbps 3.01 iLBA 13.3 15.2 抗丢包 OPUS 6-510 kbps - INTERNET OPUS的带宽范围跨度很广，适合语音和视屏 MOS值，Mean Opinion Score，用来定义语音质量。满分为5分，最低1分。
MOS 质量 5 极好的 4 不错的 3 还行吧 2 中等差 1 最差 通常的打包是20ms一个包，那么一秒就会传输1000/20=50个包。如果采样评率是8000Hz, 那么每个包的会携带 8000/50=160个采样数据。在PCMA或者PCMU中，每个采样数据占用1字节。因此20ms的一个包就携带160字节的数据。
在RTP包协议中，160字节还要加上12个自己的RTP头。 在fs上可以使用下面的命令查看fs支持的编码。
show codec </description>
    </item>
    
    <item>
      <title>pjsip</title>
      <link>https://wdd.js.org/opensips/tools/pjsip/</link>
      <pubDate>Sun, 08 Sep 2019 13:02:46 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/pjsip/</guid>
      <description>环境说明 centos7.6 docker 容器 过程 wget https://www.pjsip.org/release/2.9/pjproject-2.9.zip unzip pjproject-2.9.zip cd pjproject-2.9 chmod +x configure aconfigure yum install gcc gcc-c++ make -y make dep make make install yum install centos-release-scl yum install rh-python36 参考 https://www.pjsip.org/download.htm https://trac.pjsip.org/repos/wiki/Getting-Started https://trac.pjsip.org/repos/wiki/Getting-Started/Autoconf https://linuxize.com/post/how-to-install-python-3-on-centos-7/ </description>
    </item>
    
    <item>
      <title>centos7 安装opensips</title>
      <link>https://wdd.js.org/opensips/ch3/centos-install/</link>
      <pubDate>Thu, 05 Sep 2019 12:09:35 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/centos-install/</guid>
      <description>安装依赖 yum update &amp;amp;&amp;amp; yum install epel-release yum install openssl-devel mariadb-devel libmicrohttpd-devel \ libcurl-devel libconfuse-devel ncurses-devel 编译 下面的脚本，默认将opensips安装在/usr/local/etc/目录下
&amp;gt; cd opensips-2.4.6 # 编译 &amp;gt; make all -j4 include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; # 安装 &amp;gt; make install include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; 如果想要指定安装位置，可以使用prefix参数指定，例如指定安装在/usr/aaa目录
&amp;gt; cd opensips-2.4.6 # 编译 &amp;gt; make all -j4 prefix=/usr/aaa include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; # 安装 &amp;gt; make install prefix=/usr/aaa include_modules=&amp;#34;db_mysql httpd db_http regex rest_client carrierroute dialplan&amp;#34; </description>
    </item>
    
    <item>
      <title>SIPp：sip压测模拟ua工具</title>
      <link>https://wdd.js.org/opensips/tools/sipp/</link>
      <pubDate>Wed, 04 Sep 2019 12:47:07 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/sipp/</guid>
      <description>安装 SIPp 3.3 # 解压 tar -zxvf sipp-3.3.990.tar.gz # centos 安装依赖 yum install lksctp-tools-devel libpcap-devel gcc-c++ gcc -y # ubuntu 安装以来 apt-get install -y pkg-config dh-autoreconf ncurses-dev build-essential libssl-dev libpcap-dev libncurses5-dev libsctp-dev lksctp-tools ./configure --with-sctp --with-pcap make &amp;amp;&amp;amp; make install sipp -v SIPp v3.4-beta1 (aka v3.3.990)-SCTP-PCAP built Oct 6 2019, 20:12:17. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</description>
    </item>
    
    <item>
      <title>opensips 集成 homer6</title>
      <link>https://wdd.js.org/opensips/ch5/homer6/</link>
      <pubDate>Tue, 20 Aug 2019 11:40:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/homer6/</guid>
      <description> 参考 https://blog.opensips.org/2017/03/22/capturing-beyond-sip/ http://www.sipcapture.org/ https://github.com/sipcapture/homer/wiki </description>
    </item>
    
    <item>
      <title>模块缓存策略与reload方法</title>
      <link>https://wdd.js.org/opensips/ch3/cache-reload/</link>
      <pubDate>Tue, 20 Aug 2019 09:11:21 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/cache-reload/</guid>
      <description>常见的问题 有时候如果你直接在数据库中改动某些值，但是opensips并没有按照预设的值去执行，那么你就要尝试使用mi命令去reload相关模块。
有缓存模块 opensips在启动时，会将某些模块所使用的表一次性全部加载到数据库，状态变化时，再回写到数据库。有一下模块列表：
dispather load_balancer carrierroute dialplan &amp;hellip; 判断一个模块是否是一次性加载到内存的，有个简便方法，看这个模块是否提供类似于 xx_reload的mi接口，有reload的mi接口，就说明这个模块是使用一次性读取，变化回写的方式读写数据库。
将模块一次性加载到内存的好处时不用每次都查数据库，运行速度会大大提升。
以dispather为例子，opensips在启动时会从数据库总加载一系列的目标到内存中，然后按照设定值，周期性的向目标发送options包，如果目标挂掉，三次未响应，opensips将会将该目标的状态设置为非0值，表示该地址不可用，同时将该状态回写到数据库。
无缓存模块 无缓存的模块每次都会向数据库查询数据。常见的模块有alias_db，该模块的说明
ALIAS_DB module can be used as an alternative for user aliases via usrloc. The main feature is that it does not store all adjacent data as for user location and always uses database for search (no memory caching).
ALIAS_DB一般用于呼入时接入号的查询，在多租户的情况下，如果大多数租户都是使用呼入的场景，那么ALIAS_DB模块可能会是一个性能瓶颈，建议将该模块使用一些内存数据库替代。
从浏览器reload模块 opensips在加载了httpd和mi_http模块之后，可以在opensips主机的8888端口访问到管理页面，具体地址如：http://opensips_host:8888/mi
这个页面可以看到opensips所加载的模块，然后我们点击carrierroute, 可以看到该模块所支持的管理命令列表，如下图左侧列表所示，其中cr_reload_routes就是一个管理命令。
然后我们点击cr_reload_routes连接，跳转到下图所示页面。参数可以不用填写，直接点击submit就可以。正常情况下回返回 200 : OK，就说明reload模块成功。
使用curl命令reload模块 如果因为某些原因，无法访问web界面，那么可以使用curl等http命令行工具执行curl命令，例如
curl http://192.168.40.98:8888/mi/carrierroute/cr_reload_routes?arg= </description>
    </item>
    
    <item>
      <title>SIP注册调研</title>
      <link>https://wdd.js.org/opensips/ch1/sip-register/</link>
      <pubDate>Mon, 19 Aug 2019 21:30:52 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/sip-register/</guid>
      <description>sequenceDiagram autonumber participant a as 192.168.0.123:55647 participant b as 1.2.3.4:5060 participant c as 172.10.10.3:49543 a-&gt;&gt;b: register cseq=1, callId=1 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=2, callid=1 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=3, callId=1 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=4, callid=1 b--&gt;&gt;a: 200 c-&gt;&gt;b: register cseq=5, callid=1 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=6, callid=1 b--&gt;&gt;c: 500 Service Unavailable c-&gt;&gt;b: register cseq=7, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=8, callid=2 b--&gt;&gt;c: 200 c-&gt;&gt;b: register cseq=9, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=10, callid=2 b--&gt;&gt;c: 200 c-&gt;&gt;b: register cseq=11, callid=2 b--&gt;&gt;c: 401 Unauthorized c-&gt;&gt;b: register cseq=12, callid=2 b--&gt;&gt;c: 500 Service Unavailable a-&gt;&gt;b: register cseq=13, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=14, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=15, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=16, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=17, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=18, callid=3 b--&gt;&gt;a: 200 a-&gt;&gt;b: register cseq=19, callId=3 b--&gt;&gt;a: 401 Unauthorized a-&gt;&gt;b: register cseq=20, callid=3 b--&gt;&gt;a: 200 服务端设置的过期时间是120s 客户端每隔115s注册一次, callid和之前的保持不变 当网络变了之后，由于ip地址改变，客户端的在115秒注册，此时服务端还未超时，所以给客户端响应报错500 客户端在等了8秒之后，等待服务端超时，然后再次注册，再次注册时，callid改变 因为服务端已经超时，所以能够注册成功 需要注意的是，在一个注册周期内，客户端的注册信息包括IP、端口、协议、CallID都不能变，一旦改变了。如果服务端的记录还没有失效，新的注册就会失败。</description>
    </item>
    
    <item>
      <title>SIP路由头</title>
      <link>https://wdd.js.org/opensips/ch5/via-route/</link>
      <pubDate>Fri, 16 Aug 2019 22:00:39 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/via-route/</guid>
      <description>两种头 via headers 响应按照Via字段向前走 route headers 请求按照route字段向前走 Via头 当uac发送请求时, 每个ua都会加上自己的via头, via都的顺序很重要，每个节点都需要将自己的Via头加在最上面 响应消息按照via头记录的地址返回，每次经过自己的node时候，要去掉自己的via头 via用来指明消息应该按照什么 Route头 路由模块 模块 CARRIERROUTE DISPATCHER DROUTING LOAD_BALANCER </description>
    </item>
    
    <item>
      <title>条件语句特点</title>
      <link>https://wdd.js.org/opensips/ch5/condition/</link>
      <pubDate>Mon, 05 Aug 2019 09:57:20 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/condition/</guid>
      <description>if语句中的真和假值 假值
负数: -1, -2, -3, -4 null: hdr(not_exist) 然而这个not_exist头并不存在 &amp;ldquo;&amp;rdquo;: 空字符串 0 真值：
非空字符串: &amp;ldquo;acb&amp;rdquo; 正数: 1,2,3 </description>
    </item>
    
    <item>
      <title>opensips启动失败没有任何报错日志</title>
      <link>https://wdd.js.org/opensips/ch7/without-log/</link>
      <pubDate>Fri, 02 Aug 2019 17:48:49 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch7/without-log/</guid>
      <description> 将opensips.cfg文件中的，log_stderror的值改为yes, 让出错直接输出到标准错误流上，然后opensips start 如果第一步还是没有日志输出，则opensips -f opensips.cfg </description>
    </item>
    
    <item>
      <title>理解并测量OpenSIPS的内存资源</title>
      <link>https://wdd.js.org/opensips/blog/memory-usage/</link>
      <pubDate>Wed, 31 Jul 2019 13:50:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/memory-usage/</guid>
      <description>原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/
Running OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources.</description>
    </item>
    
    <item>
      <title>Troubleshooting missing ACK in SIP</title>
      <link>https://wdd.js.org/opensips/blog/miss-ack/</link>
      <pubDate>Wed, 31 Jul 2019 13:47:21 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/miss-ack/</guid>
      <description>We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a BYE request – but a BYE which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?
Getting to the missing ACK Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup.</description>
    </item>
    
    <item>
      <title>Troubleshooting OpenSIPS script</title>
      <link>https://wdd.js.org/opensips/blog/troubleshooting-opensips-script/</link>
      <pubDate>Wed, 31 Jul 2019 13:43:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/troubleshooting-opensips-script/</guid>
      <description>What makes OpenSIPS such an attractive and powerful SIP solutions is its high level of programmability, thanks to its C-like configuration script. But once you get into the “programming” area, you will automatically need tools and skills for troubleshooting.So here there are some some tips and tools you can use in OpenSIPS for “debugging” your configuration script.
Controlling the script logging The easiest way to troubleshoot your script is of course by using the xlog() core function and print your own messages.</description>
    </item>
    
    <item>
      <title>Running OpenSIPS in the Cloud</title>
      <link>https://wdd.js.org/opensips/blog/runing-opensips-in-cloud/</link>
      <pubDate>Wed, 31 Jul 2019 13:41:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/runing-opensips-in-cloud/</guid>
      <description>Cloud computing is a more and more viable option for running and providing SIP services. The question is how compatible are the SIP services with the Cloud environment ? So let’s have a look at this compatibility from the most sensitive (for SIP protocol) perspective – the IP network topology.A large number of existing clouds (like EC2, Google CP, Azure) have a particularity when comes to the topology of the IP network they provide – they do not provide public routable IPs directly on the virtual servers, rather they provide private IPs for the servers and a fronting public IP doing a 1-to-1 NAT to the private one.</description>
    </item>
    
    <item>
      <title>深入OpenSIPS统计引擎</title>
      <link>https://wdd.js.org/opensips/blog/deepin-stat-engine/</link>
      <pubDate>Wed, 31 Jul 2019 13:40:00 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/deepin-stat-engine/</guid>
      <description>无论你是经验丰富的OpenSIPS管理员，或者你仅仅想找到为什么ACK消息在你的网络中循环发送，唯一可以确定的是：我们或早或晚会需要OpenSIPS提供数据来回答以下问题
OpenSIPS运行了多久？ 我们是否被恶意流量攻击了？ 我们的平台处理了多少个来自运营商的无效SIP包 在流量峰值时，OpenSIPS是否拥有足够的内存来支撑运行 &amp;hellip; 幸运的是，OpenSIPS提供内置的统计支持，来方便我们快速解决以上问题。详情可以查看OpenSIPS统计接口。在本篇文章中，我们将会了解统计引擎，但是，什么是引擎？
统计引擎 总的来说，下图就是OpenSIPS引擎的样子。
统计引擎内置于OpenSIPS。它管理所有的统计数据，并且暴露一个标准的CRUD操作接口给所有的模块，让模块可以推送或者管理他们自己的统计数据。
一下有三种方式来和统计引擎进行交互
直接通过脚本访问。如通过$script(my-stat)变量 使用HTTP请求来访问 使用opensipsctl fifo命令 统计引擎是非常灵活并且可以通过不同方式与其交互，那么它怎么能让我们的使用变得方便呢？下面的一些建议，能够让你全面的发挥静态统计引擎的能力，来增强某些重要的层面。
系统开发维护 当你处理OpenSIPS的DevOps时，你经常需要监控OpenSIPS的一些运行参数。你的关注点不同，那么你就需要监控不同的方面，例如SIP事务、对话、内存使用、系统负载等等
下面是OpenSIPS统计分组的一个概要，以及组内的每一个统计值，详情可以参考wiki。
统计简介 假如我们想通过sipp对我们的平台进行流量测试，我们想压测期间观测当前的事务、对话、共享内存的值变化。或者我们我们有了一个新的SIP提供商，他们每天早上9点会开始向我们平台推送数据，我们需要监控他们的推送会对我们系统产生的影响。
你可以在OpenSIPS实例中输入以下指令：
watch -n0.2 &amp;#39;opensipsctl fifo get_statistics inuse_transactions dialog: shmem:&amp;#39; 注意 get_statistics命令即可以接受一个统计值项，也可以接受一个统计组的项。统计组都是以冒号(:)结尾。
与递增的统计指标进行交互 统计指标看起来相同，实际上分为两类
累计值。累计是一般是随着时间增长，例如rcv_requests, processed_dialogs，表示从某个时间点开始累计收到或者处理了多少个任务 计算值。计算值一般和系统运行负载有关，和时间无关。例如active_dialogs, real_used_size, 这些值都是由内部函数计算出来的计算值 一般来说，脚本中定义的统计值都是递增的，OpenSIPS无法重新计算它，只能我们自己来计算或者维护它的值。
以下方式可以快速查看计算值类的统计项
opensipsctl fifo list_statistics 某些场景，你可能需要周期性的重置累计值类的统计项。例如你可以只需要统计当天的processed_dialogs，daily_routed_minutes，那么你只需要设置一个定时任务，每天0点，重置这些统计值。
opensipsctl fifo reset_statistics processed_dialogs 在脚本中自定义统计项 在脚本中自定义统计项是非常简单的，只需要做两步
加载statistics.so模块 在某些位置调用函数, update_stat(&amp;quot;daily_routed_minutes&amp;quot;, &amp;quot;+1&amp;quot;) 实战：脚本中有许多的自定义统计项 统计每天收到的SIP消息的请求方式, 以及处理的消息长度 每隔24小时，以JSON的形式，将消息写到SIP服务器 # 设置统计组 modparam(&amp;#34;statistics&amp;#34;, &amp;#34;stat_groups&amp;#34;, &amp;#34;method, packet&amp;#34;) # 请求路由 route { ... update_stat(&amp;#34;method:$rm&amp;#34;, &amp;#34;+1&amp;#34;); update_stat(&amp;#34;packet:count&amp;#34;, &amp;#34;+1&amp;#34;); update_stat(&amp;#34;packet:total_size&amp;#34;, &amp;#34;$ml&amp;#34;) # message length .</description>
    </item>
    
    <item>
      <title>Full Anycast support in OpenSIPS 2.4</title>
      <link>https://wdd.js.org/opensips/blog/full-anycast/</link>
      <pubDate>Wed, 31 Jul 2019 13:37:31 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/full-anycast/</guid>
      <description>he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.Anycast is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP).</description>
    </item>
    
    <item>
      <title>Clustering ongoing calls with OpenSIPS 2.4</title>
      <link>https://wdd.js.org/opensips/blog/cluster-call/</link>
      <pubDate>Wed, 31 Jul 2019 13:36:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/cluster-call/</guid>
      <description>Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the clusterer module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for clustering dialog support?</description>
    </item>
    
    <item>
      <title>Clustered SIP User Location: The Full Sharing Topology</title>
      <link>https://wdd.js.org/opensips/blog/cluster-location/</link>
      <pubDate>Wed, 31 Jul 2019 13:34:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/cluster-location/</guid>
      <description>The distributed SIP user location support is one of the major features of the latest stable OpenSIPS release, namely 2.4. The aim of this extension of the OpenSIPS usrloc module is to provide a horizontally scalable solution that is easy to set up and maintain, while remaining flexible enough to cope with varying needs of each specific deployment.Throughout this text, by “data” we refer to SIP Addresses-of-Record (subscribers) and their dynamic SIP Contact bindings (network coordinates of their SIP devices) — all of these must be replicated across cluster nodes.</description>
    </item>
    
    <item>
      <title>Introducing OpenSIPS 3.0</title>
      <link>https://wdd.js.org/opensips/blog/opensips3x/</link>
      <pubDate>Wed, 31 Jul 2019 13:31:30 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/blog/opensips3x/</guid>
      <description>You already know the story – one more year, one more evolution cycle, one more OpenSIPS major release. Even more, a new OpenSIPS direction is about to start. So let me introduce you to the upcoming OpenSIPS 3.0 .For the upcoming OpenSIPS 3.0 release (and 3.x family) the main focus is on the **_devops _**concept. Shortly said, this translates into:
making the OpenSIPS script writing/developing much easier simplifying the operational activities around OpenSIPS What features and functionalities a software is able to deliver is a very important factor.</description>
    </item>
    
    <item>
      <title>核心MI命令</title>
      <link>https://wdd.js.org/opensips/ch3/core-mi/</link>
      <pubDate>Thu, 18 Jul 2019 13:54:58 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/core-mi/</guid>
      <description>在所有的fifo命令中，which命令比较重要，因为它可以列出所有的其他命令。
有些mi命令是存在于各个模块之中，所以加载的模块不通。opensipsctl fifo which输出的命令也不通。
获取执行参数 opensipsctl fifo arg 列出TCP连接数量 opensipsctl fifo list_tcp_conns 查看进程信息 opensipsctl fifo ps 查看opensips运行时长 opensipsctl fifo uptime 查看所有支持的指令 opensipsctl fifo which 获取统计数据 opensipsctl fifo get_statistics rcv_requests 重置统计数据 opensipsctl fifo get_statistics received_replies get_statistics reset_statistics uptime version pwd arg which ps kill debug cache_store cache_fetch cache_remove event_subscribe events_list subscribers_list list_tcp_conns help list_blacklists regex_reload t_uac_dlg t_uac_cancel t_hash t_reply ul_rm ul_rm_contact ul_dump ul_flush ul_add ul_show_contact ul_sync domain_reload domain_dump dlg_list dlg_list_ctx dlg_end_dlg dlg_db_sync dlg_restore_db profile_get_size profile_list_dlgs profile_get_values list_all_profiles nh_enable_ping cr_reload_routes cr_dump_routes cr_replace_host cr_deactivate_host cr_activate_host cr_add_host cr_delete_host dp_reload dp_translate address_reload address_dump subnet_dump allow_uri dr_reload dr_gw_status dr_carrier_status lb_reload lb_resize lb_list lb_status httpd_list_root_path sip_trace rtpengine_enable rtpengine_show rtpengine_reload teardown </description>
    </item>
    
    <item>
      <title>from vs to vs request-url之间的关系</title>
      <link>https://wdd.js.org/opensips/ch1/from-to-request-url/</link>
      <pubDate>Thu, 11 Jul 2019 07:38:53 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch1/from-to-request-url/</guid>
      <description>from字段用来标记请求的发起者ID to字段用来标记请求接受者的ID to字段并不能用于路由，request-url可以用来路由 一般情况下，sip消息再传输过程中，from和to字段都不会改，而request-url很可能会因为路由而改变 对于最初的请求，除了注册请求之外，request-url和to字段中的url一致 from字段：The From header field is a required header field that indicates the originator of the request. It is one of two addresses used to identify the dialog. The From header field contains a URI, but it may not contain the transport, maddr, or ttl URI parameters. A From header field may contain a tag used to identify a particular call. A From header field may contain a display name, in which case the URI is enclosed in &amp;lt; &amp;gt;.</description>
    </item>
    
    <item>
      <title>日志xlog</title>
      <link>https://wdd.js.org/opensips/ch5/xlog-level/</link>
      <pubDate>Tue, 09 Jul 2019 17:52:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/xlog-level/</guid>
      <description>建议日志格式 xlog(&amp;#34;$rm $fu-&amp;gt;$tu:$cfg_line some msg&amp;#34;) 日志级别 L_ALERT (-3) L_CRIT (-2) L_ERR (-1) - this is used by default if log_level is omitted L_WARN (1) L_NOTICE (2) L_INFO (3) L_DBG (4) 日志级别如果设置为2， 那么只会打印小于等于2的日志。默认使用xlog(&amp;ldquo;hello&amp;rdquo;), 那么日志级别就会是L_ERR
生产环境建议将日志界别调整到-1
1.x的opensips使用 debug=3 设置日志级别2.x的opensips使用 log_level=3 设置日志级别
动态设置日志级别 在程序运行时，可以通过opensipctl 命令动态设置日志级别
opensipsctl fifo log_level -2 最好使用日志级别 不要为了简便，都用 xlog(&amp;#34;msg&amp;#34;) 如果msg是信息级别，用xlog(&amp;#34;L_INFO&amp;#34;, &amp;#34;msg&amp;#34;) 如果msg是错误信息，则使用xlog(&amp;#34;msg&amp;#34;) </description>
    </item>
    
    <item>
      <title>opensips-summit-fraud</title>
      <link>https://wdd.js.org/opensips/ch8/fraud/</link>
      <pubDate>Tue, 02 Jul 2019 22:35:03 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/fraud/</guid>
      <description># # $Id$ # # OpenSIPS residential configuration script # by OpenSIPS Solutions &amp;lt;team@opensips-solutions.com&amp;gt; # # This script was generated via &amp;#34;make menuconfig&amp;#34;, from # the &amp;#34;Residential&amp;#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # http://www.opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### log_level=3 log_stderror=yes log_facility=LOG_LOCAL0 children=4 memdump=-1 /* uncomment the following line to enable debugging */ #debug_mode=yes /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes /* comment the next line to enable the auto discovery of local aliases based on revers DNS on IPs */ auto_aliases=no listen=udp:127.</description>
    </item>
    
    <item>
      <title>cluecon-fslb</title>
      <link>https://wdd.js.org/opensips/ch8/fs-loadbalance/</link>
      <pubDate>Tue, 02 Jul 2019 22:34:43 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/fs-loadbalance/</guid>
      <description># # OpenSIPS residential configuration script # by OpenSIPS Solutions &amp;lt;team@opensips-solutions.com&amp;gt; # # This script was generated via &amp;#34;make menuconfig&amp;#34;, from # the &amp;#34;Residential&amp;#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # http://www.opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### log_level=3 memdump=1 log_stderror=yes log_facility=LOG_LOCAL0 children=10 /* uncomment the following lines to enable debugging */ #debug_mode=yes /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes /* comment the next line to enable the auto discovery of local aliases based on revers DNS on IPs */ auto_aliases=no listen=udp:192.</description>
    </item>
    
    <item>
      <title>freeswitch-dtmf-language</title>
      <link>https://wdd.js.org/opensips/ch8/dtmf-lan/</link>
      <pubDate>Tue, 02 Jul 2019 22:34:27 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/dtmf-lan/</guid>
      <description># # OpenSIPS residential configuration script # by OpenSIPS Solutions &amp;lt;team@opensips-solutions.com&amp;gt; # # This script was generated via &amp;#34;make menuconfig&amp;#34;, from # the &amp;#34;Residential&amp;#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # http://www.opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### log_level=4 log_stderror=no log_facility=LOG_LOCAL0 children=4 /* uncomment the following lines to enable debugging */ #debug_mode=yes /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes /* comment the next line to enable the auto discovery of local aliases based on revers DNS on IPs */ auto_aliases=no listen = udp:10.</description>
    </item>
    
    <item>
      <title>mid-registrar</title>
      <link>https://wdd.js.org/opensips/ch8/mid-register/</link>
      <pubDate>Tue, 02 Jul 2019 22:32:02 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/mid-register/</guid>
      <description># # $Id$ # # OpenSIPS residential configuration script # by OpenSIPS Solutions &amp;lt;team@opensips-solutions.com&amp;gt; # # This script was generated via &amp;#34;make menuconfig&amp;#34;, from # the &amp;#34;Residential&amp;#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # http://www.opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### log_level=4 log_stderror=yes log_facility=LOG_LOCAL0 children=4 /* uncomment the following line to enable debugging */ #debug_mode=yes /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes /* comment the next line to enable the auto discovery of local aliases based on revers DNS on IPs */ auto_aliases=no listen=udp:10.</description>
    </item>
    
    <item>
      <title>siprec</title>
      <link>https://wdd.js.org/opensips/ch8/siprec/</link>
      <pubDate>Tue, 02 Jul 2019 22:31:18 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch8/siprec/</guid>
      <description># # OpenSIPS residential configuration script # by OpenSIPS Solutions &amp;lt;team@opensips-solutions.com&amp;gt; # # This script was generated via &amp;#34;make menuconfig&amp;#34;, from # the &amp;#34;Residential&amp;#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # http://www.opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### log_level=3 log_stderror=no log_facility=LOG_LOCAL0 children=4 /* uncomment the following lines to enable debugging */ #debug_mode=yes /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes /* comment the next line to enable the auto discovery of local aliases based on revers DNS on IPs */ auto_aliases=no listen=udp:127.</description>
    </item>
    
    <item>
      <title>sngrep: 最好用的sip可视化抓包工具</title>
      <link>https://wdd.js.org/opensips/tools/sngrep/</link>
      <pubDate>Tue, 02 Jul 2019 22:19:09 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/tools/sngrep/</guid>
      <description>1. 安装 1.1. centos vim /etc/yum.repos.d/irontec.repo
[irontec] name=Irontec RPMs repository baseurl=http://packages.irontec.com/centos/$releasever/$basearch/ rpm &amp;ndash;import http://packages.irontec.com/public.keyyum install sngrep
1.2 debian/ubuntu # debian 安装sngrep echo &amp;#34;deb http://packages.irontec.com/debian jessie main&amp;#34; &amp;gt;&amp;gt; /etc/apt/sources.list wget http://packages.irontec.com/public.key -q -O - | apt-key add - apt-get install sngrep -y debian buster 即 debian10以上可以直接 apt-get install sngrep 1.3 arch/manjaro yay -Syu sngrep 参考： https://aur.archlinux.org/packages/sngrep/
如果报错，编辑 /etc/makepkg.conf文件，删除其中的-Werror=format-security
CFLAGS=&amp;#34;-march=x86-64 -mtune=generic -O2 -pipe -fno-plt -fexceptions \ -Wp,-D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security \ -fstack-clash-protection -fcf-protection&amp;#34; 2.</description>
    </item>
    
    <item>
      <title>opensips监控</title>
      <link>https://wdd.js.org/opensips/ch3/opensips-monitor/</link>
      <pubDate>Tue, 02 Jul 2019 22:09:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/opensips-monitor/</guid>
      <description>**opensipsctl fifo get_statistics all **命令可以获取所有统计数据，在所有统计数据中，我们只关心内存，事务和回话的数量。然后将数据使用curl工具写入到influxdb中。
opensipsctl fifo reset_statistics all 重置统计数据
常用指令 命令 描述 opensipsctl fifo which 显示所有可用命令 opensipsctl fifo ps 显示所有进程 opensipsctl fifo get_statistics all 获取所有统计信息 opensipsctl fifo get_statistics core: 获取内核统计信息 opensipsctl fifo get_statistics net: 获取网路统计信息 opensipsctl fifo get_statistics pkmem: 获取私有内存相关信息 opensipsctl fifo get_statistics tm: 获取事务模块统计信息 opensipsctl fifo get_statistics sl: 获取sl模块统计信息 opensipsctl fifo get statistics shmem: 获取共享内存相关信息 opensipsctl fifo get statistics usrloc: 获取 opensipsctl fifo get statistics registrar: 获取注册统计信息 opensipsctl fifo get statistics uri: 获取uri统计信息 opensipsctl fifo get statistics load: 获取负载信息 opensipsctl fifo reset_statistics all 重置所有统计信息 shmem:total_size:: 6467616768 shmem:used_size:: 4578374040 shmem:real_used_size:: 4728909408 shmem:max_used_size:: 4728909408 shmem:free_size:: 1738707360 shmem:fragments:: 1 # 事务 tm:UAS_transactions:: 296337 tm:UAC_transactions:: 30 tm:2xx_transactions:: 174737 tm:3xx_transactions:: 0 tm:4xx_transactions:: 110571 tm:5xx_transactions:: 2170 tm:6xx_transactions:: 0 tm:inuse_transactions:: 289651 dialog:active_dialogs:: 156 dialog:early_dialogs:: 680 dialog:processed_dialogs:: 104061 dialog:expired_dialogs:: 964 dialog:failed_dialogs:: 78457 dialog:create_sent:: 0 dialog:update_sent:: 0 dialog:delete_sent:: 0 dialog:create_recv:: 0 dialog:update_recv:: 0 dialog:delete_recv:: 0 CONF_DB_URL=&amp;#34;ip:port&amp;#34; # influxdb地址 CONF_DB_NAME=&amp;#34;dbname&amp;#34; # influxdb数据库名 CONF_OPENSIPS_ROLE=&amp;#34;a&amp;#34; # 角色，随便写个字符串 PATH=&amp;#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin&amp;#34; LOCAL_IP=`ip route get 8.</description>
    </item>
    
    <item>
      <title>opensips centos7 安装与升级</title>
      <link>https://wdd.js.org/opensips/ch3/centos7-2.4/</link>
      <pubDate>Tue, 02 Jul 2019 19:42:05 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/centos7-2.4/</guid>
      <description>环境声明 系统 centos7 已经安装opensips 2.2 需要升级目标 opensips 2.4.6 要求：当前系统上没有部署mysql服务端程序 升级步骤 升级分为两步
opensips 应用升级，包括源码的下载，编译等等 opensips 数据库升级，使用opensipsdbctl工具迁移老的数据 Edge: opensips应用升级 升级过程以Makefile交付，可以先新建一个空的目录，如 /root/opensips-update/
# file: /root/opensips-update/Makefile VERSION=2.4.6 download: wget https://opensips.org/pub/opensips/$(VERSION)/opensips-$(VERSION).tar.gz; tar -zxvf opensips-$(VERSION).tar.gz; build: cd opensips-$(VERSION); make all -j4 include_modules=&amp;#34;db_mysql httpd db_http siprec&amp;#34;; # siprec是可选的 make install include_modules=&amp;#34;db_mysql httpd db_http siprec&amp;#34;; # siprec是可选的 新建空目录/root/opensips-update/ 在新目录中创建名为 Makefile的文件, 内容如上面所示 执行 make download 执行 make build Core: opensips应用升级 make all -j4 include_modules=&amp;#34;db_mysql httpd&amp;#34; make install include_modules=&amp;#34;db_mysql httpd&amp;#34; 可能遇到的报错以及解决方案 主要的问题可能是某些包冲突，或者某些库没有安装依赖。在解决问题后，需要重新编译。</description>
    </item>
    
    <item>
      <title>rtpproxy学习</title>
      <link>https://wdd.js.org/opensips/ch9/rtpproxy/</link>
      <pubDate>Thu, 20 Jun 2019 21:24:10 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/rtpproxy/</guid>
      <description>rtppoxy能提供什么功能？ VoIP NAT穿透 传输声音、视频等任何RTP流 播放预先设置的呼入放音 RTP包重新分片 包传输优化 VoIP VPN 穿透 实时流复制 rtpproxy一般和那些软件集成？ opensips Kamailio Sippy B2BUA freeswitch reSIProcate B2BUA rtpporxy的工作原理 启动参数介绍 参数 功能说明 例子 -l ipv4监听的地址 -l 192.168.3.47 -6 ipv6监听的地址 -s 控制Socket, 通过这个socket来修改，创建或者删除rtp session -s udp:192.168.3.49:6890 -F 默认情况下，rtpproxy会警告用户以超级用户的身份运行rtpproxy并且不允许远程控制。使用-F可以关闭这个限制 -m 最小使用的端口号，默认35000 -m 20000 -M 最大使用的端口号，默认65000 -M 50000 -L 单个进程最多可以使用的文件描述符。rtpproxy要求每个session使用4个文件描述符。 -L 20000 -d 日志级别，可选DBUG, INFO, WARN, ERR and CRIT, 默认DBUG -d ERR -A 广播地址，用于rtpprxy在NAT防火墙内部时使用 -A 171.16.200.13 -f 让rtpproxy前台运行，在做rtpproxy容器化时，启动脚本必须带有-f，否则容器运行后会立即退出 -V 输出rtpproxy的版本 参考 https://www.rtpproxy.org/ https://www.</description>
    </item>
    
    <item>
      <title>sdp协议简介</title>
      <link>https://wdd.js.org/opensips/ch9/sdp/</link>
      <pubDate>Thu, 20 Jun 2019 15:29:36 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/sdp/</guid>
      <description>sdp栗子 v=0 o=- 7158718066157017333 2 IN IP4 127.0.0.1 s=- t=0 0 a=group:BUNDLE 0 a=msid-semantic: WMS byn72RFJBCUzdSPhnaBU4vSz7LFwfwNaF2Sy m=audio 64030 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126 c=IN IP4 192.168.2.180 Session描述 **
v= (protocol version number, currently only 0) o= (originator and session identifier : username, id, version number, network address) s= (session name : mandatory with at least one UTF-8-encoded character) i=* (session title or short information) u=* (URI of description) e=* (zero or more email address with optional name of contacts) p=* (zero or more phone number with optional name of contacts) c=* (connection information—not required if included in all media) b=* (zero or more bandwidth information lines) One or more Time descriptions (&amp;#34;t=&amp;#34; and &amp;#34;r=&amp;#34; lines; see below) z=* (time zone adjustments) k=* (encryption key) a=* (zero or more session attribute lines) Zero or more Media descriptions (each one starting by an &amp;#34;m=&amp;#34; line; see below) 时间描述(必须) t= (time the session is active) r=* (zero or more repeat times) 媒体描述(可选) m= (media name and transport address) i=* (media title or information field) c=* (connection information — optional if included at session level) b=* (zero or more bandwidth information lines) k=* (encryption key) a=* (zero or more media attribute lines — overriding the Session attribute lines) </description>
    </item>
    
    <item>
      <title>参考资料与书籍</title>
      <link>https://wdd.js.org/opensips/ch9/books/</link>
      <pubDate>Thu, 20 Jun 2019 10:59:17 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch9/books/</guid>
      <description> Building Telephony Systems with OpenSIPS Second Edition SIP: Session Initiation Protocol Session Initiation Protocol (SIP) Basic Call Flow Examples Re-INVITE and Target-Refresh Request Handling in the Session Initiation Protocol (SIP) SDP: Session Description Protocol freeswitch权威指南 SIP: Understanding the Session Initiation Protocol, Third Edition (Artech House Telecommunications) https://tools.ietf.org/html/rfc4028 Hacking VoIP: Protocols, Attacks, and Countermeasures </description>
    </item>
    
    <item>
      <title>有状态和无状态路由</title>
      <link>https://wdd.js.org/opensips/ch5/stateful-stateless/</link>
      <pubDate>Wed, 19 Jun 2019 23:40:08 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/stateful-stateless/</guid>
      <description> 操作 无状态 有状态 SIP forward forward() t_relay() SIP replying sl_send_reply() t_reply() Create transaction t_newtran() Match transcation t_check_trans() </description>
    </item>
    
    <item>
      <title>严格路由和松散路由</title>
      <link>https://wdd.js.org/opensips/ch5/strict-loose-routing/</link>
      <pubDate>Tue, 18 Jun 2019 11:11:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/strict-loose-routing/</guid>
      <description>松散路由是sip 2版本的新的路由方法。严格路由是老的路由方法。
如何从sip消息中区分严格路由和松散路由 下图sip消息中Route字段中带有**lr, **则说明这是松散路由。
REGISTER sip:127.0.0.1 SIP/2.0 Via: SIP/2.0/UDP 127.0.0.1:58979;rport;branch=z9hG4bKPjMRzNdeTKn9rHNDtyJuVoyrDb84.cPtL8 Route: &amp;lt;sip:127.0.0.1;lr&amp;gt; Max-Forwards: 70 From: &amp;#34;1001&amp;#34; &amp;lt;sip:1001@172.17.0.2&amp;gt;;tag=oqkOzbQYd9cx5vXFjUnB1WufgWUZZxtZ To: &amp;#34;1001&amp;#34; &amp;lt;sip:1001@172.17.0.2&amp;gt; 功能上的区别 严格路由，sip请求经过uas后，invite url每次都会被重写。
松散路由，sip请求经过uas后，invite url不变。
#1 invite INVITE sip:callee@domain.com SIP/2.0 Contact: sip:caller@u1.example.com #2 invite INVITE sip:callee@domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: &amp;lt;sip:p1.example.com;lr&amp;gt; #3 invite INVITE sip:callee@u2.domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: &amp;lt;sip:p2.domain.com;lr&amp;gt; Record-Route: &amp;lt;sip:p1.example.com;lr&amp;gt; #4 200 ok SIP/2.0 200 OK Contact: sip:callee@u2.domain.com Record-Route: &amp;lt;sip:p2.domain.com;lr&amp;gt; Record-Route: &amp;lt;sip:p1.example.com;lr&amp;gt; #7 bye BYE sip:callee@u2.domain.com SIP/2.0 Route: &amp;lt;sip:p1.</description>
    </item>
    
    <item>
      <title>sip消息分发之dispatcher模块</title>
      <link>https://wdd.js.org/opensips/ch6/dispatcher/</link>
      <pubDate>Tue, 18 Jun 2019 10:51:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch6/dispatcher/</guid>
      <description>dispatcher模块用来分发sip消息。
dispatcher如何记录目的地状态 dispatcher会使用一张表。
需要关注两个字段destionations， state。
destionations表示sip消息要发往的目的地 state表示对目的地的状态检测结果 0 可用 1 不可用 2 表示正在检测 opensips只会想可用的目的地转发sip消息
id setid destionations state 1 1 sip:p1:5060 0 2 1 sip:p2:5060 1 3 1 sip:p2:5061 2 dispatcher如何检测目的地的状态 本地的opensips会周期性的向目的地发送options包，如果对方立即返回200ok, 就说明目的地可用。
在达到一定阈值后，目的地一直无响应，则opensips将其设置为不可用状态，或者正在检测状态。如下图所示
代码例子 ds_select_dst()函数会去选择可用的目的地，并且设置当前sip消息的转发地址。如果发现无用可转发地址，则进入504 服务不可用的逻辑。
如果sip终端注册时返回504，则可以从dispatcher模块，排查看看是不是所有的目的地都处于不可用状态。
if (!ds_select_dst(&amp;#34;1&amp;#34;, &amp;#34;0&amp;#34;)) { send_reply(&amp;#34;504&amp;#34;,&amp;#34;Service Unavailable&amp;#34;); exit; } </description>
    </item>
    
    <item>
      <title>变量的使用</title>
      <link>https://wdd.js.org/opensips/ch5/var/</link>
      <pubDate>Sun, 16 Jun 2019 17:18:55 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/var/</guid>
      <description>变量的使用方式 $(&amp;lt;context&amp;gt;type(name)[index]{transformation}) 变量都以$符号开头 type表示变量的类型：核心变量，自定义变量，键值对变量 name表示变量名：如$var(name), $avp(age) index表示需要，有些变量类似于数组，可以使用需要来指定。需要可以用正数和负数，如-1表示最后一个元素 transformations表示类型转换，如获取一个字符串值的长度，大小写转换等操作 context表示变量存在的作用域，opensips有请求的作用域和响应的作用域 # by type $ru # type type and name $hdr(Contact) # bye type and index $(ct[0]) # by type name and index $(avp(gw_ip)[2]) # by context $(&amp;lt;request&amp;gt;ru) $(&amp;lt;reply&amp;gt;hdr(Contact)) 引用变量 所有的引用变量都是可读的，但是只有部分变量可以修改。引用变量一般都是英文含义的首字母缩写，刚开始接触opensips的同学可能很不习惯。实际上通过首字母大概是可以猜出变量的含义的。
必须记住变量的用黄色标记。
变量名 英文含义 中文解释 是否可修改 $ru request url 请求url 是 $rU Username in SIP Request&amp;rsquo;s URI 是 $ci call id callId $hdr(from) request headers from 请求头中的from字段 是 $Ts current time unix Timestamp 当前时间的unix时间戳 $branch Branch $cl Content-Length $cs CSeq number $cT Content-Type $dd Domain of destination URI 目标地址的域名 是 $di Diversion header URI $dp Port of destination URI 目标地址的端口 是 $dP Transport protocol of destination URI 传输协议 $du Destination URI 目标地址 是 $fd From URI domain $fn From display name $ft From tag $fu From URI $fU From URI username $mb SIP message buffer $mf Message Flags $mi SIP message ID $ml SIP message length $od Domain in SIP Request&amp;rsquo;s original URI $op Port of SIP request&amp;rsquo;s original URI $oP Transport protocol of SIP request original URI $ou SIP Request&amp;rsquo;s original URI $oU Username in SIP Request&amp;rsquo;s original URI $param(idx) Route parameter $pp Process id $rd Domain in SIP Request&amp;rsquo;s URI $rb Body of request/reply 是 $rc Returned code $re Remote-Party-ID header URI $rm SIP request&amp;rsquo;s method $rp SIP request&amp;rsquo;s port 是 $rP Transport protocol of SIP request URI $rr SIP reply&amp;rsquo;s reason $rs SIP reply&amp;rsquo;s status $rt reference to URI of refer-to header $Ri Received IP address $Rp Received port $sf Script flags $si IP source address $sp Source port $td To URI Domain $tn To display name $tt To tag $tu To URI $tU To URI Username $TF String formatted time $TS Startup unix time stamp $ua User agent header 更多变量可以参考：https://www.</description>
    </item>
    
    <item>
      <title>路由的触发时机</title>
      <link>https://wdd.js.org/opensips/ch5/triger-time/</link>
      <pubDate>Sun, 16 Jun 2019 17:16:41 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/triger-time/</guid>
      <description> 掌握路由触发时机的关键是以下几点
消息是请求还是响应 消息是进入opensips的(incoming)，还是离开opensips的(outgoing) 从opensips发出去的ack请求，不会触发任何路由 **进入opensips(**incoming) 离开opensips(outgoing) 请求 触发请求路由：例如invite, register, ack 触发分支路由。如invite的转发 响应 触发响应路由。如果是大于等于300的响应，还会触发失败路由。 不会触发任何路由 </description>
    </item>
    
    <item>
      <title>【重点】初始化请求和序列化请求</title>
      <link>https://wdd.js.org/opensips/ch5/init-seque/</link>
      <pubDate>Sun, 16 Jun 2019 12:50:22 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/init-seque/</guid>
      <description>在说这两种路由前，先说一个故事。蚂蚁找食物。
蚁群里有一种蚂蚁负责搜寻食物叫做侦察兵，侦察兵得到消息，不远处可能有食物。于是侦察兵开始搜索食物的位置，并沿途留下自己的气味。翻过几座山之后，侦察兵发现了食物。然后又沿着气味回到了部落。然后通知搬运兵，沿着自己留下的气味，就可以找到食物。
在上面的故事中，侦查兵可以看成是初始化请求，搬运并可以看做是序列化请求。在学习opensips的路由过程中，能够区分初始化请求和序列化请求，是非常重要的。
一般路由处理，查数据库，查dns等都在初始化请求中做处理，序列化请求只需要简单的更具sip route字段去路由就可以了。
类型 功能 message 如何区分 特点 初始化请求 创建session或者dialog invite has_totag()是false 1. 发现被叫：初始化请求经过不同的服务器，DNS服务器，前缀路由等各种复杂的路由方法，找到被叫2. **记录路径: **记录到达被叫的路径，给后续的序列请求提供导航 序列化请求 修改或者终止session ack, bye, re-ivite, notify has_totag()是true 1. 只需要根据初始化请求提供的导航路径，来到达路径，不需要复杂的路由逻辑。 区分初始化请求和序列化请求，是用header字段中的to字段是否含有tag标签。
tag参数被用于to和from字段。使用callid，fromtag和totag三个字段可以来唯一识别一个dialog。每个tag来自一个ua。
当一个ua发出一个不在对话中的请求时，fromtag提供一半的对话标识，当对话完成时，另一方参与者提供totag标识。
举例来说，对于一个invite请求，例如Alice-&amp;gt;Proxy
invite请求to字段无tag参数 当alice回ack请求时，已经含有了to tag。这就是一个序列化请求了。因为通过之前的200ok, alice已经知道到达bob的路径。 INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b43 Max-Forwards: 70 Route: &amp;lt;sip:ss1.atlanta.example.com;lr&amp;gt; From: Alice &amp;lt;sip:alice@atlanta.example.com&amp;gt;;tag=9fxced76sl # 有from tag To: Bob &amp;lt;sip:bob@biloxi.example.com&amp;gt; # 无to tag Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: &amp;lt;sip:alice@client.atlanta.example.com;transport=tcp&amp;gt; Content-Type: application/sdp Content-Length: 151 ACK sip:bob@client.biloxi.example.com SIP/2.</description>
    </item>
    
    <item>
      <title>脚本路由模块化</title>
      <link>https://wdd.js.org/opensips/ch5/module/</link>
      <pubDate>Sun, 16 Jun 2019 11:22:56 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/module/</guid>
      <description>当你的代码一个屏幕无法展示完时，你就需要考虑模块化的事情了。
维护一个上千行的代码，是很辛苦，也是很恐怖的事情。
我们应当把自己的关注点放在某个具体的点上。
方法1 include_file 具体方法是使用include_file参数。
如果你的opensips.cfg文件到达上千行，你可以考虑使用一下include_file指令。
include_file &amp;#34;global.cfg&amp;#34; include_file &amp;#34;moudule.cfg&amp;#34; include_file &amp;#34;routing.cfg&amp;#34; 方法2 m4 宏编译 参考：https://github.com/wangduanduan/m4-opensips.cfg</description>
    </item>
    
    <item>
      <title>优雅的使用xlog输出日志行</title>
      <link>https://wdd.js.org/opensips/ch5/xlog/</link>
      <pubDate>Sun, 16 Jun 2019 11:16:32 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/xlog/</guid>
      <description>在opensips 2.2中加入新的全局配置cfg_line, 用来返回当前日志在整个文件中的行数。
注意，低于2.2的版本不能使用cfg_line。
使用方法如下：
... xlog(&amp;#34;$cfg_line enter_ack_deal&amp;#34;) ... xlog(&amp;#34;$cfg_line enter_ack_deal&amp;#34;) ... 如果没有cfg_line这个参数，你在日志中看到enter_ack_deal后，根本无法区分是哪一行打印了这个关键词。
使用了cfg_line后，可以在日志中看到类似如下的日志输出方式，很容易区分哪一行日志执行了。
23 enter_ack_deal 823 enter_ack_deal </description>
    </item>
    
    <item>
      <title>全局参数配置</title>
      <link>https://wdd.js.org/opensips/ch5/global-params/</link>
      <pubDate>Sun, 16 Jun 2019 11:03:12 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/global-params/</guid>
      <description>本全局参数基于opensips 2.4介绍。
opensips的全局参数有很多，具体可以参考。https://www.opensips.org/Documentation/Script-CoreParameters-2-4#toc37
下面介绍几个常用的参数
log_level=3 log_facility=LOG_LOCAL0 listen=172.16.200.228:4400 log_level log_level的值配置的越大，输出的日志越详细。log_level的值的范围是[-3, 4]
-3 - Alert level -2 - Critical level -1 - Error level 1 - Warning level 2 - Notice level 3 - Info level 4 - Debug level log_facility log_facility用来设置独立的opensips日志文件，参考https://www.yuque.com/wangdd/opensips/log
listen listen用来设置opensips监听的端口和协议, 由于opensips底层支持的协议很多，所以你可以监听很多不同协议。
注意一点：不要监听本地环回地址127.0.0.1, 而要监听etho0的ip地址。
listen:udp:172.16.200.228:5060 listen:tcp:172.16.200.228:5061 listen:ws:172.16.200.228:5062 </description>
    </item>
    
    <item>
      <title>函数特点</title>
      <link>https://wdd.js.org/opensips/ch5/function/</link>
      <pubDate>Sun, 16 Jun 2019 10:48:57 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/function/</guid>
      <description>opensips脚本中没有类似function这样的关键字来定义函数，它的函数主要有两个来源。
opensips核心提供的函数: 模块提供的函数: lb_is_destination(), consume_credentials() 函数特点 opensips函数的特点
最多支持6个参数 所有的参数都是字符串，即使写成数字，解析时也按照字符串解析 函数的返回值只能是整数 所有函数不能返回0，返回0会导致路由停止执行，return(0)相当于exit() 函数返回的正数可以翻译成true 函数返回的负数会翻译成false 使用return(9)返回结果 使用$rc获取上个函数的返回值 虽然opensips脚本中无法自定义函数，但是可以把route关键字作为函数来使用。
可以给
# 定义enter_log函数 route[enter_log]{ xlog(&amp;#34;$ci $fu $tu $param(1)&amp;#34;) # $param(1) 是指调用enter_log函数的第一个参数，即wangdd return(1) } route{ # 调用enter_log函数 route(enter_log, &amp;#34;wangdd&amp;#34;) # 获取enter_log的返回值 $rc xlog(&amp;#34;$rc&amp;#34;) } 如何传参 某个函数可以支持6个参数，全部都是的可选的，但是我只想传第一个和第6个，应该怎么传？
不想传参的话，需要使用逗号隔开
siprec_start_recording(srs,,,,,media_ip) </description>
    </item>
    
    <item>
      <title>路由分类</title>
      <link>https://wdd.js.org/opensips/ch5/routing-type/</link>
      <pubDate>Sun, 16 Jun 2019 10:46:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/routing-type/</guid>
      <description>opensips路由分为两类，主路由和子路由。主路由被opensips调用，子路由在主路由中被调用。可以理解子路由是一种函数。
所有路由中不允许出现无任何语句的情况，否则将会导致opensips无法正常启动，例如下面
route[some_xxx]{ } 主路由分为几类
请求路由 分支路由 失败路由 响应路由 本地路由 启动路由 定时器路由 事件路由 错误路由 inspect：查看sip消息内容 modifies: 修改sip消息内容，例如修改request url drop: 丢弃sip请求 forking: 可以理解为发起一个invite, 然后可以拨打多个人 signaling: 信令层的操作，例如返回200ok之类的
路由 是否必须 默认行为 可以做 不可以做 触发方向 触发次数 请求路由 是 drop inspect,modifies, drop, signaling incoming, inbound 分支路由 否 send out forking, modifies, drop, inspect relaying, replying,signaling outbound, outgoing, branch frok 一个请求/事务一次 失败路由 否 将错误返回给产生者 signaling，replying, inspect incoming 一个请求/事务一次 响应路由 否 relay back inspect, modifies signaling incoming, inbound 一个请求/事务一次 本地路由 否 send out signaling outbound 本地路由只能有一个 剩下的启动路由，定时器路由，事件路由，错误路由只能用来做和sip消息无关的事情。</description>
    </item>
    
    <item>
      <title>设置独立日志文件</title>
      <link>https://wdd.js.org/opensips/ch3/log/</link>
      <pubDate>Sun, 16 Jun 2019 10:33:15 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/log/</guid>
      <description>设置独立日志 默认情况下，opensips的日志会写在系统日志文件/var/log/message中，为了避免难以查阅日志，我们可以将opensips的日志写到单独的日志文件中。
环境说明
debian buster
这个需要做两步。
第一步，配置opensips.cfg文件
log_facility=LOG_LOCAL0 第二步, 创建日志配置文件
echo &amp;#34;local0.* -/var/log/opensips.log&amp;#34; &amp;gt; /etc/rsyslog.d/opensips.conf 第三步，创建日志文件
touch /var/log/opensips.log 第四步，重启rsyslog和opensips
service rsyslog restart opensipsctl restart 第五步，验证结果
tail /var/log/opensips.log 日志回滚 为了避免日志文件占用过多磁盘空间，需要做日志回滚。
安装logrotate apt install logrotate -y 日志回滚配置文件 /etc/logrotate.d/opensips
/var/log/opensips.log { noolddir size 10M rotate 100 copytruncate compress sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true /bin/kill -HUP `cat /var/run/rsyslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true endscript } 配置定时任务</description>
    </item>
    
    <item>
      <title>配置文件</title>
      <link>https://wdd.js.org/opensips/ch5/routing-script/</link>
      <pubDate>Thu, 13 Jun 2019 22:10:45 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch5/routing-script/</guid>
      <description>脚本预处理 如果你的opensips.cfg文件不大，可以写成一个文件。否则建议使用include_file引入配置文件。
include_file &amp;#34;global.cfg&amp;#34; 有些配置，建议使用m4宏处理。
脚本结构 ####### Global Parameters ######### debug=3 log_stderror=no fork=yes children=4 listen=udp:127.0.0.1:5060 ####### Modules Section ######## mpath=&amp;#34;/usr/local/lib/opensips/modules/&amp;#34; loadmodule &amp;#34;signaling.so&amp;#34; loadmodule &amp;#34;sl.so&amp;#34; loadmodule &amp;#34;tm.so&amp;#34; loadmodule &amp;#34;rr.so&amp;#34; loadmodule &amp;#34;uri.so&amp;#34; loadmodule &amp;#34;sipmsgops.so&amp;#34; modparam(&amp;#34;rr&amp;#34;, &amp;#34;append_fromtag&amp;#34;, 0) ####### Routing Logic ######## route{ if ( has_totag() ) { loose_route(); route(relay); } if ( from_uri!=myself &amp;amp;&amp;amp; uri!=myself ) { send_reply(&amp;#34;403&amp;#34;,&amp;#34;Rely forbidden&amp;#34;); exit; } record_route(); route(relay); } route[relay] { if (is_method(&amp;#34;INVITE&amp;#34;)) t_on_failure(&amp;#34;missed_call&amp;#34;); t_relay(); exit; } failure_route[missed_call] { if (t_check_status(&amp;#34;486&amp;#34;)) { $rd = &amp;#34;127.</description>
    </item>
    
    <item>
      <title>opensips管理命令</title>
      <link>https://wdd.js.org/opensips/ch3/opensipsctl/</link>
      <pubDate>Thu, 13 Jun 2019 22:03:19 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/opensipsctl/</guid>
      <description>可以使用一下命令查找opensips的相关文件夹
find / -name opensips -type d 一般来说，重要的是opensips.cfg文件，这个文件一般位于/usr/local/etc/opensips/或者/usr/etc/opensips中。主要还是要看安装时选择的默认路径。
其中1.x版本的配置文件一般位于/usr/etc/opensips目录中，2.x版本的配置一般位于/usr/local/etc/opensips目录中。
下面主要讲解几个命令。
配置文件校验 校验opensips.cfg脚本是否合法, 如果有问题，会提示那行代码有问题，但是报错位置好像一直不准确。很多时候可能是忘记写分好了。
opensips -C opensips.cfg 启动关闭与重启 使用opensipsctl命令做数据库操作前，需要先配置opensipsctlrc文件
opensips start|stop|restart opensipsctl start|stop|restart 资源创建 opensipsdbctl create # 创建数据库 opensipsctl domain add abc.cc #创建域名 opensipsctl add 1001@test.cc 12346 # 新增用户 opensipsctl rm 1001@test.cc # 删除用户 opensipsctl passwdd 1001@test.cc 09879 # 修改密码 opensipsctl -h 显示所有可用命令
/usr/local/sbin/opensipsctl $Revision: 4448 $ Existing commands: -- command &amp;#39;start|stop|restart|trap&amp;#39; trap ............................... trap with gdb OpenSIPS processes restart ............................ restart OpenSIPS start .</description>
    </item>
    
    <item>
      <title>debian jessie opensips 2.4.7 安装</title>
      <link>https://wdd.js.org/opensips/ch3/install-opensips/</link>
      <pubDate>Thu, 13 Jun 2019 21:53:16 +0800</pubDate>
      
      <guid>https://wdd.js.org/opensips/ch3/install-opensips/</guid>
      <description>1. 安装依赖 apt-get update -qq &amp;amp;&amp;amp; apt-get install -y build-essential net-tools \ bison flex m4 pkg-config libncurses5-dev rsyslog libmysqlclient-dev \ libssl-dev mysql-client libmicrohttpd-dev libcurl4-openssl-dev uuid-dev \ libpcre3-dev libconfuse-dev libxml2-dev libhiredis-dev wget lsof 2. 编译 下载opensips-2.4.7的源码，然后解压。
include_moduls可以按需指定，你可以只写你需要的模块。
cd /usr/local/src/opensips-2.4.7 make all -j4 include_modules=&amp;#34;db_mysql httpd db_http siprec regex rest_client carrierroute dialplan b2b_logic cachedb_redis proto_tls proto_wss tls_mgm&amp;#34; make install include_modules=&amp;#34;db_mysql httpd db_http siprec regex rest_client carrierroute dialplan b2b_logic cachedb_redis proto_tls proto_wss tls_mgm&amp;#34; </description>
    </item>
    
  </channel>
</rss>
