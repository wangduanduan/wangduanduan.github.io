<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Clustering ongoing calls with OpenSIPS 2.4 | 洞香春</title>
<meta name=keywords content><meta name=description content="Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the clusterer module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for clustering dialog support?"><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/blog/cluster-call/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.5b9ae0304f93db6cc493f51846f012428af399c614b4f2fbdb7fa59dd4d5ef5b.js integrity="sha256-W5rgME+T22zEk/UYRvASQorzmcYUtPL723+lndTV71s=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.120.3"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Clustering ongoing calls with OpenSIPS 2.4"><meta property="og:description" content="Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the clusterer module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for clustering dialog support?"><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/blog/cluster-call/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2019-07-31T13:36:53+08:00"><meta property="article:modified_time" content="2019-07-31T13:36:53+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Clustering ongoing calls with OpenSIPS 2.4"><meta name=twitter:description content="Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the clusterer module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for clustering dialog support?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"Clustering ongoing calls with OpenSIPS 2.4","item":"https://wdd.js.org/opensips/blog/cluster-call/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Clustering ongoing calls with OpenSIPS 2.4","name":"Clustering ongoing calls with OpenSIPS 2.4","description":"Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the clusterer module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for clustering dialog support?","keywords":[],"articleBody":"Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the clusterer module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for clustering dialog support? In this article we are going to look into the limitations of distributing ongoing calls in previous OpenSIPS versions and how we overcame them and added new possibilities in 2.4, based on the improved clustering engine.\nPrevious Limitations Up until this point, distributing ongoing dialogs essentially only consisted in sharing the relevant internal information with all other OpenSIPS instances in the cluster. To optimize the communication, whenever a new dialog is created (and confirmed) or on existing one is updated (state changes etc.), a binary message about that particular dialog is broadcasted.Limiting the data exchange to be driven by runtime events leaves an instance with no way of learning all the dialog information from the cluster when it boots up or at a particular moment in time. Consider what happens when we restart a backup OpenSIPS: any failover that we hope to be able to handle on that node will have to be delayed until it gets naturally in sync with the other node(s).But the more painful repercussion of just sharing data without any other distributed logic is the lack of a mechanism to coordinate certain data-related actions between the cluster nodes. For example, in a typical High-Availability setup with an active-passive nodes configuration, although all dialogs are duplicated to the passive node, the following must be performed exactly once:\ngenerate **BYE requests **and/or produce CDRs (Call Detail Records) upon dialog expiration; send Re-Invite or OPTIONS pings to end-points; send replication packets on dialog events; update the dialog database (if it is still used as a failsafe for binary replication, e.g. both nodes crash). Usage scenarios Before actually diving into how OpenSIPS 2.4 solves the before mentioned issues, let’s first see the most popular scenarios we considered when designing the dialog clustering support:\nActive – Backup setup for High Availability using Virtual IPs**.** The idea here would be to have a Virtual IP (or floating IP) facing the end-users. This IP will be automatically moved from a failed instance to a hot-backup server by tools like vrrpd, KeepaliveD, Heartbeat. Active – Active setup, or a double cross Active-Backup. This is a more “creative” approach using two Virtual IPs, each server being active for one of them and backup for the other, and still sharing all the dialogs, in order to handle both VIPs when a server fails. Anycast setup for Distributed calls (High Availability and Balancing). This relies on the newly add full support for Anycast** **introduced in OpenSIPS 2.4. You can find more details in the dedicated article. Dialog Clustering with OpenSIPS 2.4 The new dialog clustering support in OpenSIPS 2.4 is addressing all the mentioned limitations by properly and fully addressing the typical clustering scenarios. But first let’s see which are the newly introduced concepts in OpenSIPS 2.4 when it comes to clustering dialogs.\nData synchronization In order to address our first discussed issue, the improved clustering under-layer in OpenSIPS 2.4 offers the capability of synchronizing a freshly booted node with the complete data set from the cluster in a fast and transparent manner. This way, we can minimize the impact of restarting an OpenSIPS instance, or plugging a new node in the cluster on the fly, without needing any DB storage or having to accept the compromise of lost dialogs. We can also perform a sync at any time via an MI command, if for some reason the dialog data got desynchronized on a given instance.\nDialog ownership mechanism The other big improvement that OpenSIPS 2.4 introduces for distributing dialogs is the capability to precisely decide which node in the cluster is responsible for a dialog – responsible in the way of triggering certain actions for that dialog. This comes as a necessity because some of the dialogs are locally created on an instance, some are temporarily handled in place of a failed/inactive node and others are just kept as backup. As such, the concept of dialog “ownership” was introduced.The basic idea of this mechanism is that a single node in the dialog cluster (where all the calls are shared) is “responsible” at any time of a given dialog, in terms of taking actions for it. When the node owning the dialog goes down, another node become its owner and handle its actions.But how is this ownership concept concretely implemented in OpenSIPS 2.4?\nSharing tags In order to be able to establish an ownership relationship between the nodes and the dialog, we introduced the concept of tags or _“sharing tags” _as we call them. Each dialog is marked with a single tag; on the other hand, a node is actively responsible for (owning) a tag (and indirectly all the dialogs marked with that tag). A tag may be present on several nodes, but only a single node sees the tag as active; the other nodes aware of that tag are seeing the tag in standby/backup mode.So each node may be aware of multiple sharing tags, each with an _active _or backup state. Each tag can be defined with an implicit state at OpenSIPS startup or directly set at runtime and all this information is shared between the cluster nodes. When we set a sharing tag to active on certain node, we are practically setting that node to become the owner of all its known dialogs that are marked with that particular tag. At the same time, if another node was active for tag, it has to step down.To better understand this, we will briefly describe how the sharing tags should be used in the previously mentioned scenarios, considering a simple two node cluster:\nin an active-backup cluster with a single VIP, we would only need a single sharing tag corresponding the VIP address; the node that holds the VIP will also have the VIP set to active and perform all the dialog related actions; in an active-active cluster with two VIPs, we would need two sharing tags, corresponding to each VIP, and whichever node holds the given VIP, should have the appropriate tag set as active; in an anycast cluster setup, we will have one sharing tag corresponding to each node (because the dialog is tied to the node it was first created as opposed to an IP). If a node is up, it should have its corresponding tag active, otherwise any node can take the tag over. Configuration Setting up dialog replication in OpenSIPS 2.4 is very easy and, in the following, we will exemplify our discussed scenarios with the essential configuration:\n1. Active-backup setup Let’s use the tag named “vip” which will be configured via the dlg_sharing_tag module parameter. When starting OpenSIPS, you need to check the HA status of the node (by inspecting the HA system) and to decide which node will start as owner of the tag:modparam(“dialog”, “dlg_sharing_tag”, “vip=active”)if active or :modparam(“dialog”, “dlg_sharing_tag”, “vip=backup”)if standby.During runtime, depending on the change of the HA system, the tag may be moved (as active) to a different node by using MI commands (see following chapter).At script level, all we need to do, on each node, is to mark a newly created dialog with the sharing tag, using the set_dlg_sharing_tag() function:if (is_method(“INVITE”)) { create_dialog(); set_dlg_sharing_tag(“vip”);}\n2. Active-active setup Similar with the previous case, but we will use two tags, one for each VIP address. We will define the initial tag state for the first VIP, on the first node:modparam(“dialog”, “dlg_sharing_tag”, “vip1=active”)The second node will initially be responsible for the second VIP, so on node id 2 we will set:modparam(“dialog”, “dlg_sharing_tag”, “vip2=active”)Now, on each node, depending on which VIP do we receive the initial Invite, we mark the dialog appropriately:if (is_method(“INVITE”)) { create_dialog(); if ($Ri == 10.0.0.1 # VIP 1) set_dlg_sharing_tag(“vip1”); else if ($Ri == 10.0.0.2 # VIP 2) set_dlg_sharing_tag(“vip2”);}So, calls established via the VIP1 address will be marked with the “vip1” tag and handled by the node having the “vip1” tag as active – this will be the node 1 in normal operation.The calls established via the VIP2 address will be marked with the “vip2” tag and handled by the node having the “vip2” tag as active – this will be the node 2 in normal operation.If the node 1 fails, the HA system will move the VIP1 as active on node 2. Further, the HA system is responsible to instruct OpenSIPS running on node 2 that it become the owner of tag “vip1” also, so node 2 will start to actively handle the calls marked with “vip1” also.\n3. Anycast setup Each node has its own corresponding tag and it starts with the tag as active. So on node 1 we will have:modparam(“dialog”, “dlg_sharing_tag”, “node_1=active”)And on the second node, the same as above, but with “node_2=active”.Now, each node marks the dialogs with its own tag, for example on node 1:if (is_method(“INVITE”)) { create_dialog(); set_dlg_sharing_tag(“node_1”);}And, conversely, node 2 marks each created dialog with the “node_2” tag.If node 1 fails, the monitoring system (also responsible for the Anycast management and BGP updates) will pick one of the remaining node in the anycast group and it will activate the “node_1” tag on it. So, this new node will became owner and responsible for the calls created on former node 1.\nChanging sharing tags state All that remains to be discussed is how can we take over the ownership of the dialogs flagged with a certain sharing tag at runtime. This is of course the case when our chosen mechanism of node availability detects that a node in the cluster is down, or when we do a manual switch-over (e.g. for maintenance). So for this purpose, all we have to do is to issue the MI command dlg_set_sharing_tag_active that sets a certain sharing tag to the active state. For example, in the single VIP scenario, with a sharing tag named “vip”, after we have re-pointed the floating IP to the current machine, we would run:opensipsctl fifo dlg_set_sharing_tag_active vip\nConclusions The new dialog clustering support in OpenSIPS 2.4 is a complete one as it not only takes care of dialog replication/sharing, but also of dialog handling in terms of properly triggering dialog-specific actions.The implementation also tries to provide a consistent solution, by following and addressing the most used scenarios in terms of dialog clustering – these are real world scenarios answering to real world needs.Even more, the work on the dialog clustering was consistently correlated with work on the Anycast support, so it will be an easy task for the user to build an integrated anycast setup taking care of both transaction and dialog layers.Need more practical examples ? Join us to the OpenSIPS Summit 2018 in Amsterdam and see the Interactive Demos about the clustering support in OpenSIPS 2.4\n","wordCount":"1842","inLanguage":"en","datePublished":"2019-07-31T13:36:53+08:00","dateModified":"2019-07-31T13:36:53+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/blog/cluster-call/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>Clustering ongoing calls with OpenSIPS 2.4</h1><div class=post-meta>&lt;span title='2019-07-31 13:36:53 +0800 CST'>2019-07-31 13:36:53&lt;/span>&amp;nbsp;·&amp;nbsp;9 min&amp;nbsp;·&amp;nbsp;Eddie Wang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#previous-limitations aria-label="Previous Limitations">Previous Limitations</a></li><li><a href=#usage-scenarios aria-label="Usage scenarios">Usage scenarios</a></li><li><a href=#dialog-clustering-with-opensips-24 aria-label="Dialog Clustering with OpenSIPS 2.4">Dialog Clustering with OpenSIPS 2.4</a><ul><li><a href=#data-synchronization aria-label="Data synchronization">Data synchronization</a></li><li><a href=#dialog-ownership-mechanism aria-label="Dialog ownership mechanism">Dialog ownership mechanism</a><ul><li><a href=#sharing-tags aria-label="Sharing tags">Sharing tags</a></li></ul></li><li><a href=#configuration aria-label=Configuration>Configuration</a><ul><li><a href=#1-active-backup-setup aria-label="1. Active-backup setup">1. Active-backup setup</a></li><li><a href=#2-active-active-setup aria-label="2. Active-active setup">2. Active-active setup</a></li><li><a href=#3-anycast-setup aria-label="3. Anycast setup">3. Anycast setup</a></li><li><a href=#changing-sharing-tags-state aria-label="Changing sharing tags state">Changing sharing tags state</a></li></ul></li></ul></li><li><a href=#conclusions aria-label=Conclusions>Conclusions</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Dialog replication in OpenSIPS has been around since version 1.10, when it became clear that sharing real-time data through a database is no longer feasible in a large VoIP platform. Further steps in this direction have been made in 2.2, with the advent of the <em><strong>clusterer</strong></em> module, which manages OpenSIPS instances and their inter-communication. But have we been able to achieve the objective of a true and complete solution for <em>clustering</em> dialog support? In this article we are going to look into the limitations of distributing ongoing calls in previous OpenSIPS versions and how we overcame them and added new possibilities in 2.4, based on the <a href=https://blog.opensips.org/2018/03/13/the-new-clustering-engine-of-opensips-2-4/>improved clustering engine</a>.</p><h2 id=previous-limitations>Previous Limitations<a hidden class=anchor aria-hidden=true href=#previous-limitations>#</a></h2><p>Up until this point, distributing ongoing dialogs essentially only consisted in sharing the relevant internal information with all other OpenSIPS instances in the cluster. To optimize the communication, whenever a new dialog is created (and confirmed) or on existing one is updated (state changes etc.), a binary message about that particular dialog is broadcasted.Limiting the data exchange to be driven by runtime events leaves an instance with no way of learning all the dialog information from the cluster when it boots up or at a particular moment in time. Consider what happens when we restart a backup OpenSIPS: any failover that we hope to be able to handle on that node will have to be delayed until it gets naturally in sync with the other node(s).But the more painful repercussion of just sharing data without any other distributed logic is the lack of a mechanism to coordinate certain data-related actions between the cluster nodes. For example, in a typical High-Availability setup with an active-passive nodes configuration, although all dialogs are duplicated to the passive node, the following must be performed exactly once:</p><ul><li>generate **BYE requests **and/or produce <strong>CDR</strong>s (Call Detail Records) upon dialog expiration;</li><li>send Re-Invite or OPTIONS <strong>pings</strong> to end-points;</li><li>send replication packets on dialog events;</li><li>update the dialog database (if it is still used as a failsafe for binary replication, e.g. both nodes crash).</li></ul><h2 id=usage-scenarios>Usage scenarios<a hidden class=anchor aria-hidden=true href=#usage-scenarios>#</a></h2><p>Before actually diving into how OpenSIPS 2.4 solves the before mentioned issues, let’s first see the most popular scenarios we considered when designing the dialog clustering support:</p><ul><li><strong>Active – Backup</strong> setup for High Availability using Virtual IPs**.** The idea here would be to have a Virtual IP (or floating IP) facing the end-users. This IP will be automatically moved from a failed instance to a hot-backup server by tools like <em>vrrpd, KeepaliveD, Heartbeat</em>.</li><li><strong>Active – Active</strong> setup, or a double cross Active-Backup. This is a more “creative” approach using two Virtual IPs, each server being active for one of them and backup for the other, and still sharing all the dialogs, in order to handle both VIPs when a server fails.</li><li><strong>Anycast</strong> setup for Distributed calls (High Availability and Balancing). This relies on the newly add full support for Anycast** **introduced in OpenSIPS 2.4. You can find more details in the <a href=https://blog.opensips.org/2018/03/21/full-anycast-support-in-opensips-2-4/>dedicated article</a>.</li></ul><h2 id=dialog-clustering-with-opensips-24>Dialog Clustering with OpenSIPS 2.4<a hidden class=anchor aria-hidden=true href=#dialog-clustering-with-opensips-24>#</a></h2><p>The new dialog clustering support in OpenSIPS 2.4 is addressing all the mentioned limitations by properly and fully addressing the typical clustering scenarios. But first let’s see which are the newly introduced concepts in OpenSIPS 2.4 when it comes to clustering dialogs.</p><h3 id=data-synchronization>Data synchronization<a hidden class=anchor aria-hidden=true href=#data-synchronization>#</a></h3><p>In order to address our first discussed issue, the improved clustering under-layer in OpenSIPS 2.4 offers the capability of synchronizing a freshly booted node with the complete data set from the cluster in a fast and transparent manner. This way, we can minimize the impact of restarting an OpenSIPS instance, or plugging a new node in the cluster on the fly, without needing any DB storage or having to accept the compromise of lost dialogs. We can also perform a sync at any time via an MI command, if for some reason the dialog data got desynchronized on a given instance.</p><h3 id=dialog-ownership-mechanism>Dialog ownership mechanism<a hidden class=anchor aria-hidden=true href=#dialog-ownership-mechanism>#</a></h3><p>The other big improvement that OpenSIPS 2.4 introduces for distributing dialogs is the capability to precisely decide which node in the cluster is responsible for a dialog – responsible in the way of triggering certain actions for that dialog. This comes as a necessity because some of the dialogs are locally created on an instance, some are temporarily handled in place of a failed/inactive node and others are just kept as backup. As such, the concept of dialog “<strong>ownership</strong>” was introduced.The basic idea of this mechanism is that a single node in the dialog cluster (where all the calls are shared) is “responsible” at any time of a given dialog, in terms of taking actions for it. When the node owning the dialog goes down, another node become its owner and handle its actions.But how is this ownership concept concretely implemented in OpenSIPS 2.4?</p><h4 id=sharing-tags>Sharing tags<a hidden class=anchor aria-hidden=true href=#sharing-tags>#</a></h4><p>In order to be able to establish an ownership relationship between the nodes and the dialog, we introduced the concept of tags or _“<strong>sharing tags</strong>” _as we call them. Each dialog is marked with a single tag; on the other hand, a node is actively responsible for (owning) a tag (and indirectly all the dialogs marked with that tag). A tag may be present on several nodes, but only a single node sees the tag as <em>active</em>; the other nodes aware of that tag are seeing the tag in <em>standby/backup</em> mode.So each node may be aware of multiple sharing tags, each with an _active _or <em>backup</em> state. Each tag can be defined with an implicit state at OpenSIPS startup or directly set at runtime and all this information is shared between the cluster nodes. When we set a sharing tag to active on certain node, we are practically setting that node to become the owner of all its known dialogs that are marked with that particular tag. At the same time, if another node was active for tag, it has to step down.To better understand this, we will briefly describe how the sharing tags should be used in the previously mentioned scenarios, considering a simple two node cluster:</p><ol><li>in an active-backup cluster with a single VIP, we would only need a single sharing tag corresponding the VIP address; the node that holds the VIP will also have the VIP set to active and perform all the dialog related actions;</li><li>in an active-active cluster with two VIPs, we would need two sharing tags, corresponding to each VIP, and whichever node holds the given VIP, should have the appropriate tag set as <em>active</em>;</li><li>in an anycast cluster setup, we will have one sharing tag corresponding to each node (because the dialog is tied to the node it was first created as opposed to an IP). If a node is up, it should have its corresponding tag <em>active</em>, otherwise any node can take the tag over.</li></ol><h3 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h3><p>Setting up dialog replication in OpenSIPS 2.4 is very easy and, in the following, we will exemplify our discussed scenarios with the essential configuration:</p><h4 id=1-active-backup-setup>1. Active-backup setup<a hidden class=anchor aria-hidden=true href=#1-active-backup-setup>#</a></h4><p>Let’s use the tag named “vip” which will be configured via the <strong>dlg_sharing_tag</strong> module parameter. When starting OpenSIPS, you need to check the HA status of the node (by inspecting the HA system) and to decide which node will start as owner of the tag:modparam(&ldquo;dialog&rdquo;, &ldquo;dlg_sharing_tag&rdquo;, &ldquo;vip=active&rdquo;)if active or :modparam(&ldquo;dialog&rdquo;, &ldquo;dlg_sharing_tag&rdquo;, &ldquo;vip=backup&rdquo;)if standby.During runtime, depending on the change of the HA system, the tag may be moved (as active) to a different node by using MI commands (see following chapter).At script level, all we need to do, on each node, is to mark a newly created dialog with the sharing tag, using the <strong>set_dlg_sharing_tag()</strong> function:if (is_method(&ldquo;INVITE&rdquo;)) {    create_dialog();    set_dlg_sharing_tag(&ldquo;vip&rdquo;);}</p><h4 id=2-active-active-setup>2. Active-active setup<a hidden class=anchor aria-hidden=true href=#2-active-active-setup>#</a></h4><p>Similar with the previous case, but we will use two tags, one for each VIP address.  We will define the initial tag state for the first VIP, on the first node:modparam(&ldquo;dialog&rdquo;, &ldquo;dlg_sharing_tag&rdquo;, &ldquo;vip1=active&rdquo;)The second node will initially be responsible for the second VIP, so on node id 2 we will set:modparam(&ldquo;dialog&rdquo;, &ldquo;dlg_sharing_tag&rdquo;, &ldquo;vip2=active&rdquo;)Now, on each node, depending on which VIP do we receive the initial Invite, we mark the dialog appropriately:if (is_method(&ldquo;INVITE&rdquo;)) {    create_dialog();    if (<strong>$Ri == 10.0.0.1 # VIP 1)</strong>       set_dlg_sharing_tag(&ldquo;vip1&rdquo;);    else if (<strong>$Ri == 10.0.0.2 # VIP 2)</strong>      set_dlg_sharing_tag(&ldquo;vip2&rdquo;);}So, calls established via the VIP1 address will be marked with the “vip1” tag and handled by the node having the “vip1” tag as active – this will be the node 1 in normal operation.The calls established via the VIP2 address will be marked with the “vip2” tag and handled by the node having the “vip2” tag as active – this will be the node 2 in normal operation.If the node 1 fails, the HA system will move the VIP1 as active on node 2. Further, the HA system is responsible to instruct OpenSIPS running on node 2 that it become the owner of tag “vip1” also, so node 2 will start to actively handle the calls marked with “vip1” also.</p><h4 id=3-anycast-setup>3. Anycast setup<a hidden class=anchor aria-hidden=true href=#3-anycast-setup>#</a></h4><p>Each node has its own corresponding tag and it starts with the tag as active. So on node 1 we will have:modparam(&ldquo;dialog&rdquo;, &ldquo;dlg_sharing_tag&rdquo;, &ldquo;node_1=active&rdquo;)And on the second node, the same as above, but with <em>“node_2=active”</em>.Now, each node marks the dialogs with its own tag, for example on node 1:if (is_method(&ldquo;INVITE&rdquo;)) { create_dialog(); set_dlg_sharing_tag(&ldquo;node_1&rdquo;);}And, conversely, node 2 marks each created dialog with the <em>“node_2”</em> tag.If node 1 fails, the monitoring system (also responsible for the Anycast management and BGP updates) will pick one of the remaining node in the anycast group and it will activate the “node_1” tag on it. So, this new node will became owner and responsible for the calls created on former node 1.</p><h4 id=changing-sharing-tags-state>Changing sharing tags state<a hidden class=anchor aria-hidden=true href=#changing-sharing-tags-state>#</a></h4><p>All that remains to be discussed is how can we take over the ownership of the dialogs flagged with a certain sharing tag at runtime. This is of course the case when our chosen mechanism of node availability detects that a node in the cluster is down, or when we do a manual switch-over (e.g. for maintenance). So for this purpose, all we have to do is to issue the MI command <strong>dlg_set_sharing_tag_active</strong> that sets a certain sharing tag to the active state. For example, in the single VIP scenario, with a sharing tag named <em>“vip”,</em> after we have re-pointed the floating IP to the current machine, we would run:opensipsctl fifo dlg_set_sharing_tag_active vip</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>The new dialog clustering support in OpenSIPS 2.4 is a complete one as it not only takes care of dialog replication/sharing, but also of dialog handling in terms of properly triggering dialog-specific actions.The implementation also tries to provide a consistent solution, by following and addressing the most used scenarios in terms of dialog clustering – these are real world scenarios answering to real world needs.Even more, the work on the dialog clustering was consistently correlated with work on the Anycast support, so it will be an easy task for the user to build an integrated anycast setup taking care of both transaction and dialog layers.Need more practical examples ? Join us to the <a href=https://blog.opensips.org/2017/10/19/opensips-summit-2018/>OpenSIPS Summit 2018</a> in Amsterdam and see the Interactive Demos about the clustering support in OpenSIPS 2.4</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>