<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Troubleshooting missing ACK in SIP | 洞香春</title><meta name=keywords content><meta name=description content="We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a BYE request – but a BYE which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?
Getting to the missing ACK Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/blog/miss-ack/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.108.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Troubleshooting missing ACK in SIP"><meta property="og:description" content="We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a BYE request – but a BYE which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?
Getting to the missing ACK Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/blog/miss-ack/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2019-07-31T13:47:21+08:00"><meta property="article:modified_time" content="2019-07-31T13:47:21+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Troubleshooting missing ACK in SIP"><meta name=twitter:description content="We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a BYE request – but a BYE which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?
Getting to the missing ACK Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"Troubleshooting missing ACK in SIP","item":"https://wdd.js.org/opensips/blog/miss-ack/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Troubleshooting missing ACK in SIP","name":"Troubleshooting missing ACK in SIP","description":"We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a BYE request – but a BYE which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?\nGetting to the missing ACK Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup.","keywords":[],"articleBody":"We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a BYE request – but a BYE which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?\nGetting to the missing ACK Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup. And because the call was somehow partially established (as both end-points were able to exchange media), we need to focus on the signalling that takes place after the 200 OK reply (when the call is accepted by the callee). So, what do we have between the 200 OK reply and the full call setup ? Well, it is the ACK requests – the caller acknowledgement for the received 200 OK.And according to the RFC3261, any SIP device not receiving the ACK to its final 2xx reply has to disconnect the call by issuing a standard BYE request.So, whenever you experience such 10 seconds disconnected calls, first thing to do is to do a SIP capture/trace and to check if the callee end-device is actually getting an ACK. It is very, very import to check for ACK at the level of the callee end-device, and not at the level of caller of intermediary SIP proxies – the ACK may get lost anywhere on the path from caller to callee.\nTracing the lost ACK In order to understand how and where the ACK gets lost, we need first to understand how the ACK is routed from caller to the callee’s end-device. Without getting into all the details, the ACK is routed back to callee based on the Record-Route and Contact headers received into the 200 OK reply. So, if the ACK is mis-routed, it is mainly because of wrong information in the 2oo OK.The Record-Route headers (in the 200 OK) are less to blame, as they are inserted by the visited proxies and not changed by anyone else. Assuming that you do not have some really special scenarios with SIP proxies behind NATs, we can simply discard the possibility of having faulty Record-Routes.So, the primary suspect is the Contact header in the 200 OK – this header is inserted by the callee’s end-device and it can be altered by any proxy in the middle – so there are any many opportunities to get corrupted. And this mainly happens due to wrong handling of NAT presence on end-user side – yes, that’s it, a NATed callee device.\nCommon scenarios No NAT handling If the proxy does not properly handle NATed callee device, it will propagate into the _200 OK_reply the private IP of the callee. And of course, this IP will be unusable when comes to routing back the ACK to the callee – the proxy will have the “impossible” mission to route to a private IP :). So, the ACK will get lost and call will get disconnected.\nIf the case, with OpenSIPS, you will have to review your logic in the onreply route and perform fix_nated_contact() for the 200 OK, if callee is known as NATed.\nThe correct handling and flow has to be like this:\nExcessive NAT handling While handling NATed end-points is good, you have to be careful not to over do it. If you see a private IP in the Contact header you should not automatically replace it with the source IP of the SIP packet. Or you should not do it for any incoming reply (like “let’s do it all the time, just to be sure”).\nIn a more complex scenarios where a call may visit multiple SIP proxies, the proxies may loose valuable routing information by doing excessive NAT traversal handling. Like in the scenario below, ProxyA is over doing it, by applying the NAT traversal logic also for calls coming from a proxy (ProxyB) and not only for replies coming from an end-point. By doing this, the IP coordinates of the callee will be lost from Contact header, as ProxyA has no direct visibility to callee (in terms of IP).\nIn such a case, with OpenSIPS, you will have to review your logic in the onreply route and to be sure you perform fix_nated_contact() for the 200 OK only if the reply comes from an end-point and not from another proxy.\nConclusions SIP is complicated and you have to pay attention to all the details, if you want to get it to work. Focusing only on routing the INVITE requests is not sufficient.If you come across disconnected calls:\nget a SIP capture/trace and see if the ACK gets to the callee end-point if not, check the Contact header in the 200 OK – it must point all the time to the callee end-point (a public IP) if not, check the NAT traversal logic you have in the onreply routes – be sure you do the Contact fixing only when it is needed. Shortly, be moderate, not too few and not too much …when comes to NAT handling ","wordCount":"865","inLanguage":"en","datePublished":"2019-07-31T13:47:21+08:00","dateModified":"2019-07-31T13:47:21+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/blog/miss-ack/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>Troubleshooting missing ACK in SIP</h1><div class=post-meta><span title='2019-07-31 13:47:21 +0800 CST'>2019-07-31 13:47:21</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Eddie Wang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#getting-to-the-missing-ack aria-label="Getting to the missing ACK">Getting to the missing ACK</a></li><li><a href=#tracing-the-lost-ack aria-label="Tracing the lost ACK">Tracing the lost ACK</a></li><li><a href=#common-scenarios aria-label="Common scenarios">Common scenarios</a><ul><li><a href=#no-nathandling aria-label="No NAT handling">No NAT handling</a></li><li><a href=#excessive-nat-handling aria-label="Excessive NAT handling">Excessive NAT handling</a></li></ul></li><li><a href=#conclusions aria-label=Conclusions>Conclusions</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>We all experienced calls getting self disconnected after 5-10 seconds – usually disconnected by the callee side via a <em><strong>BYE</strong></em> request – but a <em><strong>BYE</strong></em> which was not triggered by the party behind the phone, but by the SIP stack/layer itself.This is one of the most common issues we get in SIP and one of the most annoying in the same time. But why it happens ?</p><h2 id=getting-to-the-missing-ack>Getting to the missing ACK<a hidden class=anchor aria-hidden=true href=#getting-to-the-missing-ack>#</a></h2><p>Such a decision to auto-terminate the call (beyond the end-user will and control) indicates an error in the SIP call setup. And because the call was somehow partially established (as both end-points were able to exchange media), we need to focus on the signalling that takes place after the <em><strong>200 OK</strong></em> reply (when the call is accepted by the callee). So, what do we have between the <em><strong>200 OK</strong></em> reply and the full call setup ? Well, it is the <em><strong>ACK</strong></em> requests – the caller acknowledgement for the received <em><strong>200 OK</strong></em>.And according to the <a href=https://www.ietf.org/rfc/rfc3261.txt>RFC3261</a>, any SIP device not receiving the <em><strong>ACK</strong></em> to its final <em><strong>2xx</strong></em> reply has to disconnect the call by issuing a standard <em><strong>BYE</strong></em> request.So, whenever you experience such 10 seconds disconnected calls, first thing to do is to do a SIP capture/trace and  to check if the callee end-device is actually getting an <em><strong>ACK</strong></em>. It is very, very import to check for <em><strong>ACK</strong></em> at the level of the callee end-device, and not at the level of caller of intermediary SIP proxies – the <em><strong>ACK</strong></em> may get lost anywhere on the path from caller to callee.</p><h2 id=tracing-the-lost-ack>Tracing the lost ACK<a hidden class=anchor aria-hidden=true href=#tracing-the-lost-ack>#</a></h2><p>In order to understand how and where the <em><strong>ACK</strong></em> gets lost, we need first to understand how the <em><strong>ACK</strong></em> is routed from caller to the callee’s end-device. Without getting into all the details, the <em><strong>ACK</strong></em> is routed back to callee based on the <em><strong>Record-Route</strong></em> and <em><strong>Contact</strong></em> headers received into the <em><strong>200 OK</strong></em> reply. So, if the <em><strong>ACK</strong></em> is mis-routed, it is mainly because of wrong information in the <em><strong>2oo OK</strong></em>.The <em><strong>Record-Route</strong></em> headers (in the <em><strong>200 OK</strong></em>) are less to blame, as they are inserted by the visited proxies and not changed by anyone else. Assuming that you do not have some really special scenarios with SIP proxies behind NATs, we can simply discard the possibility of having faulty <em><strong>Record-Routes</strong></em>.So, the primary suspect is the <em><strong>Contact</strong></em> header in the <em><strong>200 OK</strong></em> – this header is inserted by the callee’s end-device and it can be altered by any proxy in the middle – so there are any many opportunities to get corrupted. And this mainly happens due to wrong handling of NAT presence on end-user side  – yes, that’s it, a NATed callee device.</p><h2 id=common-scenarios>Common scenarios<a hidden class=anchor aria-hidden=true href=#common-scenarios>#</a></h2><h3 id=no-nathandling>No NAT handling<a hidden class=anchor aria-hidden=true href=#no-nathandling>#</a></h3><p>If the proxy does not properly handle NATed callee device, it will propagate into the _<strong>200 OK</strong>_reply the private IP of the callee. And of course, this IP will be unusable when comes to routing back the <em><strong>ACK</strong></em> to the callee – the proxy will have the “impossible” mission to route to a private IP :). So, the <em><strong>ACK</strong></em> will get lost and call will get disconnected.</p><p><img loading=lazy src=2022-12-03-15-31-16.png alt></p><p>If the case, with <a href=http://www.opensips.org/>OpenSIPS</a>, you will have to review your logic in the <strong><a href=http://www.opensips.org/Documentation/Script-Routes-2-2#toc4>onreply</a></strong> route and perform <strong><a href=http://www.opensips.org/html/docs/modules/2.2.x/nathelper.html#id293994>fix_nated_contact()</a></strong> for the <em><strong>200 OK</strong></em>, if callee is known as NATed.</p><p>The correct handling and flow has to be like this:</p><p><img loading=lazy src=2022-12-03-15-31-57.png alt></p><h3 id=excessive-nat-handling>Excessive NAT handling<a hidden class=anchor aria-hidden=true href=#excessive-nat-handling>#</a></h3><p>While handling NATed end-points is good, you have to be careful not to over do it. If you see a private IP in the <em><strong>Contact</strong></em> header you should not automatically replace it with the source IP of the SIP packet. Or you should not do it for any incoming reply (like “let’s do it all the time, just to be sure”).</p><p>In a more complex scenarios where a call may visit multiple SIP proxies, the proxies may loose valuable routing information by doing excessive NAT traversal handling. Like in the scenario below, ProxyA is over doing it, by applying the NAT traversal logic also for calls coming from a proxy (ProxyB) and not only for replies coming from an end-point. By doing this, the IP coordinates of the callee will be lost from <strong><em>Contact</em></strong> header, as ProxyA has no direct visibility to callee (in terms of IP).</p><p><img loading=lazy src=2022-12-03-15-32-50.png alt></p><p>In such a case, with OpenSIPS, you will have to review your logic in the <strong><a href=http://www.opensips.org/Documentation/Script-Routes-2-2#toc4>onreply</a></strong> route and to be sure you perform <strong><a href=http://www.opensips.org/html/docs/modules/2.2.x/nathelper.html#id293994>fix_nated_contact()</a></strong> for the <em><strong>200 OK</strong></em> only if the reply comes from an end-point and not from another proxy.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>SIP is complicated and you have to pay attention to all the details, if you want to get it to work. Focusing only on routing the <em><strong>INVITE</strong></em> requests is not sufficient.If you come across disconnected calls:</p><ol><li>get a SIP capture/trace and see if the <em><strong>ACK</strong></em> gets to the callee end-point</li><li>if not, check the <strong>Contact</strong> header in the <em><strong>200 OK</strong></em> – it must point all the time to the callee end-point (a public IP)</li><li>if not, check the NAT traversal logic you have in the <strong><a href=http://www.opensips.org/Documentation/Script-Routes-2-2#toc4>onreply</a></strong> routes – be sure you do the <em><strong>Contact</strong></em> fixing <strong>only</strong> when it is needed.</li></ol><p>Shortly, be moderate, not too few and not too much …when comes to NAT handling </p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>