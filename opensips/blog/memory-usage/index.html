<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>理解并测量OpenSIPS的内存资源 | 洞香春</title><meta name=keywords content><meta name=description content="原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/
Running OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/blog/memory-usage/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.119.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="理解并测量OpenSIPS的内存资源"><meta property="og:description" content="原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/
Running OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/blog/memory-usage/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2019-07-31T13:50:43+08:00"><meta property="article:modified_time" content="2019-07-31T13:50:43+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="理解并测量OpenSIPS的内存资源"><meta name=twitter:description content="原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/
Running OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"理解并测量OpenSIPS的内存资源","item":"https://wdd.js.org/opensips/blog/memory-usage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"理解并测量OpenSIPS的内存资源","name":"理解并测量OpenSIPS的内存资源","description":"原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/\nRunning OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources.","keywords":[],"articleBody":"原文：https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/\nRunning OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources.\n内存太小会导致OOM, 内存大大有会浪费\nUnfortunately picking this limit is not something that can be easily determined by a magic formula. The reason is that memory consumption is often influenced by a lot of external factors, like calling scenarios, traffic patterns, provisioned data, interactions with other external components (like AAA or DB servers), etc. Therefore, the only way to properly dimension the memory OpenSIPS is allowed to use is by monitoring memory usage, understanding the memory footprint and tuning this value accordingly. This article provides a few tips to achieve this goal.\n首先监控opensips的内存使用，然后根据监控的值调整合适的内存大小\nOpenSIPS内部的内存使用 opensips是个多进程程序并使用两种内存模型\n私有内存: 进程独占的内存，往往比较小 共享内存: opensips模块使用的内存，往往比较大 To understand the way OpenSIPS uses the available memory, we have to point out that OpenSIPS is a multi-process application that uses two types of memory: private and shared. Each process has its own private memory space and uses it to store local data, that does not need to be shared with other processes (i.e. parsing data). Most of the time the amount of private memory used is small, and usually fits into the default value of 2MB per process. Nevertheless understanding the way private memory is used is also necessary in order to properly dimension your platform’s memory.On the other hand, shared memory is a big memory pool that is shared among all processes. This is the memory used by OpenSIPS modules to store data used at run-time, and in most of the cases, the default value of 16MB is not enough. As I stated earlier, it is impossible to pick a “magic” value for this limit, mostly because there are a lot of considerations that affect it. The data stored in the shared memory can be classified in two categories:\n流量数据：1. 注册相关的数据；2. 呼叫相关的数据，tm和daillog 临时数据：数据库缓存数据\nTraffic data – data generated by your customers registration data, managed by the usrloc module, is directly linked to the number of customers registered into the platform; call data, managed by the tm and dialog modules, is related to the number of simultaneous calls done through the platform. Provisioning data – data cached from the database, used to implement the platform’s logic. The amount of memory used by each of this data may vary according to the services you offer, your customer base and their traffic.\n监控内存使用 有两种方式监控内存\nOpensips CP，这个工具比较方便，但是安装比较负载，一般不使用 通过opensips的fifo指令去获取内存。这个比较方便，可以做成crontab, 然后周期性的写入到influxdb。 There are two ways to monitor OpenSIPS memory statistics:\nfrom OpenSIPS CP Web GUI, using the statistics interface (Image 1) from cli using the opensipsctl tool: opensipsctl fifo get_statistics shmem: shmem:total_size:: 268435456 shmem:used_size:: 124220488 shmem:real_used_size:: 170203488 shmem:max_used_size:: 196065104 shmem:free_size:: 98231968 shmem:fragments:: 474863 From both you can observe 6 values:\ntotal_size: the total amount of memory provisioned used_size: the amount of memory required to store the data real_used_size: the total amount of memory required to store data and metadata max_used_size: the maximum amount of memory used since OpenSIPS started free_size: the amount of free memory fragments: the number of fragments When monitoring memory usage, the most important statistics are the max_used_size , because it indicates the minimum value OpenSIPS needs to support the traffic that has been so far and the real_used_size, because it indicates the memory used at a specific moment. We will use these metrics further on.\n理解内存使用 In order to have a better understanding about the memory used, we will take as an example a very specific platform: an outbound PSTN gateway, that is designed to support 500 CPS (calls per second) from customers and dispatch them to approximately 100K prefixes, cached by the drouting module. You can see the platform’s topology in this picture:\nTo figure out what happens in the scenario Image 1 presents, we will extract the real_used_size, max_used_size and actve_dialogs statistics:\nAs you can observe, at the beginning of the chart, the memory usage was low, close to 0. That is most likely OpenSIPS startup. Then, it grows quickly until around 60MB. That is OpenSIPS loading the 100K of prefixes into the drouting module cache. Next, as we can see in the **active_dialogs **statistic, traffic comes in in batches. Therefore OpenSIPS memory usage increases gradually, until around 170MB and stabilizes with the call-flow. After a while, the dialog numbers start to decrease, and the memory is again gradually released, until it ends to the idle memory of 60MB used by the drouting cache.Taking a closer look at the charts, you will notice two awkward things in the second half of the period:\ndialog占用的内存并不是呼叫结束后立即释放，而是由计时器去延时周期性的按批次去释放 SIP事务也不是会麻烦释放，而是会等待去耗尽网络中所有的重传消息\nopensips的很多模块往往需要一次性的把数据库中的数据加载到内存中。而在模块reload的时候，内存中会同时存在两份数据。直到新的数据完全加载完毕后，老的数据占用的内存才会释放，而在此之前，老的数据仍旧驻留在内存中，用来处理呼叫。所以在模块reload的时候，也是往往内存出现峰值的时候。 老的数据被释放之后，峰值会很快回落。\nEven though dialogs become significantly less, shared memory usage is still high. That is because dialogs are not immediately deleted from OpenSIPS memory, but on a timer job that deletes them in bulk batches from the database(increased DB performance). Also, SIP transactions are not deleted immediately after they complete, but stored for a while to absorb re-transmissions (according to RFC 3261 requirements). Even if there are no high amounts of dialogs coming in, there is a big spike of memory usage, which also changes the max_used_size statistic. The reason for this spike is a drouting module cache reload, over the MI (Management Interface): opensipsctl fifo dr_reload The reason for this spike is that during cache reload, OpenSIPS stores in memory two sets of data: the old one and the new one. The old set is used to route calls until the new set is fully loaded. After that, the memory for the old set is released, and the new set is used further on. Although this algorithm is used to increase the routing performance, it requires a large amount of memory during reload, usually doubling the memory used for provisioning.Following the article till now, you would say that looking at the memory statistics and correlating traffic with memory usage can be fairly easy to understand how OpenSIPS** **uses memory and what are the components that use more. Unfortunately that is not always true, because sometime you might not have the entire history of the events, or the events happen simultaneously, and you can not figure out why. Therefore you might end up in a situation where you are using large amount of memory, but can point out why. This makes scaling rather impossible (for both customers and provisioning rules), because you will not be able to estimate how components spread the memory among them. That is why in OpenSIPS 2.2 we added a more granular memory support, that allows you to view the memory used by each module (or group of modules). Memory usage in OpenSIPS 2.2 In order to enable granular memory support, you need to follow these steps:\ngenerate statistics files by running: # make generate-mem-stats 2\u003e /dev/null compile OpenSIPS with extra shared memory support, by running: # make menuconfig -\u003e Configure compile options -\u003e Configure compile flags -\u003e SHM_EXTRA_STATS\n# make all configure the groups in OpenSIPS configuration file: mem-group = \"traffic\": \"tm\" \"dialog\" mem-group = \"provision\": \"drouting\" restart OpenSIPS and follow the steps from the previous sections. Checking the statistics during peak time you will get something like this:\n# opensipsctl fifo get_statistics shmem_group_traffic: shmem_group_provision: shmem_group_traffic:fragments:: 153618 shmem_group_traffic:memory_used:: 85448608 shmem_group_traffic:real_used:: 86677612 shmem_group_provision:fragments:: 245614 shmem_group_provision:memory_used:: 53217232 shmem_group_provision:real_used:: 55182144 Checking the traffic statistics will show you exactly how much memory OpenSIPS uses for calls, while checking the provision statistics will show you the memory used by the drouting module. The rest of memory is used by other other modules or by the core. If you want to track those down too, group them in a new mem-group.**\nDimensioning OpenSIPS memory As you have noticed throughout this article, dimensioning OpenSIPS for a specific number of clients or provisioning data is not an easy task and requires a deep understanding of both customer traffic patterns and provisioning data, as well as OpenSIPS internals. We hope that using the tips provided in this article will help you have a better understanding of your platform, how memory resources are used by OpenSIPS, and how to dimension your VoIP platform to the desired scale.\n","wordCount":"1385","inLanguage":"en","datePublished":"2019-07-31T13:50:43+08:00","dateModified":"2019-07-31T13:50:43+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/blog/memory-usage/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>理解并测量OpenSIPS的内存资源</h1><div class=post-meta><span title='2019-07-31 13:50:43 +0800 CST'>2019-07-31 13:50:43</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Eddie Wang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#opensips%e5%86%85%e9%83%a8%e7%9a%84%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8 aria-label=OpenSIPS内部的内存使用>OpenSIPS内部的内存使用</a></li><li><a href=#%e7%9b%91%e6%8e%a7%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8 aria-label=监控内存使用>监控内存使用</a></li><li><a href=#%e7%90%86%e8%a7%a3%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8 aria-label=理解内存使用>理解内存使用</a></li><li><a href=#memory-usage-in-opensips-22 aria-label="Memory usage in OpenSIPS 2.2">Memory usage in OpenSIPS 2.2</a></li><li><a href=#dimensioning-opensips-memory aria-label="Dimensioning OpenSIPS memory">Dimensioning OpenSIPS memory</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>原文：<a href=https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/>https://blog.opensips.org/2016/12/29/understanding-and-dimensioning-memory-in-opensips/</a></p><p>Running OpenSIPS with the right memory configuration is a very important task when developing and maintaining your VoIP service, because it has a direct effect over the scale of your platform, the customers you support, as well as the services you offer. Setting the limit to a low value might make OpenSIPS run out of memory during high volume of traffic, or during complex scenarios, while setting a big value might lead to wasted resources.</p><blockquote><p>内存太小会导致OOM, 内存大大有会浪费</p></blockquote><p>Unfortunately picking this limit is not something that can be easily determined by a magic formula. The reason is that memory consumption is often influenced by a lot of external factors, like calling scenarios, traffic patterns, provisioned data, interactions with other external components (like AAA or DB servers), etc. Therefore, the only way to properly dimension the memory OpenSIPS is allowed to use is by monitoring memory usage, understanding the memory footprint and tuning this value accordingly. This article provides a few tips to achieve this goal.</p><blockquote><p>首先监控opensips的内存使用，然后根据监控的值调整合适的内存大小</p></blockquote><h1 id=opensips内部的内存使用>OpenSIPS内部的内存使用<a hidden class=anchor aria-hidden=true href=#opensips内部的内存使用>#</a></h1><blockquote><p>opensips是个多进程程序并使用两种内存模型</p><ol><li>私有内存: 进程独占的内存，往往比较小</li><li>共享内存: opensips模块使用的内存，往往比较大</li></ol></blockquote><p>To understand the way <a href=http://www.opensips.org/>OpenSIPS</a> uses the available memory, we have to point out that <a href=http://www.opensips.org/>OpenSIPS</a> is a <a href=https://en.wikipedia.org/wiki/Multiprocessing>multi-process</a> application that uses two types of memory: private and shared. Each process has its own private memory space and uses it to store local data, that does not need to be shared with other processes (i.e. parsing data). Most of the time the amount of <strong>private memory used is small, and usually fits into the default value of 2MB per process.</strong> Nevertheless understanding the way private memory is used is also necessary in order to properly dimension your platform’s memory.On the other hand, <strong>shared memory is a big memory pool that is shared among all processes.</strong> This is the memory used by <a href=http://www.opensips.org/>OpenSIPS</a> modules to store data used at run-time, and in most of the cases, the <strong>default value of 16MB is not enough</strong>. As I stated earlier, it is impossible to pick a “magic” value for this limit, mostly because there are a lot of considerations that affect it. The data stored in the shared memory can be classified in two categories:</p><blockquote><p>流量数据：1. 注册相关的数据；2. 呼叫相关的数据，tm和daillog
临时数据：数据库缓存数据</p></blockquote><ul><li>Traffic data – data generated by your customers<ul><li>registration data, managed by the <a href=http://www.opensips.org/html/docs/modules/2.2.x/usrloc.html>usrloc</a> module, is directly linked to the number of customers registered into the platform;</li><li>call data, managed by the <a href=http://www.opensips.org/html/docs/modules/2.2.x/tm.html>tm</a> and <a href=http://www.opensips.org/html/docs/modules/2.2.x/dialog.html>dialog</a> modules, is related to the number of simultaneous calls done through the platform.</li></ul></li><li>Provisioning data – data cached from the database, used to implement the platform’s logic.</li></ul><p>The amount of memory used by each of this data may vary according to the services you offer, your customer base and their traffic.</p><h1 id=监控内存使用>监控内存使用<a hidden class=anchor aria-hidden=true href=#监控内存使用>#</a></h1><blockquote><p>有两种方式监控内存</p><ol><li>Opensips CP，这个工具比较方便，但是安装比较负载，一般不使用</li><li>通过opensips的fifo指令去获取内存。这个比较方便，可以做成crontab, 然后周期性的写入到influxdb。</li></ol></blockquote><p>There are two ways to monitor <a href=http://www.opensips.org/>OpenSIPS</a> memory statistics:</p><ul><li>from <a href=http://controlpanel.opensips.org/>OpenSIPS CP</a> Web GUI, using the statistics interface (Image 1)</li></ul><p><img loading=lazy src="https://cdn.nlark.com/yuque/0/2020/png/280451/1586483198965-5a539f67-1512-4765-83d4-257fd61c9615.png#align=left&amp;display=inline&amp;height=750&amp;originHeight=750&amp;originWidth=852&amp;size=0&amp;status=done&amp;style=none&amp;width=852" alt>
 </p><ul><li>from cli using the <strong>opensipsctl</strong> tool:</li></ul><pre tabindex=0><code>opensipsctl fifo get_statistics shmem:
shmem:total_size:: 268435456
shmem:used_size:: 124220488
shmem:real_used_size:: 170203488
shmem:max_used_size:: 196065104
shmem:free_size:: 98231968
shmem:fragments:: 474863
</code></pre><p>From both you can observe 6 values:</p><ul><li><strong>total_size</strong>: the total amount of memory provisioned</li><li><strong>used_size</strong>: the amount of memory required to store the data</li><li><strong>real_used_size</strong>: the total amount of memory required to store data and metadata</li><li><strong>max_used_size</strong>: the maximum amount of memory used since <a href=http://www.opensips.org/>OpenSIPS</a> started</li><li><strong>free_size</strong>: the amount of free memory</li><li><strong>fragments</strong>: the number of fragments</li></ul><p>When monitoring memory usage, the most important statistics are the <strong>max_used_size</strong> , because it indicates the minimum value <a href=http://www.opensips.org/>OpenSIPS</a> needs to support the traffic that has been so far and the <strong>real_used_size</strong>, because it indicates the memory used at a specific moment. We will use these metrics further on.</p><h1 id=理解内存使用>理解内存使用<a hidden class=anchor aria-hidden=true href=#理解内存使用>#</a></h1><p>In order to have a better understanding about the memory used, we will take as an example a very specific platform: an outbound PSTN gateway, that is designed to support 500 CPS (calls per second) from customers and dispatch them to approximately 100K prefixes, cached by the <a href=http://www.opensips.org/html/docs/modules/2.2.x/drouting.html>drouting</a> module. You can see the platform’s topology in this picture:</p><p><img loading=lazy src=2022-12-03-15-37-32.png alt></p><p>To figure out what happens in the scenario Image 1 presents, we will extract the <strong>real_used_size</strong>, <strong>max_used_size</strong> and <strong>actve_dialogs</strong> statistics:</p><p><img loading=lazy src=2022-12-03-15-37-57.png alt></p><p><img loading=lazy src="https://cdn.nlark.com/yuque/0/2019/png/280451/1564552263141-6c73baa2-6e84-44e2-8ef6-b70f1cc1a9e9.png#align=left&amp;display=inline&amp;height=688&amp;originHeight=688&amp;originWidth=627&amp;size=0&amp;status=done&amp;style=none&amp;width=627" alt></p><p>As you can observe, at the beginning of the chart, the memory usage was low, close to 0. That is most likely OpenSIPS startup. Then, it grows quickly until around 60MB. That is <a href=http://www.opensips.org/>OpenSIPS</a> loading the 100K of prefixes into the <a href=http://www.opensips.org/html/docs/modules/2.2.x/drouting.html>drouting</a> module cache. Next, as we can see in the **active_dialogs **statistic, traffic comes in in batches. Therefore <a href=http://www.opensips.org/>OpenSIPS</a> memory usage increases gradually, until around 170MB and stabilizes with the call-flow. After a while, the dialog numbers start to decrease, and the memory is again gradually released, until it ends to the idle memory of 60MB used by the <a href=http://www.opensips.org/html/docs/modules/2.2.x/drouting.html>drouting</a> cache.Taking a closer look at the charts, you will notice two awkward things in the second half of the period:</p><blockquote><p>dialog占用的内存并不是呼叫结束后立即释放，而是由计时器去延时周期性的按批次去释放
SIP事务也不是会麻烦释放，而是会等待去耗尽网络中所有的重传消息</p></blockquote><blockquote><p>opensips的很多模块往往需要一次性的把数据库中的数据加载到内存中。而在模块reload的时候，内存中会同时存在两份数据。直到新的数据完全加载完毕后，老的数据占用的内存才会释放，而在此之前，老的数据仍旧驻留在内存中，用来处理呼叫。所以在模块reload的时候，也是往往内存出现峰值的时候。
老的数据被释放之后，峰值会很快回落。</p></blockquote><ol><li>Even though dialogs become significantly less, shared memory usage is still high. That is because dialogs are not immediately deleted from <a href=http://www.opensips.org/>OpenSIPS</a> memory, but on a timer job that deletes them in bulk batches from the database(increased DB performance). Also, SIP transactions are not deleted immediately after they complete, but stored for a while to absorb re-transmissions (according to RFC 3261 requirements).</li><li>Even if there are no high amounts of dialogs coming in, there is a big spike of memory usage, which also changes the <strong>max_used_size</strong> statistic. The reason for this spike is a <a href=http://www.opensips.org/html/docs/modules/2.2.x/drouting.html>drouting</a> module cache reload, over the MI (Management Interface):</li></ol><pre tabindex=0><code>opensipsctl fifo dr_reload
</code></pre><p>The reason for this spike is that during cache reload, <a href=http://www.opensips.org/>OpenSIPS</a> stores in memory two sets of data: the old one and the new one. The old set is used to route calls until the new set is fully loaded. After that, the memory for the old set is released, and the new set is used further on. Although this algorithm is used to increase the routing performance, it requires a large amount of memory during reload, usually doubling the memory used for provisioning.Following the article till now, you would say that looking at the memory statistics and correlating traffic with memory usage can be fairly easy to understand how <a href=http://www.opensips.org/>OpenSIPS</a>** **uses memory and what are the components that use more. Unfortunately that is not always true, because sometime you might not have the entire history of the events, or the events happen simultaneously, and you can not figure out why. Therefore you might end up in a situation where you are using large amount of memory, but can point out why. This makes scaling rather impossible (for both customers and provisioning rules), because you will not be able to estimate how components spread the memory among them. That is why in <a href=http://www.opensips.org/About/Version-2-2-x>OpenSIPS 2.2</a> we added a more granular memory support, that allows you to view the memory used by each module (or group of modules). </p><h1 id=memory-usage-in-opensips-22>Memory usage in OpenSIPS 2.2<a hidden class=anchor aria-hidden=true href=#memory-usage-in-opensips-22>#</a></h1><p>In order to enable granular memory support, you need to follow these steps:</p><ol><li>generate statistics files by running:</li></ol><pre tabindex=0><code># make generate-mem-stats 2&gt; /dev/null
</code></pre><ol><li>compile <a href=http://www.opensips.org/>OpenSIPS</a> with extra shared memory support, by running:</li></ol><pre tabindex=0><code># make menuconfig -&gt; Configure compile options -&gt; &lt;br /&gt; Configure compile flags -&gt; SHM_EXTRA_STATS&lt;br /&gt;# make all
</code></pre><ol><li>configure the groups in <a href=http://www.opensips.org/>OpenSIPS</a> configuration file:</li></ol><pre tabindex=0><code>mem-group = &#34;traffic&#34;: &#34;tm&#34; &#34;dialog&#34;
mem-group = &#34;provision&#34;: &#34;drouting&#34;
</code></pre><ol><li>restart <a href=http://www.opensips.org/>OpenSIPS</a> and follow the steps from the previous sections.</li></ol><p>Checking the statistics during peak time you will get something like this:</p><pre tabindex=0><code># opensipsctl fifo get_statistics shmem_group_traffic: shmem_group_provision:
shmem_group_traffic:fragments:: 153618
shmem_group_traffic:memory_used:: 85448608
shmem_group_traffic:real_used:: 86677612
shmem_group_provision:fragments:: 245614
shmem_group_provision:memory_used:: 53217232
shmem_group_provision:real_used:: 55182144
</code></pre><p>Checking the <strong>traffic</strong> statistics will show you exactly how much memory <a href=http://www.opensips.org/>OpenSIPS</a> uses for calls, while checking the <strong>provision</strong> statistics will show you the memory used by the <a href=http://www.opensips.org/html/docs/modules/2.2.x/drouting.html>drouting</a> module. The rest of memory is used by other other modules or by the core. If you want to track those down too, group them in a new <strong>mem-group.</strong>**</p><h1 id=dimensioning-opensips-memory>Dimensioning OpenSIPS memory<a hidden class=anchor aria-hidden=true href=#dimensioning-opensips-memory>#</a></h1><p>As you have noticed throughout this article, dimensioning <a href=http://www.opensips.org/>OpenSIPS</a> for a specific number of clients or provisioning data is not an easy task and requires a deep understanding of both customer traffic patterns and provisioning data, as well as <a href=http://www.opensips.org/>OpenSIPS</a> internals. We hope that using the tips provided in this article will help you have a better understanding of your platform, how memory resources are used by <a href=http://www.opensips.org/>OpenSIPS</a>, and how to dimension your VoIP platform to the desired scale.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>