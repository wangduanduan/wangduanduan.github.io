<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Full Anycast support in OpenSIPS 2.4 | 洞香春</title><meta name=keywords content><meta name=description content="he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.Anycast is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP)."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/blog/full-anycast/><link crossorigin=anonymous href=/assets/css/stylesheet.6d3944e058d85363bbe8a792a9b5f40002bca80be859dc19c466dd8de223973e.css integrity="sha256-bTlE4FjYU2O76KeSqbX0AAK8qAvoWdwZxGbdjeIjlz4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Full Anycast support in OpenSIPS 2.4"><meta property="og:description" content="he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.Anycast is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP)."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/blog/full-anycast/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2019-07-31T13:37:31+08:00"><meta property="article:modified_time" content="2019-07-31T13:37:31+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Full Anycast support in OpenSIPS 2.4"><meta name=twitter:description content="he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.Anycast is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"Full Anycast support in OpenSIPS 2.4","item":"https://wdd.js.org/opensips/blog/full-anycast/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Full Anycast support in OpenSIPS 2.4","name":"Full Anycast support in OpenSIPS 2.4","description":"he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.Anycast is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP).","keywords":[],"articleBody":"he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.Anycast is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP). When a packet reaches the network with an anycast destination, the router sends it to the “closest” node, based on different metrics (application status, network latency, etc). This behavior ensures that traffic is (1) balanced by sending it to one of the least busy nodes (based on application status) and also ensures (2) geo-distribution, by sending the request to the closest node (based on latency). Moreover, if a node goes down, it will be completely put out of route, ensuring (3) high availability for your platform. All these features without any special requirements from your customers, all they need is to send traffic to the anycast IP.Sounds wonderful, right? It really is! And if you are running using anycast IPs in a transaction stateless mode, things just work out of the box.\nState of the art A common Anycast setup is to assign the anycast IPs to the nodes at the edge of your platform, facing the clients. This setup ensures that all three features (load balancing, geo-distribution and high-availability) are provided for your customers’ inbound calls. However, most of the anycast “stories” we have heard or read about are only using the anycast IP for the initial incoming INVITEs from customers. Once received, the entire call is pinned to a unicast IP of the first server that received the INVITE. Therefore all sequential messages will go through that single unicast IP. Although this works fine from SIP point of view, you will lose all the anycast advantages such as high-availability.When using this approach (of only receiving initial request on the anycast IP) the inbound calls to the clients will also be affected, because besides losing dialog high-availability, you will also need to ask all your clients to accept calls from all your available unicast IPs. Imagine what happens when you add a new node.Our full anycast solution aims to sort out these limitations by always keeping the anycast IPs in the route for the entire call. This means that your clients will always have one single IP to provision, the anycast IP. And when a node goes down, all sequential messages will be re-routed (by the router) to the next available node. Of course, this node needs to have the entire call information to be able to properly close the call, but that can be easily done in OpenSIPS using dialog replication.Besides the previous issue, most of the time running in stateless mode is not possible due to application logic constraints (re-transmission handling, upstream timeout detection, etc.). Thus stateful transaction mode is required, which complicates a bit more our anycast scenario.\nAnycast in a transaction stateful scenario A SIP transaction consists of a request and all the replies associated to that request. According to the SIP RFC, when a stateful SIP proxy sends a request, the next hop should immediately send a reply as soon as it received the request. Otherwise, the SIP proxy will start re-transmitting that request until it either receives a reply, or will eventually time out. Now, let’s consider the anycast scenario described in Figure 1: Figure 1.OpenSIPS instance 1 sends an INVITE to the client, originated from the Anycast IP interface. The INVITE goes through the Router, and reaches the Client’s IP. However, when the Client replies with 200 OK, the Router decides the “shortest” path is to OpenSIPS instance 2, which has no information about the transaction. Therefore, instance 2 drops all the replies. Moreover, since instance 1 did not receive any reply, it will start re-transmitting the INVITE. And so on, and so forth, until instance 1 times out, because it did not receive any reply, and the Client times out because there was no ACK received for its replies. Therefore the call is unable to complete.To overcome this behavior, we have developed a new mechanism that is able to handle transactions in such distributed environments. The following section describes how this is done.\nDistributed transactions handling Transactions are probably the most complicated structures in SIP, especially because they are very dynamic (requests and replies are exchanged within milliseconds) and they contain a lot of data (various information from the SIP messages, requests for re-transmissions, received replies, multiple branches, etc). That makes them very hard to move around between different instances. Therefore, instead of sending transaction information to each node within the anycast “cluster”, our approach was to bring the events to the node that created the transaction. This way we minimize the amount of data exchanged between instances – instead of sending huge transaction data, we simply replicate one single message – and we are only doing this when it’s really necessary – we are only replicating messages when the router that manages the anycast config switches to a different node.When doing distributed transaction handling, the logic of the transaction module is the following: when a reply comes on one server, we check whether the current node has a transaction for that reply. If it does (i.e. the router did not switch the path), the reply is processed locally. If it does not, then somebody else must “own” that transaction. The question is who? That’s where the SIP magic comes: when we generate the INVITE request towards the client, we add a special parameter in the VIA header, indicating the ID of the node that created the transaction. When the reply comes back, that ID contains exactly the node that “owns” the transaction. Therefore, all we have to do is to take that ID and forward the message to it, using the proto_bin module. When the “owner” receives the reply, it “sees” it exactly as it would have received it directly from the client, thus treating it exactly as any other regular reply. And the call is properly established further. Figure 2.There is one more scenario that needs to be taken into account, namely what happens when a CANCEL message reaches a different node (Figure 2). Since there is no transaction found on node 2, normally that message would have been declined. However, in an anycast environment, the transaction might be “owned” by a different node. , therefore, we need to instruct him that the transaction was canceled. However, this time we have no information about who “owns” that transaction – so all we can do is to broadcast the CANCEL event to all the nodes within the cluster. If any of the nodes that receive the event find the transaction that the CANCEL refers to, it will properly reply a 200 OK message and then close all the ongoing branches. If no transaction is found on any node, the CANCEL will eventually time out on the Client side.A similar approach is done for a hop-by-hop ACK message received in an anycast interface.\nAnycast Configuration The first thing we have to do is to configure the anycast address on each node that uses it. This is done in the listen parameter:\nlisten = udp:10.10.10.10:5060 anycast The distributed transaction handling feature relies on the clusterer module to group the nodes that use the same anycast address in a cluster. The resulting cluster id has to be provisioned using the tm_replication_cluster parameter of the transaction module:\nloadmodule \"tm.so\" modparam(\"tm\", \"tm_replication_cluster\", 1) The last thing that we need to take care of is the hop-by-hop messages, such as ACK. This is automatically done by using the t_anycast_replicate() function: if (!loose_route()) { if (is_method(\"ACK\") \u0026\u0026 !t_check_trans()) { # transanction not here - replicate msg to other nodes t_anycast_replicate(); exit; } } Notice that the CANCEL is not treated in the snippet above. That is because CANCEL messages received on an anycast interface are automatically handled by the transaction layer as described in the previous section. However, if one intends to explicitly receive the CANCEL message in the script to make any adjustments (i.e. change the message Reason), they can disable the default behavior using the cluster_auto_cancel param. However, this changes the previous logic a bit, since the CANCEL must be replicated as well in case no transaction is locally found:\nmodparam(\"tm\", \"cluster_auto_cancel\", no) ... if (!loose_route()) { if (!t_check_trans()) { if (is_method(\"CANCEL\")) { # do your adjustments here t_anycast_replicate(); exit; } else if is_method(\"ACK\") { t_anycast_replicate(); exit; } } } And that’s it – you have a fully working anycast environment, with distributed transaction matching!\nFind out more! The distributed transaction handling mechanism has already been released on the OpenSIPS 2.4 development branch. To find out more about the design and internals of this feature, as well as other use cases, make sure you do not miss the Full Anycast support at the edge of your platform using OpenSIPS 2.4 presentation about this at the Amsterdam 2018 OpenSIPS Summit, May 1-4!\n","wordCount":"1543","inLanguage":"en","datePublished":"2019-07-31T13:37:31+08:00","dateModified":"2019-07-31T13:37:31+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/blog/full-anycast/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/cowboy.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/books/ title=百分之一阅读法><span>百分之一阅读法</span></a></li><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/kamailio/ title=Kamailio><span>Kamailio</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/fe/ title=前端><span>前端</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>Full Anycast support in OpenSIPS 2.4</h1><div class=post-meta><span title='2019-07-31 13:37:31 +0800 CST'>2019-07-31 13:37:31</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Eddie Wang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/opensips/blog/full-anycast/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#state-of-the-art aria-label="State of the art">State of the art</a></li><li><a href=#anycast-in-a-transaction-stateful-scenario aria-label="Anycast in a transaction stateful scenario">Anycast in a transaction stateful scenario</a></li><li><a href=#distributed-transactions-handling aria-label="Distributed transactions handling">Distributed transactions handling</a></li><li><a href=#anycast-configuration aria-label="Anycast Configuration">Anycast Configuration</a></li><li><a href=#find-out-more aria-label="Find out more!">Find out more!</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>he advantages of doing Load Balancing and High Availability **without **any particular requirements from the clients side are starting to make Anycast IPs more and more appealing in the VoIP world. But are you actually using the best out of it? This article describes how you can use OpenSIPS 2.4 to make the best use of an anycast environment.<a href=https://en.wikipedia.org/wiki/Anycast>Anycast</a> is a UDP-based special network setup where a single IP is assigned to multiple nodes, each of them being able to actively use it (as opposed to a VRRP setup, where only one instance can use the IP). When a packet reaches the network with an anycast destination, the router sends it to the “closest” node, based on different metrics (application status, network latency, etc). This behavior ensures that traffic is (1) <strong>balanced</strong> by sending it to one of the least busy nodes (based on application status) and also ensures (2) <strong>geo-distribution</strong>, by sending the request to the closest node (based on latency). Moreover, if a node goes down, it will be completely put out of route, ensuring (3) <strong>high availability</strong> for your platform. All these features without any special requirements from your customers, all they need is to send traffic to the anycast IP.Sounds wonderful, right? It really is! And if you are running using anycast IPs in a transaction stateless mode, things just work out of the box.</p><h4 id=state-of-the-art>State of the art<a hidden class=anchor aria-hidden=true href=#state-of-the-art>#</a></h4><p>A common Anycast setup is to assign the anycast IPs to the nodes at the edge of your  platform, facing the clients. This setup ensures that all three features (load balancing, geo-distribution and high-availability) are provided for your customers’ inbound calls. However, most of the anycast “stories” we have heard or read about are only using the anycast IP for the initial incoming INVITEs from customers. Once received, the entire call is pinned to a unicast IP of the first server that received the INVITE. Therefore all sequential messages will go through that single unicast IP. Although this works fine from SIP point of view, you will lose all the anycast advantages such as high-availability.When using this approach (of only receiving initial request on the anycast IP) the inbound calls to the clients will also be affected, because besides losing dialog high-availability, you will also need to ask all your clients to accept calls from all your available unicast IPs. Imagine what happens when you add a new node.Our full anycast solution aims to sort out these limitations by always keeping the anycast IPs in the route for the entire call. This means that your clients will always have one single IP to provision, the anycast IP. And when a node goes down, all sequential messages will be re-routed (by the router) to the next available node. Of course, this node needs to have the entire call information to be able to properly close the call, but that can be easily done in OpenSIPS using <a href=http://www.opensips.org/html/docs/modules/2.4.x/dialog.html#idp5554400>dialog replication</a>.Besides the previous issue, most of the time running in stateless mode is not possible due to application logic constraints (re-transmission handling, upstream timeout detection, etc.). Thus stateful transaction mode is required, which complicates a bit more our anycast scenario.</p><h4 id=anycast-in-a-transaction-stateful-scenario>Anycast in a transaction stateful scenario<a hidden class=anchor aria-hidden=true href=#anycast-in-a-transaction-stateful-scenario>#</a></h4><p>A SIP transaction consists of a request and all the replies associated to that request. According to the <a href=https://www.ietf.org/rfc/rfc3261.txt>SIP RFC</a>, when a stateful SIP proxy sends a request, the next hop should immediately send a reply as soon as it received the request. Otherwise, the SIP proxy will start re-transmitting that request until it either receives a reply, or will eventually time out. Now, let’s consider the anycast scenario described in <strong>Figure 1</strong>:<img loading=lazy src="https://blogopensips.files.wordpress.com/2018/03/anycast-transaction-stateful.png?w=380&amp;h=462#align=left&amp;display=inline&amp;height=462&amp;originHeight=462&amp;originWidth=380&amp;status=uploading&amp;width=380" alt>
Figure 1.OpenSIPS instance 1 sends an INVITE to the client, originated from the Anycast IP interface. The INVITE goes through the Router, and reaches the Client’s IP. However, when the Client replies with 200 OK, the Router decides the “shortest” path is to OpenSIPS instance 2, which has no information about the transaction. Therefore, instance 2 drops all the replies. Moreover, since instance 1 did not receive any reply, it will start re-transmitting the INVITE. And so on, and so forth, until instance 1 times out, because it did not receive any reply, and the Client times out because there was no ACK received for its replies. Therefore the call is unable to complete.To overcome this behavior, we have developed a new mechanism that is able to handle transactions in such distributed environments. The following section describes how this is done.</p><h4 id=distributed-transactions-handling>Distributed transactions handling<a hidden class=anchor aria-hidden=true href=#distributed-transactions-handling>#</a></h4><p>Transactions are probably the most complicated structures in SIP, especially because they are very dynamic (requests and replies are exchanged within milliseconds) and they contain a lot of data (various information from the SIP messages, requests for re-transmissions, received replies, multiple branches, etc). That makes them very hard to move around between different instances. Therefore, instead of sending transaction information to each node within the anycast “cluster”, our approach was to bring the events to the node that created the transaction. This way we minimize the amount of data exchanged between instances – instead of sending huge transaction data, we simply replicate one single message –  and we are only doing this when it’s really necessary – we are only replicating messages when the router that manages the anycast config switches to a different node.When doing distributed transaction handling, the logic of the <a href=http://www.opensips.org/html/docs/modules/2.4.x/tm.html>transaction module</a> is the following: when a reply comes on one server, we check whether the current node has a transaction for that reply. If it does (i.e. the router did not switch the path), the reply is processed locally. If it does not, then somebody else must “own” that transaction. The question is who? That’s where the SIP magic comes: when we generate the INVITE request towards the client, we add a special parameter in the VIA header, indicating the ID of the node that created the transaction. When the reply comes back, that ID contains exactly the node that “owns” the transaction. Therefore, all we have to do is to take that ID and forward the message to it, using the <a href=http://www.opensips.org/html/docs/modules/2.4.x/proto_bin>proto_bin module</a>. When the “owner” receives the reply, it “sees” it exactly as it would have received it directly from the client, thus treating it exactly as any other regular reply. And the call is properly established further.<img loading=lazy src="https://cdn.nlark.com/yuque/0/2019/png/280451/1564551492001-1b9052d8-a693-4856-b55a-6ff04ce7f312.png#align=left&amp;display=inline&amp;height=479&amp;originHeight=479&amp;originWidth=394&amp;size=0&amp;status=done&amp;width=394" alt>
Figure 2.There is one more scenario that needs to be taken into account, namely what happens when a CANCEL message reaches a different node (<strong>Figure 2</strong>). Since there is no transaction found on node 2, normally that message would have been declined. However, in an anycast environment, the transaction might be “owned” by a different node. , therefore, we need to instruct him that the transaction was canceled. However, this time we have no information about who “owns” that transaction – so all we can do is to broadcast the CANCEL event to all the nodes within the cluster. If any of the nodes that receive the event find the transaction that the CANCEL refers to, it will properly reply a 200 OK message and then close all the ongoing branches. If no transaction is found on any node, the CANCEL will eventually time out on the Client side.A similar approach is done for a hop-by-hop ACK message received in an anycast interface.</p><h4 id=anycast-configuration>Anycast Configuration<a hidden class=anchor aria-hidden=true href=#anycast-configuration>#</a></h4><p>The first thing we have to do is to configure the anycast address on each node that uses it. This is done in the <a href=http://www.opensips.org/Documentation/Script-CoreParameters-2-4#toc37>listen</a> parameter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>listen <span style=color:#f92672>=</span> udp:10.10.10.10:5060 anycast
</span></span></code></pre></div><p>The distributed transaction handling feature relies on the <a href=http://www.opensips.org/html/docs/modules/2.4.x/clusterer>clusterer module</a> to group the nodes that use the same anycast address in a cluster. The resulting cluster id has to be provisioned using the <a href=http://www.opensips.org/html/docs/modules/2.4.x/tm#tm_replication_cluster>tm_replication_cluster</a> parameter of the transaction module:</p><pre tabindex=0><code>loadmodule &#34;tm.so&#34;
modparam(&#34;tm&#34;, &#34;tm_replication_cluster&#34;, 1)
The last thing that we need to take care of is the hop-by-hop messages, such as ACK. This is automatically done by using the t_anycast_replicate() function:
if (!loose_route()) {
    if (is_method(&#34;ACK&#34;) &amp;&amp; !t_check_trans()) {
        # transanction not here - replicate msg to other nodes
        t_anycast_replicate();
        exit;
    }
}
</code></pre><p>Notice that the CANCEL is not treated in the snippet above. That is because CANCEL messages received on an anycast interface are automatically handled by the transaction layer as described in the previous section. However, if one intends to explicitly receive the CANCEL message in the script to make any adjustments (i.e. change the message Reason), they can disable the default behavior using the cluster_auto_cancel param. However, this changes the previous logic a bit, since the CANCEL must be replicated as well in case no transaction is locally found:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;tm&#34;</span>, <span style=color:#e6db74>&#34;cluster_auto_cancel&#34;</span>, no<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>!loose_route<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>!t_check_trans<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>is_method<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;CANCEL&#34;</span><span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># do your adjustments here</span>
</span></span><span style=display:flex><span>            t_anycast_replicate<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>            exit;
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_method<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ACK&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            t_anycast_replicate<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>            exit;
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>And that’s it – you have a fully working anycast environment, with distributed transaction matching!</p><h4 id=find-out-more>Find out more!<a hidden class=anchor aria-hidden=true href=#find-out-more>#</a></h4><p>The distributed transaction handling mechanism has already been released on the OpenSIPS 2.4 development branch. To find out more about the design and internals of this feature, as well as other use cases, make sure you do not miss the <a href=http://www.opensips.org/events/Summit-2018Amsterdam/#mu-schedule>Full Anycast support at the edge of your platform using OpenSIPS 2.4</a> presentation about this at the  <a href=http://www.opensips.org/events/Summit-2018Amsterdam>Amsterdam 2018 OpenSIPS Summit, May 1-4</a>!</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=wangduanduan/wangduanduan.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxMTkyMjMyNjA=" data-category=Announcements data-category-id=DIC_kwDOBxsz3M4CAjBq data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>