<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Improved series-based call statistics using OpenSIPS 3.2 | 洞香春</title>
<meta name=keywords content><meta name=description content="
早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。
原文：https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/
Real-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use interface that exposes simple primitives for creating, updating, and displaying various statistics, both well defined as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read. In other words, you cannot gather statistics only for a limited time frame.That is why starting with OpenSIPS 3.2, the statistics module was enhanced with a new type of statistics, namely statistics series, that allow you to provide custom stats accumulated over a specific time window (such as one second, one minute, one hour, etc.). When the stat is evaluated, only the values gathered within the specified time window is accounted, all the others are simply dropped (similar to a time-based circular buffer, or a sliding window). Using these new stats, you can easily provide standard statistics such as ACD, AST, PPT, ASR, NER, CCR in a per minute/hour fashion."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/blog/call-stat/><link crossorigin=anonymous href=/assets/css/stylesheet.821c51435cba3e33e49e590a06514c54c32ac7957095ffcc1e0f390c47cf3228.css integrity="sha256-ghxRQ1y6PjPknlkKBlFMVMMqx5Vwlf/MHg85DEfPMig=" rel="preload stylesheet" as=style><link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wdd.js.org/opensips/blog/call-stat/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://wdd.js.org/opensips/blog/call-stat/"><meta property="og:site_name" content="洞香春"><meta property="og:title" content="Improved series-based call statistics using OpenSIPS 3.2"><meta property="og:description" content=" 早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。
原文：https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/
Real-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use interface that exposes simple primitives for creating, updating, and displaying various statistics, both well defined as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read. In other words, you cannot gather statistics only for a limited time frame.That is why starting with OpenSIPS 3.2, the statistics module was enhanced with a new type of statistics, namely statistics series, that allow you to provide custom stats accumulated over a specific time window (such as one second, one minute, one hour, etc.). When the stat is evaluated, only the values gathered within the specified time window is accounted, all the others are simply dropped (similar to a time-based circular buffer, or a sliding window). Using these new stats, you can easily provide standard statistics such as ACD, AST, PPT, ASR, NER, CCR in a per minute/hour fashion."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2021-02-11T20:11:43+08:00"><meta property="article:modified_time" content="2021-02-11T20:11:43+08:00"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Improved series-based call statistics using OpenSIPS 3.2"><meta name=twitter:description content="
早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。
原文：https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/
Real-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use interface that exposes simple primitives for creating, updating, and displaying various statistics, both well defined as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read. In other words, you cannot gather statistics only for a limited time frame.That is why starting with OpenSIPS 3.2, the statistics module was enhanced with a new type of statistics, namely statistics series, that allow you to provide custom stats accumulated over a specific time window (such as one second, one minute, one hour, etc.). When the stat is evaluated, only the values gathered within the specified time window is accounted, all the others are simply dropped (similar to a time-based circular buffer, or a sliding window). Using these new stats, you can easily provide standard statistics such as ACD, AST, PPT, ASR, NER, CCR in a per minute/hour fashion."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":2,"name":"Improved series-based call statistics using OpenSIPS 3.2","item":"https://wdd.js.org/opensips/blog/call-stat/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Improved series-based call statistics using OpenSIPS 3.2","name":"Improved series-based call statistics using OpenSIPS 3.2","description":" 早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。\n原文：https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/\nReal-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use interface that exposes simple primitives for creating, updating, and displaying various statistics, both well defined as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read. In other words, you cannot gather statistics only for a limited time frame.That is why starting with OpenSIPS 3.2, the statistics module was enhanced with a new type of statistics, namely statistics series, that allow you to provide custom stats accumulated over a specific time window (such as one second, one minute, one hour, etc.). When the stat is evaluated, only the values gathered within the specified time window is accounted, all the others are simply dropped (similar to a time-based circular buffer, or a sliding window). Using these new stats, you can easily provide standard statistics such as ACD, AST, PPT, ASR, NER, CCR in a per minute/hour fashion.\n","keywords":[],"articleBody":" 早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。\n原文：https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/\nReal-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use interface that exposes simple primitives for creating, updating, and displaying various statistics, both well defined as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read. In other words, you cannot gather statistics only for a limited time frame.That is why starting with OpenSIPS 3.2, the statistics module was enhanced with a new type of statistics, namely statistics series, that allow you to provide custom stats accumulated over a specific time window (such as one second, one minute, one hour, etc.). When the stat is evaluated, only the values gathered within the specified time window is accounted, all the others are simply dropped (similar to a time-based circular buffer, or a sliding window). Using these new stats, you can easily provide standard statistics such as ACD, AST, PPT, ASR, NER, CCR in a per minute/hour fashion.\nProfiles In order to use the statistics series you first need to define a statistics profile, which describes certain properties of the statistics to be used, such as:\nthe duration of the time frame to be used – the number of seconds worth of data that should be accumulated for the statistics that use this profile; all data gathered outside of this time window is discarded the granularity of the time window – the number of slots used for each series – the more slots, the more accurate the statistic is, with a penalty of an increased memory footprint how to group statistics to make them easier to process the processing algorithm – or how data should be accumulated and interpreted when the statistic is evaluated; this is presented in the next chapter The profile needs to be specified every time data is pushed in a statistic series, so that the engine knows how to process it.\nAlgorithms The statistics series algorithm describe how the data gathered over the specified time window should be processed. There are several algorithms available:\naccumulate – this is useful when you want to count the number of times a specific event appears (such as number of requests, replies, dialogs, etc); for this algorithm, the statistic is represented as a simple counter that accumulates when data is fed, and is decreased when data (out of the sliding window) expires average – this is used to compute an average value over the entire window frame; this is useful to compute average call duration (ACD) or average post dial delay (PDD) over a specified time window percentage – used to compute the percentage of some data out of a total number of entries; useful to compute different types of ratios, such as Answer-seizure ratio (ASR), NER or CCR Usage The new functionality can be leveraged by defining one (or more) stat_series_profiles, and then feed data to that statistic according to your script’s logic using the update_stat_series() function. In order to evaluate the result of the stats, one can use the $stat() variable from within OpenSIPS’s script, or access it from outside using the get_statistics MI command.As a quick theoretical example, let us consider creating two statistics: one that counts the number of initial INVITE requests per minute your platform receives, and another one that shows the ratio of the INVITE requests out of all the other requests received.First, we shall define the two profiles that describe how the new statistics should be interpreted: the first one, should be a counter that accumulates all the initial INVITEs received in one minute, and the second one should be a percentage series, is incremented for initial INVITEs, and decremented for all the others. Both statistics series will use a 60s (one minute) window:modparam(“statistics”, “stat_series_profile”, “inv_acc_per_min: algorithm=accumulate window=60”)modparam(“statistics”, “stat_series_profile”, “inv_perc_per_min: algorithm=percentage window=60”)Now, in the main route, we shell update statistics with data:…route { … if (is_method(“INVITE”) \u0026\u0026 has_totag()) { update_stat_series(“inv_acc_per_min”, “INVITE_per_min”, “1”); update_stat_series(“inv_perc_per_min”, “INVITE_ratio”, “1”); } else { update_stat_series(“inv_perc_per_min”, “INVITE_ratio”, “-1”); } xlog(“INVITEs per min $stat(INVITE_per_min) represents $stat(INVITE_ratio)% of total requests\\n”); …}…You can query these statistics through the MI interface by running:opensips-cli -x mi get_statistics INVITE_per_min INVITE_ratio\nUse case In a production environment, the KPIs you provide your customers are very important, as they describe the quality of the service you provide. Some of these are quite standard indices (ACD, ASR, AST, PDD, NER, CCR), that are relevant for specific period of times (one minute, ten minutes, one hour). In the following paragraphs we will see how we can provide these statistics on a customer basis, as well as overall.First, we need to understand what each stat represents, to understand the logic that has to be scripted:\nASR (Answer Seizure Ratio) – the percentage of telephone calls which are answered (200 reply status code) CCR (Call Completion Ratio) – the percentage of telephone calls which are signaled back by the far-end client. Thus, 5xx, 6xx reply codes and internal 408 timeouts generated before reaching the client do not count here. The following is always true: CCR \u003e= ASR _PDD (Post Dial Delay) _– the duration, in milliseconds, between the receival of the initial INVITE and the receival of the first 180/183 provisional reply (the call state advances to “ringing”) AST (Average Setup Time) – the duration, in milliseconds, between the receival of the initial INVITE and the receival of the first 200 OK reply (the call state advances to “answered”). The following is always true: AST \u003e= PDD ACD (Average Call Duration) – the duration, in seconds, between the receival of the initial INVITE and the receival of the first BYE request from either participant (the call state advances to “ended”) NER (Network Effectiveness Ratio) – measures the ability of a server to deliver the call to the called terminal; in addition to ASR, NER also considers busy and user failures as success Now that we know what we want to see, we can start scripting: we need to load the statistics module, and define two types of profiles: one that computes average indices (used for AST, PDD, ACD), and one for percentage indices (used for ASR, NER, CCR). For each of them, we define 3 different time windows: per minute, per 10 minutes and per hour:\nloadmodule \"statistics.so\" modparam(\"statistics\", \"stat_series_profile\", \"perc: algorithm=percentage group=stats\") modparam(\"statistics\", \"stat_series_profile\", \"10m-perc: algorithm=percentage window=600 slots=10 group=stats_10m\") modparam(\"statistics\", \"stat_series_profile\", \"1h-perc: algorithm=percentage window=3600 slots=6 group=stats_1h\") modparam(\"statistics\", \"stat_series_profile\", \"avg: algorithm=average group=stats\") modparam(\"statistics\", \"stat_series_profile\", \"10m-avg: algorithm=average window=600 slots=10 group=stats_10m\") modparam(\"statistics\", \"stat_series_profile\", \"1h-avg: algorithm=average window=3600 slots=6 group=stats_1h\") In order to catch all the relevant events we need to hook on, we will be using the E_ACC_CDR and E_ACC_MISSED_EVENT events exposed by the accounting module. In order to have identify the customer that the events were triggered for, we need to export the customer’s identifier in the event:\nloadmodule \"acc.so\" modparam(\"acc\", \"extra_fields\",\"evi: customer\") route { ... if (has_totag() \u0026\u0026 is_method(\"INVITE\")) { do_accounting(\"evi\", \"cdr|missed\"); t_on_reply(\"stats\"); # store the moment the call started get_accurate_time($avp(call_start_s), $avp(call_start_us)); # TODO: store the customer's id in $acc_extra(customer) } ... } When a reply comes in, our “stats” reply route will be called, where we will update all the statistics, according to our logic. Because we need to compute them twice, once for global statistics, and once for customer’s one, we will put the logic in a new route, “calculate_stats_reply”, that we call when a reply comes in:\nonreply_route[stats] { route(calculate_stats_reply, $avp(call_start_s), $avp(call_start_us), \"\"); route(calculate_stats_reply, $avp(call_start_s), $avp(call_start_us), $acc_extra(customer)); } route[calculate_stats_reply] { # expects: # - param 1: timestamp (in seconds) when the initial request was received # - param 2: timestamp (in microseconds) when the initial request was received # - param 3: statistic identifier; for global, empty string is used if ($rs == \"180\" || $rs == \"183\" || $rs == \"200\" || $rs == \"400\" || $rs == \"403\" || $rs == \"408 || $rs == \"480\" || $rs == \"487\") { if (!isflagset(\"FLAG_PDD_CALCULATED\")) { get_accurate_time($var(now_s), $var(now_us)); ts_usec_delta($var(now_s), $var(now_us), $param(1), $param(2), $var(pdd_us)); $var(pdd_ms) = $var(pdd_us) / 1000; # milliseconds $avp(pdd) = $var(pdd_ms); setflag(\"FLAG_PDD_CALCULATED\"); } else { $var(pdd_ms) = $avp(pdd); } update_stat_series(\"avg\", \"PDD$param(3)\", $var(pdd_ms)); update_stat_series(\"10m-avg\", \"PDD_10m$param(3)\", $var(pdd_ms)); update_stat_series(\"1h-avg\", \"PDD_1h$param(3)\", $var(pdd_ms)); } if ($rs \u003e= 200 \u0026\u0026 $rs \u003c 300) { update_stat_series(\"perc\", \"ASR$param(3)\", 1); update_stat_series(\"10m-perc\", \"ASR_10m$param(3)\", 1); update_stat_series(\"1h-perc\", \"ASR_1h$param(3)\", 1); update_stat_series(\"perc\", \"NER$param(3)\", 1); update_stat_series(\"10m-perc\", \"NER_10m$param(3)\", 1); update_stat_series(\"1h-perc\", \"NER_1h$param(3)\", 1); update_stat_series(\"perc\", \"CCR$param(3)\", 1); update_stat_series(\"10m-perc\", \"CCR_10m$param(3)\", 1); update_stat_series(\"1h-perc\", \"CCR_1h$param(3)\", 1); get_accurate_time($var(now_s), $var(now_us)); ts_usec_delta($var(now_s), $var(now_us), $param(1), $param(2), $var(ast_us)); $var(ast_us) = $var(ast_us) / 1000; # milliseconds update_stat_series(\"avg\", \"AST$param(3)\", $var(ast_us)); update_stat_series(\"10m-avg\", \"AST_10m$param(3)\", $var(ast_us)); update_stat_series(\"1h-avg\", \"AST_1h$param(3)\", $var(ast_us)); } } In case of a successful call, the dialog generates a CDR, that we use to update our ACD statistics:\nevent_route[E_ACC_CDR] { route(calculate_stats_cdr, $param(duration), $param(setuptime), \"\"); route(calculate_stats_cdr, $param(duration), $param(setuptime), $param(customer)); } route[calculate_stats_cdr] { # expects: # - param 1: duration (in seconds) of the call # - param 2: setuptime (in seconds) of the call # - param 3: optional - statistic identifier; global is empty string $var(total_duration) = $param(1) + $param(2); update_stat_series(\"avg\", \"ACD$param(3)\", $var(total_duration)); update_stat_series(\"10m-avg\", \"ACD_10m$param(3)\", $var(total_duration)); update_stat_series(\"1h-avg\", \"ACD_1h$param(3)\", $var(total_duration)); } And in case of a failure, we update the corresponding statistics:\nevent_route[E_ACC_MISSED_EVENT] { route(calculate_stats_failure, $param(code), \"\"); route(calculate_stats_failure, $param(code), $param(customer)); } route[calculate_stats_failure] { # expects: # - param 1: failure code # - param 2: statistic identifier; global is empty string update_stat_series(\"perc\", \"ASR$param(3)\", -1); update_stat_series(\"10m-perc\", \"ASR_10m$param(3)\", -1); update_stat_series(\"1h-perc\", \"ASR_1h$param(3)\", -1); if ($param(1) == \"486\" || $param(1) == \"408\") { update_stat_series(\"perc\", \"NER$param(3)\", 1); update_stat_series(\"10m-perc\", \"NER_10m$param(3)\", 1); update_stat_series(\"1h-perc\", \"NER_1h$param(3)\", 1); } else { update_stat_series(\"perc\", \"NER$param(3)\", -1); update_stat_series(\"10m-perc\", \"NER_10m$param(3)\", -1); update_stat_series(\"1h-perc\", \"NER_1h$param(3)\", -1); } if ($(param(1){s.int}) \u003e 499) { update_stat_series(\"perc\", \"CCR$param(3)\", -1); update_stat_series(\"10m-perc\", \"CCR_10m$param(3)\", -1); update_stat_series(\"1h-perc\", \"CCR_1h$param(3)\", -1); } else { update_stat_series(\"perc\", \"CCR$param(3)\", 1); update_stat_series(\"10m-perc\", \"CCR_10m$param(3)\", 1); update_stat_series(\"1h-perc\", \"CCR_1h$param(3)\", 1); } } And we are all set – all you have to do is to run traffic through your server, query the statistics (over MI) at your desired pace (such as every minute), and plot them nicely in a graph to improve your monitoring experience .\nPossible enhancements There is currently no way of persisting these statistics over a restart – this means that every time you restart, the new statistics have to be re-computed, resulting in possible misleading results. In the future, it would be nice if we could provide some sort of persistent storage for them.All statistics are currently local, although it might be possible aggregate values across multiple servers using some scripting + cluster broadcast messages from script. Ideally, we shall implement this in an automatic fashion using the clusterer module.Finally, although there are currently only three algorithms supported (accumulate, percentage and average), more can be added quite easily – we shall do that in future versions.Enjoy your new statistics!\n","wordCount":"1796","inLanguage":"en","image":"https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2021-02-11T20:11:43+08:00","dateModified":"2021-02-11T20:11:43+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/blog/call-stat/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org/ accesskey=h title="洞香春 (Alt + H)"><img src=https://wdd.js.org/cowboy.ico alt aria-label=logo height=35>洞香春</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wdd.js.org/books/ title=读书><span>读书</span></a></li><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/kamailio/ title=Kamailio><span>Kamailio</span></a></li><li><a href=https://wdd.js.org/kamailio/56/ title="Kamailio 5.6 wiki"><span>Kamailio 5.6 wiki</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/fe/ title=前端><span>前端</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org/>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class="post-title entry-hint-parent">Improved series-based call statistics using OpenSIPS 3.2</h1><div class=post-meta><span title='2021-02-11 20:11:43 +0800 CST'>2021-02-11 20:11:43</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Eddie Wang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/opensips/blog/call-stat/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#profiles aria-label=Profiles>Profiles</a></li><li><a href=#algorithms aria-label=Algorithms>Algorithms</a></li><li><a href=#usage aria-label=Usage>Usage</a></li><li><a href=#use-case aria-label="Use case">Use case</a></li><li><a href=#possible-enhancements aria-label="Possible enhancements">Possible enhancements</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>早期1x和2x版本的OpenSIPS，统计模块只有两种模式，一种时计算值，另一种是从运行开始的累加值。而无法获取比如说最近一分钟，最近5分钟，这样的基于一定周期的统计值，在OpenSIPS 3.2上，提供了新的解决方案。</p></blockquote><p>原文：<a href=https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/>https://blog.opensips.org/2021/02/02/improved-series-based-call-statistics-using-opensips-3-2/</a></p><p>Real-time call statistics is an excellent tool to evaluate the quality and performance of your telephony platform, that is why it is very important to expose as many statistics as possible, accumulated over different periods of time.OpenSIPS provides an easy to use <a href=https://www.opensips.org/Documentation/Interface-Statistics-3-2>interface</a> that exposes simple primitives for creating, updating, and displaying various statistics, both <a href=https://www.opensips.org/Documentation/Interface-CoreStatistics-3-2>well defined</a> as well as tailored to your needs. However, the current implementation comes with a limitation: statistics are gathered starting from the beginning of the execution, up to the point they are read. In other words, you cannot gather statistics only for a limited time frame.That is why starting with OpenSIPS 3.2, the statistics module was enhanced with a new type of statistics, namely statistics series, that allow you to provide custom stats accumulated over a specific time window (such as one second, one minute, one hour, etc.). When the stat is evaluated, only the values gathered within the specified time window is accounted, all the others are simply dropped (similar to a time-based circular buffer, or a sliding window). Using these new stats, you can easily provide standard statistics such as ACD, AST, PPT, ASR, NER, CCR in a per minute/hour fashion.</p><h2 id=profiles>Profiles<a hidden class=anchor aria-hidden=true href=#profiles>#</a></h2><p>In order to use the statistics series you first need to define a statistics profile, which describes certain properties of the statistics to be used, such as:</p><ul><li>the duration of the time frame to be used – the number of seconds worth of data that should be accumulated for the statistics that use this profile; all data gathered outside of this time window is discarded</li><li>the granularity of the time window – the number of slots used for each series – the more slots, the more accurate the statistic is, with a penalty of an increased memory footprint</li><li>how to <a href=https://opensips.org/docs/modules/3.2.x/statistics.html#idp3070208>group</a> statistics to make them easier to process</li><li>the processing algorithm – or how data should be accumulated and interpreted when the statistic is evaluated; this is presented in the next chapter</li></ul><p>The profile needs to be specified every time data is pushed in a statistic series, so that the engine knows how to process it.</p><h2 id=algorithms>Algorithms<a hidden class=anchor aria-hidden=true href=#algorithms>#</a></h2><p>The statistics series algorithm describe how the data gathered over the specified time window should be processed. There are several algorithms available:</p><ul><li>accumulate – this is useful when you want to count the number of times a specific event appears (such as number of requests, replies, dialogs, etc); for this algorithm, the statistic is represented as a simple counter that accumulates when data is fed, and is decreased when data (out of the sliding window) expires</li><li>average – this is used to compute an average value over the entire window frame; this is useful to compute average call duration (ACD) or average post dial delay (PDD) over a specified time window</li><li>percentage – used to compute the percentage of some data out of a total number of entries; useful to compute different types of ratios, such as Answer-seizure ratio (ASR), NER or CCR</li></ul><h2 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h2><p>The new functionality can be leveraged by defining one (or more) <a href=https://opensips.org/docs/modules/3.1.x/statistics.html#param_stat_series_profile>stat_series_profile</a>s, and then feed data to that statistic according to your script’s logic using the <a href=https://opensips.org/docs/modules/3.1.x/statistics.html#func_update_stat_series>update_stat_series()</a> function. In order to evaluate the result of the stats, one can use the <a href=https://opensips.org/docs/modules/3.1.x/statistics.html#pv_stat>$stat()</a> variable from within OpenSIPS’s script, or access it from outside using the <a href=https://www.opensips.org/Documentation/Interface-CoreMI-3-2#toc12>get_statistics</a> MI command.As a quick theoretical example, let us consider creating two statistics: one that counts the number of initial INVITE requests per minute your platform receives, and another one that shows the ratio of the INVITE requests out of all the other requests received.First, we shall define the two profiles that describe how the new statistics should be interpreted: the first one, should be a counter that accumulates all the initial INVITEs received in one minute, and the second one should be a percentage series, is incremented for initial INVITEs, and decremented for all the others. Both statistics series will use a 60s (one minute) window:modparam(&ldquo;statistics&rdquo;, &ldquo;stat_series_profile&rdquo;, &ldquo;inv_acc_per_min: algorithm=accumulate window=60&rdquo;)modparam(&ldquo;statistics&rdquo;, &ldquo;stat_series_profile&rdquo;, &ldquo;inv_perc_per_min: algorithm=percentage window=60&rdquo;)Now, in the main route, we shell update statistics with data:&mldr;route {    &mldr;    if (is_method(&ldquo;INVITE&rdquo;) && has_totag()) {        update_stat_series(&ldquo;inv_acc_per_min&rdquo;, &ldquo;INVITE_per_min&rdquo;, &ldquo;1&rdquo;);        update_stat_series(&ldquo;inv_perc_per_min&rdquo;, &ldquo;INVITE_ratio&rdquo;, &ldquo;1&rdquo;);    } else {        update_stat_series(&ldquo;inv_perc_per_min&rdquo;, &ldquo;INVITE_ratio&rdquo;, &ldquo;-1&rdquo;);    }    xlog(&ldquo;INVITEs per min $stat(INVITE_per_min) represents $stat(INVITE_ratio)% of total requests\n&rdquo;);    &mldr;}&mldr;You can query these statistics through the MI interface by running:opensips-cli -x mi get_statistics INVITE_per_min INVITE_ratio</p><h2 id=use-case>Use case<a hidden class=anchor aria-hidden=true href=#use-case>#</a></h2><p>In a production environment, the KPIs you provide your customers are very important, as they describe the quality of the service you provide. Some of these are quite standard indices (ACD, ASR, AST, PDD, NER, CCR), that are relevant for specific period of times (one minute, ten minutes, one hour). In the following paragraphs we will see how we can provide these statistics on a customer basis, as well as overall.First, we need to understand what each stat represents, to understand the logic that has to be scripted:</p><ul><li><em>ASR (Answer Seizure Ratio)</em> – the percentage of telephone calls which are answered (200 reply status code)</li><li><em>CCR (Call Completion Ratio)</em> – the percentage of telephone calls which are signaled back by the far-end client. Thus, 5xx, 6xx reply codes and internal 408 timeouts generated before reaching the client do not count here. The following is always true: CCR >= ASR</li><li>_PDD (Post Dial Delay) _– the duration, in milliseconds, between the receival of the initial INVITE and the receival of the first 180/183 provisional reply (the call state advances to <em>“ringing”</em>)</li><li><em>AST (Average Setup Time)</em> – the duration, in milliseconds, between the receival of the initial INVITE and the receival of the first 200 OK reply (the call state advances to <em>“answered”</em>). The following is always true: AST >= PDD</li><li><em>ACD (Average Call Duration)</em> – the duration, in seconds, between the receival of the initial INVITE and the receival of the first BYE request from either participant (the call state advances to <em>“ended”</em>)</li><li><em>NER (Network Effectiveness Ratio)</em> – measures the ability of a server to deliver the call to the called terminal; in addition to ASR, NER also considers busy and user failures as success</li></ul><p>Now that we know what we want to see, we can start scripting: we need to load the statistics module, and define two types of profiles: one that computes average indices (used for AST, PDD, ACD), and one for percentage indices (used for ASR, NER, CCR). For each of them, we define 3 different time windows: per minute, per 10 minutes and per hour:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>loadmodule <span style=color:#e6db74>&#34;statistics.so&#34;</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;statistics&#34;</span>, <span style=color:#e6db74>&#34;stat_series_profile&#34;</span>, <span style=color:#e6db74>&#34;perc: algorithm=percentage group=stats&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;statistics&#34;</span>, <span style=color:#e6db74>&#34;stat_series_profile&#34;</span>, <span style=color:#e6db74>&#34;10m-perc: algorithm=percentage window=600 slots=10 group=stats_10m&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;statistics&#34;</span>, <span style=color:#e6db74>&#34;stat_series_profile&#34;</span>, <span style=color:#e6db74>&#34;1h-perc: algorithm=percentage window=3600 slots=6 group=stats_1h&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;statistics&#34;</span>, <span style=color:#e6db74>&#34;stat_series_profile&#34;</span>, <span style=color:#e6db74>&#34;avg: algorithm=average group=stats&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;statistics&#34;</span>, <span style=color:#e6db74>&#34;stat_series_profile&#34;</span>, <span style=color:#e6db74>&#34;10m-avg: algorithm=average window=600 slots=10 group=stats_10m&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;statistics&#34;</span>, <span style=color:#e6db74>&#34;stat_series_profile&#34;</span>, <span style=color:#e6db74>&#34;1h-avg: algorithm=average window=3600 slots=6 group=stats_1h&#34;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>In order to catch all the relevant events we need to hook on, we will be using the <a href=https://opensips.org/docs/modules/3.1.x/acc.html#event_E_ACC_CDR>E_ACC_CDR</a> and <a href=https://opensips.org/docs/modules/3.1.x/acc.html#event_E_ACC_CDR>E_ACC_MISSED_EVENT</a> events exposed by the accounting module. In order to have identify the customer that the events were triggered for, we need to export the customer’s identifier in the event:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>loadmodule <span style=color:#e6db74>&#34;acc.so&#34;</span>
</span></span><span style=display:flex><span>modparam<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;acc&#34;</span>, <span style=color:#e6db74>&#34;extra_fields&#34;</span>,<span style=color:#e6db74>&#34;evi: customer&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>route <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>has_totag<span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> is_method<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;INVITE&#34;</span><span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        do_accounting<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;evi&#34;</span>, <span style=color:#e6db74>&#34;cdr|missed&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>        t_on_reply<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;stats&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e># store the moment the call started</span>
</span></span><span style=display:flex><span>        get_accurate_time<span style=color:#f92672>(</span>$avp<span style=color:#f92672>(</span>call_start_s<span style=color:#f92672>)</span>, $avp<span style=color:#f92672>(</span>call_start_us<span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e># TODO: store the customer&#39;s id in $acc_extra(customer)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>When a reply comes in, our “stats” reply route will be called, where we will update all the statistics, according to our logic. Because we need to compute them twice, once for global statistics, and once for customer’s one, we will put the logic in a new route, “calculate_stats_reply”, that we call when a reply comes in:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>onreply_route<span style=color:#f92672>[</span>stats<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    route<span style=color:#f92672>(</span>calculate_stats_reply, $avp<span style=color:#f92672>(</span>call_start_s<span style=color:#f92672>)</span>, $avp<span style=color:#f92672>(</span>call_start_us<span style=color:#f92672>)</span>, <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    route<span style=color:#f92672>(</span>calculate_stats_reply, $avp<span style=color:#f92672>(</span>call_start_s<span style=color:#f92672>)</span>, $avp<span style=color:#f92672>(</span>call_start_us<span style=color:#f92672>)</span>, $acc_extra<span style=color:#f92672>(</span>customer<span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>route<span style=color:#f92672>[</span>calculate_stats_reply<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># expects:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># - param 1: timestamp (in seconds) when the initial request was received</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># - param 2: timestamp (in microseconds) when the initial request was received</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># - param 3: statistic identifier; for global, empty string is used</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>$rs <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;180&#34;</span> <span style=color:#f92672>||</span> $rs <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;183&#34;</span> <span style=color:#f92672>||</span> $rs <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;200&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> $rs <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;400&#34;</span> <span style=color:#f92672>||</span> $rs <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;403&#34;</span> <span style=color:#f92672>||</span> $rs <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;408
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            || </span>$rs<span style=color:#e6db74> == &#34;</span>480<span style=color:#e6db74>&#34; || </span>$rs<span style=color:#e6db74> == &#34;</span>487<span style=color:#e6db74>&#34;) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if (!isflagset(&#34;</span>FLAG_PDD_CALCULATED<span style=color:#e6db74>&#34;)) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            get_accurate_time(</span>$var<span style=color:#e6db74>(now_s), </span>$var<span style=color:#e6db74>(now_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            ts_usec_delta(</span>$var<span style=color:#e6db74>(now_s), </span>$var<span style=color:#e6db74>(now_us), </span>$param<span style=color:#e6db74>(1), </span>$param<span style=color:#e6db74>(2), </span>$var<span style=color:#e6db74>(pdd_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            </span>$var<span style=color:#e6db74>(pdd_ms) = </span>$var<span style=color:#e6db74>(pdd_us) / 1000; # milliseconds
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            </span>$avp<span style=color:#e6db74>(pdd) = </span>$var<span style=color:#e6db74>(pdd_ms);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            setflag(&#34;</span>FLAG_PDD_CALCULATED<span style=color:#e6db74>&#34;);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        } else {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            </span>$var<span style=color:#e6db74>(pdd_ms) = </span>$avp<span style=color:#e6db74>(pdd);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>avg<span style=color:#e6db74>&#34;, &#34;</span>PDD$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, </span>$var<span style=color:#e6db74>(pdd_ms));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>10m-avg<span style=color:#e6db74>&#34;, &#34;</span>PDD_10m$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, </span>$var<span style=color:#e6db74>(pdd_ms));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>1h-avg<span style=color:#e6db74>&#34;, &#34;</span>PDD_1h$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, </span>$var<span style=color:#e6db74>(pdd_ms));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if (</span>$rs<span style=color:#e6db74> &gt;= 200 &amp;&amp; </span>$rs<span style=color:#e6db74> &lt; 300) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>perc<span style=color:#e6db74>&#34;, &#34;</span>ASR$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>10m-perc<span style=color:#e6db74>&#34;, &#34;</span>ASR_10m$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>1h-perc<span style=color:#e6db74>&#34;, &#34;</span>ASR_1h$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>perc<span style=color:#e6db74>&#34;, &#34;</span>NER$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>10m-perc<span style=color:#e6db74>&#34;, &#34;</span>NER_10m$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>1h-perc<span style=color:#e6db74>&#34;, &#34;</span>NER_1h$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>perc<span style=color:#e6db74>&#34;, &#34;</span>CCR$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>10m-perc<span style=color:#e6db74>&#34;, &#34;</span>CCR_10m$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>1h-perc<span style=color:#e6db74>&#34;, &#34;</span>CCR_1h$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        get_accurate_time(</span>$var<span style=color:#e6db74>(now_s), </span>$var<span style=color:#e6db74>(now_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ts_usec_delta(</span>$var<span style=color:#e6db74>(now_s), </span>$var<span style=color:#e6db74>(now_us), </span>$param<span style=color:#e6db74>(1), </span>$param<span style=color:#e6db74>(2), </span>$var<span style=color:#e6db74>(ast_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$var<span style=color:#e6db74>(ast_us) = </span>$var<span style=color:#e6db74>(ast_us) / 1000; # milliseconds
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>avg<span style=color:#e6db74>&#34;, &#34;</span>AST$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, </span>$var<span style=color:#e6db74>(ast_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>10m-avg<span style=color:#e6db74>&#34;, &#34;</span>AST_10m$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, </span>$var<span style=color:#e6db74>(ast_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        update_stat_series(&#34;</span>1h-avg<span style=color:#e6db74>&#34;, &#34;</span>AST_1h$param<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#e6db74>&#34;, </span>$var<span style=color:#e6db74>(ast_us));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span></code></pre></div><p>In case of a successful call, the dialog generates a CDR, that we use to update our ACD statistics:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>event_route<span style=color:#f92672>[</span>E_ACC_CDR<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    route<span style=color:#f92672>(</span>calculate_stats_cdr, $param<span style=color:#f92672>(</span>duration<span style=color:#f92672>)</span>, $param<span style=color:#f92672>(</span>setuptime<span style=color:#f92672>)</span>, <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>)</span>;                             
</span></span><span style=display:flex><span>    route<span style=color:#f92672>(</span>calculate_stats_cdr, $param<span style=color:#f92672>(</span>duration<span style=color:#f92672>)</span>, $param<span style=color:#f92672>(</span>setuptime<span style=color:#f92672>)</span>, $param<span style=color:#f92672>(</span>customer<span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>route<span style=color:#f92672>[</span>calculate_stats_cdr<span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># expects:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># - param 1: duration (in seconds) of the call</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># - param 2: setuptime (in seconds) of the call</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># - param 3: optional - statistic identifier; global is empty string</span>
</span></span><span style=display:flex><span>    $var<span style=color:#f92672>(</span>total_duration<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> $param<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> + $param<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>    update_stat_series<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;avg&#34;</span>, <span style=color:#e6db74>&#34;ACD</span>$param<span style=color:#e6db74>(3)&#34;</span>, $var<span style=color:#f92672>(</span>total_duration<span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span>    update_stat_series<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;10m-avg&#34;</span>, <span style=color:#e6db74>&#34;ACD_10m</span>$param<span style=color:#e6db74>(3)&#34;</span>, $var<span style=color:#f92672>(</span>total_duration<span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span>    update_stat_series<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1h-avg&#34;</span>, <span style=color:#e6db74>&#34;ACD_1h</span>$param<span style=color:#e6db74>(3)&#34;</span>, $var<span style=color:#f92672>(</span>total_duration<span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>And in case of a failure, we update the corresponding statistics:</p><pre tabindex=0><code>event_route[E_ACC_MISSED_EVENT] {
    route(calculate_stats_failure, $param(code), &#34;&#34;);
    route(calculate_stats_failure, $param(code), $param(customer));
}
route[calculate_stats_failure] {
    # expects:
    # - param 1: failure code
    # - param 2: statistic identifier; global is empty string
    update_stat_series(&#34;perc&#34;, &#34;ASR$param(3)&#34;, -1);
    update_stat_series(&#34;10m-perc&#34;, &#34;ASR_10m$param(3)&#34;, -1);
    update_stat_series(&#34;1h-perc&#34;, &#34;ASR_1h$param(3)&#34;, -1);
    if ($param(1) == &#34;486&#34; || $param(1) == &#34;408&#34;) {
        update_stat_series(&#34;perc&#34;, &#34;NER$param(3)&#34;, 1);
        update_stat_series(&#34;10m-perc&#34;, &#34;NER_10m$param(3)&#34;, 1);
        update_stat_series(&#34;1h-perc&#34;, &#34;NER_1h$param(3)&#34;, 1);
    } else {
        update_stat_series(&#34;perc&#34;, &#34;NER$param(3)&#34;, -1);
        update_stat_series(&#34;10m-perc&#34;, &#34;NER_10m$param(3)&#34;, -1);
        update_stat_series(&#34;1h-perc&#34;, &#34;NER_1h$param(3)&#34;, -1);
    }
    if ($(param(1){s.int}) &gt; 499) {
        update_stat_series(&#34;perc&#34;, &#34;CCR$param(3)&#34;, -1);
        update_stat_series(&#34;10m-perc&#34;, &#34;CCR_10m$param(3)&#34;, -1);
        update_stat_series(&#34;1h-perc&#34;, &#34;CCR_1h$param(3)&#34;, -1);
    } else {
        update_stat_series(&#34;perc&#34;, &#34;CCR$param(3)&#34;, 1);
        update_stat_series(&#34;10m-perc&#34;, &#34;CCR_10m$param(3)&#34;, 1);
        update_stat_series(&#34;1h-perc&#34;, &#34;CCR_1h$param(3)&#34;, 1);
    }
}
</code></pre><p>And we are all set – all you have to do is to run traffic through your server, query the statistics (over MI) at your desired pace (such as every minute), and plot them nicely in a graph to improve your monitoring experience .</p><h2 id=possible-enhancements>Possible enhancements<a hidden class=anchor aria-hidden=true href=#possible-enhancements>#</a></h2><p>There is currently no way of persisting these statistics over a restart – this means that every time you restart, the new statistics have to be re-computed, resulting in possible misleading results. In the future, it would be nice if we could provide some sort of persistent storage for them.All statistics are currently local, although it might be possible aggregate values across multiple servers using some scripting + cluster broadcast messages from script. Ideally, we shall implement this in an automatic fashion using the clusterer module.Finally, although there are currently only three algorithms supported (accumulate, percentage and average), more can be added quite easily – we shall do that in future versions.Enjoy your new statistics!</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=wangduanduan/wangduanduan.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxMTkyMjMyNjA=" data-category=Announcements data-category-id=DIC_kwDOBxsz3M4CAjBq data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://wdd.js.org/>洞香春</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>