<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SIP协议拾遗补缺 | 洞香春</title><meta name=keywords content><meta name=description content="1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11."><meta name=author content="Eddie Wang"><link rel=canonical href=https://wdd.js.org/opensips/ch1/sip-notes/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ceab085cbbf58c0ec96f6d415d51b3b44e204edfd71a45b4fa2d4aac13f119d0.css integrity="sha256-zqsIXLv1jA7Jb21BXVGztE4gTt/XGkW0+i1KrBPxGdA=" rel="preload stylesheet" as=style><link crossorigin=anonymous herf=/font-awesome/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=preload href=/cowboy.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=16x16 href=https://wdd.js.org/cowboy.ico><link rel=icon type=image/png sizes=32x32 href=https://wdd.js.org/cowboy.ico><link rel=apple-touch-icon href=https://wdd.js.org/cowboy.ico><link rel=mask-icon href=https://wdd.js.org/cowboy.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.111.3"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SIP协议拾遗补缺"><meta property="og:description" content="1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11."><meta property="og:type" content="article"><meta property="og:url" content="https://wdd.js.org/opensips/ch1/sip-notes/"><meta property="og:image" content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="opensips"><meta property="article:published_time" content="2022-09-03T15:54:57+08:00"><meta property="article:modified_time" content="2022-09-03T15:54:57+08:00"><meta property="og:site_name" content="洞香春"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SIP协议拾遗补缺"><meta name=twitter:description content="1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的
2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求
3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。
5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。
6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。
8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。
9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。
10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"OpenSIPS2.4.X 中文实战系列","item":"https://wdd.js.org/opensips/"},{"@type":"ListItem","position":3,"name":"SIP协议拾遗补缺","item":"https://wdd.js.org/opensips/ch1/sip-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SIP协议拾遗补缺","name":"SIP协议拾遗补缺","description":"1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的\n2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求\n3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。\n5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。\n6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。\n8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。\n9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。\n10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11.","keywords":[],"articleBody":"1. sip协议由request-uri路由，而不是to字段 sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的\n2. 主叫生成callId和from tag, 响应to tag由另一方生成 totag的作用可以用来区分初始化请求和序列化请求\n3. sip消息有哪些头字段是必须的？ Via Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。 From To Call-ID CSeq 4. 被叫在向主叫发消息时，from和to字段为什么没变？ from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。\n5. 为什么所有via头中的branch都以z9hG4bK开头 这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。\n6. sip有两种url, 是什么？有什么区别 用户uri: AOR address of record, 例如from和to字段中的url 设备uri: 例如 contact头 用户uri用来唯一认证用户，设备uri用来唯一认证设备。 用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。 一个用户可能有多个设备 7. sip注册实际上绑定用户url和设备ip地址 我并不能直接联系你，我只能用我的手机拨打你的手机。\n8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？ 重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。\n9. sip 网关是干什么的？ 网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。\n10. sip结构组件 SIP User Agents Presence Agents B2B User Agents SIp Gateways SIP Server 代理服务器 注册服务器 重定向服务器 11. 代理服务器和UA与网关的区别？ 代理服务器没有媒体处理能力 代理服务器不解析消息体，只解析消息头 代理服务器并不分发消息 12. 什么是Forking Proxy? Forking Proxy收到一个INVITE请求，却发出去多个INVITE来呼叫多个UA, 适用于多人会议。 13. SIP url有哪些形式？ 下图是 sip url 参数列表： 比较重要的有\nlr ob transport 14. ACK请求的要点知识 只有INVITE需要ACK确认 2xx响应的ACK由主叫方产生 3xx, 4xx,5xx,6xx的ACK是逐跳的，并且一般是代理服务器产生 15. 可靠性的机制 重传 T1 T2 sip如果使用tcp， 那么tcp是自带重传的，不需要sip再做重传机制。如果使用udp, udp本身是没有可靠性的保证的。那么这就需要应用层去自己实现可靠性。\n请求在发送出去时，会启动定时器 重传在达到64T1, 呼叫宣布失败 16. ACK 消息 Cseq method会怎样改变？ Cseq不变 method变为ACK 主叫方发送ack, 其中ack的CSeq序号和invite保持一致 17. 端到端的ACK和逐跳的ACK有什么区别 对200响应的ACK是端到端的，对非200的ACK是逐跳的 端到端的ACK是一个新的事务，有新的branchId 逐跳的ACK和上一个INVITE请求的branchId一致 当你收到ACK请求时，你要判断这个ACK是应当立即传递到下一跳，还是自己处理 18. 非INVITE请求的重传 消息发送出去时，启动定时器，周期为T1 如果定时器过期，则再启动定时器，周期为2T1, 周期2倍递增，如果周期到达T2, 则以后的重传周期都是T2 如果中间收到了1xx的消息，则计时器立即将周期设置为T2, 并在T2过期时再次重发 19. INVITE请求的重传 请求以2倍之前的周期执行重传 如果收到1xx的响应，则不会再重传 20. 端到端与逐跳的区别 21. cancel消息的特点 cancel是逐跳的 cancel的CSeq和branchId和上一个invite一致 一般的cancel请求处理图 22. Via的特点 请求在传递给下一站时，UA会在在最上面加上自己的Via头。 branch tag来自 from, to, callId, request-url的hash值 大多数sip头的顺序都是不重要的，但是Via的顺序决定了，响应应该送到哪里 如果请求不是来自Via头 23. 24 CSeq CSeq 会持续增长，有可能不会按1递增 同一个事务的CSeq是相同的 ACK的CSeq会和invite一致 ","wordCount":"165","inLanguage":"en","datePublished":"2022-09-03T15:54:57+08:00","dateModified":"2022-09-03T15:54:57+08:00","author":{"@type":"Person","name":"Eddie Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wdd.js.org/opensips/ch1/sip-notes/"},"publisher":{"@type":"Organization","name":"洞香春","logo":{"@type":"ImageObject","url":"https://wdd.js.org/cowboy.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wdd.js.org accesskey=h title="洞香春 (Alt + H)"><img src=/cowboy.ico alt=logo aria-label=logo height=35>洞香春</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wdd.js.org/freeswitch/ title=FreeSWITCH><span>FreeSWITCH</span></a></li><li><a href=https://wdd.js.org/fe/ title=Frontend><span>Frontend</span></a></li><li><a href=https://wdd.js.org/golang/ title=Golang><span>Golang</span></a></li><li><a href=https://wdd.js.org/container/ title=k8s/docker><span>k8s/docker</span></a></li><li><a href=https://wdd.js.org/network/ title=Network><span>Network</span></a></li><li><a href=https://wdd.js.org/opensips/ title=OpenSIPS><span>OpenSIPS</span></a></li><li><a href=https://wdd.js.org/shell/ title=Shell><span>Shell</span></a></li><li><a href=https://wdd.js.org/vim/ title=VIM><span>VIM</span></a></li><li><a href=https://wdd.js.org/categories/ title=分类><span>分类</span></a></li><li><a href=https://wdd.js.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wdd.js.org/tags/ title=标签><span>标签</span></a></li><li><a href=https://wdd.js.org/archives/ title=归档><span>归档</span></a></li><li><a href=https://wdd.js.org/about/ title=我><span>我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wdd.js.org>Home</a>&nbsp;»&nbsp;<a href=https://wdd.js.org/opensips/>OpenSIPS2.4.X 中文实战系列</a></div><h1 class=post-title>SIP协议拾遗补缺</h1><div class=post-meta><span title='2022-09-03 15:54:57 +0800 CST'>2022-09-03 15:54:57</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Eddie Wang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-sip%e5%8d%8f%e8%ae%ae%e7%94%b1request-uri%e8%b7%af%e7%94%b1%e8%80%8c%e4%b8%8d%e6%98%afto%e5%ad%97%e6%ae%b5 aria-label="1. sip协议由request-uri路由，而不是to字段">1. sip协议由request-uri路由，而不是to字段</a></li><li><a href=#2-%e4%b8%bb%e5%8f%ab%e7%94%9f%e6%88%90callid%e5%92%8cfrom-tag-%e5%93%8d%e5%ba%94to-tag%e7%94%b1%e5%8f%a6%e4%b8%80%e6%96%b9%e7%94%9f%e6%88%90 aria-label="2. 主叫生成callId和from tag, 响应to tag由另一方生成">2. 主叫生成callId和from tag, 响应to tag由另一方生成</a></li><li><a href=#3-sip%e6%b6%88%e6%81%af%e6%9c%89%e5%93%aa%e4%ba%9b%e5%a4%b4%e5%ad%97%e6%ae%b5%e6%98%af%e5%bf%85%e9%a1%bb%e7%9a%84 aria-label="3. sip消息有哪些头字段是必须的？">3. sip消息有哪些头字段是必须的？</a></li><li><a href=#4-%e8%a2%ab%e5%8f%ab%e5%9c%a8%e5%90%91%e4%b8%bb%e5%8f%ab%e5%8f%91%e6%b6%88%e6%81%af%e6%97%b6from%e5%92%8cto%e5%ad%97%e6%ae%b5%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b2%a1%e5%8f%98 aria-label="4. 被叫在向主叫发消息时，from和to字段为什么没变？">4. 被叫在向主叫发消息时，from和to字段为什么没变？</a></li><li><a href=#5-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%89%80%e6%9c%89via%e5%a4%b4%e4%b8%ad%e7%9a%84branch%e9%83%bd%e4%bb%a5z9hg4bk%e5%bc%80%e5%a4%b4 aria-label="5. 为什么所有via头中的branch都以z9hG4bK开头">5. 为什么所有via头中的branch都以z9hG4bK开头</a></li><li><a href=#6-sip%e6%9c%89%e4%b8%a4%e7%a7%8durl-%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="6. sip有两种url, 是什么？有什么区别">6. sip有两种url, 是什么？有什么区别</a></li><li><a href=#7-sip%e6%b3%a8%e5%86%8c%e5%ae%9e%e9%99%85%e4%b8%8a%e7%bb%91%e5%ae%9a%e7%94%a8%e6%88%b7url%e5%92%8c%e8%ae%be%e5%a4%87ip%e5%9c%b0%e5%9d%80 aria-label="7. sip注册实际上绑定用户url和设备ip地址">7. sip注册实际上绑定用户url和设备ip地址</a></li><li><a href=#8-%e5%91%bc%e5%8f%ab%e7%bb%93%e6%9d%9f%e4%ba%86%e4%b8%ba%e4%bb%80%e4%b9%88%e5%91%bc%e5%8f%ab%e7%9a%84%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af%e8%bf%98%e9%9c%80%e8%a6%81%e7%bb%b4%e6%8c%81%e4%b8%80%e6%ae%b5%e6%97%b6%e9%97%b4 aria-label="8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？">8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？</a></li><li><a href=#9-sip-%e7%bd%91%e5%85%b3%e6%98%af%e5%b9%b2%e4%bb%80%e4%b9%88%e7%9a%84 aria-label="9. sip 网关是干什么的？">9. sip 网关是干什么的？</a></li><li><a href=#10-sip%e7%bb%93%e6%9e%84%e7%bb%84%e4%bb%b6 aria-label="10. sip结构组件">10. sip结构组件</a></li><li><a href=#11-%e4%bb%a3%e7%90%86%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%92%8cua%e4%b8%8e%e7%bd%91%e5%85%b3%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="11. 代理服务器和UA与网关的区别？">11. 代理服务器和UA与网关的区别？</a></li><li><a href=#12-%e4%bb%80%e4%b9%88%e6%98%afforking-proxy aria-label="12. 什么是Forking Proxy?">12. 什么是Forking Proxy?</a></li><li><a href=#13-sip-url%e6%9c%89%e5%93%aa%e4%ba%9b%e5%bd%a2%e5%bc%8f aria-label="13. SIP url有哪些形式？">13. SIP url有哪些形式？</a></li><li><a href=#14-ack%e8%af%b7%e6%b1%82%e7%9a%84%e8%a6%81%e7%82%b9%e7%9f%a5%e8%af%86 aria-label="14. ACK请求的要点知识">14. ACK请求的要点知识</a></li><li><a href=#15-%e5%8f%af%e9%9d%a0%e6%80%a7%e7%9a%84%e6%9c%ba%e5%88%b6-%e9%87%8d%e4%bc%a0-t1-t2 aria-label="15. 可靠性的机制 重传 T1 T2">15. 可靠性的机制 重传 T1 T2</a></li><li><a href=#16-ack-%e6%b6%88%e6%81%af-cseq-method%e4%bc%9a%e6%80%8e%e6%a0%b7%e6%94%b9%e5%8f%98 aria-label="16. ACK 消息 Cseq method会怎样改变？">16. ACK 消息 Cseq method会怎样改变？</a></li><li><a href=#17-%e7%ab%af%e5%88%b0%e7%ab%af%e7%9a%84ack%e5%92%8c%e9%80%90%e8%b7%b3%e7%9a%84ack%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="17. 端到端的ACK和逐跳的ACK有什么区别">17. 端到端的ACK和逐跳的ACK有什么区别</a></li><li><a href=#18-%e9%9d%9einvite%e8%af%b7%e6%b1%82%e7%9a%84%e9%87%8d%e4%bc%a0 aria-label="18. 非INVITE请求的重传">18. 非INVITE请求的重传</a></li><li><a href=#19-invite%e8%af%b7%e6%b1%82%e7%9a%84%e9%87%8d%e4%bc%a0 aria-label="19. INVITE请求的重传">19. INVITE请求的重传</a></li><li><a href=#20-%e7%ab%af%e5%88%b0%e7%ab%af%e4%b8%8e%e9%80%90%e8%b7%b3%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="20. 端到端与逐跳的区别">20. 端到端与逐跳的区别</a></li><li><a href=#21-cancel%e6%b6%88%e6%81%af%e7%9a%84%e7%89%b9%e7%82%b9 aria-label="21. cancel消息的特点">21. cancel消息的特点</a></li><li><a href=#22-via%e7%9a%84%e7%89%b9%e7%82%b9 aria-label="22. Via的特点">22. Via的特点</a></li><li><a href=#23-24-cseq aria-label="23. 24 CSeq">23. 24 CSeq</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1-sip协议由request-uri路由而不是to字段>1. sip协议由request-uri路由，而不是to字段<a hidden class=anchor aria-hidden=true href=#1-sip协议由request-uri路由而不是to字段>#</a></h1><p>sip消息再经过ua发送出去时，request-uri可能会被重写，而to字段，一般是不变的</p><h1 id=2-主叫生成callid和from-tag-响应to-tag由另一方生成>2. 主叫生成callId和from tag, 响应to tag由另一方生成<a hidden class=anchor aria-hidden=true href=#2-主叫生成callid和from-tag-响应to-tag由另一方生成>#</a></h1><p>totag的作用可以用来区分初始化请求和序列化请求</p><h1 id=3-sip消息有哪些头字段是必须的>3. sip消息有哪些头字段是必须的？<a hidden class=anchor aria-hidden=true href=#3-sip消息有哪些头字段是必须的>#</a></h1><ul><li>Via</li><li>Max-Forwards (请求消息必须有这个头，响应消息一般没有这个头) 感谢 @genmzy 提示。</li><li>From</li><li>To</li><li>Call-ID</li><li>CSeq</li></ul><h1 id=4-被叫在向主叫发消息时from和to字段为什么没变>4. 被叫在向主叫发消息时，from和to字段为什么没变？<a hidden class=anchor aria-hidden=true href=#4-被叫在向主叫发消息时from和to字段为什么没变>#</a></h1><p>from和to字段用来表名sip 请求的方向，而不是sip消息的方向。主叫发起的请求，那么在这个dialog中，所有的sip消息，主叫和被叫字段都不会变。</p><h1 id=5-为什么所有via头中的branch都以z9hg4bk开头>5. 为什么所有via头中的branch都以z9hG4bK开头<a hidden class=anchor aria-hidden=true href=#5-为什么所有via头中的branch都以z9hg4bk开头>#</a></h1><p>这个头是rfc3261中规定的，表示她是经过严格规则生成的，可以用来标记事务。</p><h1 id=6-sip有两种url-是什么有什么区别>6. sip有两种url, 是什么？有什么区别<a hidden class=anchor aria-hidden=true href=#6-sip有两种url-是什么有什么区别>#</a></h1><ul><li>用户uri: AOR address of record, 例如from和to字段中的url</li><li>设备uri: 例如 contact头</li><li>用户uri用来唯一认证用户，设备uri用来唯一认证设备。</li><li>用户uri往往需要查询数据库，而设备uri来自设备自己的网络地址，不需要查询数据库。</li><li>一个用户可能有多个设备</li></ul><h1 id=7-sip注册实际上绑定用户url和设备ip地址>7. sip注册实际上绑定用户url和设备ip地址<a hidden class=anchor aria-hidden=true href=#7-sip注册实际上绑定用户url和设备ip地址>#</a></h1><p>我并不能直接联系你，我只能用我的手机拨打你的手机。</p><p><img loading=lazy src=2022-09-03-15-59-59.png alt></p><h1 id=8-呼叫结束了为什么呼叫的状态信息还需要维持一段时间>8. 呼叫结束了，为什么呼叫的状态信息还需要维持一段时间？<a hidden class=anchor aria-hidden=true href=#8-呼叫结束了为什么呼叫的状态信息还需要维持一段时间>#</a></h1><p>重传的invite消息，可能包含相同的callI和cseq, 为了影响到之后的呼叫，需要耗尽网络中重传的包。</p><h1 id=9-sip-网关是干什么的>9. sip 网关是干什么的？<a hidden class=anchor aria-hidden=true href=#9-sip-网关是干什么的>#</a></h1><p>网关的两侧通信协议是不同的，网关负责将协议翻译成彼此可以理解的协议。sip网关也是如此。电话网络的通信协议不仅仅只有sip， 还有其他的各种信令，如七号信令，ISDN, ISUP, CAS等。</p><p><img loading=lazy src=2022-09-03-16-02-50.png alt></p><h1 id=10-sip结构组件>10. sip结构组件<a hidden class=anchor aria-hidden=true href=#10-sip结构组件>#</a></h1><ul><li>SIP User Agents</li><li>Presence Agents</li><li>B2B User Agents</li><li>SIp Gateways</li><li>SIP Server</li><li>代理服务器</li><li>注册服务器</li><li>重定向服务器</li></ul><h1 id=11-代理服务器和ua与网关的区别>11. 代理服务器和UA与网关的区别？<a hidden class=anchor aria-hidden=true href=#11-代理服务器和ua与网关的区别>#</a></h1><ul><li>代理服务器没有媒体处理能力</li><li>代理服务器不解析消息体，只解析消息头</li><li>代理服务器并不分发消息</li></ul><p><img loading=lazy src=2022-09-03-16-04-11.png alt></p><h1 id=12-什么是forking-proxy>12. 什么是Forking Proxy?<a hidden class=anchor aria-hidden=true href=#12-什么是forking-proxy>#</a></h1><p>Forking Proxy收到一个INVITE请求，却发出去多个INVITE来呼叫多个UA, 适用于多人会议。
<img loading=lazy src=2022-09-03-16-04-38.png alt></p><h1 id=13-sip-url有哪些形式>13. SIP url有哪些形式？<a hidden class=anchor aria-hidden=true href=#13-sip-url有哪些形式>#</a></h1><p>下图是 sip url 参数列表：
比较重要的有</p><ul><li>lr</li><li>ob</li><li>transport
<img loading=lazy src=2022-09-03-16-06-12.png alt></li></ul><h1 id=14-ack请求的要点知识>14. ACK请求的要点知识<a hidden class=anchor aria-hidden=true href=#14-ack请求的要点知识>#</a></h1><ul><li>只有INVITE需要ACK确认</li><li>2xx响应的ACK由主叫方产生</li><li>3xx, 4xx,5xx,6xx的ACK是逐跳的，并且一般是代理服务器产生</li></ul><p><img loading=lazy src=2022-09-03-16-07-30.png alt></p><h1 id=15-可靠性的机制-重传-t1-t2>15. 可靠性的机制 重传 T1 T2<a hidden class=anchor aria-hidden=true href=#15-可靠性的机制-重传-t1-t2>#</a></h1><p>sip如果使用tcp， 那么tcp是自带重传的，不需要sip再做重传机制。如果使用udp, udp本身是没有可靠性的保证的。那么这就需要应用层去自己实现可靠性。</p><ul><li>请求在发送出去时，会启动定时器</li><li>重传在达到64T1, 呼叫宣布失败</li></ul><h1 id=16-ack-消息-cseq-method会怎样改变>16. ACK 消息 Cseq method会怎样改变？<a hidden class=anchor aria-hidden=true href=#16-ack-消息-cseq-method会怎样改变>#</a></h1><ul><li>Cseq不变 method变为ACK</li><li>主叫方发送ack, 其中ack的CSeq序号和invite保持一致</li></ul><h1 id=17-端到端的ack和逐跳的ack有什么区别>17. 端到端的ACK和逐跳的ACK有什么区别<a hidden class=anchor aria-hidden=true href=#17-端到端的ack和逐跳的ack有什么区别>#</a></h1><ul><li>对200响应的ACK是端到端的，对非200的ACK是逐跳的</li><li>端到端的ACK是一个新的事务，有新的branchId</li><li>逐跳的ACK和上一个INVITE请求的branchId一致</li><li>当你收到ACK请求时，你要判断这个ACK是应当立即传递到下一跳，还是自己处理</li></ul><p><img loading=lazy src=2022-09-03-16-08-58.png alt></p><h1 id=18-非invite请求的重传>18. 非INVITE请求的重传<a hidden class=anchor aria-hidden=true href=#18-非invite请求的重传>#</a></h1><ul><li>消息发送出去时，启动定时器，周期为T1</li><li>如果定时器过期，则再启动定时器，周期为2T1, 周期2倍递增，如果周期到达T2, 则以后的重传周期都是T2</li><li>如果中间收到了1xx的消息，则计时器立即将周期设置为T2, 并在T2过期时再次重发</li></ul><p><img loading=lazy src=2022-09-03-16-09-17.png alt></p><h1 id=19-invite请求的重传>19. INVITE请求的重传<a hidden class=anchor aria-hidden=true href=#19-invite请求的重传>#</a></h1><ul><li>请求以2倍之前的周期执行重传</li><li>如果收到1xx的响应，则不会再重传</li></ul><p><img loading=lazy src=2022-09-03-16-09-46.png alt></p><h1 id=20-端到端与逐跳的区别>20. 端到端与逐跳的区别<a hidden class=anchor aria-hidden=true href=#20-端到端与逐跳的区别>#</a></h1><p><img loading=lazy src=2022-09-03-16-10-11.png alt></p><h1 id=21-cancel消息的特点>21. cancel消息的特点<a hidden class=anchor aria-hidden=true href=#21-cancel消息的特点>#</a></h1><ul><li>cancel是逐跳的</li><li>cancel的CSeq和branchId和上一个invite一致
一般的cancel请求处理图</li></ul><p><img loading=lazy src=2022-09-03-16-19-38.png alt></p><h1 id=22-via的特点>22. Via的特点<a hidden class=anchor aria-hidden=true href=#22-via的特点>#</a></h1><ul><li>请求在传递给下一站时，UA会在在最上面加上自己的Via头。</li><li>branch tag来自 from, to, callId, request-url的hash值</li><li>大多数sip头的顺序都是不重要的，但是Via的顺序决定了，响应应该送到哪里</li><li>如果请求不是来自Via头</li></ul><h1 id=23-24-cseq>23. 24 CSeq<a hidden class=anchor aria-hidden=true href=#23-24-cseq>#</a></h1><ul><li>CSeq 会持续增长，有可能不会按1递增</li><li>同一个事务的CSeq是相同的</li><li>ACK的CSeq会和invite一致</li></ul><p><img loading=lazy src=2022-09-03-16-20-18.png alt></p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wdd.js.org>洞香春</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>