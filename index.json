[{"content":"1. 使用摘要 一个命令的使用摘要非常重要，摘要里包含了这个工具最常用的用法。\n要注意的是，如果要用过滤器，一定要放到最后。\ntshark [ -i \u0026lt;capture interface\u0026gt;|- ] [ -f \u0026lt;capture filter\u0026gt; ] [ -2 ] [ -r \u0026lt;infile\u0026gt; ] [ -w \u0026lt;outfile\u0026gt;|- ] [ options ] [ \u0026lt;filter\u0026gt; ] tshark -G [ \u0026lt;report type\u0026gt; ] [ --elastic-mapping-filter \u0026lt;protocols\u0026gt; ] 2. 为什么要学习tshark? 一般情况下，我们可能会在服务端用tcpdump抓包，然后把包拿下来，用wireshark分析。那么我们为什么要学习tshark呢？\n相比于wireshark， tshark有以下的优点\n速度飞快：wireshark在加载包的时候，tshark可能已经给出了结果。 更稳定：wireshark在处理包的时候，常常容易崩溃 更适合做文本处理：tshark的输出是文本，这个文本很容易被awk, sort, uniq等等命令处理 但是我不建议上来就学习，更建议在熟悉wireshark之后，再去进一步学习tshark\n3. 使用场景 3.1 基本场景 用wireshark最基本的场景的把pcap文件拖动到wireshark中，然后可能加入一些过滤条件。\ntshark -r demo.pcap tshark -r demo.pcap -c 1 # 只读一个包就停止 输出的列分别为：序号，相对时间，绝对时间，源ip, 源端口，目标ip, 目标端口\n3.2 按照表格输出 tshark -r demo.pcap -T tabs 3.3 按照指定的列输出 例如，抓的的sip的包，我们只想输出sip的user-agent字段。\ntshark -r demo.pcap -Tfields -e sip.User-Agent sip and sip.Method==REGISTER 按照上面的输出，我们可以用简单的sort和seq就可以把所有的设备类型打印出来。\n3.4 过滤之后写入文件 比如一个很大的pcap文件，我们可以用tshark过滤之后，写入一个新的文件。\n例如下面的，我们使用过滤器sip and sip.Method==REGISTER, 然后把过滤后的包写入到register.pcap\n● -Y \u0026ldquo;sip and frame.cap_len \u0026gt; 1300\u0026rdquo; 查看比较大的SIP包 tshark -r demo.pcap -w register.pcap sip and sip.Method==REGISTER\n3.4 统计分析 tshark支持统计分析，例如统计rtp 丢包率。\ntshark -r demo.pcap -qn -z rtp,streams -z参数是用来各种统计分析的，具体支持的统计类型，可以用\ntshark -z help ➜ Desktop tshark -z help afp,srt ancp,tree ansi_a,bsmap ansi_a,dtap ansi_map asap,stat bacapp_instanceid,tree bacapp_ip,tree bacapp_objectid,tree bacapp_service,tree calcappprotocol,stat camel,counter camel,srt collectd,tree componentstatusprotocol,stat conv,bluetooth conv,dccp conv,eth conv,fc 参考 https://www.wireshark.org/docs/man-pages/tshark.html ","permalink":"https://wdd.js.org/network/tshark/","summary":"1. 使用摘要 一个命令的使用摘要非常重要，摘要里包含了这个工具最常用的用法。\n要注意的是，如果要用过滤器，一定要放到最后。\ntshark [ -i \u0026lt;capture interface\u0026gt;|- ] [ -f \u0026lt;capture filter\u0026gt; ] [ -2 ] [ -r \u0026lt;infile\u0026gt; ] [ -w \u0026lt;outfile\u0026gt;|- ] [ options ] [ \u0026lt;filter\u0026gt; ] tshark -G [ \u0026lt;report type\u0026gt; ] [ --elastic-mapping-filter \u0026lt;protocols\u0026gt; ] 2. 为什么要学习tshark? 一般情况下，我们可能会在服务端用tcpdump抓包，然后把包拿下来，用wireshark分析。那么我们为什么要学习tshark呢？\n相比于wireshark， tshark有以下的优点\n速度飞快：wireshark在加载包的时候，tshark可能已经给出了结果。 更稳定：wireshark在处理包的时候，常常容易崩溃 更适合做文本处理：tshark的输出是文本，这个文本很容易被awk, sort, uniq等等命令处理 但是我不建议上来就学习，更建议在熟悉wireshark之后，再去进一步学习tshark\n3. 使用场景 3.1 基本场景 用wireshark最基本的场景的把pcap文件拖动到wireshark中，然后可能加入一些过滤条件。\ntshark -r demo.pcap tshark -r demo.pcap -c 1 # 只读一个包就停止 输出的列分别为：序号，相对时间，绝对时间，源ip, 源端口，目标ip, 目标端口","title":"Tshark入门到精通"},{"content":"在服务端抓包，然后在wireshark上分析，发现wireshark提示：udp checksum字段有问题\nchecksum 0x\u0026hellip; incrorect should be 0x.. (maybe caused by udp checksum offload)\n以前我从未遇到过udp checksum的问题。所以这次是第一次遇到，所以需要学习一下。 首先udp checksum是什么？\n我们看下udp的协议组成的字段，其中就有16位的校验和\n校验和一般都是为了检验数据包在传输过程中是否出现变动的。\n如果接受端收到的udp消息校验和错误，将会被悄悄的丢弃 udp校验和是一个端到端的校验和。端到端意味它不会在中间网络设备上校验。 校验和由发送方负责计算，接收端负责验证。目的是为了发现udp首部和和数据在发送端和接受端之间是否发生了变动 udp校验和是可选的功能，但是总是应该被默认启用。 如果发送方设置了udp校验和，则接受方必须验证 发送方负责计算？具体是谁负责计算\n计算一般都是CPU的工作，但是有些网卡也是支持checksum offload的。\n所谓offload, 是指本来可以由cpu计算的，改变由网卡硬件负责计算。 这样做有很多好处，\n可以降低cpu的负载，提高系统的性能 网卡的硬件checksum, 效率更高 为什么只有发送方出现udp checksum 错误？ 我在接受方和放松方都进行了抓包，一个比较特殊的特征是，只有发送方发现了udp checksum的错误，在接受方，同样的包，udp checksum的值却是正确的。\n一句话的解释：tcpdump在接收方抓到的包，本身checksum字段还没有被计算，在后续的步骤，这个包才会被交给NIC, NIC来负责计算。\n结论 maybe caused by udp checksum offload 这个报错并没有什么问题。\n参考 ● 《tcp/ip 详解》 ● https://www.kernel.org/doc/html/latest/networking/checksum-offloads.html ● https://dominikrys.com/posts/disable-udp-checksum-validation/ ● https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/\n","permalink":"https://wdd.js.org/network/udp-checksum-offload/","summary":"在服务端抓包，然后在wireshark上分析，发现wireshark提示：udp checksum字段有问题\nchecksum 0x\u0026hellip; incrorect should be 0x.. (maybe caused by udp checksum offload)\n以前我从未遇到过udp checksum的问题。所以这次是第一次遇到，所以需要学习一下。 首先udp checksum是什么？\n我们看下udp的协议组成的字段，其中就有16位的校验和\n校验和一般都是为了检验数据包在传输过程中是否出现变动的。\n如果接受端收到的udp消息校验和错误，将会被悄悄的丢弃 udp校验和是一个端到端的校验和。端到端意味它不会在中间网络设备上校验。 校验和由发送方负责计算，接收端负责验证。目的是为了发现udp首部和和数据在发送端和接受端之间是否发生了变动 udp校验和是可选的功能，但是总是应该被默认启用。 如果发送方设置了udp校验和，则接受方必须验证 发送方负责计算？具体是谁负责计算\n计算一般都是CPU的工作，但是有些网卡也是支持checksum offload的。\n所谓offload, 是指本来可以由cpu计算的，改变由网卡硬件负责计算。 这样做有很多好处，\n可以降低cpu的负载，提高系统的性能 网卡的硬件checksum, 效率更高 为什么只有发送方出现udp checksum 错误？ 我在接受方和放松方都进行了抓包，一个比较特殊的特征是，只有发送方发现了udp checksum的错误，在接受方，同样的包，udp checksum的值却是正确的。\n一句话的解释：tcpdump在接收方抓到的包，本身checksum字段还没有被计算，在后续的步骤，这个包才会被交给NIC, NIC来负责计算。\n结论 maybe caused by udp checksum offload 这个报错并没有什么问题。\n参考 ● 《tcp/ip 详解》 ● https://www.kernel.org/doc/html/latest/networking/checksum-offloads.html ● https://dominikrys.com/posts/disable-udp-checksum-validation/ ● https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/","title":"Udp Checksum Offload"},{"content":"大多数时候我们都是图形界面的方式使用wireshak, 其实一般只要你安装了wireshark，同时也附带安装了一些命令行工具。 这些工具也可以极大的提高生产效率。 本文只是对工具的功能简介，可以使用命令 -h, 查看命令的具体使用文档。\n1. editcap 编辑抓包文件 Editcap (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Edit and/or translate the format of capture files. 举例: 按照时间范围从input.pcap文件中拿出指定时间范围的包\neditcap -A \u0026#39;2014-12-10 10:11:01\u0026#39; -B \u0026#39;2014-12-10 10:21:01\u0026#39; input.pcap output.pcap 2. androiddump 这个命令似乎可以用来对安卓系统进行抓包，没玩过安卓，不再多说。\nWireshark - androiddump v1.1.0 Usage: androiddump --extcap-interfaces [--adb-server-ip=\u0026lt;arg\u0026gt;] [--adb-server-tcp-port=\u0026lt;arg\u0026gt;] androiddump --extcap-interface=INTERFACE --extcap-dlts androiddump --extcap-interface=INTERFACE --extcap-config androiddump --extcap-interface=INTERFACE --fifo=PATH_FILENAME --capture 3. ciscodump 似乎是对思科的网络进行抓包的，没用过 Wireshark - ciscodump v1.0.0 Usage: ciscodump \u0026ndash;extcap-interfaces ciscodump \u0026ndash;extcap-interface=ciscodump \u0026ndash;extcap-dlts ciscodump \u0026ndash;extcap-interface=ciscodump \u0026ndash;extcap-config ciscodump \u0026ndash;extcap-interface=ciscodump \u0026ndash;remote-host myhost \u0026ndash;remote-port 22222 \u0026ndash;remote-username myuser \u0026ndash;remote-interface gigabit0/0 \u0026ndash;fifo=FILENAME \u0026ndash;capture\n4. randpktdump 这个似乎也是一个网络抓包的 Wireshark - randpktdump v0.1.0 Usage: randpktdump \u0026ndash;extcap-interfaces randpktdump \u0026ndash;extcap-interface=randpkt \u0026ndash;extcap-dlts randpktdump \u0026ndash;extcap-interface=randpkt \u0026ndash;extcap-config randpktdump \u0026ndash;extcap-interface=randpkt \u0026ndash;type dns \u0026ndash;count 10 \u0026ndash;fifo=FILENAME \u0026ndash;capture\n5. sshdump 这个应该是对ssh进行抓包的 Wireshark - sshdump v1.0.0 Usage: sshdump \u0026ndash;extcap-interfaces sshdump \u0026ndash;extcap-interface=sshdump \u0026ndash;extcap-dlts sshdump \u0026ndash;extcap-interface=sshdump \u0026ndash;extcap-config sshdump \u0026ndash;extcap-interface=sshdump \u0026ndash;remote-host myhost \u0026ndash;remote-port 22222 \u0026ndash;remote-username myuser \u0026ndash;remote-interface eth2 \u0026ndash;remote-capture-command \u0026rsquo;tcpdump -U -i eth0 -w -\u0026rsquo; \u0026ndash;fifo=FILENAME \u0026ndash;capture\n6. idl2wrs 7. mergecap 合并多个抓包文件 mergecap -w output.pcap input1.pcap input2.pcap input3.pcap\n8. mmdbresolve 9. randpkt 10. rawshark 11. reordercap Reordercap (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Reorder timestamps of input file frames into output file. See https://www.wireshark.org for more information. Usage: reordercap [options] Options: -n don\u0026rsquo;t write to output file if the input file is ordered. -h display this help and exit. -v print version information and exit.\n12. sharkd Usage: sharkd [\u0026lt;classic_options\u0026gt;|\u0026lt;gold_options\u0026gt;] Classic (classic_options): [-|] examples:\nunix:/tmp/sharkd.sock - listen on unix file /tmp/sharkd.sock Gold (gold_options): -a , \u0026ndash;api listen on this socket -h, \u0026ndash;help show this help information -v, \u0026ndash;version show version information -C , \u0026ndash;config-profile start with specified configuration profile Examples: sharkd -C myprofile sharkd -a tcp:127.0.0.1:4446 -C myprofile See the sharkd page of the Wireshark wiki for full details. 13. text2pcap Text2pcap (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Generate a capture file from an ASCII hexdump of packets. See https://www.wireshark.org for more information. Usage: text2pcap [options] where specifies input filename (use - for standard input) specifies output filename (use - for standard output)\n14. tshark 命令行版本的wireshark, 用的最多的 TShark (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Dump and analyze network traffic. See https://www.wireshark.org for more information.\n15. udpdump Wireshark - udpdump v0.1.0 Usage: udpdump \u0026ndash;extcap-interfaces udpdump \u0026ndash;extcap-interface=udpdump \u0026ndash;extcap-dlts udpdump \u0026ndash;extcap-interface=udpdump \u0026ndash;extcap-config udpdump \u0026ndash;extcap-interface=udpdump \u0026ndash;port 5555 \u0026ndash;fifo myfifo \u0026ndash;capture Options: \u0026ndash;extcap-interfaces: list the extcap Interfaces \u0026ndash;extcap-dlts: list the DLTs \u0026ndash;extcap-interface : specify the extcap interface \u0026ndash;extcap-config: list the additional configuration for an interface \u0026ndash;capture: run the capture \u0026ndash;extcap-capture-filter : the capture filter \u0026ndash;fifo : dump data to file or fifo \u0026ndash;extcap-version: print tool version \u0026ndash;debug: print additional messages \u0026ndash;debug-file: print debug messages to file \u0026ndash;help: print this help \u0026ndash;version: print the version \u0026ndash;port : the port to listens on. Default: 5555\n16. capinfos 打印出包的各种信息 Capinfos (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Print various information (infos) about capture files. See https://www.wireshark.org for more information. Usage: capinfos [options] \u0026hellip; General infos: -t display the capture file type -E display the capture file encapsulation -I display the capture file interface information -F display additional capture file information -H display the SHA256, RIPEMD160, and SHA1 hashes of the file -k display the capture comment\n17. captype Captype (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Print the file types of capture files.\n18. dftest ➜ ~ dftest \u0026ndash;help\nFilter: \u0026ndash;help\n19. dumpcap See https://www.wireshark.org for more information.\n","permalink":"https://wdd.js.org/network/wireshark-extra-cli/","summary":"大多数时候我们都是图形界面的方式使用wireshak, 其实一般只要你安装了wireshark，同时也附带安装了一些命令行工具。 这些工具也可以极大的提高生产效率。 本文只是对工具的功能简介，可以使用命令 -h, 查看命令的具体使用文档。\n1. editcap 编辑抓包文件 Editcap (Wireshark) 3.6.1 (v3.6.1-0-ga0a473c7c1ba) Edit and/or translate the format of capture files. 举例: 按照时间范围从input.pcap文件中拿出指定时间范围的包\neditcap -A \u0026#39;2014-12-10 10:11:01\u0026#39; -B \u0026#39;2014-12-10 10:21:01\u0026#39; input.pcap output.pcap 2. androiddump 这个命令似乎可以用来对安卓系统进行抓包，没玩过安卓，不再多说。\nWireshark - androiddump v1.1.0 Usage: androiddump --extcap-interfaces [--adb-server-ip=\u0026lt;arg\u0026gt;] [--adb-server-tcp-port=\u0026lt;arg\u0026gt;] androiddump --extcap-interface=INTERFACE --extcap-dlts androiddump --extcap-interface=INTERFACE --extcap-config androiddump --extcap-interface=INTERFACE --fifo=PATH_FILENAME --capture 3. ciscodump 似乎是对思科的网络进行抓包的，没用过 Wireshark - ciscodump v1.0.0 Usage: ciscodump \u0026ndash;extcap-interfaces ciscodump \u0026ndash;extcap-interface=ciscodump \u0026ndash;extcap-dlts ciscodump \u0026ndash;extcap-interface=ciscodump \u0026ndash;extcap-config ciscodump \u0026ndash;extcap-interface=ciscodump \u0026ndash;remote-host myhost \u0026ndash;remote-port 22222 \u0026ndash;remote-username myuser \u0026ndash;remote-interface gigabit0/0 \u0026ndash;fifo=FILENAME \u0026ndash;capture","title":"Wireshark 附带的19命令行程序"},{"content":"问题现象 主机上有两个网卡ens192和ens224。ens129网卡是对内网络的网卡，ens224是对网网络的网卡。\nSIP信令阶段都是正常的，但是发现，对于来自node3的RTP流， 并没有从ens192网卡转发给node1上。\nsequenceDiagram title network autonumber node1-\u003e\u003eens192: INVITE ens224-\u003e\u003enode2: INVITE node2-\u003e\u003eens224: 200 ok ens192-\u003e\u003enode1: 200 ok node1-\u003e\u003eens192: ACK ens224-\u003e\u003enode2: ACK node1--\u003e\u003eens192: RTP out ens224--\u003e\u003enode3: RTP out node3--\u003e\u003eens224: RTP in 抓包程序抓到了node3发送到ens224上的包，但是排查应用服务器的日志发现，似乎应用服务器根本没有收到node3上过来的包, 所以也就无法转发。\n因而怀疑是不是在内核上被拦截了。 后来通过将rp_filter设置为0, 然后语音流的转发就正常了。\n事后复盘 node3的这个IP直接往应用服务器上发包，可能会被拦截。因为在信令建立的阶段，应用服务器并没有主动发\n在kernel文档上 rp_filter - INTEGER 0 - No source validation. 1 - Strict mode as defined in RFC3704 Strict Reverse Path Each incoming packet is tested against the FIB and if the interface is not the best reverse path the packet check will fail. By default failed packets are discarded. 2 - Loose mode as defined in RFC3704 Loose Reverse Path Each incoming packet\u0026#39;s source address is also tested against the FIB and if the source address is not reachable via any interface the packet check will fail. Current recommended practice in RFC3704 is to enable strict mode to prevent IP spoofing from DDos attacks. If using asymmetric routing or other complicated routing, then loose mode is recommended. The max value from conf/{all,interface}/rp_filter is used when doing source validation on the {interface}. Default value is 0. Note that some distributions enable it in startup scripts. 参考 https://www.jianshu.com/p/717e6cd9d2bb https://www.jianshu.com/p/16d5c130670b https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt ","permalink":"https://wdd.js.org/network/rp_filter/","summary":"问题现象 主机上有两个网卡ens192和ens224。ens129网卡是对内网络的网卡，ens224是对网网络的网卡。\nSIP信令阶段都是正常的，但是发现，对于来自node3的RTP流， 并没有从ens192网卡转发给node1上。\nsequenceDiagram title network autonumber node1-\u003e\u003eens192: INVITE ens224-\u003e\u003enode2: INVITE node2-\u003e\u003eens224: 200 ok ens192-\u003e\u003enode1: 200 ok node1-\u003e\u003eens192: ACK ens224-\u003e\u003enode2: ACK node1--\u003e\u003eens192: RTP out ens224--\u003e\u003enode3: RTP out node3--\u003e\u003eens224: RTP in 抓包程序抓到了node3发送到ens224上的包，但是排查应用服务器的日志发现，似乎应用服务器根本没有收到node3上过来的包, 所以也就无法转发。\n因而怀疑是不是在内核上被拦截了。 后来通过将rp_filter设置为0, 然后语音流的转发就正常了。\n事后复盘 node3的这个IP直接往应用服务器上发包，可能会被拦截。因为在信令建立的阶段，应用服务器并没有主动发\n在kernel文档上 rp_filter - INTEGER 0 - No source validation. 1 - Strict mode as defined in RFC3704 Strict Reverse Path Each incoming packet is tested against the FIB and if the interface is not the best reverse path the packet check will fail.","title":"Linux内核参数rp_filter"},{"content":"1. grep 常用参数 参考： GNU Grep 3.0\n--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log \u0026gt; error.log 4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log 5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log 6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log 7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log 8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E \u0026#39;ERROR|DEBUG\u0026#39; trace.log 9. 多文件：从多个.log文件中搜索含有ERROR的日志 grep ERROR *.log 10. 省略文件名：从多个.log文件中搜索ERROR字段日志，并不显示日志文件名 从多个文件中搜索的日志默认每行会带有日志文件名\ngrep -h ERROR *.log 11. 时间范围： 按照时间范围搜索日志 awk \u0026#39;$2\u0026gt;\u0026#34;17:30:00\u0026#34; \u0026amp;\u0026amp; $2\u0026lt;\u0026#34;18:00:00\u0026#34;\u0026#39; trace.log 日志形式如下, $2代表第二列即11:44:58, awk需要指定列\n11-21 16:44:58 /user/info/\n12. 有没有：搜索到第一个匹配行后就停止搜索 grep -m 1 ERROR trace.log 13. 使用正则提取字符串 grep -Eo \u0026#39;cause\u0026#34;:\u0026#34;(.*?)\u0026#34;\u0026#39; test.log cause\u0026#34;:\u0026#34;A\u0026#34; cause\u0026#34;:\u0026#34;B\u0026#34; cause\u0026#34;:\u0026#34;A\u0026#34; cause\u0026#34;:\u0026#34;A\u0026#34; cause\u0026#34;:\u0026#34;A\u0026#34; 如果相对提取字符串的结果进行按照出现的次数进行排序，可以使用sort, uniq命令 grep -Eo \u0026lsquo;cause\u0026quot;:\u0026quot;(.*?)\u0026quot;\u0026rsquo; test.log | sort | uniq -c | sort -k1,1 -n\n步骤分解\nsort 对结果进行排序 uniq -c 对结果进行去重并统计出现次数 sort -k1,1 -n 按照第一列的结果，进行数值大小排序 ","permalink":"https://wdd.js.org/shell/grep-docs/","summary":"1. grep 常用参数 参考： GNU Grep 3.0\n--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log \u0026gt; error.log 4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log 5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log 6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log 7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log 8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E \u0026#39;ERROR|DEBUG\u0026#39; trace.","title":"grep常用参考"},{"content":"shell 自动化测试 https://github.com/bats-core/bats-core shell精进 https://github.com/NARKOZ/hacker-scripts https://github.com/trimstray/the-book-of-secret-knowledge https://legacy.gitbook.com/book/learnbyexample/command-line-text-processing https://github.com/dylanaraps/pure-bash-bible https://github.com/dylanaraps/pure-sh-bible https://github.com/Idnan/bash-guide https://github.com/denysdovhan/bash-handbook https://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html https://github.com/jlevy/the-art-of-command-line https://google.github.io/styleguide/shell.xml https://wiki.bash-hackers.org/start https://linuxguideandhints.com/ 安全加固 https://www.lisenet.com/2017/centos-7-server-hardening-guide/ https://highon.coffee/blog/security-harden-centos-7/ https://github.com/trimstray/the-practical-linux-hardening-guide https://github.com/decalage2/awesome-security-hardening https://www.hackingarticles.in/ https://github.com/toniblyx/my-arsenal-of-aws-security-tools ","permalink":"https://wdd.js.org/shell/star-collect/","summary":"shell 自动化测试 https://github.com/bats-core/bats-core shell精进 https://github.com/NARKOZ/hacker-scripts https://github.com/trimstray/the-book-of-secret-knowledge https://legacy.gitbook.com/book/learnbyexample/command-line-text-processing https://github.com/dylanaraps/pure-bash-bible https://github.com/dylanaraps/pure-sh-bible https://github.com/Idnan/bash-guide https://github.com/denysdovhan/bash-handbook https://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html https://github.com/jlevy/the-art-of-command-line https://google.github.io/styleguide/shell.xml https://wiki.bash-hackers.org/start https://linuxguideandhints.com/ 安全加固 https://www.lisenet.com/2017/centos-7-server-hardening-guide/ https://highon.coffee/blog/security-harden-centos-7/ https://github.com/trimstray/the-practical-linux-hardening-guide https://github.com/decalage2/awesome-security-hardening https://www.hackingarticles.in/ https://github.com/toniblyx/my-arsenal-of-aws-security-tools ","title":"Shell 书籍和资料收藏"},{"content":"人声检测 VAD 人声检测(VAD: Voice Activity Detection)是区分语音中是人说话的声音，还是其他例如环境音的一种功能。\n除此以外，人声检测还能用于减少网络中语音包传输的数据量，从而极大的降低语音的带宽，极限情况下能降低50%的带宽。\n在一个通话中，一般都是只有一个人说话，另一人听。很少可能是两个人都说话的。\n例如A在说话的时候，B可能在等待。\n虽然B在等待过程中，B的语音流依然再按照原始速度和编码再发给A, 即使这里面是环境噪音或者是无声。\nA ----\u0026gt; B # A在说话 A \u0026lt;--- B # B在等待过程中，B的语音流依然再按照原始速度和编码再发给A 如果B具有VAD检测功能，那么B就可以在不说话的时候，发送特殊标记的语音流或者通过减少语音流发送的频率，来减少无意义语音的发送。\n从而极大的降低B-\u0026gt;A的语音流。\n下图是Wireshark抓包的两种RTP包，g711编码的占214字节，但是用舒适噪音编码的只有63字节。将近减少了4倍的带宽。\n舒适噪音生成器 CNG 舒适噪音(CN stands for Comfort Noise), 是一种模拟的背景环境音。舒适噪音生成器在接收端根据发送到给的参数，来产生类似接收端的舒适噪音, 用来模拟发送方的噪音环境。\nCN也是一种RTP包的格式，定义在RFC 3389\n舒适噪音的payload, 也被称作静音插入描述帧(SID: a Silence Insertion Descriptor frame), 包括一个字节的数据，用来描述噪音的级别。也可以包含其他的额外的数据。早期版本的舒适噪音的格式定义在RFC 1890中，这个版本的格式只包含一个字段，就是噪音级别。\n噪音级别占用一个字节，其中第一个bit必须是0， 因此噪音级别有127中可能。\n0 1 2 3 4 5 6 7 +-+-+-+-+-+-+-+-+ |0| level | +-+-+-+-+-+-+-+-+ 跟着噪音级别的后续字节都是声音的频谱信息。\nByte 1 2 3 ... M+1 +-----+-----+-----+-----+-----+ |level| N1 | N2 | ... | NM | +-----+-----+-----+-----+-----+ Figure 2: CN Payload Packing Format 在SIP INVITE的SDP中也可以看到编码，如下面的CN\nm=audio 20000 RTP/AVP 8 111 63 103 104 9 0 106 105 13 110 112 113 126 a=rtpmap:106 CN/32000 a=rtpmap:105 CN/16000 a=rtpmap:13 CN/8000 当VAD函数检测到没有人声时，就会发送舒适噪音。通常来说，只有当环境噪音发生变化的时候，才需要发送CN包。接收方在收到新的CN包后，会更新产生舒适噪音的参数。\n比如下图是sngrep抓包关于webrtc的呼叫时，就能看到浏览器送到SIP Server的CN包。\n│ \u0026lt;────────────────────────────────────────────────── RTP (g711a) 130 ───────────────────── │ ──────────────────────────────────── RTP (g711a) 130 ─────────────────────────────────\u0026gt; │ │ ────────────────────────────────────────────────── RTP (g711a) 1168 ───────────────────── │ \u0026lt;\u0026lt;\u0026lt;──── 200 OK (SDP) ────── │ │ │ │ ────────────────────── 200 OK (SDP) ──────────────────\u0026gt;\u0026gt;\u0026gt; │ │ │ ──────────── ACK ─────────\u0026gt; │ │ │ │ \u0026lt;────────────────────────── ACK ───────────────────────── │ │ │ ──────────── ACK ─────────\u0026gt; │ │ │ │ \u0026lt;────────── INFO ────────── │ │ │ │ ────────────────────────── INFO ────────────────────────\u0026gt; │ │ │ \u0026lt;──────────────────────── 200 OK ──────────────────────── │ │ │ ────────── 200 OK ────────\u0026gt; │ │ │ │ \u0026lt;─────────────────────────────────────────────────── RTP (cn) 208 ─────────────────────── │ ───────────────────────────────────── RTP (cn) 208 ───────────────────────────────────\u0026gt; │ │ \u0026lt;────────────────────────── BYE ───────────────────────── │ │ FreeSWITCH WebRTC 录音质量差 FreeSWITCH bridge两个call leg, 一侧是WebRTC一侧是普通SIP终端，在录音的时候发现录音卡顿基本没办法听，但是双发通话的语音是正常的。\n最终发现录音质量差和舒适噪音有关。\n方案1: 全局抑制舒适噪音\n\u0026lt;!-- Video Settings --\u0026gt; \u0026lt;!-- Setting the max bandwdith --\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;rtp_video_max_bandwidth_in=3mb\u0026#34;/\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;rtp_video_max_bandwidth_out=3mb\u0026#34;/\u0026gt; \u0026lt;!-- WebRTC Video --\u0026gt; \u0026lt;!-- Suppress CNG for WebRTC Audio --\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;suppress_cng=true\u0026#34;/\u0026gt; \u0026lt;!-- Enable liberal DTMF for those that can\u0026#39;t get it right --\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;rtp_liberal_dtmf=true\u0026#34;/\u0026gt; \u0026lt;!-- Helps with WebRTC Audio --\u0026gt; \u0026lt;!-- Stock Video Avatars --\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;video_mute_png=$${images_dir}/default-mute.png\u0026#34;/\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;video_no_avatar_png=$${images_dir}/default-avatar.png\u0026#34;/\u0026gt; 方案2: 在Bleg抑制舒适噪音\n\u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;bridge_generate_comfort_noise=true\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;bridge\u0026#34; data=\u0026#34;sofia/user/1000\u0026#34;/\u0026gt; 参考 https://freeswitch.org/confluence/display/FREESWITCH/VAD+and+CNG https://www.rfc-editor.org/rfc/rfc3389 https://www.rfc-editor.org/rfc/rfc1890 https://freeswitch.org/confluence/display/FREESWITCH/Sofia+Configuration+Files#SofiaConfigurationFiles-suppress-cng https://freeswitch.org/confluence/display/FREESWITCH/bridge_generate_comfort_noise ","permalink":"https://wdd.js.org/freeswitch/webrtc-vad-cng/","summary":"人声检测 VAD 人声检测(VAD: Voice Activity Detection)是区分语音中是人说话的声音，还是其他例如环境音的一种功能。\n除此以外，人声检测还能用于减少网络中语音包传输的数据量，从而极大的降低语音的带宽，极限情况下能降低50%的带宽。\n在一个通话中，一般都是只有一个人说话，另一人听。很少可能是两个人都说话的。\n例如A在说话的时候，B可能在等待。\n虽然B在等待过程中，B的语音流依然再按照原始速度和编码再发给A, 即使这里面是环境噪音或者是无声。\nA ----\u0026gt; B # A在说话 A \u0026lt;--- B # B在等待过程中，B的语音流依然再按照原始速度和编码再发给A 如果B具有VAD检测功能，那么B就可以在不说话的时候，发送特殊标记的语音流或者通过减少语音流发送的频率，来减少无意义语音的发送。\n从而极大的降低B-\u0026gt;A的语音流。\n下图是Wireshark抓包的两种RTP包，g711编码的占214字节，但是用舒适噪音编码的只有63字节。将近减少了4倍的带宽。\n舒适噪音生成器 CNG 舒适噪音(CN stands for Comfort Noise), 是一种模拟的背景环境音。舒适噪音生成器在接收端根据发送到给的参数，来产生类似接收端的舒适噪音, 用来模拟发送方的噪音环境。\nCN也是一种RTP包的格式，定义在RFC 3389\n舒适噪音的payload, 也被称作静音插入描述帧(SID: a Silence Insertion Descriptor frame), 包括一个字节的数据，用来描述噪音的级别。也可以包含其他的额外的数据。早期版本的舒适噪音的格式定义在RFC 1890中，这个版本的格式只包含一个字段，就是噪音级别。\n噪音级别占用一个字节，其中第一个bit必须是0， 因此噪音级别有127中可能。\n0 1 2 3 4 5 6 7 +-+-+-+-+-+-+-+-+ |0| level | +-+-+-+-+-+-+-+-+ 跟着噪音级别的后续字节都是声音的频谱信息。\nByte 1 2 3 ... M+1 +-----+-----+-----+-----+-----+ |level| N1 | N2 | .","title":"WebRTC 人声检测与舒适噪音"},{"content":"暴露的变量必须用var定义，不能用const定义\n// main.go var VERSION = \u0026#34;unknow\u0026#34; var SHA = \u0026#34;unknow\u0026#34; var BUILD_TIME = \u0026#34;unknow\u0026#34; ... func main () { app := \u0026amp;cli.App{ Version: VERSION + \u0026#34;\\r\\nsha: \u0026#34; + SHA + \u0026#34;\\r\\nbuild time: \u0026#34; + BUILD_TIME, ... } Makefile\ntag?=v0.0.5 DATE?=$(shell date +%FT%T%z) VERSION_HASH = $(shell git rev-parse HEAD) LDFLAGS=\u0026#39;-X \u0026#34;main.VERSION=$(tag)\u0026#34; -X \u0026#34;main.SHA=$(VERSION_HASH)\u0026#34; -X \u0026#34;main.BUILD_TIME=$(DATE)\u0026#34;\u0026#39; build: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags $(LDFLAGS) -o wellcli main.go 执行make build, 产生的二进制文件，就含有注入的信息了。\n-ldflags \u0026#39;[pattern=]arg list\u0026#39; arguments to pass on each go tool link invocation. https://golang.google.cn/cmd/go/#hdr-Build_modes https://www.digitalocean.com/community/tutorials/using-ldflags-to-set-version-information-for-go-applications ","permalink":"https://wdd.js.org/golang/inject-version/","summary":"暴露的变量必须用var定义，不能用const定义\n// main.go var VERSION = \u0026#34;unknow\u0026#34; var SHA = \u0026#34;unknow\u0026#34; var BUILD_TIME = \u0026#34;unknow\u0026#34; ... func main () { app := \u0026amp;cli.App{ Version: VERSION + \u0026#34;\\r\\nsha: \u0026#34; + SHA + \u0026#34;\\r\\nbuild time: \u0026#34; + BUILD_TIME, ... } Makefile\ntag?=v0.0.5 DATE?=$(shell date +%FT%T%z) VERSION_HASH = $(shell git rev-parse HEAD) LDFLAGS=\u0026#39;-X \u0026#34;main.VERSION=$(tag)\u0026#34; -X \u0026#34;main.SHA=$(VERSION_HASH)\u0026#34; -X \u0026#34;main.BUILD_TIME=$(DATE)\u0026#34;\u0026#39; build: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags $(LDFLAGS) -o wellcli main.go 执行make build, 产生的二进制文件，就含有注入的信息了。\n-ldflags \u0026#39;[pattern=]arg list\u0026#39; arguments to pass on each go tool link invocation.","title":"在二进制文件中注入版本信息"},{"content":"FROM golang:1.16.2 as builder ENV GO111MODULE=on GOPROXY=https://goproxy.cn,direct WORKDIR /app COPY . . RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build . FROM scratch WORKDIR /app COPY --from=builder /app/your_app . # 配置时区 COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo ENV TZ=Asia/Shanghai EXPOSE 8080 ENTRYPOINT [\u0026#34;./your_app\u0026#34;] ","permalink":"https://wdd.js.org/golang/scratch-dockerfile/","summary":"FROM golang:1.16.2 as builder ENV GO111MODULE=on GOPROXY=https://goproxy.cn,direct WORKDIR /app COPY . . RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build . FROM scratch WORKDIR /app COPY --from=builder /app/your_app . # 配置时区 COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo ENV TZ=Asia/Shanghai EXPOSE 8080 ENTRYPOINT [\u0026#34;./your_app\u0026#34;] ","title":"Golang Dockerfile"},{"content":"如何在markdown中插入图片 在static 目录中创建 images 目录，然后把图片放到images目录中。\n在文章中引用的时候\n![](/images/qianxun.jpeg#center) Warning 我之前创建的文件夹的名字叫做 img, 本地可以正常显示，但是部署之后，就无法显示图片了。\n最后我把img改成images才能正常在网页上显示。\n","permalink":"https://wdd.js.org/posts/2022/hugo-blog-faq/","summary":"如何在markdown中插入图片 在static 目录中创建 images 目录，然后把图片放到images目录中。\n在文章中引用的时候\n![](/images/qianxun.jpeg#center) Warning 我之前创建的文件夹的名字叫做 img, 本地可以正常显示，但是部署之后，就无法显示图片了。\n最后我把img改成images才能正常在网页上显示。","title":"Hugo博客常见问题以及解决方案"},{"content":"g729编码的占用带宽是g711的1/8，使用g729编码，可以极大的降低带宽的费用。fs原生的mod_g927模块是需要按并发数收费的，但是我们可以使用开源的bcg729模块。\n这里需要准备两个仓库，为了加快clone速度，我将这两个模块导入到gitee上。\nhttps://gitee.com/wangduanduan/mod_bcg729 https://gitee.com/wangduanduan/bcg729 安装前提 已经安装好了freeswitch, 编译mod_bcg729模块，需要指定freeswitch头文件的位置\nstep0: 切换到工作目录 cd /usr/local/src/ step1: clone mod_bcg729 git clone https://gitee.com/wangduanduan/mod_bcg729.git step2: clone bcg729 mod_bcg729模块在编辑的时候，会检查当前目录下有没有bcg729的目录。 如果没有这个目录，就会从github上clone bcg729的项目。 所以我们可以在编译之前，先把bcg729 clone到mob_bcg729目录下\ncd mod_bcg729 git clone https://gitee.com/wangduanduan/bcg729.git step3: 编辑mod_bcg729 编译mod_bcg729需要指定fs头文件switch.h的位置。 在Makefile项目里有FS_INCLUDES这个变量用来定义fs头文件的位置\nFS_INCLUDES=/usr/include/freeswitch FS_MODULES=/usr/lib/freeswitch/mod 如果你的源码头文件路径不是/usr/include/freeswitch， 则需要在执行make命令时通过参数指定， 例如下面编译的时候。\nmake FS_INCLUDES=/usr/local/freeswitch/include/freeswitch Tip 如何找到头文件的目录？ 头文件一般在fs安装目录的include/freeswitch目录下 如果还是找不到，则可以使用 find /usr -name switch.h -type f 搜索对应的头文件 step4: 复制so文件 mod_bcg729编译之后，可以把生成的mod_bcg729.so拷贝到fs安装目录的mod目录下\nstep5: 加载模块 命令行加载\nload mod_bcg729 配置文件加载 命令行加载重启后就失效了，可以将加载的模块写入到配置文件中。 在modules.conf.xml中加入\n\u0026lt;load module=\u0026#34;mod_bcg729\u0026#34;/\u0026gt; step5: vars.xml修改 \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;global_codec_prefs=PCMU,PCMA,G729\u0026#34; /\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;outbound_codec_prefs=PCMU,PCMA,G729\u0026#34;/\u0026gt; \u0026lt;X-PRE-PROCESScmd=\u0026#34;set\u0026#34;data=\u0026#34;media_mix_inbound_outbound_codecs=true\u0026#34;/\u0026gt; step6: sip profile修改 开启转码\n\u0026lt;param name=\u0026#34;disable-transcoding\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; 然后重启fs, 进入到fs_cli中，输入: show codec, 看看有没有显示729编码。然后就是找话机，测试g729编码了。\n","permalink":"https://wdd.js.org/freeswitch/install-bcg729/","summary":"g729编码的占用带宽是g711的1/8，使用g729编码，可以极大的降低带宽的费用。fs原生的mod_g927模块是需要按并发数收费的，但是我们可以使用开源的bcg729模块。\n这里需要准备两个仓库，为了加快clone速度，我将这两个模块导入到gitee上。\nhttps://gitee.com/wangduanduan/mod_bcg729 https://gitee.com/wangduanduan/bcg729 安装前提 已经安装好了freeswitch, 编译mod_bcg729模块，需要指定freeswitch头文件的位置\nstep0: 切换到工作目录 cd /usr/local/src/ step1: clone mod_bcg729 git clone https://gitee.com/wangduanduan/mod_bcg729.git step2: clone bcg729 mod_bcg729模块在编辑的时候，会检查当前目录下有没有bcg729的目录。 如果没有这个目录，就会从github上clone bcg729的项目。 所以我们可以在编译之前，先把bcg729 clone到mob_bcg729目录下\ncd mod_bcg729 git clone https://gitee.com/wangduanduan/bcg729.git step3: 编辑mod_bcg729 编译mod_bcg729需要指定fs头文件switch.h的位置。 在Makefile项目里有FS_INCLUDES这个变量用来定义fs头文件的位置\nFS_INCLUDES=/usr/include/freeswitch FS_MODULES=/usr/lib/freeswitch/mod 如果你的源码头文件路径不是/usr/include/freeswitch， 则需要在执行make命令时通过参数指定， 例如下面编译的时候。\nmake FS_INCLUDES=/usr/local/freeswitch/include/freeswitch Tip 如何找到头文件的目录？ 头文件一般在fs安装目录的include/freeswitch目录下 如果还是找不到，则可以使用 find /usr -name switch.h -type f 搜索对应的头文件 step4: 复制so文件 mod_bcg729编译之后，可以把生成的mod_bcg729.so拷贝到fs安装目录的mod目录下\nstep5: 加载模块 命令行加载\nload mod_bcg729 配置文件加载 命令行加载重启后就失效了，可以将加载的模块写入到配置文件中。 在modules.conf.xml中加入\n\u0026lt;load module=\u0026#34;mod_bcg729\u0026#34;/\u0026gt; step5: vars.xml修改 \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;global_codec_prefs=PCMU,PCMA,G729\u0026#34; /\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;set\u0026#34; data=\u0026#34;outbound_codec_prefs=PCMU,PCMA,G729\u0026#34;/\u0026gt; \u0026lt;X-PRE-PROCESScmd=\u0026#34;set\u0026#34;data=\u0026#34;media_mix_inbound_outbound_codecs=true\u0026#34;/\u0026gt; step6: sip profile修改 开启转码","title":"安装bcg729模块"},{"content":"呼入到会议，正常来说，当会议室有且只有一人时，应该会报“当前只有一人的提示音”。但是测试的时候，输入了密码，进入了会议，却没有播报正常的提示音。\n经过排查发现，dialplan中，会议室的名字中含有@符号。\n按照fs的文档，发现@后面应该是profilename, 然而fs的conference.conf.xml却没有这个profile, 进而导致语音无法播报的问题。所以只要加入这个profile, 或者直接用@default, 就可以正确的播报语音了。\nAction data Description confname profile is \u0026ldquo;default\u0026rdquo;, no flags or pin confname+1234 profile is \u0026ldquo;default\u0026rdquo;, pin is 1234 confname@profilename+1234 profile is \u0026ldquo;profilename\u0026rdquo;, pin=1234, no flags confname+1234+flags{mute} profile is \u0026ldquo;default\u0026rdquo;, pin=1234, one flag confname++flags{endconf|moderator} profile is \u0026ldquo;default\u0026rdquo;, no p.i.n., multiple flags bridge:confname:1000@${domain_name} a \u0026ldquo;bridging\u0026rdquo; conference, you must provide another endpoint, or \u0026rsquo;none'. bridge:uuid:none a \u0026ldquo;bridging\u0026rdquo; conference with UUID assigned as conference name 所以，当你遇到问题的时候，应该仔细的再去阅读一下官方的接口文档。\n参考文档\nhttps://txlab.wordpress.com/2012/09/17/setting-up-a-conference-bridge-with-freeswitch/ https://freeswitch.org/confluence/display/FREESWITCH/mod_conference ","permalink":"https://wdd.js.org/freeswitch/conference-announce/","summary":"呼入到会议，正常来说，当会议室有且只有一人时，应该会报“当前只有一人的提示音”。但是测试的时候，输入了密码，进入了会议，却没有播报正常的提示音。\n经过排查发现，dialplan中，会议室的名字中含有@符号。\n按照fs的文档，发现@后面应该是profilename, 然而fs的conference.conf.xml却没有这个profile, 进而导致语音无法播报的问题。所以只要加入这个profile, 或者直接用@default, 就可以正确的播报语音了。\nAction data Description confname profile is \u0026ldquo;default\u0026rdquo;, no flags or pin confname+1234 profile is \u0026ldquo;default\u0026rdquo;, pin is 1234 confname@profilename+1234 profile is \u0026ldquo;profilename\u0026rdquo;, pin=1234, no flags confname+1234+flags{mute} profile is \u0026ldquo;default\u0026rdquo;, pin=1234, one flag confname++flags{endconf|moderator} profile is \u0026ldquo;default\u0026rdquo;, no p.i.n., multiple flags bridge:confname:1000@${domain_name} a \u0026ldquo;bridging\u0026rdquo; conference, you must provide another endpoint, or \u0026rsquo;none'. bridge:uuid:none a \u0026ldquo;bridging\u0026rdquo; conference with UUID assigned as conference name 所以，当你遇到问题的时候，应该仔细的再去阅读一下官方的接口文档。\n参考文档","title":"会议提示音无法正常播放"},{"content":"开启sip信令的日志 这样会让fs把收发的sip信令打印到fs_cli里面，但不是日志文件里面\nsofia global siptrace on # sofia global siptrace off 关闭 开启sofia模块的日志 sofia 模块的日志即使开启，也是输出到fs_cli里面的，不会输出到日志文件里面\nsofia loglevel all 7 # sofia loglevel \u0026lt;all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa|sresolv|stun\u0026gt; [0-9] 将fs_cli的输出，写到日志文件里 sofia tracelevel 会将某些日志重定向到日志文件里 sofia tracelevel debug # sofia tracelevel \u0026lt;console|alert|crit|err|warning|notice|info|debug\u0026gt; 注意，debug级别的日志非常多，仅仅适用于debug\n大量的日志写入磁盘\n占用太多的io 磁盘空间可能很快占满 ","permalink":"https://wdd.js.org/freeswitch/log-settings/","summary":"开启sip信令的日志 这样会让fs把收发的sip信令打印到fs_cli里面，但不是日志文件里面\nsofia global siptrace on # sofia global siptrace off 关闭 开启sofia模块的日志 sofia 模块的日志即使开启，也是输出到fs_cli里面的，不会输出到日志文件里面\nsofia loglevel all 7 # sofia loglevel \u0026lt;all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa|sresolv|stun\u0026gt; [0-9] 将fs_cli的输出，写到日志文件里 sofia tracelevel 会将某些日志重定向到日志文件里 sofia tracelevel debug # sofia tracelevel \u0026lt;console|alert|crit|err|warning|notice|info|debug\u0026gt; 注意，debug级别的日志非常多，仅仅适用于debug\n大量的日志写入磁盘\n占用太多的io 磁盘空间可能很快占满 ","title":"FS日志设置"},{"content":"About Sofia is a FreeSWITCH™ module (mod_sofia) that provides SIP connectivity to and from FreeSWITCH in the form of a User Agent. A \u0026ldquo;User Agent\u0026rdquo; (\u0026ldquo;UA\u0026rdquo;) is an application used for handling a certain network protocol; the network protocol in Sofia\u0026rsquo;s case is SIP. Sofia is the general name of any User Agent in FreeSWITCH using the SIP network protocol. For example, Sofia receives calls sent to FreeSWITCH from other SIP User Agents (UAs), sends calls to other UAs, acts as a client to register FreeSWITCH with other UAs, lets clients register with FreeSWITCH, and connects calls (i.e., to local extensions). To add a SIP Provider (Sofia User Agent) to your FreeSWITCH, please see the Interoperability Examples and add the SIP Provider information in an .xml file stored under conf/sip_profiles/\nClick here to expand Table of Contents\nSofia allows for multiple User Agents A \u0026ldquo;User Agent\u0026rdquo; (\u0026ldquo;UA\u0026rdquo;) is an application used for running a certain network protocol, and a Sofia UA is the same thing but the protocol in that case is SIP. When FreeSWITCH starts, it reads the conf/autoload_configs/sofia.conf.xml file. That file contains a \u0026ldquo;X-PRE-PROCESS\u0026rdquo; directive which instructs FreeSWITCH to subsequently load and merge any conf/sip_profiles/*.xml files. Each *.xml file so loaded and merged should contain a complete description of one or more SIP Profiles. Each SIP Profile so loaded is part of a \u0026ldquo;User Agent\u0026rdquo; or \u0026ldquo;UA\u0026rdquo;; in FreeSWITCH terms, UA = User Agent = Sofia Profile = SIP Profile. Note that the individual UAs so loaded are all merged together by FreeSWITCH and must not interfere with each other: In particular, each UA must have its own unique port on which it accepts connections (the default port for SIP is 5060).\nMultiple User Agents (Profiles) and the Dialplan Why might you want to create multiple User Agents? Here\u0026rsquo;s an example. In my office, I use a firewall. This means that calls I make to locations outside the firewall must use a STUN server to transverse the NAT in the firewall, while calls within the office don\u0026rsquo;t need to use a STUN server. In order to accommodate these requirements, I\u0026rsquo;ve created two different UAs. One of them uses a STUN server and for that matter also connects up to the PSTN through a service provider. The other UA is purely for local SIP calls. Now I\u0026rsquo;ve got two UAs defined by my profiles, each of which can handle a call. When dialing a SIP address or telephone number, which UA is used? That determination is made in the dialplan. One syntax for making a call via Sofia in the dialplan is sofia/profile_name/destination\nSo, the task becomes rather straightforward. Dialplans use pattern matching and other tricks to determine how to handle a call. My dialplan examines what I\u0026rsquo;ve dialed and then determines what profile to use with that call. If I dial a telephone number, the dialplan selects the UA that connects up to the PSTN. If I dial a SIP address outside the firewall, the dialplan selects that same UA because it uses the STUN server. But if I dial a SIP address that\u0026rsquo;s inside the firewall, the dialplan selects the \u0026ldquo;local\u0026rdquo; UA. To understand how to write dialplans, use pattern matching, etc., see Dialplan\nThe Relationship Between SIP Profiles and Domains The following content was written in a mailing list thread by Anthony Minessale in response to questions about how SIP profiles relate to domain names in FreeSWITCH. The best thing to do is take a look at these things from a step back. The domains inside the XML registry are completely different from the domains on the internet and again completely different from domains in sip packets. The profiles are again entirely different from any of the above. Its up to you to align them if you so choose. The default configuration distributed with FreeSWITCH sets up the scenario most likely to load on any machine and work out of the box. That is the primary goal of that configuration, so, It sets the domain in both the directory, the global default domain variable and the name of the internal profile to be identical to the IP addr on the box that can reach the internet. Then it sets the sip to force everything to that value. When you want to detach from this behavior, you are probably on a venture to do some kind of multi-home setup. Aliases in the tag are a list of keys you want to use to use that lead to the current profile your are configuring. Think of it as the /etc/hosts file in Unix, only for profiles. When you define aliases to match all of the possible domains hosted on a particular profile, then when you try to take a user@host.com notation and decide which profile it came from, you can use the aliases to find it providing you have added to that profile. The tag is an indicator telling the profile to open the XML registry in FreeSWITCH and run through any domains defined therein. The 2 key attributes are: alias: [true/false] (automatically create an alias for this domain as mentioned above) parse: [true/false] (scan the domain for gateway entries and include them into this profile) name: [] (either the name of a specific domain or \u0026lsquo;all\u0026rsquo; to denote parsing every domain in the directory)\nAs you showed in your question the default config has If you apply what you have learned above, it will scan for every domain (there is only one by default) and add an alias for it and not parse it for gateways. The default directory uses global config vars to set the domain to match the local IP addr on the box. So now you will have a domain in your config that is your IP addr, and the internal profile will attach to it and add an alias so that value expands to match it. This is explained in a comment at the top of directory/default.xml: FreeSWITCH works off the concept of users and domains just like email. You have users that are in domains for example 1000@domain.com.\nWhen freeswitch gets a register packet it looks for the user in the directory based on the from or to domain in the packet depending on how your sofia profile is configured. Out of the box the default domain will be the IP address of the machine running FreeSWITCH. This IP can be found by typing \u0026ldquo;sofia status\u0026rdquo; at the CLI. You will register your phones to the IP and not the hostname by default. If you wish to register using the domain please open vars.xml in the root conf directory and set the default domain to the hostname you desire. Then you would use the domain name in the client instead of the IP address to register with FreeSWITCH.\nSo having more than one profile with the default of is going to end up aliasing the same domains into all profiles who call it and cause an overwrite in the lookup table and probably an error in your logs somewhere. If you had parse=\u0026ldquo;true\u0026rdquo; on all of them, they would all try and register to the gateways in all of your domains. If you look at the stock config, external.xml is a good example of a secondary profile, it has so no aliases, and yes parse \u0026hellip; the exact opposite of the internal so that all the gateways would register from external and internal would bind to the local IP addr. So, you probably want to use separate per domain per profile you want to bind it to in more complicated setups.\nStructure of a Profile Each profile may contain several different subsections. At the present time there\u0026rsquo;s no XSD or DTD for sofia.conf.xml — and any volunteer who can create one would be very welcome indeed.\nGateway Each profile can have several gateways: elements\u0026hellip; elements\u0026hellip; A gateway has an attribute \u0026ldquo;name\u0026rdquo; by which it can be referred. A gateway describes how to use a different UA to reach destinations. For example, the gateway may provide access to the PSTN, or to a private SIP network. The reason for defining a gateway, presumably, is because the gateway requires certain information before it will accept a call from the FreeSWITCH User Agent. Variables can be defined on a gateway. Inbound variables are set on the channel of a call received from a gateway, outbound variables are set on the channel of a call sent to a gateway. An example gateway configuration would be: To reach a particular gateway from the dial plan, use sofia/gateway/\u0026lt;gateway_name\u0026gt;/\nFreeSWITCH can also subscribe to receive notification of events from the gateway. For more information see Presence - Use FreeSWITCH as a Client\nParameters The following is a list of param elements that are children of a gateway element:\nNote: The username param for the gateway is not to be confused with the username param in the Profile settings config!\nNote: extension parameter influence the contents of channel variable Caller-Destination-Number and destination_number. If it is blank, Caller-Destination-Number will always be set to gateway\u0026rsquo;s username. If it has a value, Caller-Destination-Number will always be set to this value. If it has value auto_to_user, Caller-Destination-Number will be populated with value ${sip_to_user} which means the real dialled number in case of an inbound call.\nping-min means \u0026ldquo;how many successful pings we must have before declaring a gateway up\u0026rdquo;. The interval between ping-min and ping-max is the \u0026ldquo;safe area\u0026rdquo; where a gateway is marked as UP. So if we have, for example, min 3 and max 6, if the gateway is up and we move counter between 3,4,5,6 the gateway will be up. If from 6 we loose 4 (so counter == 2) pings in a row, the gateway will be declared down. Please note that on sofia startup the gateway is always started as UP, so it will be up even if ping-min is \u0026gt; 1 . the \u0026ldquo;right\u0026rdquo; way starts when the gateway goes down.\nParam \u0026ldquo;register,\u0026rdquo; is used when this profile acts as a client to another UA. By registering, FreeSWITCH informs the other UA of its whereabouts. This is generally used when FreeSWITCH wants the other UA to send FreeSWITCH calls, and the other UA expects this sort of registration. If FreeSWITCH uses the other UA only as a gateway (e.g., to the PSTN), then registration is not generally required. Param \u0026ldquo;distinct-to\u0026rdquo; is used when you want FS to register using a distict AOR for header To. It requires proper setting of related parameters. For example if you want the REGISTER to go with: From: sip:someuser@somedomain.com To: sip:anotheruser@anotherdomain.com\nThen set the parameters as this: The latter param, \u0026ldquo;ping\u0026rdquo; is used to check gateway availability. By setting this option, FreeSWITCH will send SIP OPTIONS packets to gateway. If gateway responds with 200 or 404, gateway is pronounced up, otherwise down. [N.B. It appears that other error messages can be returned and still result in the gateway being marked as \u0026lsquo;up\u0026rsquo;?] If any call is routed to gateway with state down, FreeSWITCH will generate NETWORK_OUT_OF_ORDER hangup cause. Ping frequency is defined in seconds (value attribute) and has a minimum value of 5 seconds. Param \u0026ldquo;extension-in-contact\u0026rdquo; is used to force what the contact info will be in the registration. If you are having a problem with the default registering as gw+gateway_name@ip you can set this to true to use extension@ip. If extension is blank, it will use username@ip.\nif you need to insert the FROM digits to the Contact URI User Part when sending call to gateway BEFORE From: \u0026ldquo;8885551212\u0026rdquo; sip:88855512120@8.8.8.8 Contact: sip:gw+mygateway@7.7.7.7:7080 try adding these to gateway params\nThese channel variables will be set on all calls going through this gateway in the specified direction. However, see below for a special syntax to set profile variables rather than channel variables. Settings Settings include other, more general information about the profile, including whether or not STUN is in use. Each profile has its own settings element. Not only is this convenient — it\u0026rsquo;s possible to set up one profile to use STUN and another, with a different gateway or working behind the firewall, not needing STUN — but it\u0026rsquo;s also crucial. That\u0026rsquo;s because each profile defines a SIP User Agent, and each UA must have its own unique \u0026ldquo;sip-port.\u0026rdquo; By convention, 5060 is the default port, but it\u0026rsquo;s possible to make calls to, e.g., \u0026ldquo;foo@sip.example.com:5070\u0026rdquo;, and therefore you can define any port you please for each individual profile. The conf directory contains a complete sample sofia.conf.xml file, along with comments. See Git examples: Internal, External\nBasic settings alias This seems to make the SIP profile bind to this IP \u0026amp; port as well as your SIP / RTP IPs and ports. Anthony had this to say about aliases in a ML thread: Aliases in the tag are a list of keys you want to use to use that lead to the current profile your are configuring. Think of it as the /etc/hosts file in unix only for profiles. When you define aliases to match all of the possible domains hosted on a particular profile, then when you try to take a user@host.com notation and decide which profile it came from, you can use the aliases to find it providing you have added to that profile.\nshutdown-on-fail If set to true and the profile fails to load, FreeSWITCH will shut down. This is useful if you are running something like Pacemaker and OpenAIS which manage a pair of FreeSWITCH nodes and automatically monitor, start, stop, restart, and standby-on-fail the nodes. It will ensure that the specific node is not able to be used in a \u0026ldquo;partially up\u0026rdquo; situation.\nuser-agent-string This sets the User-Agent header in all SIP messages sent by your server. By default this could be something like \u0026ldquo;FreeSWITCH-mod_sofia/1.0.trunk-12805\u0026rdquo;. If you didn\u0026rsquo;t want to advertise detailed version information you could simply set this to \u0026ldquo;FreeSWITCH\u0026rdquo; or even \u0026ldquo;Asterisk PBX\u0026rdquo; as a joke. Take care when setting this value as certain characters such as \u0026lsquo;@\u0026rsquo; could cause other SIP proxies could reject your messages as invalid.\nlog-level sip-trace context Dialplan context in which to dump calls that come in to this profile\u0026rsquo;s ip:port\nsip-port Port to bind to for SIP traffic:\nsip-ip IP address to bind to for SIP traffic. DO NOT USE HOSTNAMES, ONLY IP ADDRESSES\nrtp-ip IP address to bind to for RTP traffic. DO NOT USE HOSTNAMES, ONLY IP ADDRESSES Multiple rtp-ip support: if more rtp-ip parameters are added, they will be used in round-robin as new calls progress. IPv6 addresses are not supported under Windows at the time of writing. See FS-4445 ext-rtp-ip This is the IP behind which FreeSWITCH is seen from the Internet, so if FreeSWITCH is behind NAT, this is basically the public IP that should be used for RTP. Possible values are: Any variable from vars.xml, e.g. $${external_rtp_ip}:\n\u0026ldquo;specific IP address\u0026rdquo;\n\u0026ldquo;when used for LAN and WAN to avoid errors in the SIP CONTACT sent to LAN devices, use\u0026rdquo;\n\u0026ldquo;auto\u0026rdquo;: the guessed IP will be used (guessed by looking in the IP routing table which interface is the default route)\n\u0026ldquo;auto-nat\u0026rdquo;: FreeSWITCH will use uPNP or NAT-PMP to discover the public IP address it should use\n\u0026ldquo;stun:DNS name or IP address\u0026rdquo;: FreeSWITCH will use the STUN server of your choice to discover the public IP address\n\u0026ldquo;host:DNS name\u0026rdquo;: FreeSWITCH will resolve the DNS name as the public IP address, so you can use a dynamic DNS host\nATTENTION: AS OF 2012Q4, \u0026rsquo;ext–\u0026rsquo; prefixed params cited above when populated with to-be-resolved DNS strings \u0026ndash; e.g. name=\u0026ldquo;ext–sip–ip\u0026rdquo; value=\u0026ldquo;stun:stun.freeswitch.org\u0026rdquo; or name=\u0026ldquo;ext‑rtp–ip\u0026rdquo; value=\u0026ldquo;host:mypublicIP.dyndns.org\u0026rdquo; \u0026ndash; are resolved to IP addresses once only at FS load time and const thereafter. FS is blind to (unaware of) any subsequent changes in your environment\u0026rsquo;s IP address. Thus, these ext– vars may become functionally incompatible with the environment\u0026rsquo;s current IP addresses with unspecified results in call flow at the network layer. FS restart is required for FS to capture the now-current, working IP address(es).\next-sip-ip This is the IP behind which FreeSWITCH is seen from the Internet, so if FreeSWITCH is behind NAT, this is basically the public IP that should be used for SIP. Possibles values are the same as those for ext-rtp-ip, and it is usually set to the same value.\ntcp-keepalive Set this to interval (in milliseconds) to send keep alive packets to user agents (UAs) registered via TCP; do not set to disable.\ntcp-pingpong tcp-ping2pong dialplan The dialplan parameter is very powerful. In the simplest configuration, it will use the XML dialplan. This means that it will read data from mod_xml_curl XML dialplans (e.g., callback to your webserver), or failing that, from the XML files specified in freeswitch.xml dialplan section. (e.g. default_context.xml)\nYou can also add enum lookups into the picture (since mod_enum provides dialplan functionality), so enum lookups override the XML dialplan\nOr reverse the order to enum is only consulted if XML lookup fails\nIt is also possible to specify a specific enum root\nOr use XML on a custom file\nWhere it will first check the specific XML file, then hit normal XML which also do a mod_xml_curl lookup assuming you have that configured and working.\nMedia related options See also: Proxy Media\nresume-media-on-hold When calls are in no media this will bring them back to media when you press the hold button. To return the calls to bypass-media after the call is unheld, enable bypass-media-after-hold.\nbypass-media-after-att-xfer This will allow a call after an attended transfer go back to bypass media after an attended transfer. bypass-media-after-hold This will allow a call to go back to bypass media after a hold. This option can be enabled only if resume-media-on-hold is set. Available from git rev 8fa385b. inbound-bypass-media Uncomment to set all inbound calls to no media mode. It means that the FreeSWITCH server only keeps the SIP messages state, but have the RTP steam go directly from end-point to end-point\ninbound-proxy-media Uncomment to set all inbound calls to proxy media mode. This means the FreeSWITCH keeps both the SIP and RTP traffic on the server but does not interact with the RTP stream.\ndisable-rtp-auto-adjust ignore-183nosdp enable-soa Set the value to \u0026ldquo;false\u0026rdquo; to diable SIP SOA from sofia to tell sofia not to touch the exchange of SDP\nt38-passthru The following options are available\n\u0026rsquo;true\u0026rsquo; enables t38 passthru \u0026lsquo;false\u0026rsquo; disables t38 passthru \u0026lsquo;once\u0026rsquo; enables t38 passthru, but sends t.38 re-invite only once (available since commit 08b25a8 from Nov. 9, 2011) Codecs related options Also see:\nCodec Negotiation Supported Codecs inbound-codec-prefs This parameter allows to change the allowed inbound codecs per profile. outbound-codec-prefs This parameter allows to change the outbound codecs per profile. codec-prefs This parameter allows to change both inbound-codec-prefs and outbound-codec-prefs at the same time. inbound-codec-negotiation set to \u0026lsquo;greedy\u0026rsquo; if you want your codec list to take precedence if \u0026lsquo;greedy\u0026rsquo; doesn\u0026rsquo;t work for you, try \u0026lsquo;scrooge\u0026rsquo; which has been known to fix misreported ptime issues with DID providers such as CallCentric. A rule of thumb is:\n\u0026lsquo;generous\u0026rsquo; permits the remote codec list have precedence and \u0026lsquo;win\u0026rsquo; the codec negotiation and selection process \u0026lsquo;greedy\u0026rsquo; forces a win by the local FreeSWITCH preference list \u0026lsquo;scrooge\u0026rsquo; takes \u0026lsquo;greedy\u0026rsquo; a step further, so that the FreeSWITCH wins even when the far side lies about capabilities during the negotiation process sip_codec_negotiation is a channel variable version of this setting\ninbound-late-negotiation Uncomment to let calls hit the dialplan before you decide if the codec is OK. bitpacking This setting is for AAL2 bitpacking on G.726. disable-transcoding Uncomment if you want to force the outbound leg of a bridge to only offer the codec that the originator is using\nrenegotiate-codec-on-reinvite STUN If you need to use a STUN server, here are common working examples:\next-rtp-ip stun.fwdnet.net is a publicly-accessible STUN server.\next-sip-ip stun-enabled Simple traversal of UDP over NATs (STUN), is used to help resolve the problems associated with SIP clients, behind NAT, using private IP address space in their messaging. Use stun when specified (default is true).\nstun-auto-disable Set to true to have the profile determine stun is not useful and turn it off globally\nNATing apply-nat-acl When receiving a REGISTER or INVITE, enable NAT mode automatically if IP address in Contact header matches an entry defined in the RFC 1918 access list. \u0026ldquo;acl\u0026rdquo; is a misnomer in this case because access will not be denied if the user\u0026rsquo;s contact IP doesn\u0026rsquo;t match.\naggressive-nat-detection This will enable NAT mode if the network IP/port from which the request was received differs from the IP/Port combination in the SIP Via: header, or if the Via: header contains the received parameter (regardless of what it contains.) Note 2009-04-05: Someone please clarify when this would be useful. It seems to me if someone needed this feature, chances are that things are so broken that they would need to use NDLB-force-rport\nVAD and CNG VAD stands for Voice Activity Detector. FreeSWITCH is capable of detecting speech and can stop transmitting RTP packets when no voice is detected.\nvad suppress-cng Suppress Comfort Noise Generator (CNG) on this profile or per call with the \u0026lsquo;suppress_cng\u0026rsquo; variable\nNDLB (A.K.A. No device left behind) NDLB-force-rport This will force FreeSWITCH to send SIP responses to the network port from which they were received. Use at your own risk! For more information see NAT Traversal.\nsafe = param that does force-rport behavior only on endpoints we know are safe to do so on. This is a dirty hack to try to work with certain endpoints behind sonicwall which does not use the same port when it does nat, when the devices do not support rport, while not breaking devices that acutally use different ports that force-rport will break NDLB-broken-auth-hash Used for when phones respond to a challenged ACK with method INVITE in the hash\nNDLB-received-in-nat-reg-contact add a ;received=\u0026quot;:\u0026quot; to the contact when replying to register for nat handling\nNDLB-sendrecv-in-session By default, \u0026ldquo;a=sendrecv\u0026rdquo; is only included in the media portion of the SDP. While this is RFC-compliant, it may break functionality for some SIP devices. To also include \u0026ldquo;a=sendrecv\u0026rdquo; in the session portion of the SDP, set this parameter to true.\nNDLB-allow-bad-iananame Introduced in rev. 15401, this was enabled by default prior to new param. Will allow codecs to match respective name even if the given string is not correct. i.e., Linksys and Sipura phones will pass G.729a by default instead of G.729 as codec string therefore not matching. If you wish to allow bad IANA names to match respective codec string, add the following param to your SIP profile. Refer to RFC 3551, RFC 3555 and the IANA list(s) for SDP\nCall ID inbound-use-callid-as-uuid On inbound calls make the uuid of the session equal to the SIP call id of that call.\noutbound-use-uuid-as-callid On outbound calls set the callid to match the uuid of the session\nThis goes in the \u0026ldquo;..sip_profiles/external.xml\u0026rdquo; file.\nTLS Please make sure to read SIP TLS before enabling certain features below as they may not behave as expected.\ntls TLS: disabled by default, set to \u0026ldquo;true\u0026rdquo; to enable tls-only disabled by default, when enabled prevents sofia from listening on the unencrypted port for this connection. This can stop many generic brute force scripts and if all your clients connect over TLS then can help decrease the exposure of your FreeSWITCH server to the world. tls-bind-params additional bind parameters for TLS tls-sip-port Port to listen on for TLS requests. (5061 will be used if unspecified) tls-cert-dir Location of the agent.pem and cafile.pem ssl certificates (needed for TLS server) tls-version TLS version (\u0026ldquo;sslv2\u0026rdquo;, \u0026ldquo;sslv3\u0026rdquo;, \u0026ldquo;sslv23\u0026rdquo;, \u0026ldquo;tlsv1\u0026rdquo;, \u0026ldquo;tlsv1.1\u0026rdquo;, \u0026ldquo;tlsv1.2\u0026rdquo;). NOTE: Phones may not work with TLSv1 When not set defaults to: \u0026ldquo;tlsv1,tlsv1.1,tlsv1.2\u0026rdquo;\ntls-passphrase If your agent.pem is protected by a passphrase stick the passphrase here to enable FreeSWITCH to decrypt the key. tls-verify-date If the client/server certificate should have the date on it validated to ensure it is not expired and is currently active. tls-verify-policy This controls what, if any security checks are done against server/client certificates. Verification is generally checking certificates are valid against the cafile.pem. Set to \u0026lsquo;in\u0026rsquo; to only verify incoming connections, \u0026lsquo;out\u0026rsquo; to only verify outgoing connections, \u0026lsquo;all\u0026rsquo; to verify all connections, also \u0026lsquo;subjects_in\u0026rsquo;, \u0026lsquo;subjects_out\u0026rsquo; and \u0026lsquo;subjects_all\u0026rsquo; for subject validation (subject validation for outgoing connections is against the hostname/ip connecting to). Multiple policies can be split with a \u0026lsquo;|\u0026rsquo; pipe, for example \u0026lsquo;subjects_in|subjects_out\u0026rsquo;. Defaults to none. tls-verify-depth When certificate validation is enabled (tls-verify-policy) how deep should we try to verify a certificate up the chain again the cafile.pem file. By default only depth of 2. tls-verify-in-subjects If subject validation is enabled for incoming connections (tls-verify-policy set to \u0026lsquo;subjects_in\u0026rsquo; or \u0026lsquo;subjects_all\u0026rsquo;) this is the list of subjects that are allowed (delimit with a \u0026lsquo;|\u0026rsquo; pipe), note this only effects incoming connections for outgoing connections subjects are always checked against hostnames/ips. DTMF rfc2833-pt TODO RFC 2833 is obsoleted by RFC 4733.\ndtmf-duration dtmf-type TODO RFC 2833 is obsoleted by RFC 4733. Set the parameter in the SIP profile:\nor\nor\nOR set the variable in the SIP gateway or user profile (NOT in the channel, it must be before CS_INIT): Note the \u0026ldquo;_\u0026rdquo; instead of \u0026ldquo;-\u0026rdquo; in profile param (this is var set in dialplan). (24.10.2010: \u0026ldquo;both\u0026rdquo; don\u0026rsquo;t seem to me work in my tests, \u0026ldquo;outbound\u0026rdquo; does) Note: for inband DTMF, Misc. Dialplan Tools start_dtmf must be used in the dialplan. Also, to change the outgoing routing from info or rfc2833 to inband, use Misc._Dialplan_Tools_start_dtmf_generate RFC 2833\npass-rfc2833 TODO RFC 2833 is obsoleted by RFC 4733. Default: false If true, it passes RFC 2833 DTMF\u0026rsquo;s from one side of a bridge to the other, untouched. Otherwise, it decodes and re-encodes them before passing them on.\nliberal-dtmf TODO RFC 2833 is obsoleted by RFC 4733. Default: false For DTMF negotiation, use this parameter to just always offer 2833 and accept both 2833 and INFO. Use of this parameter is not recommended since its purpose is to try to cope with buggy SIP implementations.\nSIP Related options enable-timer This enables or disables support for RFC 4028 SIP Session Timers.\nNote: If your switch requires the timer option; for instance, Huawei SoftX3000, it needs this optional field and drops the calls with \u0026ldquo;Session Timer Check Message Failed\u0026rdquo;, then you may be able to revert back the commit that took away the Require: timer option which is an optional field by: git log -1 -p 58c3c3a049991fedd39f62008f8eb8fca047e7c5 libs/sofia-sip/libsofia-sip-ua | patch -p1 -R touch libs/sofia-sip/.update\nmake mod_sofia-clean make mod_sofia-install\nenable-100rel This enable support for 100rel (100% reliability - PRACK message as defined in RFC3262) This fixes a problem with SIP where provisional messages like \u0026ldquo;180 Ringing\u0026rdquo; are not ACK\u0026rsquo;d and therefore could be dropped over a poor connection without retransmission. 2009-07-08: Enabling this may cause FreeSWITCH to crash, see FSCORE-392.\nminimum-session-expires This sets the \u0026ldquo;Min-SE\u0026rdquo; value (in seconds) from RFC 4028. This value must not be less than 90 seconds.\nsip-options-respond-503-on-busy When set to true, this param will make FreeSWITCH respond to incoming SIP OPTIONS with 503 \u0026ldquo;Maximum Calls In Progress\u0026rdquo; when FS is paused or maximum sessions has been exceeded. When set to false or when not set at all (default behavior), SIP OPTIONS are always responded with 200 \u0026ldquo;OK\u0026rdquo;.\nSetting this param to true is especially useful if you\u0026rsquo;re using a proxy such as OpenSIPS or Kamailio with dispatcher module to probe your FreeSWITCH servers by sending SIP OPTIONS.\nsip-force-expires Setting this param overrides the expires value in the 200 OK in response to all inbound SIP REGISTERs towards this sip_profile. This param can be overridden per individual user by setting a sip-force-expires user directory variable.\nsip-expires-max-deviation Setting this param adds a random deviation to the expires value in the 200 OK in response to all inbound SIP REGISTERs towards this sip_profile. Result will be that clients will not re-register at the same time-interval thus spreading the load on your system. For example, if you set:\nthen the expires that is responded will be between 1800-600=1200 and 1800+600=2400 seconds. This param can be overridden per individual user by setting a sip-expires-max-deviation user directory variable.\noutbound-proxy Setting this param will send all outbound transactions to the value set by outbound-proxy. send-display-update Tells FreeSWITCH not to send display UPDATEs to the leg of the call. RTP Related options auto-jitterbuffer-msec Set this to the size of the jitterbuffer you would like to have on all calls coming through this profile.\nrtp-timer-name rtp-rewrite-timestamps If you don\u0026rsquo;t want to pass through timestamps from 1 RTP stream to another, rtp-rewrite-timestamps is a parameter you can set in a SIP Profile (on a per call basis with rtp_rewrite_timestamps chanvar in a dialplan). The result is that FreeSWITCH will regenerate and rewrite the timestamps in all the RTP streams going to an endpoint using this SIP Profile. This could be necessary to fix audio issues when sending calls to some paranoid and not RFC-compliant gateways (Cirpack is known to require this).\nmedia_timeout was: rtp-timeout-sec (deprecated) The number of seconds of RTP inactivity (media silence) before FreeSWITCH considers the call disconnected, and hangs up. It is recommended that you use session timers instead. If this setting is omitted, the default value is \u0026ldquo;0\u0026rdquo;, which disables the timeout.\nmedia_hold_timeout was: rtp-hold-timeout-sec (deprecated) The number of seconds of RTP inactivity (media silence) for a call placed on hold by an endpoint before FreeSWITCH considers the call disconnected, and hangs up. It is recommended that you use session timers instead. If this setting is omitted, the default value is \u0026ldquo;0\u0026rdquo;, which disables the timeout.\nrtp-autoflush-during-bridge Controls what happens if FreeSWITCH detects that it\u0026rsquo;s not keeping up with the RTP media (audio) stream on a bridged call. (This situation can happen if the FreeSWITCH server has insufficient CPU time available.) When set to \u0026ldquo;true\u0026rdquo; (the default), FreeSWITCH will notice when more than one RTP packet is waiting to be read in the incoming queue. If this condition persists for more than five seconds, RTP packets will be discarded to \u0026ldquo;catch up\u0026rdquo; with the audio stream. For example, if there are always five extra 20 ms packets in the queue, 100 ms of audio latency can be eliminated by discarding the packets. This will cause an audio glitch as some audio is discarded, but will improve the latency by 100 ms for the rest of the call. If rtp-autoflush-during-bridge is set to false, FreeSWITCH will instead preserve all RTP packets on bridged calls, even if it increases the latency or \u0026ldquo;lag\u0026rdquo; that callers hear.\nrtp-autoflush Has the same effect as \u0026ldquo;rtp-autoflush-during-bridge\u0026rdquo;, but affects NON-bridged calls (such as faxes, IVRs and the echo test). Unlike \u0026ldquo;rtp-autoflush-during-bridge\u0026rdquo;, the default is false, meaning that high-latency packets on non-bridged calls will not be discarded. This results in smoother audio at the possible expense of increasing audio latency (or \u0026ldquo;lag\u0026rdquo;). Setting \u0026ldquo;rtp-autoflush\u0026rdquo; to true will discard packets to minimize latency when possible. Doing so may cause errors in DTMF recognition, faxes, and other processes that rely on receiving all packets.\nAuth These settings deal with authentication: requirements for identifying SIP endpoints to FreeSWITCH.\nchallenge-realm Choose the realm challenge key. Default is auto_to if not set. auto_from - uses the from field as the value for the SIP realm. auto_to - uses the to field as the value for the SIP realm. - you can input any value to use for the SIP realm. If you want URL dialing to work you\u0026rsquo;ll want to set this to auto_from. If you use any other value besides auto_to or auto_from you\u0026rsquo;ll loose the ability to do multiple domains. Note: comment out to restore the behavior before 2008-09-29\naccept-blind-auth accept any authentication without actually checking (not a good feature for most people)\nauth-calls Users in the directory can have \u0026ldquo;auth-acl\u0026rdquo; parameters applied to them so as to restrict users access to a predefined ACL or a CIDR.\nValue can be \u0026ldquo;false\u0026rdquo; to disable authentication on this profile, meaning that when calls come in the profile will not send an auth challenge to the caller.\nlog-auth-failures Write log entries ( Warning ) on authentication failures ( Registration \u0026amp; Invite ). useful for users wishing to use fail2ban. note: Required SVN#15654 or higher\nauth-all-packets On authed calls, authenticate all the packets instead of only INVITE and REGISTER(Note: OPTIONS, SUBSCRIBE, INFO and MESSAGE are not authenticated even with this option set to true, see http://jira.freeswitch.org/browse/FS-2871)\nRegistration disable-register disable register which may be undesirable in a public switch\nmultiple-registrations Valid values for this parameter are \u0026ldquo;contact\u0026rdquo;, \u0026ldquo;true\u0026rdquo;, \u0026ldquo;false\u0026rdquo;. value=\u0026ldquo;true\u0026rdquo; is the most common use. Setting this value to \u0026ldquo;contact\u0026rdquo; will remove the old registration based on sip_user, sip_host and contact field as opposed to the call_id.\nmax-registrations-per-extension Defines the number of maximum registrations per extension. Valid value for this parameter is an integer greater than 0. Please note that setting this to 1 would counteract the usage of multiple-registrations. When an attempt to register an extension is made after the maximum value has been reached sofia will respond with 403. The following example will set maximum registrations to 2\ninbound-reg-force-matching-username Force the user and auth-user to match.\nforce-publish-expires Force custom presence update expires delta (-1 means endless)\nforce-register-domain all inbound registrations will look in this domain for the users. Comment out to use multiple domains\nforce-register-db-domain all inbound reg will stored in the db using this domain. Comment out to use multiple domains\nsend-message-query-on-register Can be set to \u0026rsquo;true\u0026rsquo;, \u0026lsquo;false\u0026rsquo; or \u0026lsquo;first-only\u0026rsquo;. If set to \u0026rsquo;true\u0026rsquo; (this is the default behavior), mod_sofia will send a message-query event upon registration. mod_voicemail uses this for counting messages.\nIf set to \u0026lsquo;first-only\u0026rsquo;, only the first REGISTER will trigger the message-query (it requires the UA to increment the NC on subsequent REGISTERs. Some phones, snom for instance, do not do this). The final effect of the message-query is to cause a NOTIFY MWI message to be sent to the registering UA (it is used to satisfy terminals that expect MWI without subscribing for it).\nunregister-on-options-fail If set to True with nat-options-ping the endpoint will be unregistered if no answer on OPTIONS packet.\nnat-options-ping With this option set FreeSWITCH will periodically send an OPTIONS packet to all NATed registered endpoints to keep alive connection. If set to True with unregister-on-options-fail the endpoint will be unregistered if no answer on OPTIONS packet.\nall-reg-options-ping With this option set FreeSWITCH will periodically send an OPTIONS packet to all registered endpoints to keep alive connection. If set to True with unregister-on-options-fail the endpoint will be unregistered if no answer on OPTIONS packet.\nregistration-thread-frequency Controls how often registrations in the FreeSWITCH are checked for expiration. ping-mean-interval Controls the mean interval FreeSWITCH™ will send OPTIONS packet to registered user, by default 30 seconds.\nSubscription force-subscription-expires force suscription expires to a lower value than requested\nforce-subscription-domain all inbound subscription will look in this domain for the users. Comment out to use multiple domains\nPresence manage-presence Enable presence. If you want to share your presence (see dbname and presence-hosts) set this to \u0026ldquo;true\u0026rdquo; on the first profile and enable the shared presence database. Then on subsequent profiles that share presence set this variable to \u0026ldquo;passive\u0026rdquo; and enable the shared presence database there as well.\ndbname Used to share presence info across sofia profiles Name of the db to use for this profile\npresence-hold-state By default when a call is placed on hold, monitoring extensions show that extension as ringing. You can change this behavior by specifying this parameter and one of the following values. Available as of commit 1145905 on April 13, 2012.\nconfirmed - Extension appears busy. early (default) - Extension appears to be ringing. terminated - Extension appears idle. presence-hosts A list of domains that have a shared presence in the database specified in dbname. People who use multiple domains per profile can\u0026rsquo;t use this feature anyway, so you\u0026rsquo;ll want to set it to something like \u0026ldquo;DISABLED\u0026rdquo; in this case to avoid getting users from similar domains all mashed together. For multiple domains also known as multi-tenant calling 1001 would call all matching users in all domains. Don\u0026rsquo;t use presence-hosts with multi-tenant.\npresence-privacy Optionally globally hide the caller ID from presence notes in distributed NOTIFY messages. For example, \u0026ldquo;Talk 1002\u0026rdquo; would be the presence note for extension 1001 while it is on a call with extension 1002. If the presence privacy tag is set to true, then it would distribute the presence note as \u0026ldquo;On The Phone\u0026rdquo; (without the extension to which it is connected). So any subscriber\u0026rsquo;s to 1001\u0026rsquo;s presence would not be able to see who he/she is talking to. http://jira.freeswitch.org/browse/FS-849 This also hides the number in the status \u0026ldquo;hold\u0026rdquo;, \u0026ldquo;ring\u0026rdquo;, \u0026ldquo;call\u0026rdquo; and perhaps others. http://jira.freeswitch.org/browse/FS-4420\nsend-presence-on-register Specify whether or not to send presence information when users register. Default is not to send presence information. Valid options:\nfalse true first-only CallerID Related options caller-id type choose one, can be overridden by inbound call type and/or sip_cid_type channel variable Remote-Party-ID header: P-*-Identity family of headers: neither one: pass-callee-id (defaults to true) Disable by setting it to false if you encounter something that your gateway for some reason hates X-headers that it is supposed to ignore\nOther (TO DO) hold-music disable-hold This allows to disable Music On Hold (added in GIT commit e5cc0539ffcbf660637198c698e90c2e30b05c2f, from Fri Apr 30 19:14:39 2010 -0500). This can be useful when the calling device intends to send its own MOH, but nevertheless sends a REINVITE to FreeSWITCH triggering its MOH. This can be done from dialplan also with rtp_disable_hold channel variable.\napply-inbound-acl set which access control lists, defined in acl.conf.xml, apply to this profile\napply-register-acl apply-proxy-acl This allows traffic to be sent to FreeSWITCH via one or more proxy servers. The proxy server should add a header named X-AUTH-IP containing the IP address of the client. FreeSWITCH trusts the proxy because its IP is listed in the proxy server ACL, and uses the value of the IP in this header as the client\u0026rsquo;s IP for ACL authentication (acl defined in apply-inbound-acl).\nrecord-template max-proceeding max number of open dialogs in proceeding\nbind-params if you want to send any special bind params of your own\ndisable-transfer disable transfer which may be undesirable in a public switch\nmanual-redirect enable-3pcc enable-3pcc determines if third party call control is allowed or not. Third party call control is useful in cases where the SIP invite doesn\u0026rsquo;t include a SDP (late media negotiation). enable-3pcc can be set to either \u0026rsquo;true\u0026rsquo; or \u0026lsquo;proxy\u0026rsquo;, true accepts the call right away, proxy waits until the call has been answered then sends accepts\nnonce-ttl TTL for nonce in sip auth\nThis parameter is set to 60 seconds if not set here. It\u0026rsquo;s used to determine how long to store the user registration record in the sip_authentication table. The expires field in the sip_authentication table is this value plus the expires set by the user agent.\nsql-in-transactions If set to true (default), it will instruct the profile to wait for 500 SQL statements to accumulate or 500ms to elapse and execute them in a transaction (to boost performance).\nodbc-dsn If you have ODBC support and a working dsn you can use it instead of SQLite\nmwi-use-reg-callid username If you wish to hide the fact that you are using FreeSWITCH in the SDP message (Specifically the o= and and s= fields) , then set the username param under the profile. This has no relation whatsoever with the username parameter when we\u0026rsquo;re dealing with gateways. If this value is left unset the system defaults using FreeSWITCH as the username parameter with the o= and s= fields.\nExample: . v=0. o=root 1346068950 1346068951 IN IP4 1.2.3.4. s=root. c=IN IP4 1.2.3.4. t=0 0. m=audio 26934 RTP/AVP 18 0 101 13. a=fmtp:18 annexb=no. a=rtpmap:101 telephone-event/8000. a=fmtp:101 0-16. a=ptime:20.\nwhen you set Directory of Users To allow users to register with the server, the user information must be specified in the conf/directory/default/*xml file. To dynamically specify what users can register, use Mod xml curl\nDefault Configuration File From the FreeSWITCH Github repository\u0026rsquo;s vanilla configurations ([conf/vanilla/autoload_configs/sofia.conf.xml](https://github.com/signalwire/freeswitch/blob/master/conf/vanilla/autoload_configs/sofia.conf.xml)): conf/autoload_configs/sofia.conf.xml \u0026lt;global_settings\u0026gt; \u0026lt;!\u0026ndash; the new format for HEPv2/v3 and capture ID protocol:host:port;hep=2;capture_id=200;\n\u0026ndash;\u0026gt; \u0026lt;/global_settings\u0026gt;\nshutdown and restart FreeSWITCH (or) unload and load mod_sofia If you\u0026rsquo;ve only made changes to a particular profile, you may simply (WARNING: will drop all calls associated with this profile):\nsofia profile restart reloadxml Security Features SIP TLS for secure signaling. SRTP for secure media delivery. The Auth section above for authentication settings. 参考 https://freeswitch.org/confluence/display/FREESWITCH/Sofia+Configuration+Files ","permalink":"https://wdd.js.org/freeswitch/sofia-config/","summary":"About Sofia is a FreeSWITCH™ module (mod_sofia) that provides SIP connectivity to and from FreeSWITCH in the form of a User Agent. A \u0026ldquo;User Agent\u0026rdquo; (\u0026ldquo;UA\u0026rdquo;) is an application used for handling a certain network protocol; the network protocol in Sofia\u0026rsquo;s case is SIP. Sofia is the general name of any User Agent in FreeSWITCH using the SIP network protocol. For example, Sofia receives calls sent to FreeSWITCH from other SIP User Agents (UAs), sends calls to other UAs, acts as a client to register FreeSWITCH with other UAs, lets clients register with FreeSWITCH, and connects calls (i.","title":"Sofia 模块全部配置"},{"content":"安装单个模块 make mod_sofia-install make mod_ilbc-install fs-cli事件订阅 /event plain ALL /event plain CHANNEL_ANSWER sofia 帮助文档 sofia help USAGE: -------------------------------------------------------------------------------- sofia global siptrace \u0026lt;on|off\u0026gt; sofia capture \u0026lt;on|off\u0026gt; watchdog \u0026lt;on|off\u0026gt; sofia profile \u0026lt;name\u0026gt; [start | stop | restart | rescan] [wait] flush_inbound_reg [\u0026lt;call_id\u0026gt; | \u0026lt;[user]@domain\u0026gt;] [reboot] check_sync [\u0026lt;call_id\u0026gt; | \u0026lt;[user]@domain\u0026gt;] [register | unregister] [\u0026lt;gateway name\u0026gt; | all] killgw \u0026lt;gateway name\u0026gt; [stun-auto-disable | stun-enabled] [true | false]] siptrace \u0026lt;on|off\u0026gt; capture \u0026lt;on|off\u0026gt; watchdog \u0026lt;on|off\u0026gt; sofia \u0026lt;status|xmlstatus\u0026gt; profile \u0026lt;name\u0026gt; [reg [\u0026lt;contact str\u0026gt;]] | [pres \u0026lt;pres str\u0026gt;] | [user \u0026lt;user@domain\u0026gt;] sofia \u0026lt;status|xmlstatus\u0026gt; gateway \u0026lt;name\u0026gt; sofia loglevel \u0026lt;all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa|sresolv|stun\u0026gt; [0-9] sofia tracelevel \u0026lt;console|alert|crit|err|warning|notice|info|debug\u0026gt; sofia help -------------------------------------------------------------------------------- 开启消息头压缩 \u0026lt;param name=\u0026#34;enable-compact-headers\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; fs需要重启\n呼叫相关指令 # 显示当前呼叫 show calls # 显示呼叫数量 show calls count # 挂断某个呼叫 uuid_kill 58579bd2-db78-4c7e-a666-0f16e19be643 # 挂断所有呼叫 hupall # sip抓包 sofia profile internal siptrace on sofia profile external siptrace on # 拨打某个用户并启用echo回音 originate user/1000 \u0026amp;echo 正则测试 在fs_cli里面可以用regex快速测试正则是否符合预期结果\nregex 123123 | \\d regex 123123 | ^\\d* 变量求值 eval $${mod_dir} eval $${recording_dir} 修改UA信息 sofia_external.conf.xml sofia_internal.conf.xml \u0026lt;param name=\u0026#34;user-agent-string\u0026#34; value=\u0026#34;wdd\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;username\u0026#34; value=\u0026#34;wdd\u0026#34;/\u0026gt; 修改之后需要rescan profile.\nmod_distributor的两个常用指令 # reload distributor_ctl reload # 求值 eval ${distributor(distributor_list)} 自动接听回音测试 \u0026lt;extension name=\u0026#34;wdd_echo\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^8002\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;info\u0026#34; data=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/action\u0026gt; \u0026lt;action application=\u0026#34;answer\u0026#34; data=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/action\u0026gt; \u0026lt;action application=\u0026#34;echo\u0026#34; data=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/action\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; odbc-dsn配置错误，fs进入假死状态 最近遇到一个奇怪的问题，相同的fs镜像，在一个环境正常运行，但是再进入另一个环境的时候，fs进程运行起来了，但是所有的功能都异常，仿佛进入了假死状态。并且控制台的日志输出也没有什么有用的信息。\n后来，我想起来以前曾经遇到过这个问题。\n这个fs的镜像中没有编译odbc相关的依赖，但是看sofia_external.conf.xml和sofia_internal.conf.xml, 却有odbc相关的配置。\n\u0026lt;param name=\u0026#34;odbc-dsn\u0026#34; value=\u0026#34;....\u0026#34;\u0026gt; 所以只要把这个odbc-dsn的配置注释掉，fs就正常运行了。\n取消session-timer 某些情况下fs会对呼入的电话，在通过时长达到1分钟的时候，向对端发送一个re-invite, 实际上这还是一个invite请求，只是to字段有了tag参数。这个机制叫做session-timer, 具体定义在RFC4028中。\n但是某些SIP终端可能不支持re-invite, 然后不对这个re-invite做回应，或者回应了一个错误的状态码，都会导致这通呼叫异常挂断。\n在internal.xml中修改如下行：\n\u0026lt;param name=\u0026#34;enable-timer\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; RTP失活超时检测 某个时刻开始，客户端无法再向FS发送流媒体了。例如客户端Web页面关闭，或者浏览器关闭。\n但是在这种场景下，FS还是会向客户端发送一段时间的媒体流，然后再发送BYE消息。那么，我们如何控制这个RTP失活的检测时间呢？\n在internal.xml或者external.xml中，有以下参数，可以控制检测RTP超时时间。\nrtp-timeout-sec rtp超时秒数 rtp-hold-timeout-sec rtphold超时秒数 \u0026lt;param name=\u0026#34;rtp-timeout-sec\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;rtp-hold-timeout-sec\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; sofia profile internal restart\nfs 配置多租户分机 分机的相关配置都是位于conf/directory目录中, 我的directory目录中只有一个default.xml文件\n\u0026lt;include\u0026gt; \u0026lt;domain name=\u0026#34;123.cc\u0026#34;\u0026gt; \u0026lt;user id=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user id=\u0026#34;1001\u0026#34;\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/domain\u0026gt; \u0026lt;domain name=\u0026#34;abc.cc\u0026#34;\u0026gt; \u0026lt;user id=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user id=\u0026#34;1001\u0026#34;\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/domain\u0026gt; \u0026lt;/include\u0026gt; fs状态转移图 ","permalink":"https://wdd.js.org/freeswitch/tips/","summary":"安装单个模块 make mod_sofia-install make mod_ilbc-install fs-cli事件订阅 /event plain ALL /event plain CHANNEL_ANSWER sofia 帮助文档 sofia help USAGE: -------------------------------------------------------------------------------- sofia global siptrace \u0026lt;on|off\u0026gt; sofia capture \u0026lt;on|off\u0026gt; watchdog \u0026lt;on|off\u0026gt; sofia profile \u0026lt;name\u0026gt; [start | stop | restart | rescan] [wait] flush_inbound_reg [\u0026lt;call_id\u0026gt; | \u0026lt;[user]@domain\u0026gt;] [reboot] check_sync [\u0026lt;call_id\u0026gt; | \u0026lt;[user]@domain\u0026gt;] [register | unregister] [\u0026lt;gateway name\u0026gt; | all] killgw \u0026lt;gateway name\u0026gt; [stun-auto-disable | stun-enabled] [true | false]] siptrace \u0026lt;on|off\u0026gt; capture \u0026lt;on|off\u0026gt; watchdog \u0026lt;on|off\u0026gt; sofia \u0026lt;status|xmlstatus\u0026gt; profile \u0026lt;name\u0026gt; [reg [\u0026lt;contact str\u0026gt;]] | [pres \u0026lt;pres str\u0026gt;] | [user \u0026lt;user@domain\u0026gt;] sofia \u0026lt;status|xmlstatus\u0026gt; gateway \u0026lt;name\u0026gt; sofia loglevel \u0026lt;all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa|sresolv|stun\u0026gt; [0-9] sofia tracelevel \u0026lt;console|alert|crit|err|warning|notice|info|debug\u0026gt; sofia help -------------------------------------------------------------------------------- 开启消息头压缩 \u0026lt;param name=\u0026#34;enable-compact-headers\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; fs需要重启","title":"FS常用运维手册"},{"content":"查看FS支持的编码 show codec 编码设置 vars.xml\nglobal_codec_prefs=G722,PCMU,PCMA,GSM outbound_codec_prefs=PCMU,PCMA,GSM 查看FS使用的编码 \u0026gt; sofia status profile internal CODECS IN ILBC,PCMU,PCMA,GSM CODECS OUT ILBC,PCMU,PCMA,GSM \u0026gt; sofia status profile external CODECS IN ILBC,PCMU,PCMA,GSM CODECS OUT ILBC,PCMU,PCMA,GSM 使修改后的profile生效 \u0026gt; sofia profile internal rescan \u0026gt; sofia profile external rescan 重启profile \u0026gt; sofia profile internal restart \u0026gt; sofia profile external restart ","permalink":"https://wdd.js.org/freeswitch/media-settings/","summary":"查看FS支持的编码 show codec 编码设置 vars.xml\nglobal_codec_prefs=G722,PCMU,PCMA,GSM outbound_codec_prefs=PCMU,PCMA,GSM 查看FS使用的编码 \u0026gt; sofia status profile internal CODECS IN ILBC,PCMU,PCMA,GSM CODECS OUT ILBC,PCMU,PCMA,GSM \u0026gt; sofia status profile external CODECS IN ILBC,PCMU,PCMA,GSM CODECS OUT ILBC,PCMU,PCMA,GSM 使修改后的profile生效 \u0026gt; sofia profile internal rescan \u0026gt; sofia profile external rescan 重启profile \u0026gt; sofia profile internal restart \u0026gt; sofia profile external restart ","title":"FreeSWITCH 媒体相关操作"},{"content":"复制文本到剪贴板 sudo apt install xclip vim ~/.zshrc\nalias copy=\u0026#39;xclip -selection clipboard\u0026#39; 这样我们就可以用copy命令来考本文件内容到系统剪贴板了。\ncopy aaa.txt 判断工作区是否clean if [ -z \u0026#34;$(git status --porcelain)\u0026#34; ]; then # Working directory clean else # Uncommitted changes fi ","permalink":"https://wdd.js.org/posts/2022/shell-101/","summary":"复制文本到剪贴板 sudo apt install xclip vim ~/.zshrc\nalias copy=\u0026#39;xclip -selection clipboard\u0026#39; 这样我们就可以用copy命令来考本文件内容到系统剪贴板了。\ncopy aaa.txt 判断工作区是否clean if [ -z \u0026#34;$(git status --porcelain)\u0026#34; ]; then # Working directory clean else # Uncommitted changes fi ","title":"Shell 教程技巧"},{"content":"开启coredump #如果该命令的返回值是0，则表示不开启coredump ulimit -c # 开启coredump ulimit -c unlimited 准备c文件 #include\u0026lt;stdio.h\u0026gt; void crash() { char * p = NULL; *p = 0; } int main(){ printf(\u0026#34;hello world 1\u0026#34;); int phone [4]; phone[232] = 12; crash(); return 0; } 编译执行 gcc -g hello.c -o hello ./hello 之后程序崩溃，产生core文件。\ngdb分析 gdb 启动的二进制文件 core文件\ngdb ./hello ./core 之后输入： bt full 可以查看到更详细的信息\n➜ c-sandbox gdb ./hello ./core GNU gdb (Raspbian 7.12-6) 7.12.0.20161007-git Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;arm-linux-gnueabihf\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... Reading symbols from ./hello...done. [New LWP 25571] Core was generated by `./hello\u0026#39;. Program terminated with signal SIGSEGV, Segmentation fault. #0 0x0001045c in crash () at hello.c:6 6 *p = 0; (gdb) bt full #0 0x0001045c in crash () at hello.c:6 p = 0x0 #1 0x00010490 in main () at hello.c:13 phone = {66328, 0, 0, 0} ","permalink":"https://wdd.js.org/posts/2022/c-and-gdb/","summary":"开启coredump #如果该命令的返回值是0，则表示不开启coredump ulimit -c # 开启coredump ulimit -c unlimited 准备c文件 #include\u0026lt;stdio.h\u0026gt; void crash() { char * p = NULL; *p = 0; } int main(){ printf(\u0026#34;hello world 1\u0026#34;); int phone [4]; phone[232] = 12; crash(); return 0; } 编译执行 gcc -g hello.c -o hello ./hello 之后程序崩溃，产生core文件。\ngdb分析 gdb 启动的二进制文件 core文件\ngdb ./hello ./core 之后输入： bt full 可以查看到更详细的信息\n➜ c-sandbox gdb ./hello ./core GNU gdb (Raspbian 7.12-6) 7.12.0.20161007-git Copyright (C) 2016 Free Software Foundation, Inc.","title":"C和gdb调试"},{"content":"oh my tmux 关闭第二键ctrl-a ctrl-a可以用来移动光标到行首的，不要作为tmux的第二键\nset -gu prefix2 unbind C-a Tmux reload config :source-file ～/.tmux.conf tmux 显示时间 ctrl b + t tmux从当前目录打开新的窗口 bind \u0026#39;\u0026#34;\u0026#39; split-window -c \u0026#34;#{pane_current_path}\u0026#34; bind % split-window -h -c \u0026#34;#{pane_current_path}\u0026#34; bind c new-window -c \u0026#34;#{pane_current_path}\u0026#34; ","permalink":"https://wdd.js.org/posts/2022/tmux-faq/","summary":"oh my tmux 关闭第二键ctrl-a ctrl-a可以用来移动光标到行首的，不要作为tmux的第二键\nset -gu prefix2 unbind C-a Tmux reload config :source-file ～/.tmux.conf tmux 显示时间 ctrl b + t tmux从当前目录打开新的窗口 bind \u0026#39;\u0026#34;\u0026#39; split-window -c \u0026#34;#{pane_current_path}\u0026#34; bind % split-window -h -c \u0026#34;#{pane_current_path}\u0026#34; bind c new-window -c \u0026#34;#{pane_current_path}\u0026#34; ","title":"Tmux 常见问题以及解决方案"},{"content":"修改coc-vim的错误提示 coc-vim的错误提示窗口背景色是粉红，前景色是深红。这样的掩饰搭配，很难看到具体的文字颜色。\n所以我们需要把前景色改成白色。\n:highlight CocErrorFloat ctermfg=White 参考 https://stackoverflow.com/questions/64180454/how-to-change-coc-nvim-floating-window-colors\nvim go一直卡在初始化 有可能没有安装二进制工具\n:GoInstallBinaries neovim 光标变成细线解决方案 :set guicursor= ","permalink":"https://wdd.js.org/vim/vim-faq/","summary":"修改coc-vim的错误提示 coc-vim的错误提示窗口背景色是粉红，前景色是深红。这样的掩饰搭配，很难看到具体的文字颜色。\n所以我们需要把前景色改成白色。\n:highlight CocErrorFloat ctermfg=White 参考 https://stackoverflow.com/questions/64180454/how-to-change-coc-nvim-floating-window-colors\nvim go一直卡在初始化 有可能没有安装二进制工具\n:GoInstallBinaries neovim 光标变成细线解决方案 :set guicursor= ","title":"Vim 常见问题以及解决方案"},{"content":"我承认，vscode很香，但是vim的开发方式也让我无法割舍。\nvscode中有个vim插件，基本上可以满足大部分vim的功能。\n这里我定义了我在vim常用的leader快捷键。\n设置,为默认的leader \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, 在Normal模式能comand+c复制 \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-c\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-v\u0026gt;\u0026#34;: false }, leader快捷键 在插入模式安jj会跳出插入模式 ,a: 跳到行尾部，并进入插入模式 ,c: 关闭当前标签页 ,C: 关闭其他标签页 ,j: 跳转到左边标签页 ,k: 跳转到右边标签页 ,w: 保存文件 ,t: 给出提示框 ,b: 显示或者隐藏文件树窗口 完整的配置 \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;vim.insertModeKeyBindings\u0026#34;: [ { \u0026#34;before\u0026#34;: [ \u0026#34;j\u0026#34;, \u0026#34;j\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34; ] } ], \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-c\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-v\u0026gt;\u0026#34;: false }, \u0026#34;vim.normalModeKeyBindingsNonRecursive\u0026#34;: [ { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;a\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;c\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.action.closeActiveEditor\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;C\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.action.closeOtherEditors\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;j\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.action.previousEditor\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;k\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.action.nextEditor\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;w\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.action.files.save\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;t\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;editor.action.showHover\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;b\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.action.toggleSidebarVisibility\u0026#34; ] }, ] ","permalink":"https://wdd.js.org/vim/vscode-vim/","summary":"我承认，vscode很香，但是vim的开发方式也让我无法割舍。\nvscode中有个vim插件，基本上可以满足大部分vim的功能。\n这里我定义了我在vim常用的leader快捷键。\n设置,为默认的leader \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, 在Normal模式能comand+c复制 \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-c\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-v\u0026gt;\u0026#34;: false }, leader快捷键 在插入模式安jj会跳出插入模式 ,a: 跳到行尾部，并进入插入模式 ,c: 关闭当前标签页 ,C: 关闭其他标签页 ,j: 跳转到左边标签页 ,k: 跳转到右边标签页 ,w: 保存文件 ,t: 给出提示框 ,b: 显示或者隐藏文件树窗口 完整的配置 \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;vim.insertModeKeyBindings\u0026#34;: [ { \u0026#34;before\u0026#34;: [ \u0026#34;j\u0026#34;, \u0026#34;j\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34; ] } ], \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-c\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-v\u0026gt;\u0026#34;: false }, \u0026#34;vim.normalModeKeyBindingsNonRecursive\u0026#34;: [ { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;a\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;leader\u0026gt;\u0026#34;, \u0026#34;c\u0026#34; ], \u0026#34;commands\u0026#34;: [ \u0026#34;workbench.","title":"vscode vim插件自定义快捷键"},{"content":"neovim如何与系统剪贴板交互？ neovim和系统剪贴板的交互方式和vim的机制是不同的，所以不要先入为主的用vim的方式使用neovim。\nneovim需要外部的程序与系统剪贴板进行交互，参考:help clipboard\nneovim按照如下的优先级级方式选择交互程序：\n- |g:clipboard| - pbcopy, pbpaste (macOS) - wl-copy, wl-paste (if $WAYLAND_DISPLAY is set) - xclip (if $DISPLAY is set) - xsel (if $DISPLAY is set) - lemonade (for SSH) https://github.com/pocke/lemonade - doitclient (for SSH) http://www.chiark.greenend.org.uk/~sgtatham/doit/ - win32yank (Windows) - termux (via termux-clipboard-set, termux-clipboard-set) - tmux (if $TMUX is set) 因为我的操作系统是linux, 所以方便的方式是直接安装xclip。\nsudo pacman -Syu xclip 两个系统剪贴板有何不同？ 对于windows和mac来说，只有有一个系统剪贴板，对于linux有两个。\n剪贴板，鼠标选择剪贴板 剪贴板，选择之后复制剪贴板 如下图，我用鼠标选择了12345, 但是没有按ctrl + c, 这时候你打开nvim， 执行:reg, 可以看到注册器\n\u0026#34;* 12345 如果按了ctrl + c\n\u0026#34;* 12345 \u0026#34;+ 12345 所以，在vim中如果想粘贴系统剪贴板中的内容，可以是用 C-R * 或者 C-R +\n如何把vim buffer中的全部内容复制到系统剪贴板? :%y+ ","permalink":"https://wdd.js.org/vim/clipboard/","summary":"neovim如何与系统剪贴板交互？ neovim和系统剪贴板的交互方式和vim的机制是不同的，所以不要先入为主的用vim的方式使用neovim。\nneovim需要外部的程序与系统剪贴板进行交互，参考:help clipboard\nneovim按照如下的优先级级方式选择交互程序：\n- |g:clipboard| - pbcopy, pbpaste (macOS) - wl-copy, wl-paste (if $WAYLAND_DISPLAY is set) - xclip (if $DISPLAY is set) - xsel (if $DISPLAY is set) - lemonade (for SSH) https://github.com/pocke/lemonade - doitclient (for SSH) http://www.chiark.greenend.org.uk/~sgtatham/doit/ - win32yank (Windows) - termux (via termux-clipboard-set, termux-clipboard-set) - tmux (if $TMUX is set) 因为我的操作系统是linux, 所以方便的方式是直接安装xclip。\nsudo pacman -Syu xclip 两个系统剪贴板有何不同？ 对于windows和mac来说，只有有一个系统剪贴板，对于linux有两个。\n剪贴板，鼠标选择剪贴板 剪贴板，选择之后复制剪贴板 如下图，我用鼠标选择了12345, 但是没有按ctrl + c, 这时候你打开nvim， 执行:reg, 可以看到注册器","title":"和系统剪贴板进行交互"},{"content":"在vscode中，可以选中一个目录，然后在目录中搜索对应的关键词，再查找到对应文件中，然后做替换。\n在vim也可以这样做。\n但是这件事要分成两步。\n根据关键词，查找文件 对多个文件进行替换 搜索关键词 搜索关键词可以用grep, 或者vim自带的vimgrep。\n但是我更喜欢用ripgrep，因为速度很快。\nripgrep也有对应的vim插件 https://github.com/jremmen/vim-ripgrep\n例如要搜索关键词 key1, 那么符合关键词的文件将会被放到quickfix列表中。\n:Rg key1 可以用 :copen 来打开quickfix列表。\n替换 cdo :cdo %s/key1/key2/gc c表示在替换的时候，需要手工确认每一项。\n在替换的时候，可以输入\ny (yes)执行替换 n (no)忽略此处替换 a (all)替换此处和之后的所有项目 q (quit) 退出替换过程 l (last) 替换此处后退出 ^E 向上滚动屏幕 ^Y 向下滚动屏幕 ","permalink":"https://wdd.js.org/vim/search-dir-replace/","summary":"在vscode中，可以选中一个目录，然后在目录中搜索对应的关键词，再查找到对应文件中，然后做替换。\n在vim也可以这样做。\n但是这件事要分成两步。\n根据关键词，查找文件 对多个文件进行替换 搜索关键词 搜索关键词可以用grep, 或者vim自带的vimgrep。\n但是我更喜欢用ripgrep，因为速度很快。\nripgrep也有对应的vim插件 https://github.com/jremmen/vim-ripgrep\n例如要搜索关键词 key1, 那么符合关键词的文件将会被放到quickfix列表中。\n:Rg key1 可以用 :copen 来打开quickfix列表。\n替换 cdo :cdo %s/key1/key2/gc c表示在替换的时候，需要手工确认每一项。\n在替换的时候，可以输入\ny (yes)执行替换 n (no)忽略此处替换 a (all)替换此处和之后的所有项目 q (quit) 退出替换过程 l (last) 替换此处后退出 ^E 向上滚动屏幕 ^Y 向下滚动屏幕 ","title":"搜索工作目录下的文件并替换"},{"content":" Info C表示按住Ctrl, C-o表示同时按住Ctrl和o 1. 在tmux中 vim-airline插件颜色显示不正常 解决方案：\nexport TERM=screen-256color 2. buffer相关操作 :ls # 显示所有打开的buffer :b {bufferName} #支持tab键自动补全 :bd # 关闭当前buffer :bn # 切换到下一个buffer :bp # 切换到上一个buffer :b# # 切换到上一个访问过的buffer :b1 # 切换到buffer1 :bm # 切换到最近修改过的buffer :sb {bufferName} # 上下分屏 :vert sb {bufferName} # 左右分屏 3. 跳转到对应的符号上 下面这种符号，一般都是成双成对的，只要在其中一个上按%, 就会自动跳转到对应的符号\n() [] {} 4. 关闭netrw的banner 如果熟练的是用了netrw，就可以把默认开启的banner给关闭掉。\nlet g:netrw_banner = 0 let g:netrw_liststyle = 3 let g:netrw_winsize = 25 5. 如何同时保存所有发生变化的文件？ 把所有发生变化的文件给保存 :wa 把所有发生变化的文件都保存，然后退出vim :xa 退出vim, 所有发生变化的文件都不保存，:qa! 6. 插入当前时间 :r!date 7. 光标下的文件跳转 按gf可以跳转光标下的文件\nimport {say} from \u0026#39;./api\u0026#39; 也有可能跳的不准确，或者找不到，因为vim不知道文件后缀\n:set suffixesadd+=.js 8. 文件对比 如果你安装了vim, vimdiff就会自动携带\nvimdiff a.txt b.txt 9. 在插入模式快速删除 C-h 删除前一个字符 C-w 删除前一个单词 C-u 删除到行首 10. 在多行末尾增加特定的字符 例如下面的命令，可以在多行末尾增加;\n:%s/$/;/ 11. 对撤销进行撤销 u可以用来撤销，C-r可以用来对撤销进行撤销\n12. 重新读取文件 假如你对一个文件进行了一些修改，但是还没有保存，这是你想丢弃这些修改，如果用撤销的话，太麻烦。\n你可以用下面的命令，让vim重新读取磁盘上的文件，覆盖当前buffer中的文件。\n:e! 13. 对当前buffer执行外部命令 例如对go代码进行格式化\n:!go fmt % 也可以是一个json文件，我们可以用行选中之后执行:'\u0026lt;,'\u0026gt;!jq, 如果需要对全文进行json格式化，可以使用:%!jq\n{\u0026#34;name\u0026#34;:\u0026#34;wdd\u0026#34;,\u0026#34;age\u0026#34;:1} { \u0026#34;name\u0026#34;: \u0026#34;wdd\u0026#34;, \u0026#34;age\u0026#34;: 1 } Warning !和命令之间不能有空格 14. 只读模式打开文件 只读模式打开文件: vim -R file 禁止修改打开文件: vim -M file 15. 显示或者隐藏特殊字符 :set list :set nolist 16. 把另一个文件读取到当前buffer里面 b.txt是另一个文件\n# 读取到光标的位置 :read b.txt # 读区到当前buffer的开头 :0read b.txt # 读区到当前buffer的结尾 :$read b.txt 17. 把当前文件的一部分写入到另一个文件中 # 把当前文件写入到c.txt, 如果c.txt存在，则写入失败 :write c.txt # 把当前文件写入到c.txt, 如果c.txt存在，则强制写入 # 注意这里!必须紧跟着write, 并且空格是必须的，否则就是执行外部命令了 :write! c.txt # 把当前文件的当前行到文件末尾写入到c.txt :.$write c.txt # 把当前文件以追加的方式写入到另一个文件中 :write \u0026gt;\u0026gt;c.txt 18. 自带文件浏览器的必背命令 :Sex # 文件浏览器上下分布 :Vex # 文件浏览器左右分布 F1 打开帮助信息 % 创建文件 d 创建目录 D 删除文件或者目录 R 文件重命名 gh 隐藏以.开头的文件 返回上一级 t 用新的标签页面页面打开文件 c 把浏览的目录设置为当前工作的目录 19. 执行命令后，快速进入插入模式 C 从光标处删除到行尾，然后进入插入模式 S 清空当前行的内容，然后进入插入模式 s 删除光标下的字符，然后进入插入模式 O\t在当前行上插入一行，然后进入插入模式 o\t在当前行下插入一行，然后进入插入模式 I\t光标移动当当前行的一个字符前，然后进入插入模式 A\t贯标移动到当前航的最后一个字符后，然后进入插入模式 20. 必会的几个寄存器 有名寄存器 a-z 黑洞寄存器 _ 表达式寄存器 = 当前文件名寄存器 % 上次查找的模式寄存器 / 复制专用寄存器 0 C-r 是用来调用寄存器的。比如说我想粘贴当前文件名，我只需要按C-r %, 就可以自动粘贴到当前的文件中\n21. 基于tag的跳转 C-] 跳到对应tag上 C-o 跳回来 C-t 跳回来 C-w ] 在新的window中打开标签 C-w } 预览 pclose 关闭预览 22. html标签删除 dit 删除标签内部的元素 dat 删除标签 23. 原始格式粘贴 如果粘贴到vim中的文本缩进出现问题，\n:set paste 然后再执行C-v粘贴\n取消粘贴模式用 :set nopaste\n24. 按列删除或者按列保留 # 只保留第二列 :%!awk \u0026#39;{print $2}\u0026#39; # 删除第二列 :%!awk \u0026#39;{$2=\u0026#34;\u0026#34;;print $0}\u0026#39; 25. 查找多个关键词 /key1\\|key2\\|key3 26. 快速将光标所在行移动到屏幕中央 zz 26. 窗口快捷键 工作区切分窗口命令 s 水平切分窗口，新窗口仍然显示当前缓冲区 v 垂直切分窗口，新窗口仍然显示当前缓冲区 sp {file} 水平切分为当前窗口，新窗口中载入file vsp {file} 垂直切分窗口，并在新窗口载入file 窗口之间切换 w 在窗口间循环切换 h 切换到左边窗口 l 切换到右边窗口 j 切换到下边的窗口 k 切换到上边的窗口 窗口关闭 :clo[se] 关闭活动窗口 :on[ly] 关闭其他窗口 窗口改变大小 = 使所有窗口等宽等高 _ 最大化活动窗口的高度 | 最大化活动 27. 9种插入模式 i 进入插入模式，所输入新的内容将会在正常模式所在光标的前面 a 进入插入模式，所输入的新的内容将会在正常模式所在光标的后面 你知道从插入模式退出的时候，光标会向前移动一个字符吗？\n进入插入模式的技巧\ni 在光标前插入 a 在光标后插入 A 在行的末尾进入插入 I (大写的i), 在行的第一个非空白字符前进入插入模式 C 删除光标后的所有字符，然后进入插入模式 s 删除光标后的一个字符，然后进入插入模式 S 清空当前行，然后进入插入模式 o 在当前行的下面一行新建一行，并进入插入模式 O 在当前行的上面一行新建一行，并进入插入模式 28. 算数运算 ctrl a 对数字进行加运算， 如果光标不在数字上，将会自动向后移动道对应的数字上 ctrl x 对数字进行减运算 29. 可视模式快捷键 v 激活面向字符的可视模式 再按一次，可以退出 V 激活面向行的可视模式， 再按一次可以退出 ctrl v 激活面向列的可视模式 gv 重选上次的选区 o 移动选区的端点 30. 把光标所在的单词插入到Ex C-r C-w 31. 全局 文件另存为 :saveas filename 关闭当前窗口 :close 32. 光标移动 移动光标到页面顶部，中部，底部 H,M,L 移动到下个单词开头，结尾 w,e 移动到上个单词开头 b 移动光标 上下左右 k,j,h,l 移动到匹配的括号 % 移动到行首 0 移动到行首非空白字符 ^ 移动到行尾非空白字符 g 移动到行尾 $ 移动到文件第一行 gg 移动到文件最后一行 G 移动到第10行 10G 移动屏幕使光标居中 zz 跳转到上一次的位置 ctrl+o 例如你在159行，然后你按了gg, 光标调到了第一行，然后你按ctrl+o, 光标会回到159行 跳转到下一次的位置 ctrl+i 跳转到下个同样单词的地方 * 跳转到上个同样单词的地方 # 跳到字符a出现的位置 fa, Fa 调到字符a出现的前一个位置 ta, Ta 跳到之前的位置 `` 跳到之前修改的位置 `. 跳到选区的起始位置 `\u0026lt; 跳到选区的结束位置 `\u0026gt; 33. 滚动屏幕 向下，向上滚动一屏 ctrl+b, ctrl+f 向下，向上滚动半屏 ctrl+d, ctrl+u 34. 插入模式 光标前、后插入 i，a 行首，行尾插入 I, A 在当前行上、下另一起行插入 O, o 从当前单词末尾插入 ea 退出插入模式 esc 删除前一个单词 ctrl+w 删除到行首 ctrl+u 35. 编辑 替换光标下的字符 r 将下一行合并到当前行 J 将下一行合并到当前行，并一种中间的空白字符 gJ 清空当前行，并进入插入模式 cc 清空当前单词，并进入插入模式 cw 撤销修改 u 删除光标下的一个字符，然后进入插入模式 s 36. 选择文本 普通光标选择, 进入选择文本模式 v 行选择，进入选择文本模式 V 块选择，进入选择文本模式 ctrl+v 在多行行首插入注释# ctrl+v 然后选择快，然后输入I, 然后输入#， 然后按esc 注意，输入I指令时，光标只会定位到一个位置，编辑的内容也只是在一个位置，但是按了esc后，多行都会出现# 进入选择文本模式之后 选择光标所在单词（光标要先位于单词上） aw 选择光标所在()区域，包括()， 光标要先位于一个括号上 ab 选择光标所在[]区域，包括[], 光标要先位于一个括号上 aB 选择光标所在()区域，不包括()， 光标要先位于一个括号上 ib 选择光标所在[]区域，不包括[], 光标要先位于一个括号上 iB 退出可视化区域 esc 37. 选择文本命令 向左右缩进 \u0026lt;, \u0026gt; 复制 y 剪切 d 大小写转换 ~ 38. 标记 显示标记列表 :marks 标记当前位置为a ma 跳转到标记a的位置 `a 39. 剪切删除 剪切当前行 dd 剪切2行 2dd 剪切当前单词 dw 从光标所在位置剪切到行尾 D, d$ 剪切当前字符 x 删除单引号中的内容 di\u0026rsquo; da’ 删除包括' 删除双引号中的内容 di\u0026quot; da\u0026quot; 删除包括\u0026quot; 删除中括号中的内容 di[ da[ 删除包括[ 删除大括号中的内容 di{ da{ 删除包括{ 删除括号中的内容 di( da( 删除包含( 从当前光标位置，删除到到字符a dta 40. global命令 删除所有不包含匹配项的文本行 :v/re/d re可以是字符，也可以是正则 显示所有不包含匹配项的文本行 :v/re/p re可以是字符，也可以是正则 删除包含匹配项的行 :g/re/d re可以是字符，也可以是正则 显示所有包含匹配项的行 :g/re/p re可以是字符，也可以是正则 41. 文本对象 当前单词 iw 当前单词和一个空格 aw 当前句子 is 当前句子和一个空格 as 当前段落 ip 当前段落和一个空行 ap 一对圆括号 a) 或 ab 圆括号内部 i) 或 ib 一对花括号 a}或 aB 花括号内部 i}或 iB a表示匹配两点和两点之间的字符), }, ], \u0026gt; , ‘, “, `, t(xml) i表示匹配两点内部之间的字符 42. 复制 复制当前行 yy 复制2行 2yy 复制当前单词 yw 从光标所在位置复制到行尾 y$ 复制单引号中的内容 yi\u0026rsquo; ya\u0026rsquo; 复制包括' 复制双引号中的内容 yi\u0026quot; ya” 复制包括\u0026quot; 复制中括号中的内容 yi[ ya[ 复制包括[ 复制大括号中的内容 yi{ ya{ 复制包括{ 43. 粘贴 在光标后粘贴 p 在光标前粘贴 P 44. 保存退出 保存 w 保存并退出 wq 不保存退出 q! 保存所有tab页并退出 wqa 46. 查找 向下查找key /key 向上查找key ?key 下一个key n 上一个key N 移除搜索结果高亮 :noh 设置搜索高亮 :set hlsearch 统计当前模式匹配的个数 :%s///gn 47. 字符串替换 全文将old替换为new %s/old/new/g 全文将old替换为new, 但是会一个一个确认 %s/old/new/gc 48. 多文件搜索 多文件搜索 :vimgrep /key/ {file} vimgrep /export/ */ 切换到下一个文件 cn 切换到上一个文件 cp 查看搜索结果列表 copen 查看文件缓冲区 :ls 49. 窗口分割 水平分割窗口 :split 默认split仅针对当前文件，如果在新窗口打开新的文件，可以：split file 垂直分割窗口 :vsplit 打开空白的窗口 :new 关闭分割的窗口 ctrl+wq, :close 有时候ctrl+wq不管用，需要用close 窗口之间切换 ctrl+ww 切换到左边窗口 ctrl+wh 切换到右边窗口 ctrl+wl 切换到下边窗口 ctrl+wj 切换到上边窗口 ctrl+wk 关闭所有窗口 :qall 这表示 \u0026ldquo;quit all\u0026rdquo; (全部退出)。如果任何一个窗口没有存盘，Vim 都不会退出。同时光 标会自动跳到那个窗口，你可以用 \u0026ldquo;:write\u0026rdquo; 命令保存该文件或者 \u0026ldquo;:quit!\u0026rdquo; 放弃修改。 保存所有窗口修改后的内容 :wall 如果你知道有窗口被改了，而你想全部保存 关闭所有窗口，放弃所有修改 :qall! 注意，这个命令是不能撤销的。 保存所有修改，然后退出vim :wqall 窗口更多内容 http://vimcdoc.sourceforge.net/doc/usr_08.html#usr_08.txt\n50. 宏 录制宏a qa 停止录制宏 q 51. 标签页 新建标签页 tabnew 在新标签页中打开file tabnew file 切换到下个标签页 gt 切换到上个标签页 gT 关闭当前标签页 :tabclose, :tabc 关闭其他标签页 :tabo, :tabonly 在所有标签页中执行命令 :tabdo commad :tabdo w 52. 文本折叠 折叠文本内容 zfap http://vimcdoc.sourceforge.net/doc/usr_28.html#usr_28.txt 打开折叠 zo 关闭折叠 zc 展开所有折叠 zr 打开所有光标行上的折叠用 zO 关闭所有光标行上的折叠用 zC 删除一个光标行上的折叠用 zd 删除所有光标行上的折叠用 zD 53. 设置 设置vim编辑器的宽度 set columns=200 54. 自动补全 使用自动补全的下一个列表项 ctrl+n 使用自动补全的上一个列表项 ctrl+p 确认当前选择项 ctrl+y 还原最早输入项 ctrl+e 55. 杂项 在vim中执行外部命令 :!ls -al 查看当前光标所在行与百分比 ctrl+g 挂起vim, 使其在后台运行 ctrl+z 查看后台挂起的程序 jobs 使挂起的vim前台运行 fg 如果有多个后台挂起的任务， 则需要指定任务序号，如 ：fg %1 在每行行尾添加字符串abc :%s/$/abc 在每行行首添加字符串abc :%s/^/abc 每行行尾删除字符串abc :%s/$/abc 每行行首删除字符串abc :%s/^/abc 删除含有abc字符串的行 :g/abc/d 删除每行行首到特定字符的内容，非贪婪匹配 : %s/^.{-}abc// var = abc123, 会删除var = abc 调换当前行和它的下一行 ddp 全文格式化 gg 跳到第一行 shift v shift g = 参考\nhttps://vim.rtorr.com/lang/zh_cn http://vimcdoc.sourceforge.net/doc/help.html https://www.oschina.net/translate/learn-vim-progressively ","permalink":"https://wdd.js.org/vim/vim-tips/","summary":"Info C表示按住Ctrl, C-o表示同时按住Ctrl和o 1. 在tmux中 vim-airline插件颜色显示不正常 解决方案：\nexport TERM=screen-256color 2. buffer相关操作 :ls # 显示所有打开的buffer :b {bufferName} #支持tab键自动补全 :bd # 关闭当前buffer :bn # 切换到下一个buffer :bp # 切换到上一个buffer :b# # 切换到上一个访问过的buffer :b1 # 切换到buffer1 :bm # 切换到最近修改过的buffer :sb {bufferName} # 上下分屏 :vert sb {bufferName} # 左右分屏 3. 跳转到对应的符号上 下面这种符号，一般都是成双成对的，只要在其中一个上按%, 就会自动跳转到对应的符号\n() [] {} 4. 关闭netrw的banner 如果熟练的是用了netrw，就可以把默认开启的banner给关闭掉。\nlet g:netrw_banner = 0 let g:netrw_liststyle = 3 let g:netrw_winsize = 25 5. 如何同时保存所有发生变化的文件？ 把所有发生变化的文件给保存 :wa 把所有发生变化的文件都保存，然后退出vim :xa 退出vim, 所有发生变化的文件都不保存，:qa!","title":"1001个Vim高级技巧 - 0-55"},{"content":"增加mermaid shortcodes 在themes/YourTheme/layouts/shortcodes/mermaid.html 增加如下内容\n\u0026lt;script async type=\u0026#34;application/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js\u0026#34;\u0026gt; var config = { startOnLoad:true, theme:\u0026#39;{{ if .Get \u0026#34;theme\u0026#34; }}{{ .Get \u0026#34;theme\u0026#34; }}{{ else }}dark{{ end }}\u0026#39;, align:\u0026#39;{{ if .Get \u0026#34;align\u0026#34; }}{{ .Get \u0026#34;align\u0026#34; }}{{ else }}center{{ end }}\u0026#39; }; mermaid.initialize(config); \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; 在blog中增加如下代码 Warning 注意下面的代码，你在实际写的时候，要把 /* 和 */ 删除 {{/*\u0026lt; mermaid align=\u0026#34;left\u0026#34; theme=\u0026#34;neutral\u0026#34; */\u0026gt;}} pie title French Words I Know \u0026#34;Merde\u0026#34; : 50 \u0026#34;Oui\u0026#34; : 35 \u0026#34;Alors\u0026#34; : 10 \u0026#34;Non\u0026#34; : 5 {{/*\u0026lt; /mermaid \u0026gt;*/}} pie title French Words I Know \"Merde\" : 50 \"Oui\" : 35 \"Alors\" : 10 \"Non\" : 5 sequenceDiagram title French Words I Know autonumber Alice-\u003e\u003eBob: hello Bob--\u003e\u003eAlice: hi Alice-\u003eBob: talking ","permalink":"https://wdd.js.org/posts/2022/02-hugo-add-mermaid/","summary":"增加mermaid shortcodes 在themes/YourTheme/layouts/shortcodes/mermaid.html 增加如下内容\n\u0026lt;script async type=\u0026#34;application/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js\u0026#34;\u0026gt; var config = { startOnLoad:true, theme:\u0026#39;{{ if .Get \u0026#34;theme\u0026#34; }}{{ .Get \u0026#34;theme\u0026#34; }}{{ else }}dark{{ end }}\u0026#39;, align:\u0026#39;{{ if .Get \u0026#34;align\u0026#34; }}{{ .Get \u0026#34;align\u0026#34; }}{{ else }}center{{ end }}\u0026#39; }; mermaid.initialize(config); \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; 在blog中增加如下代码 Warning 注意下面的代码，你在实际写的时候，要把 /* 和 */ 删除 {{/*\u0026lt; mermaid align=\u0026#34;left\u0026#34; theme=\u0026#34;neutral\u0026#34; */\u0026gt;}} pie title French Words I Know \u0026#34;Merde\u0026#34; : 50 \u0026#34;Oui\u0026#34; : 35 \u0026#34;Alors\u0026#34; : 10 \u0026#34;Non\u0026#34; : 5 {{/*\u0026lt; /mermaid \u0026gt;*/}} pie title French Words I Know \"","title":"hugo博客增加mermaid 绘图插件"},{"content":" 序号 书名 3 4 5 6 7 8 9 1 经济学通识课 13 17 2 如何结交比你更优秀的人 29 35 3 人体简史 21 24 4 高效程序员的45个习惯 38 5 一本书看透股权架构 7 9 6 学习之道 16 22 7 梦幻花 0 8 月亮与六便士 21 9 Wireshark 网络分析就这么简单 38 49 10 信息简史 16 18 ","permalink":"https://wdd.js.org/posts/2022/01-reading-plan/","summary":" 序号 书名 3 4 5 6 7 8 9 1 经济学通识课 13 17 2 如何结交比你更优秀的人 29 35 3 人体简史 21 24 4 高效程序员的45个习惯 38 5 一本书看透股权架构 7 9 6 学习之道 16 22 7 梦幻花 0 8 月亮与六便士 21 9 Wireshark 网络分析就这么简单 38 49 10 信息简史 16 18 ","title":"一月份阅读计划"},{"content":"安装gitlab runner 本机安装 之所以要本机安装，是因为要测试方便, 当然也能安装docker版本的。\n参考： - https://docs.gitlab.com/runner/install/\n# 本机安装 参考： - https://docs.gitlab.com/runner/install/linux-repository.html wget https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh chmod +x script.deb.sh # 我是deeepin操作系统，脚本无法识别，需要手工指定 sudo os=debian dist=buster ./script.deb.sh sudo apt-get install gitlab-runner gitlab-runner --h NAME: gitlab-runner - a GitLab Runner USAGE: gitlab-runner [global options] command [command options] [arguments...] VERSION: 14.6.0 (5316d4ac) AUTHOR: GitLab Inc. \u0026lt;support@gitlab.com\u0026gt; 注册runner 参考：\nhttps://docs.gitlab.com/runner/register/ 参考 https://docs.gitlab.com/runner/install/linux-repository.html 快速开始 ","permalink":"https://wdd.js.org/posts/2021/gitlab-ci-cd/","summary":"安装gitlab runner 本机安装 之所以要本机安装，是因为要测试方便, 当然也能安装docker版本的。\n参考： - https://docs.gitlab.com/runner/install/\n# 本机安装 参考： - https://docs.gitlab.com/runner/install/linux-repository.html wget https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh chmod +x script.deb.sh # 我是deeepin操作系统，脚本无法识别，需要手工指定 sudo os=debian dist=buster ./script.deb.sh sudo apt-get install gitlab-runner gitlab-runner --h NAME: gitlab-runner - a GitLab Runner USAGE: gitlab-runner [global options] command [command options] [arguments...] VERSION: 14.6.0 (5316d4ac) AUTHOR: GitLab Inc. \u0026lt;support@gitlab.com\u0026gt; 注册runner 参考：\nhttps://docs.gitlab.com/runner/register/ 参考 https://docs.gitlab.com/runner/install/linux-repository.html 快速开始 ","title":"Gitlab 持续集成记录"},{"content":"要求 [必须] 能够保存密码, 或者用私钥登录 [必须] 能够支持ftp/sftp [必须] 开源免费 [必须] 界面漂亮，支持中文字符 [可选] 支持同步ssh配置 [必须] 支持跨平台 ​\nTabby A terminal for a more modern age (formerly Terminus) https://github.com/Eugeny/tabby https://tabby.sh/ 25.7k Star 基于electron, 主要开发语言typescript\nElecterm Terminal/ssh/sftp client(linux, mac, win) https://github.com/electerm/electerm https://electerm.github.io/electerm/ 4.8k star 基于electron, 主要开发语言javascript\nWindTerm A Quicker and better SSH/Telnet/Serial/Shell/Sftp client for DevOps.\nhttps://github.com/kingToolbox/WindTerm 2.6K star 主要开发语言: C\n","permalink":"https://wdd.js.org/posts/2021/free-ssh-gui-clients/","summary":"要求 [必须] 能够保存密码, 或者用私钥登录 [必须] 能够支持ftp/sftp [必须] 开源免费 [必须] 界面漂亮，支持中文字符 [可选] 支持同步ssh配置 [必须] 支持跨平台 ​\nTabby A terminal for a more modern age (formerly Terminus) https://github.com/Eugeny/tabby https://tabby.sh/ 25.7k Star 基于electron, 主要开发语言typescript\nElecterm Terminal/ssh/sftp client(linux, mac, win) https://github.com/electerm/electerm https://electerm.github.io/electerm/ 4.8k star 基于electron, 主要开发语言javascript\nWindTerm A Quicker and better SSH/Telnet/Serial/Shell/Sftp client for DevOps.\nhttps://github.com/kingToolbox/WindTerm 2.6K star 主要开发语言: C","title":"开源免费的ssh gui clients"},{"content":"web框架 https://github.com/gofiber/fiber http client https://github.com/go-resty/resty mock https://github.com/jarcoal/httpmock 项目结构 https://github.com/golang-standards/project-layout 环境变量操作 https://github.com/caarlos0/env https://github.com/kelseyhightower/envconfig 测试框架 https://github.com/stretchr/testify 日志框架 https://github.com/uber-go/zap html解析 https://github.com/PuerkitoBio/goquery cli工具 https://github.com/urfave/cli 各种库大全集 https://github.com/avelino/awesome-go 终端颜色 https://github.com/fatih/color 剪贴板 https://github.com/atotto/clipboard 数据库驱动 https://github.com/go-sql-driver/mysql 热重载 https://github.com/cosmtrek/air 时间处理 https://github.com/golang-module/carbon 错误封装 https://github.com/pkg/errors 结构体转二进制 https://github.com/lunixbochs/struc VIM智能补全提示 需要安装coc-go, 还有vim-go\n","permalink":"https://wdd.js.org/golang/my-start-repo/","summary":"web框架 https://github.com/gofiber/fiber http client https://github.com/go-resty/resty mock https://github.com/jarcoal/httpmock 项目结构 https://github.com/golang-standards/project-layout 环境变量操作 https://github.com/caarlos0/env https://github.com/kelseyhightower/envconfig 测试框架 https://github.com/stretchr/testify 日志框架 https://github.com/uber-go/zap html解析 https://github.com/PuerkitoBio/goquery cli工具 https://github.com/urfave/cli 各种库大全集 https://github.com/avelino/awesome-go 终端颜色 https://github.com/fatih/color 剪贴板 https://github.com/atotto/clipboard 数据库驱动 https://github.com/go-sql-driver/mysql 热重载 https://github.com/cosmtrek/air 时间处理 https://github.com/golang-module/carbon 错误封装 https://github.com/pkg/errors 结构体转二进制 https://github.com/lunixbochs/struc VIM智能补全提示 需要安装coc-go, 还有vim-go","title":"我常用的第三方库"},{"content":" Error EXTRA *mysql.MySQLError=Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026lsquo;? ( 然而我仔细看了看sql语句，没有看出来究竟哪里有sql报错。\n然而当我把作为placeholder的问号去掉，直接用表的名字，sql是可以直接执行的。我意识到这个可能是和placeholder有关。\n搜索了一下，看到一个链接 https://github.com/go-sql-driver/mysql/issues/848\nPlaceholder can\u0026rsquo;t be used for table name or column name. It\u0026rsquo;s MySQL spec. Not bug of this project.\n大意是说，placeholder是不能作为表名或者列名的。\n在mysql关于prepared文档介绍中，在允许使用prepared的语句里，没有看到create table可以用placeholder https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html\nprepared语句的优点有以下几个\n优化查询速度 防止sql注入 但是也有一些限制\n不是所有语句都能用prepared语句。常见的用法应该是作为select where之后的条件，或者INSERT语句之后的值 不支持一个sql中多条查询语句的形式 ","permalink":"https://wdd.js.org/golang/mysql-placeholder/","summary":" Error EXTRA *mysql.MySQLError=Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026lsquo;? ( 然而我仔细看了看sql语句，没有看出来究竟哪里有sql报错。\n然而当我把作为placeholder的问号去掉，直接用表的名字，sql是可以直接执行的。我意识到这个可能是和placeholder有关。\n搜索了一下，看到一个链接 https://github.com/go-sql-driver/mysql/issues/848\nPlaceholder can\u0026rsquo;t be used for table name or column name. It\u0026rsquo;s MySQL spec. Not bug of this project.\n大意是说，placeholder是不能作为表名或者列名的。\n在mysql关于prepared文档介绍中，在允许使用prepared的语句里，没有看到create table可以用placeholder https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html\nprepared语句的优点有以下几个\n优化查询速度 防止sql注入 但是也有一些限制\n不是所有语句都能用prepared语句。常见的用法应该是作为select where之后的条件，或者INSERT语句之后的值 不支持一个sql中多条查询语句的形式 ","title":"mysql placeholder的错误使用方式"},{"content":"本来打算用gdb调试的，看了官方的文档https://golang.org/doc/gdb， 官方更推荐使用delve这个工具调试。\n我的电脑是linux, 所以就用如下的命令安装。\ngo install github.com/go-delve/delve/cmd/dlv@latest\n我要调试的并不是一个代码而是一个测试的代码。\n当执行测试的时候报错的位置是xxx/demo/demo_test.go, 200行\ndlv test moduleName/demo \u0026gt; b demo_test.go:200 # 在文件的对应行设置端点 \u0026gt; bp # print all breakpoint \u0026gt; c # continue to exe \u0026gt; p variableName ","permalink":"https://wdd.js.org/golang/debug-with-dlv/","summary":"本来打算用gdb调试的，看了官方的文档https://golang.org/doc/gdb， 官方更推荐使用delve这个工具调试。\n我的电脑是linux, 所以就用如下的命令安装。\ngo install github.com/go-delve/delve/cmd/dlv@latest\n我要调试的并不是一个代码而是一个测试的代码。\n当执行测试的时候报错的位置是xxx/demo/demo_test.go, 200行\ndlv test moduleName/demo \u0026gt; b demo_test.go:200 # 在文件的对应行设置端点 \u0026gt; bp # print all breakpoint \u0026gt; c # continue to exe \u0026gt; p variableName ","title":"Debug With Dlv"},{"content":"在线书籍 《Go语言原本》https://golang.design/under-the-hood/ 《Golang修养之路》https://www.kancloud.cn/aceld/golang 《Go语言高性能编程》https://geektutu.com/post/high-performance-go.html 《7天用Go从零实现Web框架Gee教程》https://geektutu.com/post/gee.html 博客关注 https://carlosbecker.com/ https://www.alexedwards.net/blog https://gobyexample.com/ 文章收藏 https://carlosbecker.com/posts/env-structs-golang https://www.alexedwards.net/blog/json-surprises-and-gotchas https://www.alexedwards.net/blog/how-to-manage-database-timeouts-and-cancellations-in-go https://www.alexedwards.net/blog/custom-command-line-flags https://www.alexedwards.net/blog/how-to-properly-parse-a-json-request-body https://www.alexedwards.net/blog/working-with-redis https://www.alexedwards.net/blog/organising-database-access https://www.alexedwards.net/blog/interfaces-explained ","permalink":"https://wdd.js.org/golang/learn-material/","summary":"在线书籍 《Go语言原本》https://golang.design/under-the-hood/ 《Golang修养之路》https://www.kancloud.cn/aceld/golang 《Go语言高性能编程》https://geektutu.com/post/high-performance-go.html 《7天用Go从零实现Web框架Gee教程》https://geektutu.com/post/gee.html 博客关注 https://carlosbecker.com/ https://www.alexedwards.net/blog https://gobyexample.com/ 文章收藏 https://carlosbecker.com/posts/env-structs-golang https://www.alexedwards.net/blog/json-surprises-and-gotchas https://www.alexedwards.net/blog/how-to-manage-database-timeouts-and-cancellations-in-go https://www.alexedwards.net/blog/custom-command-line-flags https://www.alexedwards.net/blog/how-to-properly-parse-a-json-request-body https://www.alexedwards.net/blog/working-with-redis https://www.alexedwards.net/blog/organising-database-access https://www.alexedwards.net/blog/interfaces-explained ","title":"Golang学习资料"},{"content":"手工执行，可以获得预期结果，但是在crontab中，却查不到结果。\nstage_count=$(ack -h \u0026#34;\\- name:\u0026#34; -t yaml | wc -l) 最终使用--nofilter参数，解决了问题。\nstage_count=$(ack --nofilter -h \u0026#34;\\- name:\u0026#34; -t yaml | wc -l) 参考\nhttps://stackoverflow.com/questions/55777520/ack-fails-in-cronjob-but-runs-fine-from-commandline ","permalink":"https://wdd.js.org/shell/contab-ack/","summary":"手工执行，可以获得预期结果，但是在crontab中，却查不到结果。\nstage_count=$(ack -h \u0026#34;\\- name:\u0026#34; -t yaml | wc -l) 最终使用--nofilter参数，解决了问题。\nstage_count=$(ack --nofilter -h \u0026#34;\\- name:\u0026#34; -t yaml | wc -l) 参考\nhttps://stackoverflow.com/questions/55777520/ack-fails-in-cronjob-but-runs-fine-from-commandline ","title":"Ack 在contab中无法查到关键词"},{"content":"我只使用VIM作为主力开发工具，已经快到200天了。聊聊这其中的一些感受。\n对大部分来说，提到文本编辑器，我们可能会想到word, nodepad++, webstorm, sublime, vscode。\n这些GUI工具在给我们提供便利性的同时，也在逐渐固化我们对于编辑器的认知与思维方式。\n闭上眼睛，提到编辑器，你脑海里想到的界面是什么呢？\n左边一个文件浏览窗口 右边一个多标签页的文件编辑窗口 陌生感 想象一下，我们在使用编辑器的时候，哪些动作做的最多\n鼠标移动到文件浏览窗口，通过滚轮的滚动，来选择文件，单击之后，打开一个文件。但是在VIM上，完全没有这种操作。 GUI下可以同时打开多个文件，进行编辑。但是很多人觉得VIM只能打开一个文件，甚至想打开另一个文件的时候，先要退出VIM。即使打开了多个文件，也不知道这些文件要如何切换。 但是当你刚开始使用VIM的时候，可能并没有安装什么插件，这时候你会有以下的一些困惑\n你用VIM打开一个文件后，怎么再打开一个文件呢？因为默认的VIM是没有文件浏览窗口的。你在GUI模式下养成的经验，在VIM上完全无法使用。你可能甚至不知道要怎么退出VIM。所有的一切都那么陌生。\n虚无感 VIM一般都运行在终端之上，给人感觉云里雾里，虚无缥缈。而编辑器就不同了，你看到的文件夹，打开的文件，对你来说就像是身上穿的衣服，手里搬的砖。终端呢，黑乎乎的，没啥颜色与图标，看起来那么不切实际，仿佛是天边的云彩，千变万化，无法琢磨。\n恐惧感 很多人可能做过那种梦，就是在梦里感觉自己在自由落体，然后惊醒。在你使用VIM的时候，可能也会有这种感觉。例如，一个文件我写了几百行了，万一ssh远程连接断了，或者说终端崩溃了，我写的文件会不会丢呢？为了安全起见，还是不用VIM吧。\n挫折感 使用VIM的时候，你必然要经历过很多困难，这些困难让你感觉到挫折，失去了继续学习的欲望。内心的另外一个人可能会说，我只想安安静静地做一个写代码的美男子，为什么要折腾这毫无颜值、难用的VIM呢？\n","permalink":"https://wdd.js.org/vim/why-you-leave-vim/","summary":"我只使用VIM作为主力开发工具，已经快到200天了。聊聊这其中的一些感受。\n对大部分来说，提到文本编辑器，我们可能会想到word, nodepad++, webstorm, sublime, vscode。\n这些GUI工具在给我们提供便利性的同时，也在逐渐固化我们对于编辑器的认知与思维方式。\n闭上眼睛，提到编辑器，你脑海里想到的界面是什么呢？\n左边一个文件浏览窗口 右边一个多标签页的文件编辑窗口 陌生感 想象一下，我们在使用编辑器的时候，哪些动作做的最多\n鼠标移动到文件浏览窗口，通过滚轮的滚动，来选择文件，单击之后，打开一个文件。但是在VIM上，完全没有这种操作。 GUI下可以同时打开多个文件，进行编辑。但是很多人觉得VIM只能打开一个文件，甚至想打开另一个文件的时候，先要退出VIM。即使打开了多个文件，也不知道这些文件要如何切换。 但是当你刚开始使用VIM的时候，可能并没有安装什么插件，这时候你会有以下的一些困惑\n你用VIM打开一个文件后，怎么再打开一个文件呢？因为默认的VIM是没有文件浏览窗口的。你在GUI模式下养成的经验，在VIM上完全无法使用。你可能甚至不知道要怎么退出VIM。所有的一切都那么陌生。\n虚无感 VIM一般都运行在终端之上，给人感觉云里雾里，虚无缥缈。而编辑器就不同了，你看到的文件夹，打开的文件，对你来说就像是身上穿的衣服，手里搬的砖。终端呢，黑乎乎的，没啥颜色与图标，看起来那么不切实际，仿佛是天边的云彩，千变万化，无法琢磨。\n恐惧感 很多人可能做过那种梦，就是在梦里感觉自己在自由落体，然后惊醒。在你使用VIM的时候，可能也会有这种感觉。例如，一个文件我写了几百行了，万一ssh远程连接断了，或者说终端崩溃了，我写的文件会不会丢呢？为了安全起见，还是不用VIM吧。\n挫折感 使用VIM的时候，你必然要经历过很多困难，这些困难让你感觉到挫折，失去了继续学习的欲望。内心的另外一个人可能会说，我只想安安静静地做一个写代码的美男子，为什么要折腾这毫无颜值、难用的VIM呢？","title":"让你放弃VIM的一些原因"},{"content":"为了能够在所有环境达到一致且极致的编程体验。我已经准备了好长的时间，从vscode切换到vim上做开发。\n我的切换计划分为多个阶段：\n尝试：使用vim编辑单个文件 练习：在vscode上安装vim插件，用了一段时间，感觉很别扭。 徘徊：尝试使用vim作为开发，用了一段时间后，我发现开发速度相比于vim上很慢。特别是多文件编辑，文件创建。没有vscode编辑器的那种文件侧边栏，感觉写代码不太真实，云里雾里的感觉。然后我就又切换到vscode上开发。 精进：我一直认为我vim已经学的差不多了，但是用vim的时候，总是感觉使不上劲。我觉得我没有系统的学习vim。然后我就去找了vim方面的书籍《vim实用技巧》。这本书我看过第一遍，我觉得自己之前对vim的理解太过肤浅。然后我就找机会从书中学习的技巧练习写代码。这本书我看了不下于三遍，每次看都有收获。每每遇到困惑的地方，我就会随手去查查。然后做总结。 切换：从今年双十一，我开始使用vim做开发，直到今天，我一直都没有使用vscode, 并且我也把vscode卸载了。我之所以敢于卸载vscode, 是因为我觉得我在vim上开发的效率，已经高于vscode。 熟练运用vim之后，我发现在vim上切换文件，打开文件还是创建文件，速度非常快，完全不需要鼠标点击。\n除了没有右边的代码预览视图，vim功能都有。而且我越用越觉得vim的netrw插件要比vscode左边栏的文件树窗口好用。\n还有代码搜索，我使用了ack， 用这个命令搜索关键词，简直快的飞起。\n","permalink":"https://wdd.js.org/vim/from-vscode-to-vim/","summary":"为了能够在所有环境达到一致且极致的编程体验。我已经准备了好长的时间，从vscode切换到vim上做开发。\n我的切换计划分为多个阶段：\n尝试：使用vim编辑单个文件 练习：在vscode上安装vim插件，用了一段时间，感觉很别扭。 徘徊：尝试使用vim作为开发，用了一段时间后，我发现开发速度相比于vim上很慢。特别是多文件编辑，文件创建。没有vscode编辑器的那种文件侧边栏，感觉写代码不太真实，云里雾里的感觉。然后我就又切换到vscode上开发。 精进：我一直认为我vim已经学的差不多了，但是用vim的时候，总是感觉使不上劲。我觉得我没有系统的学习vim。然后我就去找了vim方面的书籍《vim实用技巧》。这本书我看过第一遍，我觉得自己之前对vim的理解太过肤浅。然后我就找机会从书中学习的技巧练习写代码。这本书我看了不下于三遍，每次看都有收获。每每遇到困惑的地方，我就会随手去查查。然后做总结。 切换：从今年双十一，我开始使用vim做开发，直到今天，我一直都没有使用vscode, 并且我也把vscode卸载了。我之所以敢于卸载vscode, 是因为我觉得我在vim上开发的效率，已经高于vscode。 熟练运用vim之后，我发现在vim上切换文件，打开文件还是创建文件，速度非常快，完全不需要鼠标点击。\n除了没有右边的代码预览视图，vim功能都有。而且我越用越觉得vim的netrw插件要比vscode左边栏的文件树窗口好用。\n还有代码搜索，我使用了ack， 用这个命令搜索关键词，简直快的飞起。","title":"从VSCode切换到VIM"},{"content":"1. 如何安装go 本次安装环境是win10子系统 ubuntu 20.04\n打开网站 https://golang.google.cn/dl/\n选择合适的最新版的连接\ncd mkdir download cd download wget https://golang.google.cn/dl/go1.16.3.linux-amd64.tar.gz tar -C /usr/local -xvf go1.16.3.linux-amd64.tar.gz 因为我用的是zsh 所以我在~/.zshrc中，将go的bin目录加入到PATH中 export PATH=$PATH:/usr/local/go/bin 保存.zshrc之后 source ~/.zshrc ➜ download go version go version go1.16.3 linux/amd64 2. go proxy设置 Go 1.13 及以上（推荐）\n打开你的终端并执行\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 3. go get 下载的文件在哪？ 检查 go env\nGOPATH=\u0026#34;/Users/wangdd/go” /Users/wangdd/go/pkg/mod total 0 drwxr-xr-x 4 wangdd staff 128B Sep 14 09:17 cache drwxr-xr-x 8 wangdd staff 256B Sep 14 09:17 github.com drwxr-xr-x 3 wangdd staff 96B Sep 14 09:17 golang.org 路径在GOPATH/pkg/mod 目录下\n4. cannot find module providing package github.com 在项目根目录执行\ngo mod init module_name 5. 选择什么Web框架 fiber 如果你要写一个web服务器，最快速的方式是挑选一个熟悉的框架。 如果你熟悉Node.js中的express框架，那你会非常快速的上手fiber，因为fiber就是参考express做的。\nhttps://github.com/gofiber/fiber\n6. 自动构建 air npm中有个包，叫做nodemon，它会在代码变更之后，重启服务器。\n如果你需要在golang中类似的功能，可以使用https://github.com/cosmtrek/air\n7. 如何查看官方库文档 go doc fmt | less ","permalink":"https://wdd.js.org/golang/golang-start-faq/","summary":"1. 如何安装go 本次安装环境是win10子系统 ubuntu 20.04\n打开网站 https://golang.google.cn/dl/\n选择合适的最新版的连接\ncd mkdir download cd download wget https://golang.google.cn/dl/go1.16.3.linux-amd64.tar.gz tar -C /usr/local -xvf go1.16.3.linux-amd64.tar.gz 因为我用的是zsh 所以我在~/.zshrc中，将go的bin目录加入到PATH中 export PATH=$PATH:/usr/local/go/bin 保存.zshrc之后 source ~/.zshrc ➜ download go version go version go1.16.3 linux/amd64 2. go proxy设置 Go 1.13 及以上（推荐）\n打开你的终端并执行\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 3. go get 下载的文件在哪？ 检查 go env\nGOPATH=\u0026#34;/Users/wangdd/go” /Users/wangdd/go/pkg/mod total 0 drwxr-xr-x 4 wangdd staff 128B Sep 14 09:17 cache drwxr-xr-x 8 wangdd staff 256B Sep 14 09:17 github.","title":"Golang初学者的问题"},{"content":"exec user process caused \u0026#34;no such file or diectory\u0026#34; 解决方案： 将镜像构建的 Dockerfile ENTRYPOINT [\u0026quot;/run.sh\u0026quot;] 改为下面的\nENTRYPOINT [\u0026#34;sh\u0026#34;,\u0026#34;/run.sh\u0026#34;] 其实就是加了个sh\n","permalink":"https://wdd.js.org/posts/2022/docker-exec-user-process/","summary":"exec user process caused \u0026#34;no such file or diectory\u0026#34; 解决方案： 将镜像构建的 Dockerfile ENTRYPOINT [\u0026quot;/run.sh\u0026quot;] 改为下面的\nENTRYPOINT [\u0026#34;sh\u0026#34;,\u0026#34;/run.sh\u0026#34;] 其实就是加了个sh","title":"exec user process caused no such file or diectory"},{"content":"命令行编辑 向左移动光标\tctrl + b 向右移动光标\tctrl + f 移动光标到行尾\tctrl + e 移动光标到行首\tctrl + a 清除前面一个词\tctrl + w 清除光标到行首\tctrl + u 清除光标到行尾\tctrl + k 命令行搜索\tctrl + r 解压与压缩 1、压缩命令： 命令格式：\ntar -zcvf 压缩文件名 .tar.gz 被压缩文件名 可先切换到当前目录下，压缩文件名和被压缩文件名都可加入路径。\n2、解压缩命令： 命令格式：\ntar -zxvf 压缩文件名.tar.gz 解压缩后的文件只能放在当前的目录。\ncrontab 每隔x秒执行一次 每隔5秒\n* * * * * for i in {1..12}; do /bin/cmd -arg1 ; sleep 5; done 每隔15秒\n* * * * * /bin/cmd -arg1 * * * * * sleep 15; /bin/cmd -arg1 * * * * * sleep 30; /bin/cmd -arg1 * * * * * sleep 45; /bin/cmd -arg1 awk从第二行开始读取 awk \u0026#39;NR\u0026gt;2{print $1}\u0026#39; 查找大文件，并清空文件内容 find /var/log -type f -size +1M -exec truncate --size 0 \u0026#39;{}\u0026#39; \u0026#39;;\u0026#39; switch case 语句 echo \u0026#39;Input a number between 1 to 4\u0026#39; echo \u0026#39;Your number is:\\c\u0026#39; read aNum case $aNum in 1) echo \u0026#39;You select 1\u0026#39; ;; 2) echo \u0026#39;You select 2\u0026#39; ;; 3) echo \u0026#39;You select 3\u0026#39; ;; 4) echo \u0026#39;You select 4\u0026#39; ;; *) echo \u0026#39;You do not select a number between 1 to 4\u0026#39; ;; esac 以$开头的特殊变量 echo $$ # 进程pid echo $# # 收到的参数个数 echo $@ # 列表方式的参数 $1 $2 $3 echo $? # 上个进程的退出码 echo $* # 类似列表方式，但是参数被当做一个实体, \u0026#34;$1c$2c$3\u0026#34; c是IFS的第一个字符 echo $0 # 脚本名 echo $1 $2 $3 # 第一、第二、第三个参数 for i in $@ do echo $i done for j in $@ do echo $j done 判断git仓库是否clean check_is_repo_clean () { if [ -n \u0026#34;$(git status --porcelain)\u0026#34; ]; then echo \u0026#34;Working directory is not clean\u0026#34; exit 1 fi } 文件批处理 for in循环 for f in *.txt; do mv $f $f.gz; done for d in *.gz; do gunzip $d; done shell 重定向到/dev/null ls \u0026amp;\u0026gt;/dev/null; #标准错误和标准输出都不想看 ls 1\u0026gt;/dev/null; #不想看标准输出 ls 2\u0026gt;/dev/null; 标准错误不想看 sed: -e expression #1, char 21: unknown option to `s' 出现这个问题，一般是要替换的字符串中也有/符号，所以要把分隔符改成 ! 或者 |\nsed -i \u0026#34;s!WJ_CONF_URL!$WJ_CONF_URL!g\u0026#34; file.txt 发送UDP消息 在shell是bash的时候， 可以使用 echo 或者 cat将内容重定向到 /dev/udp/ip/port中，来发送udp消息\necho \u0026#34;hello\u0026#34; \u0026gt; /dev/udp/192.168.1.1/8000 grep排除自身 下面查找名称包括rtpproxy的进程，grep出来找到这个进程外，还找到了grep这条语句的进程，一般来说，这个进程是多余的。\n➜ ~ ps aux | grep rtpproxy root 3353 0.3 0.0 186080 968 ? Sl 2019 250:05 rtpproxy -f -l root 31440 0.0 0.0 112672 980 pts/0 S+ 10:12 0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn rtpproxy 但是，如果我们用中括号，将搜索关键词的第一个字符包裹起来，就可以排除grep自身。\n[root@localhost ~]# ps aux | grep \u0026#39;[r]tpproxy\u0026#39; root 3353 0.3 0.0 186080 968 ? Sl 2019 250:06 rtpproxy -f -l ","permalink":"https://wdd.js.org/shell/all-in-one/","summary":"命令行编辑 向左移动光标\tctrl + b 向右移动光标\tctrl + f 移动光标到行尾\tctrl + e 移动光标到行首\tctrl + a 清除前面一个词\tctrl + w 清除光标到行首\tctrl + u 清除光标到行尾\tctrl + k 命令行搜索\tctrl + r 解压与压缩 1、压缩命令： 命令格式：\ntar -zcvf 压缩文件名 .tar.gz 被压缩文件名 可先切换到当前目录下，压缩文件名和被压缩文件名都可加入路径。\n2、解压缩命令： 命令格式：\ntar -zxvf 压缩文件名.tar.gz 解压缩后的文件只能放在当前的目录。\ncrontab 每隔x秒执行一次 每隔5秒\n* * * * * for i in {1..12}; do /bin/cmd -arg1 ; sleep 5; done 每隔15秒\n* * * * * /bin/cmd -arg1 * * * * * sleep 15; /bin/cmd -arg1 * * * * * sleep 30; /bin/cmd -arg1 * * * * * sleep 45; /bin/cmd -arg1 awk从第二行开始读取 awk \u0026#39;NR\u0026gt;2{print $1}\u0026#39; 查找大文件，并清空文件内容 find /var/log -type f -size +1M -exec truncate --size 0 \u0026#39;{}\u0026#39; \u0026#39;;\u0026#39; switch case 语句 echo \u0026#39;Input a number between 1 to 4\u0026#39; echo \u0026#39;Your number is:\\c\u0026#39; read aNum case $aNum in 1) echo \u0026#39;You select 1\u0026#39; ;; 2) echo \u0026#39;You select 2\u0026#39; ;; 3) echo \u0026#39;You select 3\u0026#39; ;; 4) echo \u0026#39;You select 4\u0026#39; ;; *) echo \u0026#39;You do not select a number between 1 to 4\u0026#39; ;; esac 以$开头的特殊变量 echo $$ # 进程pid echo $# # 收到的参数个数 echo $@ # 列表方式的参数 $1 $2 $3 echo $?","title":"常用shell技巧"},{"content":"如何学习网络协议？ 大学时，学到网络协议的7层模型时，老师教了大家一个顺口溜：物数网传会表应。并说这是重点，年年必考，5分的题目摆在这里，你们爱背不背。 考试的时候，果然遇到这个问题，搜索枯肠，只能想到这7个字的第一个字，因为这5分，差点挂科。 后来工作面试，面试官也是很喜欢七层模型，三次握手之类的问题，但是遇到这些问题时，总是觉得很心虚。\n1. 协议分层 四层网络协议模型中，应用层以下一般都是交给操作系统来处理。应用层对于四层模型来说，仅仅是冰山一角。海面下巨复杂的三层协议，都被操作系统给隐藏起来了，一般我们在页面上发起一个ajax请求，看见了network面板多了一个http请求，至于底层是如何实现的，我们并不关心。\n应⽤层负责处理特定的应⽤程序细节。 运输层运输层主要为两台主机上的应⽤程序提供端到端的通信。 网络层处理理分组在⽹网络中的活动，例例如分组的选路 链路层处理理与电缆(或其他任何传输媒介)的物理理接⼝口细节 下面重点讲一下运输层和网络层\n1.1. 运输层的两兄弟 运输层有两个比较重要的协议。tcp和udp。\n大哥tcp是比较严谨认真、温柔体贴、慢热内向的协议，发出去的消息，总是一个一个认真检查，等待对方回复和确认，如果一段时间内，对方没有回复确认消息，还会再次发送消息，如果对方回复说你发的太快了，tcp还会体贴的把发送消息的速度降低。\n弟弟udp则比较可爱呆萌、调皮好动、不负责任的协议。哥哥tcp所具有的特点，弟弟udp一个也没有。但是有的人说不清哪里好 但就是谁都替代不了，udp没有tcp那些复杂的校验和重传等复杂的步骤，所以它发送消息非常快，而且并不保证对方一定收到。如果对方收不到消息，那么udp就会呆萌的看着你，笑着对你说：我已经尽力了。一般语音而视频数据都是用udp协议传输的，因为音频或者视频卡了一下并不影响整体的质量，而对实时性的要求会更高。\n1.2. 运输层和网络层的区别 运输层关注的是端到端层面，及End1到End2，忽略中间的任何点。 网络层关注两点之间的层面，即hop1如何到hop2，hop2如何到hop3 网络层并不保证消息可靠性，可靠性上层的传输层负责。TCP采用超时重传，分组确认的机制，保证消息不会丢失。 从下图tcp, udp, ip协议中，可以发现\n传输层的tcp和udp都是有源端口和目的端口，但是没有ip字段 源ip和目的ip只在ip数据报中 理解各个协议，关键在于理解报文的各个字段的含义 1.3. ip和端口号的真正含义 上个章节讲到运输层和网络层的区别，其中端口号被封装在运输层，ip被封装到网络成，\n那么端口号和ip地址到底有什么区别呢？\nip用来用来标记主机的位置 端口号用来标记该数据应该被目标主机上的哪个应用程序去处理 1.4. 数据在协议栈的流动 封装与分用 当发送消息时，数据在向下传递时，经过不同层次的协议处理，打上各种头部信息 当接受消息时，数据在向上传递，通过不同的头部信息字段，才知道要交给上层的那个模块来处理。比如一个ip包，如果没有头部信息，那么这个消息究竟是交给tcp协议来处理，还是udp来处理，就不得而知了 2. 深入阅读，好书推荐 《http权威指南》 有人说这本书太厚，偷偷告诉你，其实这本书并厚，因为这本书的后面的30%部分都是附录，这本书的精华是前50%的部分 《图解http》、《图解tcp/ip》这两本图解的书，知识点讲的都是比较通俗易懂的，适合入门 《tcp/ip 详解 卷1》这本书，让你知其然，更知其所以然 《tcp/ip 基础》、《tcp/ip 路由技术》这两本书，会让你从不同角度思考协议 《精通wireshark》、《wireshark网络分析实战》如果你看了很多书，却从来没有试过网络抓包，那你只是懂纸上谈兵罢了。你永远无法理解tcp三次握手的怦然心动，与四次分手的刻骨铭心。 ","permalink":"https://wdd.js.org/posts/2019/books-about-network-protocol/","summary":"如何学习网络协议？ 大学时，学到网络协议的7层模型时，老师教了大家一个顺口溜：物数网传会表应。并说这是重点，年年必考，5分的题目摆在这里，你们爱背不背。 考试的时候，果然遇到这个问题，搜索枯肠，只能想到这7个字的第一个字，因为这5分，差点挂科。 后来工作面试，面试官也是很喜欢七层模型，三次握手之类的问题，但是遇到这些问题时，总是觉得很心虚。\n1. 协议分层 四层网络协议模型中，应用层以下一般都是交给操作系统来处理。应用层对于四层模型来说，仅仅是冰山一角。海面下巨复杂的三层协议，都被操作系统给隐藏起来了，一般我们在页面上发起一个ajax请求，看见了network面板多了一个http请求，至于底层是如何实现的，我们并不关心。\n应⽤层负责处理特定的应⽤程序细节。 运输层运输层主要为两台主机上的应⽤程序提供端到端的通信。 网络层处理理分组在⽹网络中的活动，例例如分组的选路 链路层处理理与电缆(或其他任何传输媒介)的物理理接⼝口细节 下面重点讲一下运输层和网络层\n1.1. 运输层的两兄弟 运输层有两个比较重要的协议。tcp和udp。\n大哥tcp是比较严谨认真、温柔体贴、慢热内向的协议，发出去的消息，总是一个一个认真检查，等待对方回复和确认，如果一段时间内，对方没有回复确认消息，还会再次发送消息，如果对方回复说你发的太快了，tcp还会体贴的把发送消息的速度降低。\n弟弟udp则比较可爱呆萌、调皮好动、不负责任的协议。哥哥tcp所具有的特点，弟弟udp一个也没有。但是有的人说不清哪里好 但就是谁都替代不了，udp没有tcp那些复杂的校验和重传等复杂的步骤，所以它发送消息非常快，而且并不保证对方一定收到。如果对方收不到消息，那么udp就会呆萌的看着你，笑着对你说：我已经尽力了。一般语音而视频数据都是用udp协议传输的，因为音频或者视频卡了一下并不影响整体的质量，而对实时性的要求会更高。\n1.2. 运输层和网络层的区别 运输层关注的是端到端层面，及End1到End2，忽略中间的任何点。 网络层关注两点之间的层面，即hop1如何到hop2，hop2如何到hop3 网络层并不保证消息可靠性，可靠性上层的传输层负责。TCP采用超时重传，分组确认的机制，保证消息不会丢失。 从下图tcp, udp, ip协议中，可以发现\n传输层的tcp和udp都是有源端口和目的端口，但是没有ip字段 源ip和目的ip只在ip数据报中 理解各个协议，关键在于理解报文的各个字段的含义 1.3. ip和端口号的真正含义 上个章节讲到运输层和网络层的区别，其中端口号被封装在运输层，ip被封装到网络成，\n那么端口号和ip地址到底有什么区别呢？\nip用来用来标记主机的位置 端口号用来标记该数据应该被目标主机上的哪个应用程序去处理 1.4. 数据在协议栈的流动 封装与分用 当发送消息时，数据在向下传递时，经过不同层次的协议处理，打上各种头部信息 当接受消息时，数据在向上传递，通过不同的头部信息字段，才知道要交给上层的那个模块来处理。比如一个ip包，如果没有头部信息，那么这个消息究竟是交给tcp协议来处理，还是udp来处理，就不得而知了 2. 深入阅读，好书推荐 《http权威指南》 有人说这本书太厚，偷偷告诉你，其实这本书并厚，因为这本书的后面的30%部分都是附录，这本书的精华是前50%的部分 《图解http》、《图解tcp/ip》这两本图解的书，知识点讲的都是比较通俗易懂的，适合入门 《tcp/ip 详解 卷1》这本书，让你知其然，更知其所以然 《tcp/ip 基础》、《tcp/ip 路由技术》这两本书，会让你从不同角度思考协议 《精通wireshark》、《wireshark网络分析实战》如果你看了很多书，却从来没有试过网络抓包，那你只是懂纸上谈兵罢了。你永远无法理解tcp三次握手的怦然心动，与四次分手的刻骨铭心。 ","title":"如何学习网络协议？"},{"content":"什么是呼叫中心？ 呼叫中心又称为客户服务中心。有以下关键词\nCTI 通信网络 计算机 企业级 高质量、高效率、全方位、综合信息服务 呼叫中心历史 1956年美国泛美航空公司建成世界第一家呼叫中心。\n阶段 行业范围 技术 功能与意义 第一代呼叫中心 民航 PBX、电话排队 主要服务由人工完成 第二代呼叫中心 银行、生活 IVR(交互式语音应答)、DTMF 显著提高工作效率，提供全天候服务 第三代呼叫中心 CTI(电脑计算机集成) 语音数据同步，客户信息存储与查阅，个性化服务，自动化 第四代呼叫中心 接入电子邮件、互联网、手机短信等 多渠道接入、多渠道统一排队 第五代呼叫中心 接入社交网络、社交媒体(微博、微信等) 文本交谈，音频视频沟通 呼叫中心分类 按呼叫方式分类 外呼型呼叫中心（如电话营销） 客服型呼叫中心（如客户服务） 混合型呼叫中心 （如营销和客服） 按技术架构分类 交换机 板卡 软交换（IPCC） 【交换机类型呼叫中心】\n","permalink":"https://wdd.js.org/posts/2019/call-center-brief-history/","summary":"什么是呼叫中心？ 呼叫中心又称为客户服务中心。有以下关键词\nCTI 通信网络 计算机 企业级 高质量、高效率、全方位、综合信息服务 呼叫中心历史 1956年美国泛美航空公司建成世界第一家呼叫中心。\n阶段 行业范围 技术 功能与意义 第一代呼叫中心 民航 PBX、电话排队 主要服务由人工完成 第二代呼叫中心 银行、生活 IVR(交互式语音应答)、DTMF 显著提高工作效率，提供全天候服务 第三代呼叫中心 CTI(电脑计算机集成) 语音数据同步，客户信息存储与查阅，个性化服务，自动化 第四代呼叫中心 接入电子邮件、互联网、手机短信等 多渠道接入、多渠道统一排队 第五代呼叫中心 接入社交网络、社交媒体(微博、微信等) 文本交谈，音频视频沟通 呼叫中心分类 按呼叫方式分类 外呼型呼叫中心（如电话营销） 客服型呼叫中心（如客户服务） 混合型呼叫中心 （如营销和客服） 按技术架构分类 交换机 板卡 软交换（IPCC） 【交换机类型呼叫中心】","title":"呼叫中心简史"},{"content":"2008-2018 十年，往事如昨 2018年已经是昨天，今天是2019的第一天。\n2008年已经是10年前，10年前的傍晚，我走在南京仙林的一个大街上，提着一瓶矿泉水，擦着额头的汗水，仰头看着大屏幕上播放着北京奥运会的开幕式。\n10年前的夏天，我带着一步诺基亚手机功能机，独自一人去了南京。\n坐过绣球公园的石凳，穿过天妃宫的回廊，吹过阅江楼的凉爽的江风，踏着古老斑驳的城墙，在林荫小路的长椅上，我想着10年后我会在哪里？做着什么事情？\n往事如昨，而今将近而立，但是依然觉得自己还是10年的那个独自出去玩的小男孩。\n2018 读了10年都没有读完的书，五味杂陈 2018年，在我做手术前，我觉得自己出了工作的时间外，大多数时间都在看书。2018年这一年看的书，要比2008到2018年这十年间的看的书都要多。这都归功于我对每天的看书都有定量的计划，一旦按照这个计划实行几个月，积累的效果还是非常明显的。\n2018年，手机几乎成为人的四肢之外的第五肢。对大多人来说，上厕所可以不带纸，但是不能不带手机。\n各种APP, 都在极力的吸引用户多花点时间在自己身上 信息流充斥着各种毫无营养，专门吸人眼球的垃圾新闻，但是这种新闻的阅读量还是蛮大的 各种借钱，信用卡，花呗等都像青楼的小姐，妩媚的笑容，说道：官人，进来做一做 共享单车，在今年退潮之后，才发现自己都在裸泳 比特币，挖矿机。不知道谁割了谁的韭菜，总希望有下一个傻子来接盘，最后发现自己可能就是最后一个傻子 AI，人工智能很火，放佛就快要进入终结者那样的世界 锤子垮了，曾经吹过的牛逼，曾经理想主义终于脱去那又黑又亮的面具 图灵测试（The Turing test）由艾伦·麦席森·图灵发明，指测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。 进行多次测试后，如果有超过30%的测试者不能确定出被测试者是人还是机器，那么这台机器就通过了测试，并被认为具有人类智能。图灵测试一词来源于计算机科学和密码学的先驱阿兰·麦席森·图灵写于1950年的一篇论文《计算机器与智能》，其中30%是图灵对2000年时的机器思考能力的一个预测，目前我们已远远落后于这个预测。\n最后说一下图灵测试，在AI方面，这个测试无人不知。一个机器如果通过了图灵测试，则说明该机器具有了只能。但是三体的作者大刘曾经说过一句话，给我一种醍醐灌顶的感觉，假如一个机器人有能力通过图灵测试，却假装无法通过，你说这个机器是否具有人工智能。所以大刘的这种说法才更加让人恐惧。机器人能通过图灵测试，只说明这个机器人具有了智能。但是现阶段的智能只不过是条件反射，或者是基于概率计算的结果。后者这种能通话测试，却假装无法通过的智能。这不仅仅是智能，而是机器的城府。\n有智能的机器并不可怕，有城府的机器人才是真正的可怕。\n如果梦中更加幸福快乐，为什么要回到现实 火影的最后，大筒木辉夜使用无限月读将世界上的所有人都带入梦境，每个人的查克拉都被吸取，并作为神树的养料。\n如果真的存在大筒木这样的上帝，那么时间就是查克拉。人类唯一真正拥有过的东西，时间，将作为神树的养料，从每个人身上提取。\n各种具有吸引力的术，其实可以理解为无限月读，让人沉醉于梦幻中。\n如果梦中更加幸福快乐，为什么要回到现实中承受压力与悲哀呢？ 目前我无法回复自己的这个问题，期待2019年我可以得到这个答案。\n工作方面 2019年，我会在做一些后端方面的工作，努力加油吧。\n","permalink":"https://wdd.js.org/posts/2018/where-time-you-spend-what-you-will-be/","summary":"2008-2018 十年，往事如昨 2018年已经是昨天，今天是2019的第一天。\n2008年已经是10年前，10年前的傍晚，我走在南京仙林的一个大街上，提着一瓶矿泉水，擦着额头的汗水，仰头看着大屏幕上播放着北京奥运会的开幕式。\n10年前的夏天，我带着一步诺基亚手机功能机，独自一人去了南京。\n坐过绣球公园的石凳，穿过天妃宫的回廊，吹过阅江楼的凉爽的江风，踏着古老斑驳的城墙，在林荫小路的长椅上，我想着10年后我会在哪里？做着什么事情？\n往事如昨，而今将近而立，但是依然觉得自己还是10年的那个独自出去玩的小男孩。\n2018 读了10年都没有读完的书，五味杂陈 2018年，在我做手术前，我觉得自己出了工作的时间外，大多数时间都在看书。2018年这一年看的书，要比2008到2018年这十年间的看的书都要多。这都归功于我对每天的看书都有定量的计划，一旦按照这个计划实行几个月，积累的效果还是非常明显的。\n2018年，手机几乎成为人的四肢之外的第五肢。对大多人来说，上厕所可以不带纸，但是不能不带手机。\n各种APP, 都在极力的吸引用户多花点时间在自己身上 信息流充斥着各种毫无营养，专门吸人眼球的垃圾新闻，但是这种新闻的阅读量还是蛮大的 各种借钱，信用卡，花呗等都像青楼的小姐，妩媚的笑容，说道：官人，进来做一做 共享单车，在今年退潮之后，才发现自己都在裸泳 比特币，挖矿机。不知道谁割了谁的韭菜，总希望有下一个傻子来接盘，最后发现自己可能就是最后一个傻子 AI，人工智能很火，放佛就快要进入终结者那样的世界 锤子垮了，曾经吹过的牛逼，曾经理想主义终于脱去那又黑又亮的面具 图灵测试（The Turing test）由艾伦·麦席森·图灵发明，指测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。 进行多次测试后，如果有超过30%的测试者不能确定出被测试者是人还是机器，那么这台机器就通过了测试，并被认为具有人类智能。图灵测试一词来源于计算机科学和密码学的先驱阿兰·麦席森·图灵写于1950年的一篇论文《计算机器与智能》，其中30%是图灵对2000年时的机器思考能力的一个预测，目前我们已远远落后于这个预测。\n最后说一下图灵测试，在AI方面，这个测试无人不知。一个机器如果通过了图灵测试，则说明该机器具有了只能。但是三体的作者大刘曾经说过一句话，给我一种醍醐灌顶的感觉，假如一个机器人有能力通过图灵测试，却假装无法通过，你说这个机器是否具有人工智能。所以大刘的这种说法才更加让人恐惧。机器人能通过图灵测试，只说明这个机器人具有了智能。但是现阶段的智能只不过是条件反射，或者是基于概率计算的结果。后者这种能通话测试，却假装无法通过的智能。这不仅仅是智能，而是机器的城府。\n有智能的机器并不可怕，有城府的机器人才是真正的可怕。\n如果梦中更加幸福快乐，为什么要回到现实 火影的最后，大筒木辉夜使用无限月读将世界上的所有人都带入梦境，每个人的查克拉都被吸取，并作为神树的养料。\n如果真的存在大筒木这样的上帝，那么时间就是查克拉。人类唯一真正拥有过的东西，时间，将作为神树的养料，从每个人身上提取。\n各种具有吸引力的术，其实可以理解为无限月读，让人沉醉于梦幻中。\n如果梦中更加幸福快乐，为什么要回到现实中承受压力与悲哀呢？ 目前我无法回复自己的这个问题，期待2019年我可以得到这个答案。\n工作方面 2019年，我会在做一些后端方面的工作，努力加油吧。","title":"时间花在哪里，你就会成为什么样的人"},{"content":"1. v-for设置key值 key的值应当是遍历元素的某个唯一属性，例如 item.id，而不是遍历的序号index。直接把key的值绑定为index, 可能会引起不必要的bug\n// good \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // very bad \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 如果要遍历的对象没有一个唯一的id, 非常建议给要遍历的元素加上唯一的id。推荐使用nanoid\nimport nanoid from \u0026#39;nanoid\u0026#39; ... someAjax() .then((res)=\u0026gt;{ res.users.forEach((item)=\u0026gt;{ item.id = nanoid() }) this.users = res.users }) .catch((err)=\u0026gt;{ console.error(err) }) ... 2. v-for元素一定要是对象 除非是最简单的渲染，如果要在渲染期间改变某个元素值，那么只能将简单元素构造为对象。\n// very bad var example1 = new Vue({ el: \u0026#39;#example-1\u0026#39;, data: { items: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] } }) \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-for=\u0026#34;item in items\u0026#34; v-model=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; // good var example1 = new Vue({ el: \u0026#39;#example-1\u0026#39;, data: { items: [{id:1, value:\u0026#39;a\u0026#39;}, {id: 2, value:\u0026#39;b\u0026#39;}, {id:3, value:\u0026#39;c\u0026#39;}] } }) \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; v-model=\u0026#34;item.value\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; 3. v-for不要和v-if一起使用 一般情况下，列表中的元素需要按照某些条件进行显示或者隐藏，那么建议使用计算属性。\n好处：\n渲染效率更高 解藕渲染层的逻辑，可维护性更强 // very bad var example1 = new Vue({ el: \u0026#39;#example-1\u0026#39;, data: { items: [ {id:1, value:\u0026#39;a\u0026#39;, show: true}, {id:2, value:\u0026#39;b\u0026#39;, show: false}, {id:3, value:\u0026#39;c\u0026#39;, show: false} ] } }) \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-for=\u0026#34;item in items\u0026#34; v-if=\u0026#34;item.show\u0026#34; :key=\u0026#34;item.id\u0026#34; v-model=\u0026#34;item.value\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; // very good var example1 = new Vue({ el: \u0026#39;#example-1\u0026#39;, data: { items: [ {id:1, value:\u0026#39;a\u0026#39;, show: true}, {id:2, value:\u0026#39;b\u0026#39;, show: false}, {id:3, value:\u0026#39;c\u0026#39;, show: false} ] }, computed: { itemsShow: function(){ return this.items.filter(function(item){ return item.show }) } } }) \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-for=\u0026#34;item in itemsShow\u0026#34; v-if=\u0026#34;item.show\u0026#34; :key=\u0026#34;item.id\u0026#34; v-model=\u0026#34;item.value\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://wdd.js.org/posts/2018/vue-style-guide/","summary":"1. v-for设置key值 key的值应当是遍历元素的某个唯一属性，例如 item.id，而不是遍历的序号index。直接把key的值绑定为index, 可能会引起不必要的bug\n// good \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // very bad \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 如果要遍历的对象没有一个唯一的id, 非常建议给要遍历的元素加上唯一的id。推荐使用nanoid\nimport nanoid from \u0026#39;nanoid\u0026#39; ... someAjax() .then((res)=\u0026gt;{ res.users.forEach((item)=\u0026gt;{ item.id = nanoid() }) this.users = res.users }) .catch((err)=\u0026gt;{ console.error(err) }) ... 2. v-for元素一定要是对象 除非是最简单的渲染，如果要在渲染期间改变某个元素值，那么只能将简单元素构造为对象。\n// very bad var example1 = new Vue({ el: \u0026#39;#example-1\u0026#39;, data: { items: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] } }) \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-for=\u0026#34;item in items\u0026#34; v-model=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; // good var example1 = new Vue({ el: \u0026#39;#example-1\u0026#39;, data: { items: [{id:1, value:\u0026#39;a\u0026#39;}, {id: 2, value:\u0026#39;b\u0026#39;}, {id:3, value:\u0026#39;c\u0026#39;}] } }) \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.","title":"v-for Vue风格指南"},{"content":"1. demo 如果你对下面的代码没有任何疑问就能自信的回答出输出的内容，那么本篇文章就不值得你浪费时间了。\nvar var1 = 1 var var2 = true var var3 = [1,2,3] var var4 = var3 function test (var1, var3) { var1 = \u0026#39;changed\u0026#39; var3[0] = \u0026#39;changed\u0026#39; var3 = \u0026#39;changed\u0026#39; } test(var1, var3) console.log(var1, var2, var3, var4) 2. 深入理解原始类型 原始类型有5个 Undefinded, Null, Boolean, Number, String\n2.1. 原始类型变量没有属性和方法 // 抬杠, 下面的length属性，toString方法怎么有属性和方法呢？ var a = \u0026#39;oooo\u0026#39; a.length a.toString 原始类型中，有三个特殊的引用类型Boolean, Number, String，在操作原始类型时，原始类型变量会转换成对应的基本包装类型变量去操作。参考JavaScript高级程序设计 5.6 基本包装类型。\n2.2. 原始类型值不可变 原始类型的变量的值是不可变的，只能给变量赋予新的值。\n下面给出例子\n// str1 开始的值是aaa var str1 = \u0026#39;aaa\u0026#39; // 首先创建一个能容纳6个字符串的新字符串 // 然后再这个字符串中填充 aaa和bbb // 最后销毁字符串 aaa和bbb // 而不能理解成在str1的值aaa后追加bbb str1 = str1 + \u0026#39;bbb\u0026#39; 其他原始类型的值也是不可变的, 例如数值类型的。\n2.3. 原始类型值是字面量 3. 变量和值有什么区别？ 不是每一个值都有地址，但每一个变量有。《Go程序设计语言》 变量没有类型，值有。变量可以用来保存任何类型的值。《You-Dont-Know-JS》 变量都是有内存地址的，变量有用来保存各种类型的值；不同类型的值，占用的空间不同。\nvar a = 1 typeof a // 检测的不是变量a的类型，而是a的值1的类型 4. 变量访问有哪些方式？ 变量访问的方式有两种：\n按值访问 按引用访问 在JS中，五种基本类型Undefinded, Null, Boolean, Number, String是按照值访问的。基本类型变量的值就是字面上表示的值。而引用类型的值是指向该对象的指针，而指针可以理解为内存地址。\n可以理解基本类型的变量的值，就是字面上写的数值。而引用类型的值则是一个内存地址。但是这个内存地址，对于程序来说，是透明不可见的。无论是Get还是Set都无法操作这个内存地址。\n下面是个示意表格。\n语句 变量 值 Get 访问类型 var a = 1 a 1 1 按值 var a = [] a 0x00000320 [] 按引用 抬杠 Undefinded, Null, Boolean, Number是基本类型可以理解，因为这些类型的变量所占用的内存空间都是大小固定的。但是string类型的变量，字符串的长短都是不一样的，也就是说，字符串占用的内存空间大小是不固定的，为什么string被列为按值访问呢？\n基本类型和引用类型的本质区别是，当这个变量被分配值时，它需要向操作系统申请内存资源，如果你向操作系统申请的内存空间的大小是固定的，那么就是基本类型，反之，则为引用类型。\n5. 例子的解释 var var1 = 1 var var2 = true var var3 = [1,2,3] var var4 = var3 function test (var1, var3) { var1 = \u0026#39;changed\u0026#39; // a var3[0] = \u0026#39;changed\u0026#39; // b var3 = \u0026#39;changed\u0026#39; // c } test(var1, var3) console.log(var1, var2, var3, var4) 上面的js分为两个调用栈，在\n图1 外层的调用栈。有四个变量v1、v2、v3、v4 图2 调用test是传参，内层的v1、v3会屏蔽外层的v1、v3。内层的v1,v3和外层的v1、v3内存地址是不同的。内层v1和外层v1已经没有任何关系了，但是内层的v3和外层v3仍然指向同一个数组。 图3 内层的v1的值被改变成\u0026rsquo;changed‘, v3[0]的值被改变为\u0026rsquo;changed\u0026rsquo;。 图4 内层v3的值被重写为字符串changed, 彻底断了与外层v3联系。 图5 当test执行完毕，内层的v1和v3将不会存在，ox75和ox76位置的内存空间也会被释放 最终的输出：\n1 true [\u0026#34;changed\u0026#34;, 2, 3] [\u0026#34;changed\u0026#34;, 2, 3] 6. 如何深入学习JS、Node.js 看完两个stackoverflow上两个按照投票数量的榜单\nJavaScript问题榜单 Node.js问题榜单 如果学习有捷径的话，踩一遍别人踩过的坑，可能就是捷径。\n7. 参考 is-javascript-a-pass-by-reference-or-pass-by-value-language\nIs number in JavaScript immutable? duplicate\nImmutability in JavaScript\nthe-secret-life-of-javascript-primitives\nJavaScript data types and data structuresLanguages Edit Advanced\nUnderstanding Javascript immutable variable\nExplaining Value vs. Reference in Javascript\nYou-Dont-Know-JS\n《JavaScript高级程序设计（第3版）》[美] 尼古拉斯·泽卡斯\n","permalink":"https://wdd.js.org/posts/2018/deep-in-javascript-variable-value-arguments/","summary":"1. demo 如果你对下面的代码没有任何疑问就能自信的回答出输出的内容，那么本篇文章就不值得你浪费时间了。\nvar var1 = 1 var var2 = true var var3 = [1,2,3] var var4 = var3 function test (var1, var3) { var1 = \u0026#39;changed\u0026#39; var3[0] = \u0026#39;changed\u0026#39; var3 = \u0026#39;changed\u0026#39; } test(var1, var3) console.log(var1, var2, var3, var4) 2. 深入理解原始类型 原始类型有5个 Undefinded, Null, Boolean, Number, String\n2.1. 原始类型变量没有属性和方法 // 抬杠, 下面的length属性，toString方法怎么有属性和方法呢？ var a = \u0026#39;oooo\u0026#39; a.length a.toString 原始类型中，有三个特殊的引用类型Boolean, Number, String，在操作原始类型时，原始类型变量会转换成对应的基本包装类型变量去操作。参考JavaScript高级程序设计 5.6 基本包装类型。\n2.2. 原始类型值不可变 原始类型的变量的值是不可变的，只能给变量赋予新的值。\n下面给出例子\n// str1 开始的值是aaa var str1 = \u0026#39;aaa\u0026#39; // 首先创建一个能容纳6个字符串的新字符串 // 然后再这个字符串中填充 aaa和bbb // 最后销毁字符串 aaa和bbb // 而不能理解成在str1的值aaa后追加bbb str1 = str1 + \u0026#39;bbb\u0026#39; 其他原始类型的值也是不可变的, 例如数值类型的。","title":"深入理解 JavaScript中的变量、值、函数传参"},{"content":"当函数执行到this.agents.splice()时，我设置了断点。发现传参index是0，但是页面上的列表项对应的第一行数据没有被删除，\nWTF！！！ 这是什么鬼！然后我打开Vue Devtools, 然后刷新了一下，发现那个数组的第一项还是存在的。什么鬼？？\nremoveOneAgentByIndex: function (index) { this.agents.splice(index, 1) } 然后我就谷歌了一下，发现这个splice not working properly my object list VueJs, 大概意思是v-for的时候最好给列表项绑定:key=。然后我是试了这个方法，发现没啥作用。\n最终我决定，单步调试，如果我发现该问题出在Vue自身，那我就该抛弃Vue, 学习React了\n单步调试中出现一个异常的情况，removeOneAgentByIndex是被A函数调用的，A函数由websocket事件驱动。正常情况下应该触发一次的事件，服务端却发送了两次到客户端。由于事件重复，第一次执行A删除时，实际上removeOneAgentByIndex是执行成功了，但是重复的第二个事件到来时，A函数又往agents数组中添加了一项。导致看起来，removeOneAgentByIndex函数执行起来似乎没有设么作用。而且这两个重复的事件是在几乎是在同一时间发送到客户端，所以我几乎花了将近一个小时去解决这个bug。引起这个bug的原因是事件重复，所以我在前端代码中加入事件去重功能，最终解决这个问题。\n我记得之前看过一篇文章，一个开发者调通过回调函数计费，回调函数是由事件触发，但是没想到有时候事件会重发，导致重复计费。后来这名开发者在自己的代码中加入事件去重的功能，最终解决了这个问题。\n事后总结：我觉得我不该怀疑Vue这种库出现了问题，但是我又不禁去怀疑。\n通过这个bug, 我也学到了第二方法，可以删除Vue数组中的某一项，参考下面代码。\n// Only in 2.2.0+: Also works with Array + index. removeOneAgentByIndex: function (index) { this.$delete(this.agents, index) } 另外Vue devtools有时候并不会实时的观测到组件属性的变化，即使点了Refresh按钮。如果点了Refresh按钮还不行，那建议你重新打开谷歌浏览器的devtools面板。\n","permalink":"https://wdd.js.org/posts/2018/vue-array-splice-not-work/","summary":"当函数执行到this.agents.splice()时，我设置了断点。发现传参index是0，但是页面上的列表项对应的第一行数据没有被删除，\nWTF！！！ 这是什么鬼！然后我打开Vue Devtools, 然后刷新了一下，发现那个数组的第一项还是存在的。什么鬼？？\nremoveOneAgentByIndex: function (index) { this.agents.splice(index, 1) } 然后我就谷歌了一下，发现这个splice not working properly my object list VueJs, 大概意思是v-for的时候最好给列表项绑定:key=。然后我是试了这个方法，发现没啥作用。\n最终我决定，单步调试，如果我发现该问题出在Vue自身，那我就该抛弃Vue, 学习React了\n单步调试中出现一个异常的情况，removeOneAgentByIndex是被A函数调用的，A函数由websocket事件驱动。正常情况下应该触发一次的事件，服务端却发送了两次到客户端。由于事件重复，第一次执行A删除时，实际上removeOneAgentByIndex是执行成功了，但是重复的第二个事件到来时，A函数又往agents数组中添加了一项。导致看起来，removeOneAgentByIndex函数执行起来似乎没有设么作用。而且这两个重复的事件是在几乎是在同一时间发送到客户端，所以我几乎花了将近一个小时去解决这个bug。引起这个bug的原因是事件重复，所以我在前端代码中加入事件去重功能，最终解决这个问题。\n我记得之前看过一篇文章，一个开发者调通过回调函数计费，回调函数是由事件触发，但是没想到有时候事件会重发，导致重复计费。后来这名开发者在自己的代码中加入事件去重的功能，最终解决了这个问题。\n事后总结：我觉得我不该怀疑Vue这种库出现了问题，但是我又不禁去怀疑。\n通过这个bug, 我也学到了第二方法，可以删除Vue数组中的某一项，参考下面代码。\n// Only in 2.2.0+: Also works with Array + index. removeOneAgentByIndex: function (index) { this.$delete(this.agents, index) } 另外Vue devtools有时候并不会实时的观测到组件属性的变化，即使点了Refresh按钮。如果点了Refresh按钮还不行，那建议你重新打开谷歌浏览器的devtools面板。","title":"WTF!! Vue数组splice方法无法正常工作"},{"content":"使用jenkins作为打包的工具，主机上的磁盘空间总是被慢慢被占满，直到jenkins无法运行。本文从几个方面来清理docker垃圾。\n批量删除已经退出的容器 docker ps -a | grep \u0026#34;Exited\u0026#34; | awk \u0026#39;{print $1 }\u0026#39; | xargs docker rm 批量删除带有none字段的镜像 $3一般就是取出每一行的镜像id字段\n# 方案1： 根据镜像id删除镜像 docker images| grep none |awk \u0026#39;{print $3 }\u0026#39;|xargs docker rmi # 方案2: 根据镜像名删除镜像 docker images | grep wecloud | awk \u0026#39;{print $1\u0026#34;:\u0026#34;$2}\u0026#39; | xargs docker rmi 方案1，根据镜像ID删除镜像时，有写镜像虽然镜像名不同，但是镜像ID都是相同的，这是后往往会删除失败。所以根据镜像名删除镜像的效果会更好。\n删除镜像定时任务脚本 #!/bin/bash # create by wangduanduan # when current free disk less then max free disk, you can remove docker images # GREEN=\u0026#39;\\033[0;32m\u0026#39; RED=\u0026#39;\\033[0;31m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; max_free_disk=5 # 5G. when current free disk less then max free disk, remove docker images current_free_disk=`df -lh | grep centos-root | awk \u0026#39;{print strtonum($4)}\u0026#39;` df -lh echo \u0026#34;max_free_disk: $max_free_disk G\u0026#34; echo -e \u0026#34;current_free_disk: ${GREEN} $current_free_disk G ${NC}\u0026#34; if [ $current_free_disk -lt $max_free_disk ] then echo -e \u0026#34;${RED} need to clean up docker images ${NC}\u0026#34; docker images | grep none | awk \u0026#39;{print $3 }\u0026#39; | xargs docker rmi docker images | grep wecloud | awk \u0026#39;{print $1\u0026#34;:\u0026#34;$2}\u0026#39; | xargs docker rmi else echo -e \u0026#34;${GREEN}no need clean${NC}\u0026#34; fi 注意事项 为了加快打包的速度，一般不要太频繁的删除镜像。因为老的镜像中的某些不改变的层，可以作为新的镜像的缓存，从而大大加快构建的速度。\n","permalink":"https://wdd.js.org/posts/2018/docker-images-clean-up/","summary":"使用jenkins作为打包的工具，主机上的磁盘空间总是被慢慢被占满，直到jenkins无法运行。本文从几个方面来清理docker垃圾。\n批量删除已经退出的容器 docker ps -a | grep \u0026#34;Exited\u0026#34; | awk \u0026#39;{print $1 }\u0026#39; | xargs docker rm 批量删除带有none字段的镜像 $3一般就是取出每一行的镜像id字段\n# 方案1： 根据镜像id删除镜像 docker images| grep none |awk \u0026#39;{print $3 }\u0026#39;|xargs docker rmi # 方案2: 根据镜像名删除镜像 docker images | grep wecloud | awk \u0026#39;{print $1\u0026#34;:\u0026#34;$2}\u0026#39; | xargs docker rmi 方案1，根据镜像ID删除镜像时，有写镜像虽然镜像名不同，但是镜像ID都是相同的，这是后往往会删除失败。所以根据镜像名删除镜像的效果会更好。\n删除镜像定时任务脚本 #!/bin/bash # create by wangduanduan # when current free disk less then max free disk, you can remove docker images # GREEN=\u0026#39;\\033[0;32m\u0026#39; RED=\u0026#39;\\033[0;31m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; max_free_disk=5 # 5G.","title":"Docker镜像批量清理脚本"},{"content":"本文重点是讲解如何解决循环依赖这个问题。关心这个问题是如何产生的，可以自行谷歌。\n如何重现这个问题 // a.js const {sayB} = require(\u0026#39;./b.js\u0026#39;) sayB() function sayA () { console.log(\u0026#39;say A\u0026#39;) } module.exports = { sayA } // b.js const {sayA} = require(\u0026#39;./a.js\u0026#39;) sayA() function sayB () { console.log(\u0026#39;say B\u0026#39;) } module.exports = { sayB } 执行下面的代码\n➜ test git:(master) ✗ node a.js /Users/dd/wj-gitlab/tools/test/b.js:3 sayA() ^ TypeError: sayA is not a function at Object.\u0026lt;anonymous\u0026gt; (/Users/dd/wj-gitlab/tools/test/b.js:3:1) at Module._compile (module.js:635:30) at Object.Module._extensions..js (module.js:646:10) at Module.load (module.js:554:32) at tryModuleLoad (module.js:497:12) at Function.Module._load (module.js:489:3) at Module.require (module.js:579:17) at require (internal/module.js:11:18) at Object.\u0026lt;anonymous\u0026gt; (/Users/dd/wj-gitlab/tools/test/a.js:1:78) at Module._compile (module.js:635:30) sayA is not a function那么sayA是个什么呢，实际上它是 undefined\n遇到这种问题时，你最好能意识到可能是循环依赖的问题，否则找问题可能事倍功半。\n如何找到循环依赖的的文件 上文的示例代码很简单，2个文件，很容易找出循环依赖。如果有十几个文件，手工去找循环依赖的文件，也是非常麻烦的。\n下面推荐一个工具 madge, 它可以可视化的查看文件之间的依赖关系。\n注意下图1，以cli.js为起点，所有的箭头都是向右展开的，这说明没有循环依赖。如果有箭头出现向左逆流，那么就可能是循环依赖的点。\n图2中，出现向左的箭头，说明出现了循环依赖，说明要此处断开循环。\n如何解决循环依赖 方案1： 先导出自身模块 将module.exports放到文件头部，先将自身模块导出，然后再导入其他模块。\n来自：http://maples7.com/2016/08/17/cyclic-dependencies-in-node-and-its-solution/\n// a.js module.exports = { sayA } const {sayB} = require(\u0026#39;./b.js\u0026#39;) sayB() function sayA () { console.log(\u0026#39;say A\u0026#39;) } // b.js module.exports = { sayB } const {sayA} = require(\u0026#39;./a.js\u0026#39;) console.log(typeof sayA) sayA() function sayB () { console.log(\u0026#39;say A\u0026#39;) } 方案2： 间接调用 通过引入一个event的消息传递，让多个个模块可以间接传递消息，多个模块之间也可以通过发消息相互调用。\n// a.js require(\u0026#39;./b.js\u0026#39;) const bus = require(\u0026#39;./bus.js\u0026#39;) bus.on(\u0026#39;sayA\u0026#39;, sayA) setTimeout(() =\u0026gt; { bus.emit(\u0026#39;sayB\u0026#39;) }, 0) function sayA () { console.log(\u0026#39;say A\u0026#39;) } module.exports = { sayA } // b.js const bus = require(\u0026#39;./bus.js\u0026#39;) bus.on(\u0026#39;sayB\u0026#39;, sayB) setTimeout(() =\u0026gt; { bus.emit(\u0026#39;sayA\u0026#39;) }, 0) function sayB () { console.log(\u0026#39;say B\u0026#39;) } module.exports = { sayB } // bus.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} module.exports = new MyEmitter() 总结 出现循环依赖，往往是代码的结构出现了问题。应当主动去避免循环依赖这种问题，但是遇到这种问题，无法避免时，也要意识到是循环依赖导致的问题，并找方案解决。\n最后给出一个有意思的问题，下面的代码运行node a.js会输出什么？为什么会这样？\n// a.js var moduleB = require(\u0026#39;./b.js\u0026#39;) setInterval(() =\u0026gt; { console.log(\u0026#39;setInterval A\u0026#39;) }, 500) setTimeout(() =\u0026gt; { console.log(\u0026#39;setTimeout moduleA\u0026#39;) moduleB.sayB() }, 2000) function sayA () { console.log(\u0026#39;say A\u0026#39;) } module.exports = { sayA } // b.js var moduleA = require(\u0026#39;./a.js\u0026#39;) setInterval(() =\u0026gt; { console.log(\u0026#39;setInterval B\u0026#39;) }, 500) setTimeout(() =\u0026gt; { console.log(\u0026#39;setTimeout moduleB\u0026#39;) moduleA.sayA() }, 2000) function sayB () { console.log(\u0026#39;say B\u0026#39;) } module.exports = { sayB } ","permalink":"https://wdd.js.org/posts/2018/how-to-fix-circular-dependencies-in-node-js/","summary":"本文重点是讲解如何解决循环依赖这个问题。关心这个问题是如何产生的，可以自行谷歌。\n如何重现这个问题 // a.js const {sayB} = require(\u0026#39;./b.js\u0026#39;) sayB() function sayA () { console.log(\u0026#39;say A\u0026#39;) } module.exports = { sayA } // b.js const {sayA} = require(\u0026#39;./a.js\u0026#39;) sayA() function sayB () { console.log(\u0026#39;say B\u0026#39;) } module.exports = { sayB } 执行下面的代码\n➜ test git:(master) ✗ node a.js /Users/dd/wj-gitlab/tools/test/b.js:3 sayA() ^ TypeError: sayA is not a function at Object.\u0026lt;anonymous\u0026gt; (/Users/dd/wj-gitlab/tools/test/b.js:3:1) at Module._compile (module.js:635:30) at Object.Module._extensions..js (module.js:646:10) at Module.load (module.js:554:32) at tryModuleLoad (module.","title":"Node.js 如何找出循环依赖的文件？如何解决循环依赖问题？"},{"content":"shields小徽章介绍 一般开源项目都会有一些小徽章来标识项目的状态信息，并且这些信息是会自动更新的。在shields的官网https://shields.io/#/, 上面有各种各样的小图标，并且有很多自定义的方案。\n起因：如何给私有部署的jenkins制作shields服务？ 私有部署的jenkins是用来打包docker镜像的，而我想获取最新的项目打包的jenkins镜像信息。但是私有的jenkins项目信息，公网的shields服务是无法获取其信息的。那么如果搭建一个私有的shields服务呢？\n第一步：如何根据一些信息，制作svg图标 查看shields图标的源码，可以看到这些图标都是svg格式的图标。然后的思路就是，将文字信息转成svg图标。最后我发现这个思路是个死胡同，\n有个npm包叫做，text-to-svg, 似乎可以将文本转成svg, 但是看了文本转svg的效果，果断就放弃了。\n最后回到起点，看了shields官方仓库，发现一个templates目录，豁然开朗。原来svg图标是由svg的模板生成的，每次生成图标只需要将信息添加到模板中，然后就可以渲染出svg字符串了。\n顺着这个思路，发现一个包shields-lightweight\nvar shields = require(\u0026#39;shields-lightweight\u0026#39;); var svgBadge = shields.svg(\u0026#39;subject\u0026#39;, \u0026#39;status\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;flat\u0026#39;); 这个包的确可以生成和shields一样的小徽章，但是如果徽章中有中文，那么中文就会溢出。因为一个中文字符的宽度要比一个英文字符宽很多。\n所以我就fork了这个项目，重写了图标宽度计算的方式。shields-less\nnpm install shields-less var shieldsLess = require(\u0026#39;shields-less\u0026#39;) var svgBadge = shieldsLess.svg({ leftText: \u0026#39;npm 黄河远上白云间\u0026#39;, rightText: \u0026#39;hello 世界\u0026#39; }) var svgBadge2 = shieldsLess.svg({ leftText: \u0026#39;npm 黄河远上白云间\u0026#39;, rightText: \u0026#39;hello 世界\u0026#39;, style: \u0026#39;square\u0026#39; }) var svgBadge2 = shieldsLess.svg({ leftText: \u0026#39;npm 黄河远上白云间\u0026#39;, rightText: \u0026#39;hello 世界\u0026#39;, leftColor: \u0026#39;#e64a19\u0026#39;, rightColor: \u0026#39;#448aff\u0026#39;, style: \u0026#39;square\u0026#39; // just two style: square and plat(default) }) 渲染后的效果，查看在线demo: https://wdd.js.org/shields-less/example/\nshields服务开发 shields服务其实很简单。架构如下，客户端浏览器发送一个请求，向shields服务，shield服务解析请求，并向jenkins服务发送请求，jenkins服务每个项目都有json的http接口，可以获取项目信息的。shields将从jenkins获取的信息封装到svg小图标中，然后将svg小图标发送到客户端。\n最终效果 ","permalink":"https://wdd.js.org/posts/2018/how-to-make-shields-badge/","summary":"shields小徽章介绍 一般开源项目都会有一些小徽章来标识项目的状态信息，并且这些信息是会自动更新的。在shields的官网https://shields.io/#/, 上面有各种各样的小图标，并且有很多自定义的方案。\n起因：如何给私有部署的jenkins制作shields服务？ 私有部署的jenkins是用来打包docker镜像的，而我想获取最新的项目打包的jenkins镜像信息。但是私有的jenkins项目信息，公网的shields服务是无法获取其信息的。那么如果搭建一个私有的shields服务呢？\n第一步：如何根据一些信息，制作svg图标 查看shields图标的源码，可以看到这些图标都是svg格式的图标。然后的思路就是，将文字信息转成svg图标。最后我发现这个思路是个死胡同，\n有个npm包叫做，text-to-svg, 似乎可以将文本转成svg, 但是看了文本转svg的效果，果断就放弃了。\n最后回到起点，看了shields官方仓库，发现一个templates目录，豁然开朗。原来svg图标是由svg的模板生成的，每次生成图标只需要将信息添加到模板中，然后就可以渲染出svg字符串了。\n顺着这个思路，发现一个包shields-lightweight\nvar shields = require(\u0026#39;shields-lightweight\u0026#39;); var svgBadge = shields.svg(\u0026#39;subject\u0026#39;, \u0026#39;status\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;flat\u0026#39;); 这个包的确可以生成和shields一样的小徽章，但是如果徽章中有中文，那么中文就会溢出。因为一个中文字符的宽度要比一个英文字符宽很多。\n所以我就fork了这个项目，重写了图标宽度计算的方式。shields-less\nnpm install shields-less var shieldsLess = require(\u0026#39;shields-less\u0026#39;) var svgBadge = shieldsLess.svg({ leftText: \u0026#39;npm 黄河远上白云间\u0026#39;, rightText: \u0026#39;hello 世界\u0026#39; }) var svgBadge2 = shieldsLess.svg({ leftText: \u0026#39;npm 黄河远上白云间\u0026#39;, rightText: \u0026#39;hello 世界\u0026#39;, style: \u0026#39;square\u0026#39; }) var svgBadge2 = shieldsLess.svg({ leftText: \u0026#39;npm 黄河远上白云间\u0026#39;, rightText: \u0026#39;hello 世界\u0026#39;, leftColor: \u0026#39;#e64a19\u0026#39;, rightColor: \u0026#39;#448aff\u0026#39;, style: \u0026#39;square\u0026#39; // just two style: square and plat(default) }) 渲染后的效果，查看在线demo: https://wdd.","title":"shields小徽章是如何生成的？以及搭建自己的shield服务器"},{"content":" 今年的国庆，我宅在家里，没有出去玩。因为在我们在法定节假日，最好不要出去旅游。\n因为这世界本来有很多路，走的人太多了，也就没了路。\n堵在高速，堵在景区，堵在厕所，堵在某个街角\n在家里刷完美剧《无耻之徒》八季，说心里话：这部剧刷新我的人生观，感觉自己在七天之内重生似的\n虚伪往往冠以荣耀，荣耀往往冠以虚荣 古龙小说有个特点，越是卑鄙无耻，虚荣腹黑的人，往往冠以正能量慢慢的名字，例如：小李飞刀中的总是喜欢主持正义的大侠赵正义。我觉得，古龙先生一定看过李宗吾的厚黑学，并且深有研究。\n无耻之徒中的frank，也是类似赵正义这类人。\n看剧过程中，几次忍不住想把frank掐死。但是某些时候，frank也会散发出一种大人物的闪光点。\n居中人物看似无耻，很黄很暴力，但是整部剧给人以正能量满满的感觉。反观国产脑残电视剧，哪些动不动说什么我已经等你五千年之类的狗屁对白，让我一听就觉得piece of shit。\n没有好人，也没有坏人，只是人罢了 回首往事，怎么可能没有后悔与遗憾，人生本来就没有完美的 无论如何，血缘关系是无法切断的关系 ","permalink":"https://wdd.js.org/posts/2018/shameless-and-glory/","summary":" 今年的国庆，我宅在家里，没有出去玩。因为在我们在法定节假日，最好不要出去旅游。\n因为这世界本来有很多路，走的人太多了，也就没了路。\n堵在高速，堵在景区，堵在厕所，堵在某个街角\n在家里刷完美剧《无耻之徒》八季，说心里话：这部剧刷新我的人生观，感觉自己在七天之内重生似的\n虚伪往往冠以荣耀，荣耀往往冠以虚荣 古龙小说有个特点，越是卑鄙无耻，虚荣腹黑的人，往往冠以正能量慢慢的名字，例如：小李飞刀中的总是喜欢主持正义的大侠赵正义。我觉得，古龙先生一定看过李宗吾的厚黑学，并且深有研究。\n无耻之徒中的frank，也是类似赵正义这类人。\n看剧过程中，几次忍不住想把frank掐死。但是某些时候，frank也会散发出一种大人物的闪光点。\n居中人物看似无耻，很黄很暴力，但是整部剧给人以正能量满满的感觉。反观国产脑残电视剧，哪些动不动说什么我已经等你五千年之类的狗屁对白，让我一听就觉得piece of shit。\n没有好人，也没有坏人，只是人罢了 回首往事，怎么可能没有后悔与遗憾，人生本来就没有完美的 无论如何，血缘关系是无法切断的关系 ","title":"荣耀往往冠以虚伪 正能量满满的《无耻之徒》"},{"content":"前后端分离应用的架构 在前后端分离架构中，为了避免跨域以及暴露内部服务地址。一般来说，我会在Express这层中加入一个反向代理。\n所有向后端服务访问的请求，都通过代理转发到内部的各个服务。\n这个反向代理服务器，做起来很简单。用http-proxy-middleware这个模块，几行代码就可以搞定。\n// app.js Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) http-proxy-middleware实际上是对于node-http-proxy的更加简便的封装。node-http-proxy是http-proxy-middleware的底层包，如果node-http-proxy有问题，那么这个问题就会影响到http-proxy-middleware这个包。\n最近的bug http-proxy-middleware最近有个问题，请求体在被代理转发前，如果请求体被解析了。那么后端服务将会收不到请求结束的消息，从浏览器的网络面板可以看出，一个请求一直在pending状态。\nCannot proxy after parsing body #299, 实际上这个问题在node-http-proxy也被提出过，而且处于open状态。POST fails/hangs examples to restream also not working #1279\n目前这个bug还是处于open状态，但是还是有解决方案的。就是将请求体解析的中间件挂载在代理之后。\n下面的代码，express.json()会对json格式的请求体进行解析。方案1在代理前就进行body解析，所有格式是json的请求体都会被解析。\n但是有些走代理的请求，如果我们并不关心请求体的内容是什么，实际上我们可以不解析那些走代理的请求。所以，可以先挂载代理中间件，然后挂载请求体解析中间件，最后挂载内部的一些接口服务。\n// 方案1 bad app.use(express.json()) Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) app.use(\u0026#39;/api\u0026#39;, (req, res, next)=\u0026gt; { }) // 方案2 good Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) app.use(express.json()) app.use(\u0026#39;/api\u0026#39;, (req, res, next)=\u0026gt; { }) 总结 经过这个问题，我对Express中间件的挂载顺序有了更加深刻的认识。\n同时，在使用第三方包的过程中，如果该包bug，那么也需要自行找出合适的解决方案。而这个能力，往往就是高手与新手的区别。\n","permalink":"https://wdd.js.org/posts/2018/express-middleware-order-proxy-problem/","summary":"前后端分离应用的架构 在前后端分离架构中，为了避免跨域以及暴露内部服务地址。一般来说，我会在Express这层中加入一个反向代理。\n所有向后端服务访问的请求，都通过代理转发到内部的各个服务。\n这个反向代理服务器，做起来很简单。用http-proxy-middleware这个模块，几行代码就可以搞定。\n// app.js Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) http-proxy-middleware实际上是对于node-http-proxy的更加简便的封装。node-http-proxy是http-proxy-middleware的底层包，如果node-http-proxy有问题，那么这个问题就会影响到http-proxy-middleware这个包。\n最近的bug http-proxy-middleware最近有个问题，请求体在被代理转发前，如果请求体被解析了。那么后端服务将会收不到请求结束的消息，从浏览器的网络面板可以看出，一个请求一直在pending状态。\nCannot proxy after parsing body #299, 实际上这个问题在node-http-proxy也被提出过，而且处于open状态。POST fails/hangs examples to restream also not working #1279\n目前这个bug还是处于open状态，但是还是有解决方案的。就是将请求体解析的中间件挂载在代理之后。\n下面的代码，express.json()会对json格式的请求体进行解析。方案1在代理前就进行body解析，所有格式是json的请求体都会被解析。\n但是有些走代理的请求，如果我们并不关心请求体的内容是什么，实际上我们可以不解析那些走代理的请求。所以，可以先挂载代理中间件，然后挂载请求体解析中间件，最后挂载内部的一些接口服务。\n// 方案1 bad app.use(express.json()) Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) app.use(\u0026#39;/api\u0026#39;, (req, res, next)=\u0026gt; { }) // 方案2 good Object.keys(proxyTable).forEach(function (context) { app.use(proxyMiddleware(context, proxyTable[context])) }) app.use(express.json()) app.use(\u0026#39;/api\u0026#39;, (req, res, next)=\u0026gt; { }) 总结 经过这个问题，我对Express中间件的挂载顺序有了更加深刻的认识。\n同时，在使用第三方包的过程中，如果该包bug，那么也需要自行找出合适的解决方案。而这个能力，往往就是高手与新手的区别。","title":"Express代理中间件问题与解决方案"},{"content":"《中国新说唱 - 第九期》四位评委一致认为会被流行的歌曲，几乎都没有流行，反观那些评分较低的嘻哈歌曲，反而在各大音乐排行版上名列前茅。\n评委认为会流行的歌曲有以下特点\n词要简单，不要有深度，越简单约容易流行 要中西结合，国际化更好 对于第一点，无疑是在侮辱嘻哈音乐听众的智商。\n对于第二点，实际上只是在吹嘘罢了。难道山歌就一定比中英文结合的说明要层次低。\n纵观网易云音乐排行榜上的比较流行的嘻哈音乐，可以发现有以下特点。\n歌词有血有肉 节奏缓和，吐字清晰，容易模仿 爱情和青春主题更讨喜 对于第一点，如果你的歌词，只是再说自己有多牛逼，别人多low，那么你的歌一定火不了。\n对于第二点，虽然嘻哈音乐讲究说唱的速度，但是如果你的歌曲，整片速度快的都像在高速公路上飙车，那么没有人能跟上。观众顶多会送你一个老司机牌坊，然后就没有然后了。\n缓和的说唱，更容易打动人心。\n爱情和青春，永恒不变的讨喜主题。\n","permalink":"https://wdd.js.org/posts/2018/what-hip-hop-music-will-be-popular/","summary":"《中国新说唱 - 第九期》四位评委一致认为会被流行的歌曲，几乎都没有流行，反观那些评分较低的嘻哈歌曲，反而在各大音乐排行版上名列前茅。\n评委认为会流行的歌曲有以下特点\n词要简单，不要有深度，越简单约容易流行 要中西结合，国际化更好 对于第一点，无疑是在侮辱嘻哈音乐听众的智商。\n对于第二点，实际上只是在吹嘘罢了。难道山歌就一定比中英文结合的说明要层次低。\n纵观网易云音乐排行榜上的比较流行的嘻哈音乐，可以发现有以下特点。\n歌词有血有肉 节奏缓和，吐字清晰，容易模仿 爱情和青春主题更讨喜 对于第一点，如果你的歌词，只是再说自己有多牛逼，别人多low，那么你的歌一定火不了。\n对于第二点，虽然嘻哈音乐讲究说唱的速度，但是如果你的歌曲，整片速度快的都像在高速公路上飙车，那么没有人能跟上。观众顶多会送你一个老司机牌坊，然后就没有然后了。\n缓和的说唱，更容易打动人心。\n爱情和青春，永恒不变的讨喜主题。","title":"什么样的嘻哈音乐会被听众喜欢"},{"content":"我们用自己的时间，交换到别人的快乐 关于王阳明的心学的书籍，我看过一本，但是没看完。\n虽然我没看，但是我似乎已经理解了心学。\n可以从我个人的角度说明\n上大学时，我有段时间迷上玩英雄联盟，但是因为玩的太菜，所以不久就放弃了。但是喜欢看一些关于游戏的直播视频。 有时候看歌唱比赛，觉得人家唱的那么好听，顿生仰慕之心，进而去了解这个人 喜欢看某个电视剧，然后就追着看了 刷某个APP, 一刷就几十分钟过去了 \u0026hellip; 做这些事情，都有一个特点，就是我们：我们用自己的时间，交换到别人的快乐，仿佛与魔鬼做了交易。\n从心学的角度来说明，我们总是从外界去求取快乐，求取自我实现。\n而王阳明老师交给我的是，你应该从你的内心发现快乐，不需要依赖外呼去实现内心的安静与愉悦。\n自己内心的愉悦是永恒的，从外界获取愉悦是短暂的。\n因为不想无聊，所以出卖自己的时间 用自己的时间去交换别人的快乐，还有另外一个原因。\n就是自己的时间太无聊，因为无法忍受无聊，所以要找点乐子。\n但是从深层次来讲，我们为什么会感到无聊呢？\n因为你无事可做啊？ 无事可做最无聊\n看着手机上满屏的APP图标，\n仿佛是路过青楼，\n每个APP都在妩媚的招手笑道：官人进来坐坐好吗？\n每个APP都希望你可以花费更多的时间在它上面，\n就像是后宫剧的争宠一样，\n因为时间就是流量，\n流量就是金钱\n我们被圈养成优秀的绵羊 屠夫一定不是最富有的，牧羊人一定是最富有的人。\n屠夫杀猪，猪感觉很痛，而且猪要是被杀了，就没办法再杀了\n牧羊人不一样，牧羊人有每次只褥一只的几根羊毛\n绵羊丝毫感觉不到，\n所以牧羊人必须驯服越来越多的绵羊\n让后让每个绵羊以毛质鲜亮为美\n毛质鲜亮浓密的绵羊，称为优秀的绵羊\n我们都慢慢被培养成优秀的绵羊\n","permalink":"https://wdd.js.org/posts/2018/wangyangmin-school-of-mind/","summary":"我们用自己的时间，交换到别人的快乐 关于王阳明的心学的书籍，我看过一本，但是没看完。\n虽然我没看，但是我似乎已经理解了心学。\n可以从我个人的角度说明\n上大学时，我有段时间迷上玩英雄联盟，但是因为玩的太菜，所以不久就放弃了。但是喜欢看一些关于游戏的直播视频。 有时候看歌唱比赛，觉得人家唱的那么好听，顿生仰慕之心，进而去了解这个人 喜欢看某个电视剧，然后就追着看了 刷某个APP, 一刷就几十分钟过去了 \u0026hellip; 做这些事情，都有一个特点，就是我们：我们用自己的时间，交换到别人的快乐，仿佛与魔鬼做了交易。\n从心学的角度来说明，我们总是从外界去求取快乐，求取自我实现。\n而王阳明老师交给我的是，你应该从你的内心发现快乐，不需要依赖外呼去实现内心的安静与愉悦。\n自己内心的愉悦是永恒的，从外界获取愉悦是短暂的。\n因为不想无聊，所以出卖自己的时间 用自己的时间去交换别人的快乐，还有另外一个原因。\n就是自己的时间太无聊，因为无法忍受无聊，所以要找点乐子。\n但是从深层次来讲，我们为什么会感到无聊呢？\n因为你无事可做啊？ 无事可做最无聊\n看着手机上满屏的APP图标，\n仿佛是路过青楼，\n每个APP都在妩媚的招手笑道：官人进来坐坐好吗？\n每个APP都希望你可以花费更多的时间在它上面，\n就像是后宫剧的争宠一样，\n因为时间就是流量，\n流量就是金钱\n我们被圈养成优秀的绵羊 屠夫一定不是最富有的，牧羊人一定是最富有的人。\n屠夫杀猪，猪感觉很痛，而且猪要是被杀了，就没办法再杀了\n牧羊人不一样，牧羊人有每次只褥一只的几根羊毛\n绵羊丝毫感觉不到，\n所以牧羊人必须驯服越来越多的绵羊\n让后让每个绵羊以毛质鲜亮为美\n毛质鲜亮浓密的绵羊，称为优秀的绵羊\n我们都慢慢被培养成优秀的绵羊","title":"偷时间的人与王阳明心学"},{"content":"负和游戏 我很早就听过一个名词，叫做零和游戏，或者又叫做零和博弈。\n零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有所得，其他方必有所失。 维基百科\n最近读的一本书 《以交易为生》，本来是耐着兴趣读下去的\n没想到读到某些地方，也给我醍醐灌顶的感觉\n世界上哪有零和游戏啊，都是负和游戏。\n你给张三转1000块，按理说你少了1000块，张三多了1000块，1000 - 1000 = 0 和为零。\n实际上呢，你转账时还需要付手续费吧。1000 - 1000 - 1 = -1\n同样的情况，坐庄的人总是需要抽成的。\n嘻哈音乐 去年爱奇艺的《中国有嘻哈》红遍大江南北\n所以今天又搞了个第二季\n任何事情，第一遍总是最好的，续集往往都不如人意。\n从谷歌趋势和百度统计来看，这档节目热度在平稳降低。\n另外，爱奇艺也有可能是有点心虚。以前视频下面都会写出播放量，但是现在都不显示播放量数据了，而是显示热度。\n说实在的17年中国有嘻哈能火，完全是因为它能够在众多娱乐节目中给人非常特别的感觉。\n但是18年中国新说唱，和其他节目有什么区别能，同质化严重。\n","permalink":"https://wdd.js.org/posts/2018/negative-game-and-hipop-music/","summary":"负和游戏 我很早就听过一个名词，叫做零和游戏，或者又叫做零和博弈。\n零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有所得，其他方必有所失。 维基百科\n最近读的一本书 《以交易为生》，本来是耐着兴趣读下去的\n没想到读到某些地方，也给我醍醐灌顶的感觉\n世界上哪有零和游戏啊，都是负和游戏。\n你给张三转1000块，按理说你少了1000块，张三多了1000块，1000 - 1000 = 0 和为零。\n实际上呢，你转账时还需要付手续费吧。1000 - 1000 - 1 = -1\n同样的情况，坐庄的人总是需要抽成的。\n嘻哈音乐 去年爱奇艺的《中国有嘻哈》红遍大江南北\n所以今天又搞了个第二季\n任何事情，第一遍总是最好的，续集往往都不如人意。\n从谷歌趋势和百度统计来看，这档节目热度在平稳降低。\n另外，爱奇艺也有可能是有点心虚。以前视频下面都会写出播放量，但是现在都不显示播放量数据了，而是显示热度。\n说实在的17年中国有嘻哈能火，完全是因为它能够在众多娱乐节目中给人非常特别的感觉。\n但是18年中国新说唱，和其他节目有什么区别能，同质化严重。","title":"负和游戏与嘻哈音乐"},{"content":"2018年的学习计划是学习Go语言，\n同时读完kindle里面的300多本书。\n300多本书中，有古龙的武侠小说。\n在学习Go语言的时候，感觉Go语言真实到处都是规矩，一板一眼都仿佛是少林高僧般矜持。\n什么出家人不打诳语啦，酒肉穿肠过\u0026hellip;\n我并不是说有规矩不好，规矩是风格，没有什么好不好的。\n小孩子才说好坏，大人只说利弊。\nJavaScript就有点奇技淫巧了，似乎有点像李寻欢一样\n放荡不羁、忧郁伤感、被人误解\n但是NodeJs横空出世，方佛像小李飞刀\n没有人看出它是怎么出手的，但是它已经席卷了编程界\n但是我最近兴趣却是学习Go语言\n就像朱自清说的：酣眠必不可少，小睡也别有风味\n","permalink":"https://wdd.js.org/posts/2018/js-go-gongfu-story/","summary":"2018年的学习计划是学习Go语言，\n同时读完kindle里面的300多本书。\n300多本书中，有古龙的武侠小说。\n在学习Go语言的时候，感觉Go语言真实到处都是规矩，一板一眼都仿佛是少林高僧般矜持。\n什么出家人不打诳语啦，酒肉穿肠过\u0026hellip;\n我并不是说有规矩不好，规矩是风格，没有什么好不好的。\n小孩子才说好坏，大人只说利弊。\nJavaScript就有点奇技淫巧了，似乎有点像李寻欢一样\n放荡不羁、忧郁伤感、被人误解\n但是NodeJs横空出世，方佛像小李飞刀\n没有人看出它是怎么出手的，但是它已经席卷了编程界\n但是我最近兴趣却是学习Go语言\n就像朱自清说的：酣眠必不可少，小睡也别有风味","title":"JavaScript Golang 与 武侠小说"},{"content":"兼容性：对，说你呢！IE! 当我们在说浏览器兼容性的时候，其实我们大多数时候在说IE浏览器的兼容性。\n对，说你呢！IE!\n现在jQuery的最新版已经是3.3.1， 根据jQuery的官方说明。\n最新版的jQuery支持IE9+, 如果你想支持IE6-8，那么你最好去用jQuery 1.12。\nCurrent Active Support Desktop Internet Explorer: 9+ If you need to support older browsers like Internet Explorer 6-8, Opera 12.1x or Safari 5.1+, use jQuery 1.12. 来自 Browser Support\njQuery的亮点 我只想安安静静的做东西，不想和各种浏览器diss或者battle。\n所以老司机总是选择一个合适的轮子，\n","permalink":"https://wdd.js.org/posts/2018/jquery-ie-browser-support/","summary":"兼容性：对，说你呢！IE! 当我们在说浏览器兼容性的时候，其实我们大多数时候在说IE浏览器的兼容性。\n对，说你呢！IE!\n现在jQuery的最新版已经是3.3.1， 根据jQuery的官方说明。\n最新版的jQuery支持IE9+, 如果你想支持IE6-8，那么你最好去用jQuery 1.12。\nCurrent Active Support Desktop Internet Explorer: 9+ If you need to support older browsers like Internet Explorer 6-8, Opera 12.1x or Safari 5.1+, use jQuery 1.12. 来自 Browser Support\njQuery的亮点 我只想安安静静的做东西，不想和各种浏览器diss或者battle。\n所以老司机总是选择一个合适的轮子，","title":"jQuery 与IE浏览器兼容性的思考"},{"content":" 写给所有用github pages做博客，又想搞个图床的人\n1. 适用场景 假如你用github page用markdown写个人博客的话，而你正好又用到一些图床的话，那你可以继续看下去。\n2. 图床分类 图床可以分为两类：\n云服务提供的对象存储: 例如七牛、阿里云提供的对象存储 专门的图床网站: 例如sm.ms, 路过图床，极简图床类似的，一般都是免费 先说云服务提供的对象存储。\n2.1. 七牛云 七牛图床也是推荐比较多的。而且七牛OSS在认证过后提供免费的10G存储空间，你看到的是免费，10G存储空间。\n但是还有些信息没有告诉你。\n免费的仅仅是存储空间，流量费超标了，还是要另算费用的哟 免费提供的外链仅仅是HTTP, HTTPS可是不免费的哟 免费提供的图片的外链是测试的域名，30天后会被回收的哟。也就是说，如果你用测试域名，那么你的图片很可能不知哪天就无法访问了。当然了，你也可以绑定一个正式的域名，但是你需要买个域名，对这个域名进行域名备案、公安网备案。如果你仅仅是为github pages搞个图床，那备案之路是不容易的，你要考虑是否值得。 2.2. 阿里云 如果你用阿里云的对象存储，阿里云是没有免空间的，但是其实空间并不贵，我之前买的9块钱40G一年的空间。而且阿里云提供正式的外链域名，域名是不会被回收的。\n但是如果你以为阿里云很划算的话，你就很傻很天真了。\n阿里云的对象存储计费是慢复杂的，而且不便宜。\n阿里云OSS计费由四个部分组成: 存储费用 + 流量费用 + 请求费用 + 数据处理费用\n至于具体计费细节我就不多说了，只说一个真实的故事。\n七牛云给出测试域名回收通告之后，当天我就把500多张图片，大概24MB左右，全部迁移到阿里云OSS。当晚凌晨左右，正在躺在床上看灌篮高手的正起劲的我，突然收到阿里云OSS欠费通知。于是我虎躯一震，翻身下床，打开电脑，还了欠费，删了OSS。\n总之，天下没有免费的午餐，出来混，总是要还的。\n2.3. 又拍云 又拍云提供的外链，也是需要绑定域名的，而且域名需要备案。\n2.4. 专门的图床网站 专门的图床网站，一般都是免费的。但是免费的，除非站长能力超强、票子超多，否则没有盈利模式的话，早晚可能还是免不了无法访问的结局。\n详情可以看一下， 盘点一下免费好用的图床\n3. 为了方便、还是为了折腾 给markdown图片一个图床，出发点是为了方便。为了markdown在迁移时，图片不会无法访问。\n但是我觉得在这个出发点上，我们越绕越远。为了方便，而折腾出一系列麻烦事。\n4. 解决思路 博客尽量少加图片 尽量将图片放在博客目录下，不使用图床 对于不重要的图片，可以使用免费图床 可以购买一些付费的专门的图床服务 5. 省钱还是省事，鱼与熊掌 想省钱，往往就不能省事，需要有折腾的耐力。\n有钱任性的话，什么事都好办了。想上哪个云，上哪个云。\n","permalink":"https://wdd.js.org/posts/2018/the-hard-way-of-markdown-insert-images/","summary":"写给所有用github pages做博客，又想搞个图床的人\n1. 适用场景 假如你用github page用markdown写个人博客的话，而你正好又用到一些图床的话，那你可以继续看下去。\n2. 图床分类 图床可以分为两类：\n云服务提供的对象存储: 例如七牛、阿里云提供的对象存储 专门的图床网站: 例如sm.ms, 路过图床，极简图床类似的，一般都是免费 先说云服务提供的对象存储。\n2.1. 七牛云 七牛图床也是推荐比较多的。而且七牛OSS在认证过后提供免费的10G存储空间，你看到的是免费，10G存储空间。\n但是还有些信息没有告诉你。\n免费的仅仅是存储空间，流量费超标了，还是要另算费用的哟 免费提供的外链仅仅是HTTP, HTTPS可是不免费的哟 免费提供的图片的外链是测试的域名，30天后会被回收的哟。也就是说，如果你用测试域名，那么你的图片很可能不知哪天就无法访问了。当然了，你也可以绑定一个正式的域名，但是你需要买个域名，对这个域名进行域名备案、公安网备案。如果你仅仅是为github pages搞个图床，那备案之路是不容易的，你要考虑是否值得。 2.2. 阿里云 如果你用阿里云的对象存储，阿里云是没有免空间的，但是其实空间并不贵，我之前买的9块钱40G一年的空间。而且阿里云提供正式的外链域名，域名是不会被回收的。\n但是如果你以为阿里云很划算的话，你就很傻很天真了。\n阿里云的对象存储计费是慢复杂的，而且不便宜。\n阿里云OSS计费由四个部分组成: 存储费用 + 流量费用 + 请求费用 + 数据处理费用\n至于具体计费细节我就不多说了，只说一个真实的故事。\n七牛云给出测试域名回收通告之后，当天我就把500多张图片，大概24MB左右，全部迁移到阿里云OSS。当晚凌晨左右，正在躺在床上看灌篮高手的正起劲的我，突然收到阿里云OSS欠费通知。于是我虎躯一震，翻身下床，打开电脑，还了欠费，删了OSS。\n总之，天下没有免费的午餐，出来混，总是要还的。\n2.3. 又拍云 又拍云提供的外链，也是需要绑定域名的，而且域名需要备案。\n2.4. 专门的图床网站 专门的图床网站，一般都是免费的。但是免费的，除非站长能力超强、票子超多，否则没有盈利模式的话，早晚可能还是免不了无法访问的结局。\n详情可以看一下， 盘点一下免费好用的图床\n3. 为了方便、还是为了折腾 给markdown图片一个图床，出发点是为了方便。为了markdown在迁移时，图片不会无法访问。\n但是我觉得在这个出发点上，我们越绕越远。为了方便，而折腾出一系列麻烦事。\n4. 解决思路 博客尽量少加图片 尽量将图片放在博客目录下，不使用图床 对于不重要的图片，可以使用免费图床 可以购买一些付费的专门的图床服务 5. 省钱还是省事，鱼与熊掌 想省钱，往往就不能省事，需要有折腾的耐力。\n有钱任性的话，什么事都好办了。想上哪个云，上哪个云。","title":"markdown博客图床上传的艰辛之路"},{"content":"IE11有安全设置中有两个选项，\n跨域浏览窗口和框架 通过域访问数据源 如果上面两个选项被禁用，那么IE11会拒绝跨域请求。如果想要跨域成功，必须将上面两个选项设置为启用。\n第一步 打开IE11 点击浏览器右上角的齿轮图标 点击弹框上的 Internet选项 第二步 点击安全 点击Internet 点击自定义级别 第三步 找到跨域浏览窗口和框架\n如果这项是禁用的，那么要勾选启用。\n找到通过域访问数据源\n如果这项是禁用的，那么要勾选启用。\n最后在点击确定。\n最后，如果跨域浏览窗口和框架,通过域访问数据源都启用了，还是无法跨域。那么最好重启一下电脑。有些设置可能在重启后才会生效。\n","permalink":"https://wdd.js.org/posts/2018/ie-cross-domain-settings/","summary":"IE11有安全设置中有两个选项，\n跨域浏览窗口和框架 通过域访问数据源 如果上面两个选项被禁用，那么IE11会拒绝跨域请求。如果想要跨域成功，必须将上面两个选项设置为启用。\n第一步 打开IE11 点击浏览器右上角的齿轮图标 点击弹框上的 Internet选项 第二步 点击安全 点击Internet 点击自定义级别 第三步 找到跨域浏览窗口和框架\n如果这项是禁用的，那么要勾选启用。\n找到通过域访问数据源\n如果这项是禁用的，那么要勾选启用。\n最后在点击确定。\n最后，如果跨域浏览窗口和框架,通过域访问数据源都启用了，还是无法跨域。那么最好重启一下电脑。有些设置可能在重启后才会生效。","title":"IE11跨域检查跨域设置"},{"content":" 大三那年的暑假 大三那年暑假，很多同学都回去了，寝室大楼空空如也。\n留在上海的同学都在各自找着兼职的工作，为了不显得无聊，我也在网上随便发了一些简历，试试看运气。\n写简历最难写的部分就是写你自己的长处是什么？搜索枯肠，觉得自己似乎也没什特长。感觉大学三年学到一些东西，又感觉什么都没学到。\n如果没有特长，总该也有点理想吧，比如想干点什么？ 似乎我也没什么想做的事情。\n小时候我们都有理想，慢慢长大后，理想越来越模糊，变得越来越迷茫。\n大学里，大部分的人都是在打游戏。我也曾迷恋过打游戏，但是因为自己比较菜，总是被虐，所以放弃了。\n但是我也不是那种天天对着笔记本看电视剧的人。\n回忆初三那年的暑假 记得，初三的暑假，我参加了一个学校看展的一个免费的计算机培训班。因为培训的老师说，培训结束前会有一个测试，成绩最好的会有几百块的奖励。\n为了几百块的奖励，我第一个背诵完五笔拆字法。随后老师教了我们PS, 就是photoshop。当时我的理解就是，ps可以做出很多搞笑的图片。\n为了成为一个有能力做出搞笑图片的人。我在高中和大学期间，断断续续的系统的自学了PS。\n下面给展示几张我的PS照片\n【毕业照】\n【帮别人做的艺术照】\n【刺客信条 换脸 我自己】\n【旅游照 换脸 我自己】\n【宿舍楼 上面ps了一条狼】\n古玩艺术电商中的店小二 基本上，我的PS技术还是能够找点兼职做的。没过多久，我收到了面试邀请，面试的公司位于一个古玩收藏品市场中。\n当然我面试成功了，开出的日薪也是非常诱人，每天35元。\n在上海，35元一天的工资，除去来回上下班做地铁和公交，还有中午饭的费用外，基本上不会剩下什么，有时候稍微午饭丰盛点，自己就要倒贴。但是这也是一次不错的尝试，至少有史以来，除去父母以外，我用能力问别人要钱了。\n35元的日薪持续很短一段时间，然后我就涨薪了，到达每天100元。在这个做兼职的地方，我最高拿到的日薪是200元。\n兼职期间我做了各式各样的工作：\n古玩艺术品摄影 海报制作 拍卖图册制作 linux运维 APP UI 设计 网页设计 python爬虫 兼职的日志过得很苦，单是还算充实。虽然工资不高，但是因为还没毕业，也没有奢望过高的工资。\n【上图 我在一个古玩店的拍摄玉器的时候，有个小女孩过来找我玩，我随手拍的】\n【上图 是在1号线 莲花路地铁站 因为错过了地铁拍的】\n【上图 是从1号线 莲花地铁站 转公交拍的】\n【每天早上起的很早，能够看到军训的学生在操场上奔跑】\n【在古玩店一般都要拍到很晚，因为是按张数算拍照工资，拍的越多，工资越高。还好晚上回公司 打车费用是可以报销的】\n【晚上还要回到学校，一般到学校就快晚上10点左右了】\n【毕业了，新校区依然很漂亮】\n【毕业了，老校区下了一场雨】\n【毕业了，青春像一艘船，沉入海底】\n【毕业了，我等的人，你在哪里？】\n","permalink":"https://wdd.js.org/posts/2018/the-rest-of-your-life/","summary":"大三那年的暑假 大三那年暑假，很多同学都回去了，寝室大楼空空如也。\n留在上海的同学都在各自找着兼职的工作，为了不显得无聊，我也在网上随便发了一些简历，试试看运气。\n写简历最难写的部分就是写你自己的长处是什么？搜索枯肠，觉得自己似乎也没什特长。感觉大学三年学到一些东西，又感觉什么都没学到。\n如果没有特长，总该也有点理想吧，比如想干点什么？ 似乎我也没什么想做的事情。\n小时候我们都有理想，慢慢长大后，理想越来越模糊，变得越来越迷茫。\n大学里，大部分的人都是在打游戏。我也曾迷恋过打游戏，但是因为自己比较菜，总是被虐，所以放弃了。\n但是我也不是那种天天对着笔记本看电视剧的人。\n回忆初三那年的暑假 记得，初三的暑假，我参加了一个学校看展的一个免费的计算机培训班。因为培训的老师说，培训结束前会有一个测试，成绩最好的会有几百块的奖励。\n为了几百块的奖励，我第一个背诵完五笔拆字法。随后老师教了我们PS, 就是photoshop。当时我的理解就是，ps可以做出很多搞笑的图片。\n为了成为一个有能力做出搞笑图片的人。我在高中和大学期间，断断续续的系统的自学了PS。\n下面给展示几张我的PS照片\n【毕业照】\n【帮别人做的艺术照】\n【刺客信条 换脸 我自己】\n【旅游照 换脸 我自己】\n【宿舍楼 上面ps了一条狼】\n古玩艺术电商中的店小二 基本上，我的PS技术还是能够找点兼职做的。没过多久，我收到了面试邀请，面试的公司位于一个古玩收藏品市场中。\n当然我面试成功了，开出的日薪也是非常诱人，每天35元。\n在上海，35元一天的工资，除去来回上下班做地铁和公交，还有中午饭的费用外，基本上不会剩下什么，有时候稍微午饭丰盛点，自己就要倒贴。但是这也是一次不错的尝试，至少有史以来，除去父母以外，我用能力问别人要钱了。\n35元的日薪持续很短一段时间，然后我就涨薪了，到达每天100元。在这个做兼职的地方，我最高拿到的日薪是200元。\n兼职期间我做了各式各样的工作：\n古玩艺术品摄影 海报制作 拍卖图册制作 linux运维 APP UI 设计 网页设计 python爬虫 兼职的日志过得很苦，单是还算充实。虽然工资不高，但是因为还没毕业，也没有奢望过高的工资。\n【上图 我在一个古玩店的拍摄玉器的时候，有个小女孩过来找我玩，我随手拍的】\n【上图 是在1号线 莲花路地铁站 因为错过了地铁拍的】\n【上图 是从1号线 莲花地铁站 转公交拍的】\n【每天早上起的很早，能够看到军训的学生在操场上奔跑】\n【在古玩店一般都要拍到很晚，因为是按张数算拍照工资，拍的越多，工资越高。还好晚上回公司 打车费用是可以报销的】\n【晚上还要回到学校，一般到学校就快晚上10点左右了】\n【毕业了，新校区依然很漂亮】\n【毕业了，老校区下了一场雨】\n【毕业了，青春像一艘船，沉入海底】\n【毕业了，我等的人，你在哪里？】","title":"毕业后，青春像一艘船，沉入海底"},{"content":"1. 环境 node 8.11.3 2. 基本使用 // 01.js const EventEmitter = require(\u0026#39;events\u0026#39;); class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter(); myEmitter.on(\u0026#39;event\u0026#39;, () =\u0026gt; { console.log(\u0026#39;an event occurred!\u0026#39;); }); myEmitter.emit(\u0026#39;event\u0026#39;); 输出：\nan event occurred! 3. 传参与this指向 emit()方法可以传不限制数量的参数。 除了箭头函数外，在回调函数内部，this会被绑定到EventEmitter类的实例上 // 02.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() myEmitter.on(\u0026#39;event\u0026#39;, function (a, b){ console.log(a, b, this, this === myEmitter) }) myEmitter.on(\u0026#39;event\u0026#39;, (a, b) =\u0026gt; { console.log(a, b, this, this === myEmitter) }) myEmitter.emit(\u0026#39;event\u0026#39;, \u0026#39;a\u0026#39;, {name:\u0026#39;wdd\u0026#39;}) 输出：\na { name: \u0026#39;wdd\u0026#39; } MyEmitter { domain: null, _events: { event: [ [Function], [Function] ] }, _eventsCount: 1, _maxListeners: undefined } true a { name: \u0026#39;wdd\u0026#39; } {} false 4. 同步还是异步调用listeners? emit()法会同步按照事件注册的顺序执行回调 // 03.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() myEmitter.on(\u0026#39;event\u0026#39;, () =\u0026gt; { console.log(\u0026#39;01 an event occurred!\u0026#39;) }) myEmitter.on(\u0026#39;event\u0026#39;, () =\u0026gt; { console.log(\u0026#39;02 an event occurred!\u0026#39;) }) console.log(1) myEmitter.emit(\u0026#39;event\u0026#39;) console.log(2) 输出：\n1 01 an event occurred! 02 an event occurred! 2 深入思考，为什么事件回调要同步？异步了会有什么问题？\n同步去调用事件监听者，能够确保按照注册顺序去调用事件监听者，并且避免竞态条件和逻辑错误。\n5. 如何只订阅一次事件？ 使用once去只订阅一次事件 // 04.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() let m = 0 myEmitter.once(\u0026#39;event\u0026#39;, () =\u0026gt; { console.log(++m) }) myEmitter.emit(\u0026#39;event\u0026#39;) myEmitter.emit(\u0026#39;event\u0026#39;) 6. 不订阅，就发飙的错误事件 error是一个特别的事件名，当这个事件被触发时，如果没有对应的事件监听者，则会导致程序崩溃。\nevents.js:183 throw er; // Unhandled \u0026#39;error\u0026#39; event ^ Error: test at Object.\u0026lt;anonymous\u0026gt; (/Users/xxx/github/node-note/events/05.js:12:25) at Module._compile (module.js:635:30) at Object.Module._extensions..js (module.js:646:10) at Module.load (module.js:554:32) at tryModuleLoad (module.js:497:12) at Function.Module._load (module.js:489:3) at Function.Module.runMain (module.js:676:10) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:608:3 所以，最好总是给EventEmitter实例添加一个error的监听器\nconst EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() myEmitter.on(\u0026#39;error\u0026#39;, (err) =\u0026gt; { console.log(err) }) console.log(1) myEmitter.emit(\u0026#39;error\u0026#39;, new Error(\u0026#39;test\u0026#39;)) console.log(2) 7. 内部事件 newListener与removeListener newListener与removeListener是EventEmitter实例的自带的事件，你最好不要使用同样的名字作为自定义的事件名。\nnewListener在订阅者被加入到订阅列表前触发 removeListener在订阅者被移除订阅列表后触发 // 06.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() myEmitter.on(\u0026#39;newListener\u0026#39;, (event, listener) =\u0026gt; { console.log(\u0026#39;----\u0026#39;) console.log(event) console.log(listener) }) myEmitter.on(\u0026#39;myEmitter\u0026#39;, (err) =\u0026gt; { console.log(err) }) 输出：\n从输出可以看出，即使没有去触发myEmitter事件，on()方法也会触发newListener事件。\n---- myEmitter [Function] 8. 事件监听数量限制 myEmitter.listenerCount(\u0026rsquo;event\u0026rsquo;): 用来计算一个实例上某个事件的监听者数量 EventEmitter.defaultMaxListeners: EventEmitter类默认的最大监听者的数量，默认是10。超过会有警告输出。 myEmitter.getMaxListeners()： EventEmitter实例默认的某个事件最大监听者的数量，默认是10。超过会有警告输出。 myEmitter.eventNames()： 返回一个实例上又多少种事件 EventEmitter和EventEmitter实例的最大监听数量为10并不是一个硬性规定，只是一个推荐值，该值可以通过setMaxListeners()接口去改变。\n改变EventEmitter的最大监听数量会影响到所有EventEmitter实例 该变EventEmitter实例的最大监听数量只会影响到实例自身 如无必要，最好的不要去改变默认的监听数量限制。事件监听数量是node检测内存泄露的一个标准一个维度。\nEventEmitter实例的最大监听数量不是一个实例的所有监听数量。\n例如同一个实例A类型事件5个监听者，B类型事件6个监听者，这个并不会有告警。如果A类型有11个监听者，就会有告警提示。\n如果在事件中发现类似的告警提示Possible EventEmitter memory leak detected，要知道从事件最大监听数的角度去排查问题。\n// 07.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() const maxListeners = 11 for (let i = 0; i \u0026lt; maxListeners; i++) { myEmitter.on(\u0026#39;event\u0026#39;, (err) =\u0026gt; { console.log(err, 1) }) } myEmitter.on(\u0026#39;event1\u0026#39;, (err) =\u0026gt; { console.log(err, 11) }) console.log(myEmitter.listenerCount(\u0026#39;event\u0026#39;)) console.log(EventEmitter.defaultMaxListeners) console.log(myEmitter.getMaxListeners()) console.log(myEmitter.eventNames()) 输出：\n11 10 10 [ \u0026#39;event\u0026#39;, \u0026#39;event1\u0026#39; ] (node:23957) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 event listeners added. Use emitter.setMaxListeners() to increase limit ","permalink":"https://wdd.js.org/posts/2018/deepin-nodejs-events/","summary":"1. 环境 node 8.11.3 2. 基本使用 // 01.js const EventEmitter = require(\u0026#39;events\u0026#39;); class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter(); myEmitter.on(\u0026#39;event\u0026#39;, () =\u0026gt; { console.log(\u0026#39;an event occurred!\u0026#39;); }); myEmitter.emit(\u0026#39;event\u0026#39;); 输出：\nan event occurred! 3. 传参与this指向 emit()方法可以传不限制数量的参数。 除了箭头函数外，在回调函数内部，this会被绑定到EventEmitter类的实例上 // 02.js const EventEmitter = require(\u0026#39;events\u0026#39;) class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() myEmitter.on(\u0026#39;event\u0026#39;, function (a, b){ console.log(a, b, this, this === myEmitter) }) myEmitter.on(\u0026#39;event\u0026#39;, (a, b) =\u0026gt; { console.","title":"NodeJS Events 模块笔记"},{"content":"一个*的作用：打散或者聚合可迭代序列 代码如下：\ndef showArgs(*args): print(args) showArgs() showArgs(\u0026#39;A\u0026#39;) showArgs(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) mylist = [\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;] mytuple = (\u0026#39;H\u0026#39;, \u0026#39;G\u0026#39;) myset = {\u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;} showArgs(*mylist) showArgs(*mytuple) showArgs(*myset) showArgs(mylist) showArgs(mytuple) showArgs(myset) 代码输出\n() (\u0026#39;A\u0026#39;,) (\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) (\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;) (\u0026#39;H\u0026#39;, \u0026#39;G\u0026#39;) (\u0026#39;Y\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Z\u0026#39;) ([\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;],) ((\u0026#39;H\u0026#39;, \u0026#39;G\u0026#39;),) ({\u0026#39;Y\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Z\u0026#39;},) 结论\n*作为函数形参时，可以将传入的实参收集到一个元组中 *作为函数实参时，可以将单个的列表，元组，集合打散成多个参数传入函数 效用：如果某个函数需要的参数是不定数量的参数，那么可以使用一个*号，将可迭代对象打散后传入，这样就可以避免循环了。\n两个*的作用：打散或者聚合字典 代码如下：\ndef showArgs(**args): print(args) showArgs(name=\u0026#39;wdd\u0026#39;) myDict = {\u0026#39;name\u0026#39;:\u0026#39;wdd\u0026#39;} showArgs(**myDict) showArgs(myDict=\u0026#39;1\u0026#39;) showArgs(myDict) 代码输出：\n{\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;} {\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;} {\u0026#39;myDict\u0026#39;: \u0026#39;1\u0026#39;} Traceback (most recent call last): File \u0026#34;test3.py\u0026#34;, line 10, in \u0026lt;module\u0026gt; showArgs(myDict) TypeError: showArgs() takes 0 positional arguments but 1 was given 结论：\n传入关键字参数k1=v1,k2=v2和传入**{'k1':'v1','k2':'v2'}的效果是相同的 函数签名如果是位置参数，则必须按照key=value的形式传参，只穿一个key会报错 总结 * 和 ** 都是一种很简介的写法 这个函数需要传不定数量的参数，如果你本身就是有一个数组的情况下，可以不使用循环。直接打散。\nmyArr = [1,2,3] myDict = {\u0026#39;name\u0026#39;:\u0026#39;wdd\u0026#39;, \u0026#39;age\u0026#39;: 11} # 方法1 for i in myArr: someFunc1(i) someFunc2(name=myDict[\u0026#39;name\u0026#39;], age=myDict[\u0026#39;age\u0026#39;]) # 方法2 someFunc1(*myArr) someFunc2(**myDict) ","permalink":"https://wdd.js.org/posts/2018/python-learn-note-01/","summary":"一个*的作用：打散或者聚合可迭代序列 代码如下：\ndef showArgs(*args): print(args) showArgs() showArgs(\u0026#39;A\u0026#39;) showArgs(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) mylist = [\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;] mytuple = (\u0026#39;H\u0026#39;, \u0026#39;G\u0026#39;) myset = {\u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;} showArgs(*mylist) showArgs(*mytuple) showArgs(*myset) showArgs(mylist) showArgs(mytuple) showArgs(myset) 代码输出\n() (\u0026#39;A\u0026#39;,) (\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) (\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;) (\u0026#39;H\u0026#39;, \u0026#39;G\u0026#39;) (\u0026#39;Y\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Z\u0026#39;) ([\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;],) ((\u0026#39;H\u0026#39;, \u0026#39;G\u0026#39;),) ({\u0026#39;Y\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Z\u0026#39;},) 结论\n*作为函数形参时，可以将传入的实参收集到一个元组中 *作为函数实参时，可以将单个的列表，元组，集合打散成多个参数传入函数 效用：如果某个函数需要的参数是不定数量的参数，那么可以使用一个*号，将可迭代对象打散后传入，这样就可以避免循环了。\n两个*的作用：打散或者聚合字典 代码如下：\ndef showArgs(**args): print(args) showArgs(name=\u0026#39;wdd\u0026#39;) myDict = {\u0026#39;name\u0026#39;:\u0026#39;wdd\u0026#39;} showArgs(**myDict) showArgs(myDict=\u0026#39;1\u0026#39;) showArgs(myDict) 代码输出：\n{\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;} {\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;} {\u0026#39;myDict\u0026#39;: \u0026#39;1\u0026#39;} Traceback (most recent call last): File \u0026#34;test3.","title":"python学习笔记 星号的作用"},{"content":"STEP 1: jenkins Additional Build Arguments jenkins Docker Build and Publish插件有个高级选项，Additional Build Arguments\n可以在docker构建时，将额外的参数传递给dockerfile。\n$BUILD_NUMBER是jenkins自带的一个环境变量，每次构建后都会加1，如：1，2，3，它是一个动态的变量，不同的构建具有不同的构建序号。\n--build-arg my_build_number=\u0026#34;$BUILD_NUMBER\u0026#34; STEP 2: dockerfile arg dockerfile 增加如下参数。如果只做了第一步，但是没有在dockerfile中申明运行时会多传入哪些参数，构建就会失败。\nARG 参数指定了构建时可以传递哪些参数进来，并且可以设置默认值，但是docker构建时传递的参数会覆盖默认值。\nENV 指令将my_build_number设置为一个环境变量，它的值为ARG参数的值。\n如果你构建的程序是nodejs项目，你就可以通过process.env.my_build_number获取jenkins构建镜像时传入的参数。\nARG my_build_number=\u0026#39;\u0026#39; ENV my_build_number ${my_build_number} ","permalink":"https://wdd.js.org/posts/2018/inject-environment-variables-to-docker-from-jenkins-build/","summary":"STEP 1: jenkins Additional Build Arguments jenkins Docker Build and Publish插件有个高级选项，Additional Build Arguments\n可以在docker构建时，将额外的参数传递给dockerfile。\n$BUILD_NUMBER是jenkins自带的一个环境变量，每次构建后都会加1，如：1，2，3，它是一个动态的变量，不同的构建具有不同的构建序号。\n--build-arg my_build_number=\u0026#34;$BUILD_NUMBER\u0026#34; STEP 2: dockerfile arg dockerfile 增加如下参数。如果只做了第一步，但是没有在dockerfile中申明运行时会多传入哪些参数，构建就会失败。\nARG 参数指定了构建时可以传递哪些参数进来，并且可以设置默认值，但是docker构建时传递的参数会覆盖默认值。\nENV 指令将my_build_number设置为一个环境变量，它的值为ARG参数的值。\n如果你构建的程序是nodejs项目，你就可以通过process.env.my_build_number获取jenkins构建镜像时传入的参数。\nARG my_build_number=\u0026#39;\u0026#39; ENV my_build_number ${my_build_number} ","title":"jenkins构建镜像时，如何向镜像中注入动态环境变量？"},{"content":" 关于jest和jenkins集成，我走了一些弯路。之前一直用jenkins打包nodejs镜像。想做nodejs自动化接口测试时，我也按照打包镜像的套路走，感觉走到死胡同。网上搜jest jenkins integration, 感觉很多答案都不靠谱。终于自己走通了一遍。\n1. 安装jenkins nodejs插件 地址：https://plugins.jenkins.io/nodejs\n注意该插件要求jenkins版本不低于1.651.3 1.1. 安装方法 方法1：在jenkins插件管理，可选插件中搜索并安装 方法2：如果搜索不到nodejs, 可以在该插件的介绍页面选择latest.hpi, 下载这个文件，然后再插件管理》高级标签页面选择上传刚才的hpi文件。\n1.2. 插件初始化设置 在全局工具管理页面，路径为/configureTools/,\n点击Nodejs 安装这一栏，新增别名 选择Nodejs版本，建议不要最新版，最好和本地开发环境一样的版本即可 输入一些全局安装包，例如: yarn 最后别忘记点击保存 2. 创建一个任务 输入一个名称 选择FreeStyle风格 点击确定 3. 任务配置 3.1. 源码管理 源码管理当然选择私有部署的git仓库了 3.2. 触发器构建 记住方框里面的地址，这个地址需要填入到gilab响应仓库的settings\u0026gt;integrations\u0026gt;URL, 然后选择add webhook, 这边git一旦push, jenkins那边就会自动构建测试任务了。 【下图： 私有gitlab仓库集成设置】\n3.3. 构建环境选择nodejs 3.4. 构建 选择执行shell 在命令中输入如下代码 注意：第一次构建可能会很慢，因为要安装nodejs, npm, yarn之类的软件\necho $PATH // 输出 path pwd // 输入当前目录 node --version // 输出node版本 yarn --version // 输出yarn版本 yarn --registry=https://registry.npm.taobao.org // 使用淘宝仓库，安装更快 yarn run test:report // 运行测试 3.5. 构建后操作 构建后操作可以选择安装一个publish html reports, 用来查看测试报告。如果没有改选项，则需要安装该插件 4. 第一次构建 不出意外的情况下，第一次构建成功。\n安装了publish html reports插件后，这边会多出一个选项。\n点击进去可以发现测试报告。\n注意 测试报告并不是publish html reports生成的。\n5. 测试报告如何生成？ 测试报告实际上是jest-html-reporter生成的。\n\u0026#34;scripts\u0026#34;: { \u0026#34;test:report\u0026#34;: \u0026#34;jest --reporters=\u0026#39;jest-html-reporter\u0026#39;\u0026#34; }, 我的项目目录如下：\n6. 最后: 如果你也需要自动化接口测试工具 可以试试我最近写的一个工具：https://github.com/wangduanduan/Aest。\n6.1. Aest 功能强大的REST接口测试工具, Power By Jest, axios, superstruct, mustache, lodash\n6.2. 特点 非常简单: 大部分工作量在于写配置文件 请求模板: 可以在配置文件中加入运行时变量，如/users/{{id}} 响应体结构验证: 支持对响应体的字段类型进行严格校验，多字段、少字段、字段类型不符合预期都会报错 非常详细的报错提示: 6.3. 安装 yarn add aester npm i aester -S ","permalink":"https://wdd.js.org/posts/2018/yarn-jenkins-ci-tutorial/","summary":"关于jest和jenkins集成，我走了一些弯路。之前一直用jenkins打包nodejs镜像。想做nodejs自动化接口测试时，我也按照打包镜像的套路走，感觉走到死胡同。网上搜jest jenkins integration, 感觉很多答案都不靠谱。终于自己走通了一遍。\n1. 安装jenkins nodejs插件 地址：https://plugins.jenkins.io/nodejs\n注意该插件要求jenkins版本不低于1.651.3 1.1. 安装方法 方法1：在jenkins插件管理，可选插件中搜索并安装 方法2：如果搜索不到nodejs, 可以在该插件的介绍页面选择latest.hpi, 下载这个文件，然后再插件管理》高级标签页面选择上传刚才的hpi文件。\n1.2. 插件初始化设置 在全局工具管理页面，路径为/configureTools/,\n点击Nodejs 安装这一栏，新增别名 选择Nodejs版本，建议不要最新版，最好和本地开发环境一样的版本即可 输入一些全局安装包，例如: yarn 最后别忘记点击保存 2. 创建一个任务 输入一个名称 选择FreeStyle风格 点击确定 3. 任务配置 3.1. 源码管理 源码管理当然选择私有部署的git仓库了 3.2. 触发器构建 记住方框里面的地址，这个地址需要填入到gilab响应仓库的settings\u0026gt;integrations\u0026gt;URL, 然后选择add webhook, 这边git一旦push, jenkins那边就会自动构建测试任务了。 【下图： 私有gitlab仓库集成设置】\n3.3. 构建环境选择nodejs 3.4. 构建 选择执行shell 在命令中输入如下代码 注意：第一次构建可能会很慢，因为要安装nodejs, npm, yarn之类的软件\necho $PATH // 输出 path pwd // 输入当前目录 node --version // 输出node版本 yarn --version // 输出yarn版本 yarn --registry=https://registry.","title":"jest jenkins搭建自动化测试CI教程"},{"content":"1. jenkins项目配置 1.1. 构建触发器设置 方框位置打钩 注意：椭圆圈住的位置的URL在下文中会用到, 该URL是JenKins自动生成的 如果你的项目中看不到这一项，那么你需要安装Gitlab Plugin\n1.2. 构建 注意：$BUILD_NUMBER是JenKins自带的一个环境变量，表示当前构建的次数。加上这个之后，每次构建产生的tag都不一样。\n构建生成的项目名称如下图所示。\nDocker Build and Publish 高级设置\nSkip Push 默认情况该值处于选中状态，如果需要push到私有仓库，那么该项目要取消勾选。如果你构建的项目没有push到私有仓库，那么就是该值引起的问题\n其他参数可以自行设置。\n2. gitlab配置 2.1. 配置WebHooks 找到项目的 projectX \u0026gt; Settings \u0026gt; Integrations页面。\n在椭圆中填入1.1章节中的URL 选中Push events 点击Add webhook 添加成功后，会在Add webhook按钮下出现 Webhooks列表，你可以点击某一个webhook后的Test按钮进行测试。\n如果测试成功，jenkins那边会新建构建任务。\n如果测试失败，gitlab这边会给出具体的错误信息。\n3. 高级技巧 3.2 构建节流 在使用GitLab CI自动构建项目时。正常情况GitLab项目的每次push，JenKins都会自动打包。\n如果一样项目一分钟收到30次push, JenKins做30次打包是非常浪费资源的。通过设置构建节流，可以限制单位时间内JenKins的构建次数。\n下图设置Throttle Builds每小时只能构建一次，但是允许用户手动构建时，跳过构建节流的限制。\n3.1. JenKins环境变量 jenkins还有更多的环境变量，可以在构建时读取出来，方便参数化构建。\n例如你想获取当前构建的累积次数，可以用$BUILD_NUMBER\n环境变量 描述 BUILD_URL The URL where the results of this build can be found (e.g. http://buildserver/jenkins/job/MyJobName/666/) EXECUTOR_NUMBER The unique number that identifies the current executor (among executors of the same machine) that\u0026rsquo;s carrying out this build. This is the number you see in the \u0026ldquo;build executor status\u0026rdquo;, except that the number starts from 0, not 1. NODE_NAME The name of the node the current build is running on. Equals \u0026lsquo;master\u0026rsquo; for master node. BUILD_NUMBER The current build number, such as \u0026ldquo;153\u0026rdquo; BUILD_ID The current build id, such as \u0026ldquo;2005-08-22_23-59-59\u0026rdquo; (YYYY-MM-DD_hh-mm-ss, defunct since version 1.597) WORKSPACE The absolute path of the workspace. BUILD_TAG String of jenkins-${JOB_NAME}-${BUILD_NUMBER}. Convenient to put into a resource file, a jar file, etc for easier identification. JENKINS_URL Set to the URL of the Jenkins master that\u0026rsquo;s running the build. This value is used by Jenkins CLI for example JOB_NAME Name of the project of this build. This is the name you gave your job when you first set it up. It\u0026rsquo;s the third column of the Jenkins Dashboard main page. JAVA_HOME If your job is configured to use a specific JDK, this variable is set to the JAVA_HOME of the specified JDK. When this variable is set, PATH is also updated to have $JAVA_HOME/bin. SVN_REVISION For Subversion-based projects, this variable contains the revision number of the module. If you have more than one module specified, this won\u0026rsquo;t be set. GIT_URL For Git-based projects, this variable contains the Git url (like git@github.com:user/repo.git or [https://github.com/user/repo.git]) GIT_COMMIT For Git-based projects, this variable contains the Git hash of the commit checked out for the build (like ce9a3c1404e8c91be604088670e93434c4253f03) (all the GIT_* variables require git plugin) GIT_BRANCH For Git-based projects, this variable contains the Git branch that was checked out for the build (normally origin/master) CVS_BRANCH For CVS-based projects, this variable contains the branch of the module. If CVS is configured to check out the trunk, this environment variable will not be set. 参考 Building a software project ","permalink":"https://wdd.js.org/posts/2018/gitlab-jenkins-ci-tutorial/","summary":"1. jenkins项目配置 1.1. 构建触发器设置 方框位置打钩 注意：椭圆圈住的位置的URL在下文中会用到, 该URL是JenKins自动生成的 如果你的项目中看不到这一项，那么你需要安装Gitlab Plugin\n1.2. 构建 注意：$BUILD_NUMBER是JenKins自带的一个环境变量，表示当前构建的次数。加上这个之后，每次构建产生的tag都不一样。\n构建生成的项目名称如下图所示。\nDocker Build and Publish 高级设置\nSkip Push 默认情况该值处于选中状态，如果需要push到私有仓库，那么该项目要取消勾选。如果你构建的项目没有push到私有仓库，那么就是该值引起的问题\n其他参数可以自行设置。\n2. gitlab配置 2.1. 配置WebHooks 找到项目的 projectX \u0026gt; Settings \u0026gt; Integrations页面。\n在椭圆中填入1.1章节中的URL 选中Push events 点击Add webhook 添加成功后，会在Add webhook按钮下出现 Webhooks列表，你可以点击某一个webhook后的Test按钮进行测试。\n如果测试成功，jenkins那边会新建构建任务。\n如果测试失败，gitlab这边会给出具体的错误信息。\n3. 高级技巧 3.2 构建节流 在使用GitLab CI自动构建项目时。正常情况GitLab项目的每次push，JenKins都会自动打包。\n如果一样项目一分钟收到30次push, JenKins做30次打包是非常浪费资源的。通过设置构建节流，可以限制单位时间内JenKins的构建次数。\n下图设置Throttle Builds每小时只能构建一次，但是允许用户手动构建时，跳过构建节流的限制。\n3.1. JenKins环境变量 jenkins还有更多的环境变量，可以在构建时读取出来，方便参数化构建。\n例如你想获取当前构建的累积次数，可以用$BUILD_NUMBER\n环境变量 描述 BUILD_URL The URL where the results of this build can be found (e.","title":"GitLab JenKins 自动化构建"},{"content":"需求描述 可以把字符串下载成txt文件 可以把对象序列化后下载json文件 下载由ajax请求返回的Excel, Word, pdf 等等其他文件 基本思想 downloadJsonIVR () { var data = {name: \u0026#39;age\u0026#39;} data = JSON.stringify(data) data = new Blob([data]) var a = document.createElement(\u0026#39;a\u0026#39;) var url = window.URL.createObjectURL(data) a.href = url a.download = \u0026#39;what-you-want.json\u0026#39; a.click() }, 从字符串下载文件 从ajax请求中下载文件 ","permalink":"https://wdd.js.org/posts/2018/js-download-file/","summary":"需求描述 可以把字符串下载成txt文件 可以把对象序列化后下载json文件 下载由ajax请求返回的Excel, Word, pdf 等等其他文件 基本思想 downloadJsonIVR () { var data = {name: \u0026#39;age\u0026#39;} data = JSON.stringify(data) data = new Blob([data]) var a = document.createElement(\u0026#39;a\u0026#39;) var url = window.URL.createObjectURL(data) a.href = url a.download = \u0026#39;what-you-want.json\u0026#39; a.click() }, 从字符串下载文件 从ajax请求中下载文件 ","title":"JavaScript动态下载文件"},{"content":" 1. 风雨总在阳光后 今天在使用一个npm包时，无论怎么搞，它的功能总是无法符合我的预期。\n于是我把这个包卸载了，自己写了几行代码，来替代这个包的功能，运行正常。\n这件事情引起我的反思，当初我用这个包，是因为这个包提供功能，可以让我少写几行代码。\n于是我就用了，感觉很好，天朗气清，惠风和畅。然而好景不长，风雨总在阳光后。\nnpm包大多是开源的项目，你可以免费的使用这些包带来的好处。\n但是如果出现bug, 你也不要苛责哪些包的开发者，毕竟大多数开发者都是无私奉献，并没有从中取得什么好处。\n如果你自己可以几行代码就可以搞定的事情，就不要在npm包中找解决方案了。不要用偷懒的接口给自己以后的道路挖坑。\n2. 少的哲学 一个变量可以满足要求话， 就不要写两个变量， 因为变量是小鬼， 越多变量， 越难控制。\n一行代码可以完成的功能， 就不要写两行了， 因为代码行是用过的鞋垫， 行数越多， 味道越臭。\n最漂亮的函数体内只有一行代码， 如果做不到， 那么最多铺满编辑器的一屏， 不用滚动屏幕就可以看完整个函数体， 也不需要切换你脑子里的上下文环境和调用栈了。\n如果可以的话， 我想做一个不用写代码的程序员\n3. 代码可读性 如果你今天写的代码， 只有上帝和你自己能看懂， 那么一个月之后， 这些代码只有上帝能看懂。\n代码不是写给计算机看的， 而是写给人看的。 如果你写的代码只有编译器能看懂， 那么你那么叼， 你为什么不使用只有0和1的键盘呢？\n4. 有能力就自己动手 如果你自己造不了轮子， 没关系，大多数人都在使用别人造的轮子， 如果你造不了螺丝， 那你最好还是改行做点别的事情，\n如果你看不懂轮子的说明书， 因为那毕竟是英文啊！ 那有怎样，你自己写的代码不就是英文码 你既然这么害怕英文， 为什么不自己用中文写代码呢\n","permalink":"https://wdd.js.org/posts/2018/add-npm-package-to-your-project-realy-necessary/","summary":"1. 风雨总在阳光后 今天在使用一个npm包时，无论怎么搞，它的功能总是无法符合我的预期。\n于是我把这个包卸载了，自己写了几行代码，来替代这个包的功能，运行正常。\n这件事情引起我的反思，当初我用这个包，是因为这个包提供功能，可以让我少写几行代码。\n于是我就用了，感觉很好，天朗气清，惠风和畅。然而好景不长，风雨总在阳光后。\nnpm包大多是开源的项目，你可以免费的使用这些包带来的好处。\n但是如果出现bug, 你也不要苛责哪些包的开发者，毕竟大多数开发者都是无私奉献，并没有从中取得什么好处。\n如果你自己可以几行代码就可以搞定的事情，就不要在npm包中找解决方案了。不要用偷懒的接口给自己以后的道路挖坑。\n2. 少的哲学 一个变量可以满足要求话， 就不要写两个变量， 因为变量是小鬼， 越多变量， 越难控制。\n一行代码可以完成的功能， 就不要写两行了， 因为代码行是用过的鞋垫， 行数越多， 味道越臭。\n最漂亮的函数体内只有一行代码， 如果做不到， 那么最多铺满编辑器的一屏， 不用滚动屏幕就可以看完整个函数体， 也不需要切换你脑子里的上下文环境和调用栈了。\n如果可以的话， 我想做一个不用写代码的程序员\n3. 代码可读性 如果你今天写的代码， 只有上帝和你自己能看懂， 那么一个月之后， 这些代码只有上帝能看懂。\n代码不是写给计算机看的， 而是写给人看的。 如果你写的代码只有编译器能看懂， 那么你那么叼， 你为什么不使用只有0和1的键盘呢？\n4. 有能力就自己动手 如果你自己造不了轮子， 没关系，大多数人都在使用别人造的轮子， 如果你造不了螺丝， 那你最好还是改行做点别的事情，\n如果你看不懂轮子的说明书， 因为那毕竟是英文啊！ 那有怎样，你自己写的代码不就是英文码 你既然这么害怕英文， 为什么不自己用中文写代码呢","title":"如无必要，请不要多安装任意一个npm包"},{"content":" 1. 什么是REST? 2. REST API最为重要的约束 3. REST API HTTP方法 与 CURD 4. 状态码 5. RESTful架构设计 6. 文档 7. 版本 8. 深入理解状态与无状态 9. 参考 1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia\nREST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。\nRESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。\n2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。 这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。\n4. 状态码 1xx - informational; 2xx - success; 3xx - redirection; 4xx - client error; 5xx - server error. 5. RESTful架构设计 GET /users - get all users; GET /users/123 - get a particular user with id = 123; GET /posts - get all posts. POST /users. PUT /users/123 - upgrade a user entity with id = 123. DELETE /users/123 - delete a user with id = 123. 6. 文档 7. 版本 版本管理一般有两种\n位于url中的版本标识： http://example.com/api/v1 位于请求头中的版本标识：Accept: application/vnd.redkavasyl+json; version=2.0 8. 深入理解状态与无状态 我认为REST架构最难理解的就是状态与无状态。下面我画出两个示意图。\n图1是有状态的服务，状态存储于单个服务之中，一旦一个服务挂了，状态就没了，有状态服务很难扩展。无状态的服务，状态存储于客户端，一个请求可以被投递到任何服务端，即使一个服务挂了，也不回影响到同一个客户端发来的下一个请求。\n【图1 有状态的架构】\n【图2 无状态的架构】\neach request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server. Session state is therefore kept entirely on the client. rest_arch_style stateless\n每一个请求自身必须携带所有的信息，让客户端理解这个请求。举个栗子，常见的翻页操作，应该客户端告诉服务端想要看第几页的数据，而不应该让服务端记住客户端看到了第几页。\n9. 参考 A Beginner’s Tutorial for Understanding RESTful API Versioning REST Services ","permalink":"https://wdd.js.org/posts/2018/think-about-restful-api/","summary":"1. 什么是REST? 2. REST API最为重要的约束 3. REST API HTTP方法 与 CURD 4. 状态码 5. RESTful架构设计 6. 文档 7. 版本 8. 深入理解状态与无状态 9. 参考 1. 什么是REST? 表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换（REST，英文：Representational State Transfer）是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。匹配或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。wikipdeia\nREST API 不是一个标准或者一个是协议，仅仅是一种风格，一种style。\nRESTful API的简单定义可以轻松解释这个概念。 REST是一种架构风格，RESTful是它的解释。也就是说，如果您的后端服务器具有REST API，并且您（从网站/应用程序）向客户端请求此API，则您的客户端为RESTful。\n2. REST API最为重要的约束 Client-Server 通信只能由客户端单方面发起，表现为请求-响应的形式 Stateless 通信的会话状态（Session State）应该全部由客户端负责维护 Cache 响应内容可以在通信链的某处被缓存，以改善网络效率 Uniform Interface 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性 Layered System 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 Code-On-Demand 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 3. REST API HTTP方法 与 CURD REST API 使用POST，GET, PUT, DELETE的HTTP方法来描述对资源的增、查、改、删。 这四个HTTP方法在数据层对应着SQL的插入、查询、更新、删除操作。","title":"Restful API 架构思考"},{"content":"1. 问题现象 有时候发现mac风扇响的厉害，于是我检查了mac系统的活动监视器，发现Google Chrome Helper占用99%的CPU。\n通常来说Chrome如果占用过高的内存，这并不是什么问题，毕竟Chrome的性能以及易用性是建立在占用很多内存的基础上的。但是无论什么程序，持续的占用超过80%的cpu，都是极不正常的。大多数程序都是占用维持在低于10%的CPU。\n活动监视器指出问题出现在Chrome浏览器。那么问题可以再次细分为三块。\nChrome系统自身问题 一些插件，例如flash插件，扩展插件 网页程序js出现的问题 2. 从任务管理器着手 其实Chrome浏览器自身也是有任务管理器的，一般来说windows版chrome按住shift+esc就会调出任务管理器窗口。mac版调出任务管理器没有快捷，只能通过Window \u0026gt; Task Manager调出。\n调出任务管理器后，发现一个标签页，CPU占用率达到99%， 那就说明，应该是这个标签页中存在持续占用大量CPU计算的程序。\n最后找到这个页面，发现该页面背景图是一种动态粒子图。就是基于particles.js做的。我想，终于找到你了。\n于是我把这个动态图的相关js代码给注释掉，电脑的风扇也终于变得安静了。\n3. 问题总结 问题解决的总结：解决问题的方法时很简单的，基于一个现象，找到一个原因，基于这个原因再找到一个现象，然后一步一步缩小问题范围，逼近最终原因。\n机器CPU过高，一般都是可以从任务管理器着手解决。系统的任务管理器可以监控各个程序占用的CPU是否正常，通常程序自身也是有任务管理的。\n像谷歌浏览器这种软件，几乎本身就是一个操作系统，所以说它的任务管理器也是必不可少的。Chrome浏览器再带的任务管理器可以告诉你几个关键信息。\n任务占用的内存 任务占用的CPU 任务占用的网络流量大小 如果你一打开谷歌浏览器，你的电脑风扇就拼命转，那你最好打开谷歌浏览器的任务管理器看看。\n4. 关于动态背景图的思考 动态背景图往往都会给人很酷炫的感觉，但是这种背景图的制作并不是很复杂，如果你使用particles.js来制作，制作一些动态背景图只需要几行代码就可以搞定。但是这种酷炫的背后，CPU也在承受着压力。\nparticles.js提供的demo效果图，在Chrome中CPU会被提高到100%。\n也有几家使用动态背景图的官网。我记得知乎以前就用过动态背景图，但是现在找不到了。另外一个使用动态背景图的是daocloud, CPU也是会在首页飙升到50%。\n所谓：强招必自损，动态背景图在给人以炫酷科技感的同时，也需要权衡这种技术对客户计算机的压力。\n另外，不要小看JavaScript, 它也可能引起大问题\n","permalink":"https://wdd.js.org/posts/2018/how-to-fix-google-chrome-very-high-cpu-cost/","summary":"1. 问题现象 有时候发现mac风扇响的厉害，于是我检查了mac系统的活动监视器，发现Google Chrome Helper占用99%的CPU。\n通常来说Chrome如果占用过高的内存，这并不是什么问题，毕竟Chrome的性能以及易用性是建立在占用很多内存的基础上的。但是无论什么程序，持续的占用超过80%的cpu，都是极不正常的。大多数程序都是占用维持在低于10%的CPU。\n活动监视器指出问题出现在Chrome浏览器。那么问题可以再次细分为三块。\nChrome系统自身问题 一些插件，例如flash插件，扩展插件 网页程序js出现的问题 2. 从任务管理器着手 其实Chrome浏览器自身也是有任务管理器的，一般来说windows版chrome按住shift+esc就会调出任务管理器窗口。mac版调出任务管理器没有快捷，只能通过Window \u0026gt; Task Manager调出。\n调出任务管理器后，发现一个标签页，CPU占用率达到99%， 那就说明，应该是这个标签页中存在持续占用大量CPU计算的程序。\n最后找到这个页面，发现该页面背景图是一种动态粒子图。就是基于particles.js做的。我想，终于找到你了。\n于是我把这个动态图的相关js代码给注释掉，电脑的风扇也终于变得安静了。\n3. 问题总结 问题解决的总结：解决问题的方法时很简单的，基于一个现象，找到一个原因，基于这个原因再找到一个现象，然后一步一步缩小问题范围，逼近最终原因。\n机器CPU过高，一般都是可以从任务管理器着手解决。系统的任务管理器可以监控各个程序占用的CPU是否正常，通常程序自身也是有任务管理的。\n像谷歌浏览器这种软件，几乎本身就是一个操作系统，所以说它的任务管理器也是必不可少的。Chrome浏览器再带的任务管理器可以告诉你几个关键信息。\n任务占用的内存 任务占用的CPU 任务占用的网络流量大小 如果你一打开谷歌浏览器，你的电脑风扇就拼命转，那你最好打开谷歌浏览器的任务管理器看看。\n4. 关于动态背景图的思考 动态背景图往往都会给人很酷炫的感觉，但是这种背景图的制作并不是很复杂，如果你使用particles.js来制作，制作一些动态背景图只需要几行代码就可以搞定。但是这种酷炫的背后，CPU也在承受着压力。\nparticles.js提供的demo效果图，在Chrome中CPU会被提高到100%。\n也有几家使用动态背景图的官网。我记得知乎以前就用过动态背景图，但是现在找不到了。另外一个使用动态背景图的是daocloud, CPU也是会在首页飙升到50%。\n所谓：强招必自损，动态背景图在给人以炫酷科技感的同时，也需要权衡这种技术对客户计算机的压力。\n另外，不要小看JavaScript, 它也可能引起大问题","title":"记一次如何解决谷歌浏览器占用过高cpu问题过程"},{"content":"最近有个朋友的孩子得了白血病，我曾经以为白血病就是血液是白色的，后来查了资料才知道，白血病的白字是白细胞的意思。\n虽然我对白血病不甚了解，我也知道这个病是很严重的，最低要花个四五十万，可能也是治不好。\n达尔文的物种进化论物竞天择，适者生存在人类面前似乎并不顶用。脖子短的长颈鹿慢慢饿死了，生存下来的都是脖子长的。按照这个道理，人类之中得了各种癌症的都会慢慢死去，逐渐减少，剩下的人应该都是健康的居多。但是事实呢，各种得了疑难杂症的人不仅没有减少，反而增多了。\n你不能因为一个人有某种癌症，就剥夺他繁衍后代的权利吧。\n最近在看一本书《我们为什么生病》，这本书我还没看完，但是获取到一点概念：生病的原因并不仅仅只有遗传因素，外界的因素往往也是至关重要的。\n以后我看完这本书时，再来补充内容吧。\n","permalink":"https://wdd.js.org/posts/2018/think-about-leukemia/","summary":"最近有个朋友的孩子得了白血病，我曾经以为白血病就是血液是白色的，后来查了资料才知道，白血病的白字是白细胞的意思。\n虽然我对白血病不甚了解，我也知道这个病是很严重的，最低要花个四五十万，可能也是治不好。\n达尔文的物种进化论物竞天择，适者生存在人类面前似乎并不顶用。脖子短的长颈鹿慢慢饿死了，生存下来的都是脖子长的。按照这个道理，人类之中得了各种癌症的都会慢慢死去，逐渐减少，剩下的人应该都是健康的居多。但是事实呢，各种得了疑难杂症的人不仅没有减少，反而增多了。\n你不能因为一个人有某种癌症，就剥夺他繁衍后代的权利吧。\n最近在看一本书《我们为什么生病》，这本书我还没看完，但是获取到一点概念：生病的原因并不仅仅只有遗传因素，外界的因素往往也是至关重要的。\n以后我看完这本书时，再来补充内容吧。","title":"关于白血病的思考"},{"content":" 有些安全性不太重要的数据，我不想花大力气搞一台服务器，再安装mysql或者 monogdb，再写点rest接口。这也太麻烦了，浏览器里本来就有很好用的数据库。你为什么不尝试一下呢？\n1. 客户端存储目前有两个方案比较 方案 优点 缺点 localStorage 简单易用，同步操作 存储容量小，一般不超过10MB indexDB 接口都是异步的，操作不便 容量比localStorage大 如果要使用localStorage，那么存储量比较小。如果是用indexDB，那么最好找点开源库，直接封装友好的API, 来方便我们使用indexDB。\n下面介绍一些很好用的的库。\n2. 简介 2.1. localForage 离线存储， 提供强大的API封装IndexedDB,WebSQL,localStorage 12073 star https://github.com/localForage/localForage localforage.setItem(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;, function (err) { // if err is non-null, we got an error localforage.getItem(\u0026#39;key\u0026#39;, function (err, value) { // if err is non-null, we got an error. otherwise, value is the value }); }); 2.2. Dexie.js 专业封装 IndexedDB 3040 star https://github.com/dfahlander/Dexie.js const db = new Dexie(\u0026#39;MyDatabase\u0026#39;); // Declare tables, IDs and indexes db.version(1).stores({ friends: \u0026#39;++id, name, age\u0026#39; }); // Find some old friends await db.friends .where(\u0026#39;age\u0026#39;) .above(75) .toArray(); // or make a new one await db.friends.add({ name: \u0026#39;Camilla\u0026#39;, age: 25, street: \u0026#39;East 13:th Street\u0026#39;, picture: await getBlob(\u0026#39;camilla.png\u0026#39;) }); 2.3. zangodb 给HTML5 IndexedDB 封装类似mongodb类似接口, 如果你熟悉mongodb, 那一定会用zangodb 688 star https://github.com/erikolson186/zangodb let db = new zango.Db(\u0026#39;mydb\u0026#39;, { people: [\u0026#39;age\u0026#39;] }); let people = db.collection(\u0026#39;people\u0026#39;); let docs = [ { name: \u0026#39;Frank\u0026#39;, age: 20 }, { name: \u0026#39;Thomas\u0026#39;, age: 33 }, { name: \u0026#39;Todd\u0026#39;, age: 33 }, { name: \u0026#39;John\u0026#39;, age: 28 }, { name: \u0026#39;Peter\u0026#39;, age: 33 }, { name: \u0026#39;George\u0026#39;, age: 28 } ]; people.insert(docs).then(() =\u0026gt; { return people.find({ name: { $ne: \u0026#39;John\u0026#39; }, age: { $gt: 20 } }).group({ _id: { age: \u0026#39;$age\u0026#39; }, count: { $sum: 1 } }).project({ _id: 0, age: \u0026#39;$_id.age\u0026#39; }).sort({ age: -1 }).forEach(doc =\u0026gt; console.log(\u0026#39;doc:\u0026#39;, doc)); }).catch(error =\u0026gt; console.error(error)); 2.4. JsStore 使用类似 sql的接口操作 indexDB 74 star https://github.com/ujjwalguptaofficial/JsStore var value = { column1: value1, column2: value2, column3: value3, ... columnN: valueN }; connection.insert({ into: \u0026#34;TABLE_NAME\u0026#34;, values: [Value], //you can insert multiple values at a time }).then(function(rowsAffected) { if (rowsAffected \u0026gt; 0) { alert(\u0026#39;Successfully Added\u0026#39;); } }).catch(function(error) { alert(error.message); }); 2.5. minimongo 基于localstorage的浏览器端mongodb数据库 697 star https://github.com/mWater/minimongo // Require minimongo var minimongo = require(\u0026#34;minimongo\u0026#34;); var LocalDb = minimongo.MemoryDb; // Create local db (in memory database with no backing) db = new LocalDb(); // Add a collection to the database db.addCollection(\u0026#34;animals\u0026#34;); doc = { species: \u0026#34;dog\u0026#34;, name: \u0026#34;Bingo\u0026#34; }; // Always use upsert for both inserts and modifies db.animals.upsert(doc, function() { // Success: // Query dog (with no query options beyond a selector) db.animals.findOne({ species:\u0026#34;dog\u0026#34; }, {}, function(res) { console.log(\u0026#34;Dog\u0026#39;s name is: \u0026#34; + res.name); }); }); 2.6. pouchdb 基于indexDB的CouchDB-style浏览器端数据库 10599 star https://github.com/pouchdb/pouchdb var db = new PouchDB(\u0026#39;dbname\u0026#39;); db.put({ _id: \u0026#39;dave@gmail.com\u0026#39;, name: \u0026#39;David\u0026#39;, age: 69 }); db.changes().on(\u0026#39;change\u0026#39;, function() { console.log(\u0026#39;Ch-Ch-Changes\u0026#39;); }); db.replicate.to(\u0026#39;http://example.com/mydb\u0026#39;); 2.7. lowdb 小型json数据库，浏览器端基于localStorage, lodash风格的接口，让它非常可爱😊 7997 star https://github.com/typicode/lowdb import low from \u0026#39;lowdb\u0026#39; import LocalStorage from \u0026#39;lowdb/adapters/LocalStorage\u0026#39; const adapter = new LocalStorage(\u0026#39;db\u0026#39;) const db = low(adapter) db.defaults({ posts: [] }) .write() // Data is automatically saved to localStorage db.get(\u0026#39;posts\u0026#39;) .push({ title: \u0026#39;lowdb\u0026#39; }) .write() 3. 参考 html5-local-storage-revisited maximum-item-size-in-indexeddb ","permalink":"https://wdd.js.org/posts/2018/client-side-storage-about-indexdb/","summary":"有些安全性不太重要的数据，我不想花大力气搞一台服务器，再安装mysql或者 monogdb，再写点rest接口。这也太麻烦了，浏览器里本来就有很好用的数据库。你为什么不尝试一下呢？\n1. 客户端存储目前有两个方案比较 方案 优点 缺点 localStorage 简单易用，同步操作 存储容量小，一般不超过10MB indexDB 接口都是异步的，操作不便 容量比localStorage大 如果要使用localStorage，那么存储量比较小。如果是用indexDB，那么最好找点开源库，直接封装友好的API, 来方便我们使用indexDB。\n下面介绍一些很好用的的库。\n2. 简介 2.1. localForage 离线存储， 提供强大的API封装IndexedDB,WebSQL,localStorage 12073 star https://github.com/localForage/localForage localforage.setItem(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;, function (err) { // if err is non-null, we got an error localforage.getItem(\u0026#39;key\u0026#39;, function (err, value) { // if err is non-null, we got an error. otherwise, value is the value }); }); 2.2. Dexie.js 专业封装 IndexedDB 3040 star https://github.com/dfahlander/Dexie.js const db = new Dexie(\u0026#39;MyDatabase\u0026#39;); // Declare tables, IDs and indexes db.","title":"浏览器端数据库存储方案的整理 -- indexDB 和 localStorage"},{"content":"之前做的一个项目，使用了Vuex。最近又做了一个项目，也打算用Vuex。只是某些Vuex的概念比较模糊了。所以打算写篇文章记录一下。\n我记得以前看过一篇文章，核心思想就是你应该尽早使用Vuex，但是在网上也搜不到了。\n无论谁来讲Vuex, 其实都没有官网讲的好，参见官网Vuex 是什么？, 如果你对Vuex有任何概念不清晰，官网都是最好的老师。\n官网最后说：\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。参考Creating a Global Event Bus with Vue.js\n但是，杀鸡用牛刀也未尝不可。\n程序员往往喜欢：Talk is cheap, show me the code。废话少说，放码过来。我也是，有时候想弄清楚一个问题，往往喜欢去直接看代码。但是对整体的设计原理概念不甚了解。\n但是，当我看到官网这张图，我盯着看了几分钟后，理解了这张图，也完全理解了Vuex。\n那么为什么要尽早使用Vuex呢？\nVuex其实很简单，没你想象的那么复杂 越早Vuex使用越熟练，也能提高自己的知识储备 你迟早需要状态管理的，与其将来痛苦重构，不如尽早享受Vuex带来的畅爽感觉 至于怎么使用Vuex，我就不多说了。网上优秀的教程蛮多的。\n","permalink":"https://wdd.js.org/posts/2018/you-should-use-vuex-early/","summary":"之前做的一个项目，使用了Vuex。最近又做了一个项目，也打算用Vuex。只是某些Vuex的概念比较模糊了。所以打算写篇文章记录一下。\n我记得以前看过一篇文章，核心思想就是你应该尽早使用Vuex，但是在网上也搜不到了。\n无论谁来讲Vuex, 其实都没有官网讲的好，参见官网Vuex 是什么？, 如果你对Vuex有任何概念不清晰，官网都是最好的老师。\n官网最后说：\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。参考Creating a Global Event Bus with Vue.js\n但是，杀鸡用牛刀也未尝不可。\n程序员往往喜欢：Talk is cheap, show me the code。废话少说，放码过来。我也是，有时候想弄清楚一个问题，往往喜欢去直接看代码。但是对整体的设计原理概念不甚了解。\n但是，当我看到官网这张图，我盯着看了几分钟后，理解了这张图，也完全理解了Vuex。\n那么为什么要尽早使用Vuex呢？\nVuex其实很简单，没你想象的那么复杂 越早Vuex使用越熟练，也能提高自己的知识储备 你迟早需要状态管理的，与其将来痛苦重构，不如尽早享受Vuex带来的畅爽感觉 至于怎么使用Vuex，我就不多说了。网上优秀的教程蛮多的。","title":"你应该尽早使用Vuex"},{"content":"某些IE浏览器location.origin属性是undefined，所以如果你要使用该属性，那么要注意做个能力检测。\nif (!window.location.origin) { window.location.origin = window.location.protocol + \u0026#34;//\u0026#34; + window.location.hostname + (window.location.port ? \u0026#39;:\u0026#39; + window.location.port: \u0026#39;\u0026#39;); }i ","permalink":"https://wdd.js.org/posts/2018/ie-not-support-location-origin/","summary":"某些IE浏览器location.origin属性是undefined，所以如果你要使用该属性，那么要注意做个能力检测。\nif (!window.location.origin) { window.location.origin = window.location.protocol + \u0026#34;//\u0026#34; + window.location.hostname + (window.location.port ? \u0026#39;:\u0026#39; + window.location.port: \u0026#39;\u0026#39;); }i ","title":"IE浏览器不支持location.origin"},{"content":"1. 目前E2E测试工具有哪些？ 项目 Web Star puppeteer Chromium (~170Mb Mac, ~282Mb Linux, ~280Mb Win) 31906 nightmare Electron 15502 nightwatch WebDriver 8135 protractor selenium 7532 casperjs PhantomJS 7180 cypress Electron 5303 Zombie 不需要 4880 testcafe 不需要 4645 CodeceptJS webdriverio 1665 端到端测试一般都需要一个Web容器，来运行前端应用。例如Chromium, Electron, PhantomJS, WebDriver等等。\n从体积角度考虑，这些Web容器体积一般都很大。\n从速度的角度考虑：PhantomJS, WebDriver \u0026lt; Electon, Chromium。\n而且每个工具的侧重点也不同，建议按照需要去选择。\n2. 优秀的端到端测试工具应该有哪些特点？ 安装简易：我希望它非常容易安装，最好可以一行命令就可以安装完毕 依赖较少：我只想做个E2E测试，不想安装jdk, python之类的东西 速度很快：运行测试用例的速度要快 报错详细：详细的报错 API完备：鼠标键盘操作接口，DOM查询接口等 Debug方便：出错了可以很方便的调试，而不是去猜 3. 为什么要用Cypress？ Cypress基本上拥有了上面的特点之外，还有以下特点。\n时光穿梭 测试运行时，Cypress会自动截图，你可以轻易的查看每个时间的截图 Debug友好 不需要再去猜测为什么测试有失败了，Cypress提供Chrome DevTools, 所以Debug是非常方便的。 实时刷新 Cypress检测测试用例改变后，会自动刷新 自动等待 不需要在使用wait类似的方法等待某个DOM出现，Cypress会自动帮你做这些 Spies, stubs, and clocks Verify and control the behavior of functions, server responses, or timers. The same functionality you love from unit testing is right at your fingertips. 网络流量控制 在不涉及服务器的情况下轻松控制，存根和测试边缘案例。无论你喜欢，你都可以存储网络流量。 一致的结果 我们的架构不使用Selenium或WebDriver。向快速，一致和可靠的无剥落测试问好。 截图和视频 查看失败时自动截取的截图，或无条件运行时整个测试套件的视频。 4. 安装cypress 4.1. 使用npm方法安装 注意这个方法需要下载压缩过Electron, 所以可能会花费几分钟时间，请耐心等待。\nnpm i cypress -D 4.2. 直接下载Cypress客户端 你可以把Cypress想想成一个浏览器，可以单独把它下载下来，安装到电脑上，当做一个客户端软件来用。\n打开之后就是这个样子，可以手动去打开项目，运行测试用例。\n5. 初始化Cypress Cypress初始化，会在项目根目录自动生成cypress文件夹，并且里面有些测试用例模板，可以很方便的学习。\n初始化的方法有两种。\n如果你下载的客户端，那么你用客户端打开项目时，它会检测项目目录下有没有Cypress目录，如果没有，就自动帮你生成模板。\n如果你使用npm安装的Cypress，可以使用命令node_modules/.bin/cypress open去初始化\n6. 编写测试用例 // hacker-news.js describe(\u0026#39;Hacker News登录测试\u0026#39;, () =\u0026gt; { it(\u0026#39;登录页面\u0026#39;, () =\u0026gt; { cy.visit(\u0026#39;https://news.ycombinator.com/login?goto=news\u0026#39;) cy.get(\u0026#39;input[name=\u0026#34;acct\u0026#34;]\u0026#39;).eq(0).type(\u0026#39;test\u0026#39;) cy.get(\u0026#39;input[name=\u0026#34;pw\u0026#34;]\u0026#39;).eq(0).type(\u0026#39;123456\u0026#39;) cy.get(\u0026#39;input[value=\u0026#34;login\u0026#34;]\u0026#39;).click() cy.contains(\u0026#39;Bad login\u0026#39;) }) }) 7. 查看结果 打开Cypress客户端，选择要测试项目的根目录，点击hacker-news.js后，测试用例就会自动运行\n运行结束后，左侧栏目鼠标移动上去，右侧栏都会显示出该步骤的截图，所以叫做时光穿梭功能。\n从截图也可以看出来，Cypress的步骤描述很详细。\n","permalink":"https://wdd.js.org/posts/2018/e2e-testing-hacker-news-with-cypress/","summary":"1. 目前E2E测试工具有哪些？ 项目 Web Star puppeteer Chromium (~170Mb Mac, ~282Mb Linux, ~280Mb Win) 31906 nightmare Electron 15502 nightwatch WebDriver 8135 protractor selenium 7532 casperjs PhantomJS 7180 cypress Electron 5303 Zombie 不需要 4880 testcafe 不需要 4645 CodeceptJS webdriverio 1665 端到端测试一般都需要一个Web容器，来运行前端应用。例如Chromium, Electron, PhantomJS, WebDriver等等。\n从体积角度考虑，这些Web容器体积一般都很大。\n从速度的角度考虑：PhantomJS, WebDriver \u0026lt; Electon, Chromium。\n而且每个工具的侧重点也不同，建议按照需要去选择。\n2. 优秀的端到端测试工具应该有哪些特点？ 安装简易：我希望它非常容易安装，最好可以一行命令就可以安装完毕 依赖较少：我只想做个E2E测试，不想安装jdk, python之类的东西 速度很快：运行测试用例的速度要快 报错详细：详细的报错 API完备：鼠标键盘操作接口，DOM查询接口等 Debug方便：出错了可以很方便的调试，而不是去猜 3. 为什么要用Cypress？ Cypress基本上拥有了上面的特点之外，还有以下特点。\n时光穿梭 测试运行时，Cypress会自动截图，你可以轻易的查看每个时间的截图 Debug友好 不需要再去猜测为什么测试有失败了，Cypress提供Chrome DevTools, 所以Debug是非常方便的。 实时刷新 Cypress检测测试用例改变后，会自动刷新 自动等待 不需要在使用wait类似的方法等待某个DOM出现，Cypress会自动帮你做这些 Spies, stubs, and clocks Verify and control the behavior of functions, server responses, or timers.","title":"端到端测试哪家强？不容错过的Cypress"},{"content":"1. WakaTime 自动化时间记录工具 WakaTime致力为程序员提供于自动化时间记录功能，它提供很多的IDE插件，可以通过这些插件清晰的告诉你一些可视化的信息。\nWakeTime功能列表\n每个项目你所花费的时间 每种编程语言你所花费的时间 一天的平均编码信息 编辑器使用记录 可以生成日报，周报，月报，以邮件的形式发送给你 可以生成嵌入式的代码，以图片形式展现 \u0026hellip; 1.1. WakeTime Dashboard 欣赏 1.2. WakaTime插件 支持哪些IDE? 1.3. WakaTime 生成嵌入式图片代码 在线预览地址：https://wdd.js.org/about/\n2. RescueTime 拯救你的时间 RescueTime， RescueTime也是一款时间分析软件，支持多个平台。包括Mac, Windows, Linux, Android, Chrome插件，FireFox插件\n相比于WakaTime, RescueTime并不局限于IDE中，它可以记录更多维度的时间花费，包括如下。\n在每个应用上花费的时间 在每个网站花费的时间 按照天，周，月生成报表 可视化分析时间花费 2.1. RescueTime Dashboard 欣赏 3. 分析与对比 WakaTime比较适合IDE的时间记录，RescueTime记录的维度更广。两款软件都有免费版和收费版，其实免费版的功能都已经够用了。\n4. 关于时间 抛弃时间的人，时间也抛弃他。——莎士比亚 一个人越知道时间的价值，越倍觉失时的痛苦！——但丁 平庸的人关心怎样耗费时间，有才能的人竭力利用时间。——叔本华 逝者如斯夫，不舍昼夜。——孔子 ","permalink":"https://wdd.js.org/posts/2018/time-tracking-tools-overview/","summary":"1. WakaTime 自动化时间记录工具 WakaTime致力为程序员提供于自动化时间记录功能，它提供很多的IDE插件，可以通过这些插件清晰的告诉你一些可视化的信息。\nWakeTime功能列表\n每个项目你所花费的时间 每种编程语言你所花费的时间 一天的平均编码信息 编辑器使用记录 可以生成日报，周报，月报，以邮件的形式发送给你 可以生成嵌入式的代码，以图片形式展现 \u0026hellip; 1.1. WakeTime Dashboard 欣赏 1.2. WakaTime插件 支持哪些IDE? 1.3. WakaTime 生成嵌入式图片代码 在线预览地址：https://wdd.js.org/about/\n2. RescueTime 拯救你的时间 RescueTime， RescueTime也是一款时间分析软件，支持多个平台。包括Mac, Windows, Linux, Android, Chrome插件，FireFox插件\n相比于WakaTime, RescueTime并不局限于IDE中，它可以记录更多维度的时间花费，包括如下。\n在每个应用上花费的时间 在每个网站花费的时间 按照天，周，月生成报表 可视化分析时间花费 2.1. RescueTime Dashboard 欣赏 3. 分析与对比 WakaTime比较适合IDE的时间记录，RescueTime记录的维度更广。两款软件都有免费版和收费版，其实免费版的功能都已经够用了。\n4. 关于时间 抛弃时间的人，时间也抛弃他。——莎士比亚 一个人越知道时间的价值，越倍觉失时的痛苦！——但丁 平庸的人关心怎样耗费时间，有才能的人竭力利用时间。——叔本华 逝者如斯夫，不舍昼夜。——孔子 ","title":"抛弃时间的人，时间也抛弃他，时间记录工具分享"},{"content":" 1. 谷歌搜索指令 2. 基本命令 3. 关键词使用 4. 特殊工具 4.1. define 快速返回关键词定义 4.2. 计算器 4.3. 单位转换 4.4. 时区查询 4.5. 地区查询 4.6. 天气查询 5. 参考 1. 谷歌搜索指令 2. 基本命令 符号 简介 语法 注意点 示例 | 包含A且必须包含B | A +B | A和+之间有空格 | Maxwell +wills | 包含A且不包含B | A -B | A和+之间有空格 | Maxwell -Absolom \u0026quot; \u0026quot; | 完整匹配AB | \u0026ldquo;AB\u0026rdquo; | | \u0026ldquo;Thomas Jefferson\u0026rdquo; OR | 包含A或者B | A OR B 或者 A | B | | nodejs OR webpack +-\u0026ldquo;OR | 指令可以组合，完成更复杂的查询 | | | beach -sandy +albert +nathaniel ~ | 包含A, 并且包含B的近义词 | A ~B | | github ~js .. | 区间查询 AB之间 | A..B | | china 1888..2000 | 匹配任意字符 | | | node* java site: | 站内搜索 | A site:B | | | DLL site:webpack.js.org filetype: | 按照文件类型搜索 | A filetype:B | | csta filetype:pdf 3. 关键词使用 方法 说明 示例 列举关键词 列举所有和搜索相关的关键词，并且尽量把重要的关键词排在前面。不同的关键词顺序会导致不同的返回不同的结果 书法 毛笔 绘画 不要使用某些词 如代词介词语气词，如i, the, of, it, 我，吗 搜索引擎一般会直接忽略这些信息含量少的词 大小写不敏感 大写字符和小写字符在搜索引擎看没有区别，尽量使用小写的就可以 4. 特殊工具 4.1. define 快速返回关键词定义 4.2. 计算器 4.3. 单位转换 4.4. 时区查询 4.5. 地区查询 4.6. 天气查询 5. 参考 Advanced Google Search Commands Google_rules_for_searching.pdf An introduction to search commands ","permalink":"https://wdd.js.org/posts/2018/master-google-search-command/","summary":"1. 谷歌搜索指令 2. 基本命令 3. 关键词使用 4. 特殊工具 4.1. define 快速返回关键词定义 4.2. 计算器 4.3. 单位转换 4.4. 时区查询 4.5. 地区查询 4.6. 天气查询 5. 参考 1. 谷歌搜索指令 2. 基本命令 符号 简介 语法 注意点 示例 | 包含A且必须包含B | A +B | A和+之间有空格 | Maxwell +wills | 包含A且不包含B | A -B | A和+之间有空格 | Maxwell -Absolom \u0026quot; \u0026quot; | 完整匹配AB | \u0026ldquo;AB\u0026rdquo; | | \u0026ldquo;Thomas Jefferson\u0026rdquo; OR | 包含A或者B | A OR B 或者 A | B | | nodejs OR webpack +-\u0026ldquo;OR | 指令可以组合，完成更复杂的查询 | | | beach -sandy +albert +nathaniel ~ | 包含A, 并且包含B的近义词 | A ~B | | github ~js .","title":"掌握谷歌搜索高级指令"},{"content":"1. 角色划分 名称 角色 账户 A 银行家 0 B 建筑商 100万 C 商人 0 2. 建筑商向银行存储100万 名称 角色 账户 A 银行家 100万 现金 B 建筑商 100万 支票 C 商人 0 2. 商人向银行贷款100万 此时银行的账户存款已经是0了，但是B还在银行存了100万。那银行究竟是还有100万呢, 还是一毛都没有了呢。\n此时建筑商如果要取现金，那么银行马上就要破产。\n名称 角色 账户 A 银行家 100现金 B 建筑商 100万 支票 C 商人 100万 支票 3. 商人需要建筑商来建造房子 商人需要建筑商来建筑房子，费用是100万，付给建筑商，建筑商又把100支票存到银行\n名称 角色 账户 A 银行家 100万现金 B 建筑商 200万 支票 C 商人 0 商人又从银行借钱100万，来付给建筑商建房子，建筑商把钱存到银行\n名称 角色 账户 A 银行家 100万现金 B 建筑商 300万 支票 C 商人 0 只要这个循环还在继续，你会发现，建筑商的账面上的支票越来越多，但是银行始终都是100万现金存在那里，从来都没动过。\n💰就这样魔术般的产生， 如果银行那一天缺钱了，银行就拿一张纸出来，上面写着1000万。看！银行造钱就是那么容易。\n","permalink":"https://wdd.js.org/posts/2018/the-secret-of-bank-create-money/","summary":"1. 角色划分 名称 角色 账户 A 银行家 0 B 建筑商 100万 C 商人 0 2. 建筑商向银行存储100万 名称 角色 账户 A 银行家 100万 现金 B 建筑商 100万 支票 C 商人 0 2. 商人向银行贷款100万 此时银行的账户存款已经是0了，但是B还在银行存了100万。那银行究竟是还有100万呢, 还是一毛都没有了呢。\n此时建筑商如果要取现金，那么银行马上就要破产。\n名称 角色 账户 A 银行家 100现金 B 建筑商 100万 支票 C 商人 100万 支票 3. 商人需要建筑商来建造房子 商人需要建筑商来建筑房子，费用是100万，付给建筑商，建筑商又把100支票存到银行\n名称 角色 账户 A 银行家 100万现金 B 建筑商 200万 支票 C 商人 0 商人又从银行借钱100万，来付给建筑商建房子，建筑商把钱存到银行\n名称 角色 账户 A 银行家 100万现金 B 建筑商 300万 支票 C 商人 0 只要这个循环还在继续，你会发现，建筑商的账面上的支票越来越多，但是银行始终都是100万现金存在那里，从来都没动过。","title":"金钱游戏 - 银行造钱的秘密"},{"content":"大部分时间，我都是使用git命令行来完成各种git操作。\n然而有时候，想可视化的查看各个分支之间的关系时，还是觉得有个GUI工具比较完美。\n众里寻他千百度，默然回首，她在github上。\nGitUp, The Git interface you've been missing all your life has finally arrived http://gitup.co/\n1. 功能介绍 1.1. 可视化、实时绘图、快速查看 仓库可视化: GitUp让你清晰明了的看到你的整个分支的迷宫 实时绘图: 你做的任何改变，都会立刻反应到GitUp的图形上，不用刷新，不用等待 快速查看: 高亮选中的commit，并且按空格键会查看到commit的详情 1.2. 远离脏乱、快速撤销、时光穿梭 远离脏乱: GitUp给你完整的，透明的控制本地仓库的能力，非常方便去取消你不想要的改变 快速撤销: 你只需要按 command + z就可以快速取消 快照穿梭: GitUp的快照功能提供一种时光穿梭的功能，你可以访问任何时间点的文件 1.3. 全功能、快捷键、改变！ 全功能: Rewrite, split, delete, and re-order commits, fixup and squash, cherry-pick, merge, rebase全都有, 而且非常快 快捷键: GitUp提供很多的快捷键 放弃原来的方法吧: 你只需要专心写代码，剩下的事情都交给GitUp来处理吧 1.4. 速度非常快 速度非常快: GitUp 加载和渲染超40000个commit的git仓库，只需要1秒之内。GitUp之所以这么快的原因是，GitUp绕过git的接口，直接与git本地数据库交互。所以，有些时候，GitUp要比git的原生命令要快的多。 1.5. 实时搜索 实时搜索: 你可以按照分支，tag, commmit消息，作者，甚至diff的内容进行搜索，GitUp会马上把结果提供给你。 1.6. 命令行工具 GitUp也提供命令行工具，可以在命令行中打开GitUp图形界面。\n➜ gitup help Usage: gitup [command] Commands: help Show this help. open (default) Open the current Git repository in GitUp. map Open the current Git repository in GitUp in Map view. commit Open the current Git repository in GitUp in Commit view. stash Open the current Git repository in GitUp in Stashes view. 2. 好消息与坏消息 好消息: GitUp免费开源 坏消息: GitUp仅支持macOS平台 3. 别被GitUp忽悠了 事实上，无论Git相关的gui工具牛吹得有多大，git的常用命令，也是非常建议你学会使用的。\n作为一个程序员，一个讲究效率的程序员，命令行才是最好的工具。不要因为一点点难学，就放弃学习。\n就像玛丽莲梦露所说的：你无法接受我差的一面，就不配拥有我最好的一面\n","permalink":"https://wdd.js.org/posts/2018/gitup-the-git-gui-you-will-like/","summary":"大部分时间，我都是使用git命令行来完成各种git操作。\n然而有时候，想可视化的查看各个分支之间的关系时，还是觉得有个GUI工具比较完美。\n众里寻他千百度，默然回首，她在github上。\nGitUp, The Git interface you've been missing all your life has finally arrived http://gitup.co/\n1. 功能介绍 1.1. 可视化、实时绘图、快速查看 仓库可视化: GitUp让你清晰明了的看到你的整个分支的迷宫 实时绘图: 你做的任何改变，都会立刻反应到GitUp的图形上，不用刷新，不用等待 快速查看: 高亮选中的commit，并且按空格键会查看到commit的详情 1.2. 远离脏乱、快速撤销、时光穿梭 远离脏乱: GitUp给你完整的，透明的控制本地仓库的能力，非常方便去取消你不想要的改变 快速撤销: 你只需要按 command + z就可以快速取消 快照穿梭: GitUp的快照功能提供一种时光穿梭的功能，你可以访问任何时间点的文件 1.3. 全功能、快捷键、改变！ 全功能: Rewrite, split, delete, and re-order commits, fixup and squash, cherry-pick, merge, rebase全都有, 而且非常快 快捷键: GitUp提供很多的快捷键 放弃原来的方法吧: 你只需要专心写代码，剩下的事情都交给GitUp来处理吧 1.4. 速度非常快 速度非常快: GitUp 加载和渲染超40000个commit的git仓库，只需要1秒之内。GitUp之所以这么快的原因是，GitUp绕过git的接口，直接与git本地数据库交互。所以，有些时候，GitUp要比git的原生命令要快的多。 1.5. 实时搜索 实时搜索: 你可以按照分支，tag, commmit消息，作者，甚至diff的内容进行搜索，GitUp会马上把结果提供给你。 1.6. 命令行工具 GitUp也提供命令行工具，可以在命令行中打开GitUp图形界面。","title":"GitUp, 你不可错过的秀外慧中的git工具"},{"content":"如何衡量工作经验 衡量工作经验的并不是一个数字, 比如说你工作2年了，他工作4年了。4的确是大于2的，但是这又能说明什么呢？我们需要的干货！硬货！而不是一个数字。\n那么，什么是干货, 硬货\n个人技术博客 技术文章 github项目 个人项目star数量 个人微信公众号的粉丝数量 一些解决问题的方法 向开源项目提交bug或者PR 这些东西才是HR真正想要看的东西，这些东西可以算作是资产。即使是你换工作了，这些资产都会始终跟着你自己。\n所谓工作经验，就是那些可以直接证明你的价值的东西\n","permalink":"https://wdd.js.org/posts/2018/what-is-work-experience/","summary":"如何衡量工作经验 衡量工作经验的并不是一个数字, 比如说你工作2年了，他工作4年了。4的确是大于2的，但是这又能说明什么呢？我们需要的干货！硬货！而不是一个数字。\n那么，什么是干货, 硬货\n个人技术博客 技术文章 github项目 个人项目star数量 个人微信公众号的粉丝数量 一些解决问题的方法 向开源项目提交bug或者PR 这些东西才是HR真正想要看的东西，这些东西可以算作是资产。即使是你换工作了，这些资产都会始终跟着你自己。\n所谓工作经验，就是那些可以直接证明你的价值的东西","title":"当我们谈论工作经验时，我们在谈论什么"},{"content":"1. Express设置缓存 Express设置静态文件的方法很简单，一行代码搞定。app.use(express.static(path.join(__dirname, 'public'), {maxAge: MAX_AGE})), 注意MAX_AGE的单位是毫秒。这句代码的含义是让pulic目录下的所有文件都可以在浏览器中缓存，过期时长为MAX_AGE毫秒。\napp.use(express.static(path.join(__dirname, \u0026#39;public\u0026#39;), {maxAge: config.get(\u0026#39;maxAge\u0026#39;)})) 2. Express让浏览器清除缓存 缓存的好处是可以更快的访问服务，但是缓存也有坏处。例如设置缓存为10天，第二天的时候服务更新了。如果客户端不强制刷新页面的话，浏览器会一致使用更新前的静态文件，这样会导致一些BUG。你总当每次出问题时，客户打电话给你后，你让他强制刷新浏览器吧？\n所以，最好在服务重启后，重新让浏览器获取最新的静态文件。\n设置的方式是给每一个静态文件设置一个时间戳。\n例如：vendor/loadjs/load.js?_=123898923423\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n2.1. Express 路由 // /routes/index.js router.get(\u0026#39;/home\u0026#39;, function (req, res, next) { res.render(\u0026#39;home\u0026#39;, {config: config, serverStartTimestamp: new Date().getTime()}) }) 2.2. 视图文件 // views/home.html \u0026lt;script src=\u0026#34;vendor/loadjs/load.js?_=\u0026lt;%= serverStartTimestamp %\u0026gt;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 设置之后，每次服务更新或者重启，浏览器都会使用最新的时间戳serverStartTimestamp，去获取静态文件。\n2.3. 动态加载JS文件 有时候js文件并不是直接在HTML中引入，可能是使用了一些js文件加载库，例如requirejs, LABjs等。这些情况下，可以在全局设置环境变量SERVER_START_TIMESTAMP，用来表示服务启动的时间戳，在获取js的时候，将该时间戳拼接在路径上。\n注意：环境变量SERVER_START_TIMESTAMP，一定要在其他脚本使用前定义。\n// views/home.html \u0026lt;script\u0026gt; var SERVER_START_TIMESTAMP = \u0026lt;%= serverStartTimestamp %\u0026gt; \u0026lt;/script\u0026gt; // load.js \u0026#39;vendor/contact-center/skill.js?_=\u0026#39; + SERVER_START_TIMESTAMP ","permalink":"https://wdd.js.org/posts/2018/express-static-file-cache-setting-and-cleaning/","summary":"1. Express设置缓存 Express设置静态文件的方法很简单，一行代码搞定。app.use(express.static(path.join(__dirname, 'public'), {maxAge: MAX_AGE})), 注意MAX_AGE的单位是毫秒。这句代码的含义是让pulic目录下的所有文件都可以在浏览器中缓存，过期时长为MAX_AGE毫秒。\napp.use(express.static(path.join(__dirname, \u0026#39;public\u0026#39;), {maxAge: config.get(\u0026#39;maxAge\u0026#39;)})) 2. Express让浏览器清除缓存 缓存的好处是可以更快的访问服务，但是缓存也有坏处。例如设置缓存为10天，第二天的时候服务更新了。如果客户端不强制刷新页面的话，浏览器会一致使用更新前的静态文件，这样会导致一些BUG。你总当每次出问题时，客户打电话给你后，你让他强制刷新浏览器吧？\n所以，最好在服务重启后，重新让浏览器获取最新的静态文件。\n设置的方式是给每一个静态文件设置一个时间戳。\n例如：vendor/loadjs/load.js?_=123898923423\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n2.1. Express 路由 // /routes/index.js router.get(\u0026#39;/home\u0026#39;, function (req, res, next) { res.render(\u0026#39;home\u0026#39;, {config: config, serverStartTimestamp: new Date().getTime()}) }) 2.2. 视图文件 // views/home.html \u0026lt;script src=\u0026#34;vendor/loadjs/load.js?_=\u0026lt;%= serverStartTimestamp %\u0026gt;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 设置之后，每次服务更新或者重启，浏览器都会使用最新的时间戳serverStartTimestamp，去获取静态文件。\n2.3. 动态加载JS文件 有时候js文件并不是直接在HTML中引入，可能是使用了一些js文件加载库，例如requirejs, LABjs等。这些情况下，可以在全局设置环境变量SERVER_START_TIMESTAMP，用来表示服务启动的时间戳，在获取js的时候，将该时间戳拼接在路径上。\n注意：环境变量SERVER_START_TIMESTAMP，一定要在其他脚本使用前定义。\n// views/home.html \u0026lt;script\u0026gt; var SERVER_START_TIMESTAMP = \u0026lt;%= serverStartTimestamp %\u0026gt; \u0026lt;/script\u0026gt; // load.js \u0026#39;vendor/contact-center/skill.js?_=\u0026#39; + SERVER_START_TIMESTAMP ","title":"Express静态文件浏览器缓存设置与缓存清除"},{"content":"small is beautiful new Vue({ el: \u0026#39;#app\u0026#39;, methods: { hello: function(){ console.log(\u0026#39;hello\u0026#39;) } }, created: function(){ this.hello() } }) big is ugly new Vue({ el: \u0026#39;#app\u0026#39;, methods: { hello: function(){ console.log(\u0026#39;hello\u0026#39;) }, hello1: function(){ console.log(\u0026#39;hello1\u0026#39;) }, hello2: function(){ console.log(\u0026#39;hello2\u0026#39;) }, hello3: function(){ console.log(\u0026#39;hello3\u0026#39;) }, // a lot of function be added, this is ugly helloN: function(){ console.log(\u0026#39;helloN\u0026#39;) }, }, created: function(){ this.hello() } }) mixins is powerful var mix = { created: function () { console.log(\u0026#39;i am mixins\u0026#39;) }, methods: { helloX: function(){ console.log(\u0026#39;helloX\u0026#39;) } } } new Vue({ el: \u0026#39;#app\u0026#39;, mixins: [mix], methods: { hello: function(){ console.log(\u0026#39;hello\u0026#39;) }, hello1: function(){ console.log(\u0026#39;hello1\u0026#39;) }, hello2: function(){ console.log(\u0026#39;hello2\u0026#39;) }, hello3: function(){ console.log(\u0026#39;hello3\u0026#39;) } }, created: function(){ this.hello() } }) reading more guide-mixins ","permalink":"https://wdd.js.org/posts/2018/small-is-powerful-vue-mixins/","summary":"small is beautiful new Vue({ el: \u0026#39;#app\u0026#39;, methods: { hello: function(){ console.log(\u0026#39;hello\u0026#39;) } }, created: function(){ this.hello() } }) big is ugly new Vue({ el: \u0026#39;#app\u0026#39;, methods: { hello: function(){ console.log(\u0026#39;hello\u0026#39;) }, hello1: function(){ console.log(\u0026#39;hello1\u0026#39;) }, hello2: function(){ console.log(\u0026#39;hello2\u0026#39;) }, hello3: function(){ console.log(\u0026#39;hello3\u0026#39;) }, // a lot of function be added, this is ugly helloN: function(){ console.log(\u0026#39;helloN\u0026#39;) }, }, created: function(){ this.hello() } }) mixins is powerful var mix = { created: function () { console.","title":"Small is Powerful Vue mixins"},{"content":"1. 把错误打印出来 WebSocket断开的原因有很多，最好在WebSocket断开时，将错误打印出来。\n在线demo地址：https://wdd.js.org/websocket-demos/\nws.onerror = function (e) { console.log(\u0026#39;WebSocket发生错误: \u0026#39; + e.code) console.log(e) } 如果你想自己玩玩WebSocket, 但是你又不想自己部署一个WebSocket服务器，你可以使用ws = new WebSocket('wss://echo.websocket.org/'), 你向echo.websocket.org发送消息，它会回复你同样的消息。\n2. 重要信息错误状态码 WebSocket断开时，会触发CloseEvent, CloseEvent会在连接关闭时发送给使用 WebSockets 的客户端. 它在 WebSocket 对象的 onclose 事件监听器中使用。CloseEvent的code字段表示了WebSocket断开的原因。可以从该字段中分析断开的原因。\n3. 关闭状态码表 一般来说1006的错误码出现的情况比较常见，该错误码一般出现在断网时。\n状态码 名称 描述 0–999 保留段, 未使用. 1000 CLOSE_NORMAL 正常关闭; 无论为何目的而创建, 该链接都已成功完成任务. 1001 CLOSE_GOING_AWAY 终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开. 1002 CLOSE_PROTOCOL_ERROR 由于协议错误而中断连接. 1003 CLOSE_UNSUPPORTED 由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据). 1004 保留. 其意义可能会在未来定义. 1005 CLOSE_NO_STATUS 保留. 表示没有收到预期的状态码. 1006 CLOSE_ABNORMAL 保留. 用于期望收到状态码时连接非正常关闭 (也就是说, 没有发送关闭帧). 1007 Unsupported Data 由于收到了格式不符的数据而断开连接 (如文本消息中包含了非 UTF-8 数据). 1008 Policy Violation 由于收到不符合约定的数据而断开连接. 这是一个通用状态码, 用于不适合使用 1003 和 1009 状态码的场景. 1009 CLOSE_TOO_LARGE 由于收到过大的数据帧而断开连接. 1010 Missing Extension 客户端期望服务器商定一个或多个拓展, 但服务器没有处理, 因此客户端断开连接. 1011 Internal Error 客户端由于遇到没有预料的情况阻止其完成请求, 因此服务端断开连接. 1012 Service Restart 服务器由于重启而断开连接. 1013 Try Again Later 服务器由于临时原因断开连接, 如服务器过载因此断开一部分客户端连接. 1014 由 WebSocket标准保留以便未来使用. 1015 TLS Handshake 保留. 表示连接由于无法完成 TLS 握手而关闭 (例如无法验证服务器证书). 1016–1999 由 WebSocket标准保留以便未来使用. 2000–2999 由 WebSocket拓展保留使用. 3000–3999 可以由库或框架使用.? 不应由应用使用. 可以在 IANA 注册, 先到先得. 4000–4999 可以由应用使用. 4. 其他注意事项 如果你的服务所在的域是HTTPS的，那么使用的WebSocket协议也必须是wss, 而不能是ws\n5. 如何在老IE上使用原生WebSocket？ web-socket-js是基于flash的技术，只需要引入两个js文件和一个swf文件，就可以让浏览器用于几乎原生的WebSocket接口。另外，web-socket-js还是需要在ws服务端843端口做一个flash安全策略文件的服务。\n我自己曾经基于stompjs和web-socket-js，做WebSocket兼容到IE5, 当然了stompjs在低版本的IE上有兼容性问题, 而且stompjs已经不再维护了，你可以使用我fork的一个版本，地址是：https://github.com/wangduanduan/stomp-websocket/blob/master/lib/stomp.js\n主要是老版本IE在正则表达式行为方面有点异常。\n// fix ie8, ie9, RegExp not normal problem // in chrome the frames length will be 2, but in ie8, ie9, it well be 1 // by wdd 20180321 if (frames.length === 1) { frames.push(\u0026#39;\u0026#39;) } 6. 参考 CloseEvent getting the reason why websockets closed with close code 1006 Defined Status Codes ","permalink":"https://wdd.js.org/posts/2018/websocket-close-reasons/","summary":"1. 把错误打印出来 WebSocket断开的原因有很多，最好在WebSocket断开时，将错误打印出来。\n在线demo地址：https://wdd.js.org/websocket-demos/\nws.onerror = function (e) { console.log(\u0026#39;WebSocket发生错误: \u0026#39; + e.code) console.log(e) } 如果你想自己玩玩WebSocket, 但是你又不想自己部署一个WebSocket服务器，你可以使用ws = new WebSocket('wss://echo.websocket.org/'), 你向echo.websocket.org发送消息，它会回复你同样的消息。\n2. 重要信息错误状态码 WebSocket断开时，会触发CloseEvent, CloseEvent会在连接关闭时发送给使用 WebSockets 的客户端. 它在 WebSocket 对象的 onclose 事件监听器中使用。CloseEvent的code字段表示了WebSocket断开的原因。可以从该字段中分析断开的原因。\n3. 关闭状态码表 一般来说1006的错误码出现的情况比较常见，该错误码一般出现在断网时。\n状态码 名称 描述 0–999 保留段, 未使用. 1000 CLOSE_NORMAL 正常关闭; 无论为何目的而创建, 该链接都已成功完成任务. 1001 CLOSE_GOING_AWAY 终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开. 1002 CLOSE_PROTOCOL_ERROR 由于协议错误而中断连接. 1003 CLOSE_UNSUPPORTED 由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据). 1004 保留. 其意义可能会在未来定义. 1005 CLOSE_NO_STATUS 保留. 表示没有收到预期的状态码. 1006 CLOSE_ABNORMAL 保留. 用于期望收到状态码时连接非正常关闭 (也就是说, 没有发送关闭帧).","title":"WebSocket断开原因分析"},{"content":"无论什么语言，都需要逻辑，而逻辑中，能否判断出真假，是最基本也是最重要技能之一。\nJS中的假值有6个 false '' undefinded null 0, +0, -0 NaN 有点类似假值的真值有两个 {} [] 空对象和空数组，很多初学者都很用把这两个当做假值。但是实际上他们是真值，你只需要记住，除了null之外的所有对象类型的数据，都是真值。\ntypeof null // \u0026#39;object\u0026#39; 据说：typeof null返回对象这是一个js语言中的bug。实际上typeof null应该返回null才比较准确，但是这个bug已经存来好久了。几乎所有的代码里都这样去判断。如果把typeof null给改成返回null, 那么这必定会导致JS世界末日。\n我们承认JS并不完美，她有很多小缺点，但是这并不妨碍她吸引万千开发者拜倒在她的石榴裙下。\n就像一首歌唱的：有些人说不清哪里好 但就是谁都替代不了\n","permalink":"https://wdd.js.org/posts/2018/js-true-and-false-value/","summary":"无论什么语言，都需要逻辑，而逻辑中，能否判断出真假，是最基本也是最重要技能之一。\nJS中的假值有6个 false '' undefinded null 0, +0, -0 NaN 有点类似假值的真值有两个 {} [] 空对象和空数组，很多初学者都很用把这两个当做假值。但是实际上他们是真值，你只需要记住，除了null之外的所有对象类型的数据，都是真值。\ntypeof null // \u0026#39;object\u0026#39; 据说：typeof null返回对象这是一个js语言中的bug。实际上typeof null应该返回null才比较准确，但是这个bug已经存来好久了。几乎所有的代码里都这样去判断。如果把typeof null给改成返回null, 那么这必定会导致JS世界末日。\n我们承认JS并不完美，她有很多小缺点，但是这并不妨碍她吸引万千开发者拜倒在她的石榴裙下。\n就像一首歌唱的：有些人说不清哪里好 但就是谁都替代不了","title":"js中的真值和假值"},{"content":"1. AWS EC2 不支持WebSocket 直达解决方案 英文版\n简单说一下思路：WebSocket底层基于TCP协议的，如果你的服务器基于HTTP协议暴露80端口，那WebSocket肯定无法连接。你只要将HTTP协议修改成TCP协议就可以了。\n然后是安全组的配置：\n同样如果使用了NGINX作为反向代理，那么NGINX也需要做配置的。\n// https://gist.githubusercontent.com/unshift/324be6a8dc9e880d4d670de0dc97a8ce/raw/29507ed6b3c9394ecd7842f9d3228827cffd1c58/elasticbeanstalk_websockets files: \u0026#34;/etc/nginx/conf.d/01_websockets.conf\u0026#34; : mode: \u0026#34;000644\u0026#34; owner: root group: root content : | upstream nodejs { server 127.0.0.1:8081; keepalive 256; } server { listen 8080; location / { proxy_pass http://nodejs; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } \u0026#34;/opt/elasticbeanstalk/hooks/appdeploy/enact/41_remove_eb_nginx_confg.sh\u0026#34;: mode: \u0026#34;000755\u0026#34; owner: root group: root content : | mv /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf.old 2. NGINX做反向代理是需要注意的问题 如果排除所有问题后，那剩下的问题可以考虑出在反向代理上，一下有几点是可以考虑的。\nHTTP的版本问题: http有三个版本，http 1.0, 1.1, 2.0, 现在主流的浏览器都是使用http 1.1版本，为了保证更好的兼容性，最好转发时不要修改协议的版本号\nNGINX具有路径重写功能，如果你使用了该功能，就要考虑问题可能出在这里，因为NGINX在路径重写时，需要对路径进行编解码，有可能在解码之后，没有编码就发送给后端的服务器，导致后端服务器无法对URL进行解码。\n3. IE8 IE9 有没有简单方便支持WebSocket的方案 目前测试下来，最简单方案是基于flash的。参考：https://github.com/gimite/web-socket-js,\n注意该方案需要在WebSocket服务上的843端口, 提供socket_policy_files, 也可以参考：A PolyFill for WebSockets\n网上也有教程是使用socket.io基于ajax长轮训的方案，如果服务端已经确定的情况下，一般是不会轻易改动服务端代码的。而且ajax长轮训也是有延迟，和disconnect时，无法回调的问题。\n4. stompjs connected后，没有调用connect_callBack 该问题主要是使用web-socket-js，在ie8,ie9上出现的\n该问题还没有分析出原因，但是看了stompjs的源码不是太多，明天用源码调试看看原因。\n问题已经找到，请参考：https://github.com/wangduanduan/stomp-websocket#about-ie8-ie9-use-websocket\n5. 参考文献 STOMP Over WebSocket STOMP Protocol Specification, Version 1.1 Stomp Over Websocket文档, ","permalink":"https://wdd.js.org/posts/2018/stomp-over-websocket/","summary":"1. AWS EC2 不支持WebSocket 直达解决方案 英文版\n简单说一下思路：WebSocket底层基于TCP协议的，如果你的服务器基于HTTP协议暴露80端口，那WebSocket肯定无法连接。你只要将HTTP协议修改成TCP协议就可以了。\n然后是安全组的配置：\n同样如果使用了NGINX作为反向代理，那么NGINX也需要做配置的。\n// https://gist.githubusercontent.com/unshift/324be6a8dc9e880d4d670de0dc97a8ce/raw/29507ed6b3c9394ecd7842f9d3228827cffd1c58/elasticbeanstalk_websockets files: \u0026#34;/etc/nginx/conf.d/01_websockets.conf\u0026#34; : mode: \u0026#34;000644\u0026#34; owner: root group: root content : | upstream nodejs { server 127.0.0.1:8081; keepalive 256; } server { listen 8080; location / { proxy_pass http://nodejs; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } \u0026#34;/opt/elasticbeanstalk/hooks/appdeploy/enact/41_remove_eb_nginx_confg.sh\u0026#34;: mode: \u0026#34;000755\u0026#34; owner: root group: root content : | mv /etc/nginx/conf.","title":"在实践中我遇到stompjs, websocket和nginx的问题与总结"},{"content":" 1. 代码应当易于理解 唯一标准：让别人理解的时间最小 2. 把信息装到名字里 选择专业的词 避免泛泛的名字 使用具体的名字代替抽象的名字 为名字携带更多的信息 名字的作用域越大，最好名字越长 丢掉没用的词 单词 更多选择 send deliver, dispatch, announce, distribute,route find search, extract, locate, recover start launch, create, begin, open make create, set up, build, generate, compose, add ,new 3. 审美 我之前学设计的时候看过一本书，写给大家看的设计书（第3版）将这本书中的设计审美原理应用到写代码上，真实十分贴切，如果你读过此书，你的审美能力会大幅提高。\n对齐 重复 对比 亲密性 按照亲密关系分段 顺序 4. 写什么样的注释 不要写一眼就能看懂的注释，类似于此地无银三百两 与其写注释，不如把变量名函数名写好，可以从名字中理解 记录你的思想 加入评论 指出哪里有陷阱，需要注意 言简意赅，不要啰嗦 不要使用不明确的代词，不要像像算命先生，如何解释都对 5. 可读性控制流 追求最小理解时间，而不是最少代码行 尽可能提前return结果 少点嵌套，要尽可能扁平化 理解执行流程。有些是连续执行。有些是随时都可能执行，像事件回调 避免使用while, 一般我们循环都是为了遍历数组，为什么不用forEach呢？ 6. 拆分超长表达式 拆分超长的表达式 拆分巨大的语句 尽量把逻辑包裹在函数中，不要重复你自己 DRY 7. 变量与可读性 减少变量，变量越少越好 减少中间结果，垂直消费 减少用于控制流的变量 缩小变量的作用域 用到变量再定义，不要提前定义，不然还要随时想着，之前定义的变量是用干嘛的呢？ 8. 重构 抽取不相关的自子问题 抽取各种配置性的变量在一起，他们都是配置 尽量写纯函数 创建大量通用代码 打造自己的武器装备库 简化接口传参 过犹不及，不要太苛刻 9. 一次只做一件事 10. 少写代码 最好的代码就是没有代码 别费神实现那个功能，你不会需要的 质疑和拆分的需求 保持小代码库 删除没用的代码 删除没有的注释 11. 调试 尽可能将错误打印出来，不要隐藏 ","permalink":"https://wdd.js.org/posts/2018/art-of-readable-code/","summary":"1. 代码应当易于理解 唯一标准：让别人理解的时间最小 2. 把信息装到名字里 选择专业的词 避免泛泛的名字 使用具体的名字代替抽象的名字 为名字携带更多的信息 名字的作用域越大，最好名字越长 丢掉没用的词 单词 更多选择 send deliver, dispatch, announce, distribute,route find search, extract, locate, recover start launch, create, begin, open make create, set up, build, generate, compose, add ,new 3. 审美 我之前学设计的时候看过一本书，写给大家看的设计书（第3版）将这本书中的设计审美原理应用到写代码上，真实十分贴切，如果你读过此书，你的审美能力会大幅提高。\n对齐 重复 对比 亲密性 按照亲密关系分段 顺序 4. 写什么样的注释 不要写一眼就能看懂的注释，类似于此地无银三百两 与其写注释，不如把变量名函数名写好，可以从名字中理解 记录你的思想 加入评论 指出哪里有陷阱，需要注意 言简意赅，不要啰嗦 不要使用不明确的代词，不要像像算命先生，如何解释都对 5. 可读性控制流 追求最小理解时间，而不是最少代码行 尽可能提前return结果 少点嵌套，要尽可能扁平化 理解执行流程。有些是连续执行。有些是随时都可能执行，像事件回调 避免使用while, 一般我们循环都是为了遍历数组，为什么不用forEach呢？ 6. 拆分超长表达式 拆分超长的表达式 拆分巨大的语句 尽量把逻辑包裹在函数中，不要重复你自己 DRY 7.","title":"笔记 编写可读性代码的艺术"},{"content":" 1. 自问自答 该问题是否是必现的？ 该问题出现多久了？ 问题出现前后有没有什么异常？ 例如几分钟之前启动了其他的服务，有其他服务在更新 2. 要事实，不要推测 在bug报告里，要设法搞清什么是事实（例如：压测环境座席监控没有数据）。什么是推测（例如：我想问题可能出在XXX）。如果愿意的话，您可以省去推测，但是千万别省略事实。\n3. 要精确，不要模糊 3.1. 不要使用代词 3.2. 不要使用\u0026quot;没有\u0026quot; 4. 要详细，不要粗略 5. 建议要提供的数据 建议 错误日志, 程序员最喜欢bug里的错误日志，错误日志能说明一切，非常建议你能提供错误日志 必须 操作步骤, 有利于程序员去重现bug 可选 错误截图, 在描述不清楚的时候，错误截图时更好的方法 6. 参考 如何有效地报告 Bug ","permalink":"https://wdd.js.org/posts/2018/how-to-report-bug-effective/","summary":" 1. 自问自答 该问题是否是必现的？ 该问题出现多久了？ 问题出现前后有没有什么异常？ 例如几分钟之前启动了其他的服务，有其他服务在更新 2. 要事实，不要推测 在bug报告里，要设法搞清什么是事实（例如：压测环境座席监控没有数据）。什么是推测（例如：我想问题可能出在XXX）。如果愿意的话，您可以省去推测，但是千万别省略事实。\n3. 要精确，不要模糊 3.1. 不要使用代词 3.2. 不要使用\u0026quot;没有\u0026quot; 4. 要详细，不要粗略 5. 建议要提供的数据 建议 错误日志, 程序员最喜欢bug里的错误日志，错误日志能说明一切，非常建议你能提供错误日志 必须 操作步骤, 有利于程序员去重现bug 可选 错误截图, 在描述不清楚的时候，错误截图时更好的方法 6. 参考 如何有效地报告 Bug ","title":"如何高效地报告 Bug"},{"content":"1. 问题现象 HTTP 状态码为 200 OK 时， jquery ajax报错\n2. 问题原因 jquery ajax的dataType字段包含：json, 但是服务端返回的数据不是规范的json格式，导致jquery解析json字符串报错，最终导致ajax报错。\njQuery ajax 官方文档上说明：\n\u0026ldquo;json\u0026rdquo;: Evaluates the response as JSON and returns a JavaScript object. Cross-domain \u0026ldquo;json\u0026rdquo; requests are converted to \u0026ldquo;jsonp\u0026rdquo; unless the request includes jsonp: false in its request options. The JSON data is parsed in a strict manner; any malformed JSON is rejected and a parse error is thrown. As of jQuery 1.9, an empty response is also rejected; the server should return a response of null or {} instead. (See json.org for more information on proper JSON formatting.)\n设置dataType为json时，jquery就会去解析响应体为JavaScript对象。跨域的json请求会被转化成jsonp, 除非设置了jsonp: false。JSON数据会以严格模式去解析，任何不规范的JSON字符串都会解析异常并抛出错误。从jQuery 1.9起，一个空的响应也会被抛出异常。服务端应该返回一个null或者{}去代替空响应。参考json.org, 查看更多内容\n3. 解决方案 这个问题的原因是后端返回的数据格式不规范，所以后端在返回结果是，不要使用空的响应，也不应该去手动拼接JSON字符串，而应该交给响应的库来实现JSON序列化字符串工作。\n方案1： 如果后端确定响应体中不返回数据，那么就把状态码设置为204，而不是200。我一直逼着后端同事这么做。 方案2：如果后端接口想返回200，那么请返回一个null或者{}去代替空响应 方案3：别用jQuery的ajax，换个其他的库试试 4. 参考 Ajax request returns 200 OK, but an error event is fired instead of success jQuery.ajax ","permalink":"https://wdd.js.org/posts/2018/status-code-200-jquery-ajax-failed/","summary":"1. 问题现象 HTTP 状态码为 200 OK 时， jquery ajax报错\n2. 问题原因 jquery ajax的dataType字段包含：json, 但是服务端返回的数据不是规范的json格式，导致jquery解析json字符串报错，最终导致ajax报错。\njQuery ajax 官方文档上说明：\n\u0026ldquo;json\u0026rdquo;: Evaluates the response as JSON and returns a JavaScript object. Cross-domain \u0026ldquo;json\u0026rdquo; requests are converted to \u0026ldquo;jsonp\u0026rdquo; unless the request includes jsonp: false in its request options. The JSON data is parsed in a strict manner; any malformed JSON is rejected and a parse error is thrown. As of jQuery 1.9, an empty response is also rejected; the server should return a response of null or {} instead.","title":"状态码为200时 jQuery ajax报错"},{"content":"1. 兼容情况 如果想浏览器支持粘贴功能，那么浏览器必须支持，document.execCommand(\u0026lsquo;copy\u0026rsquo;)方法，也可以根据document.queryCommandEnabled(\u0026lsquo;copy\u0026rsquo;)，返回的true或者false判断浏览器是否支持copy命令。\n从下表可以看出，主流的浏览器都支持execCommand命令\n2. 复制的原理 查询元素 选中元素 执行复制命令 3. 代码展示 // html \u0026lt;input id=\u0026#34;username\u0026#34; value=\u0026#34;123456\u0026#34;\u0026gt; // 查询元素 var username = document.getElementById(‘username’) // 选中元素 username.select() // 执行复制 document.execCommand(\u0026#39;copy\u0026#39;) 注意: 以上代码只是简单示意，在实践过程中还有几个要判断的情况\n首要要去检测浏览器execCommand能力检测 选取元素时，有可能选取元素为空，要考虑这种情况的处理 4. 第三方方案 clipboard.js是一个比较方便的剪贴板库，功能蛮多的。\n\u0026lt;!-- Target --\u0026gt; \u0026lt;textarea id=\u0026#34;bar\u0026#34;\u0026gt;Mussum ipsum cacilds...\u0026lt;/textarea\u0026gt; \u0026lt;!-- Trigger --\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; data-clipboard-action=\u0026#34;cut\u0026#34; data-clipboard-target=\u0026#34;#bar\u0026#34;\u0026gt; Cut to clipboard \u0026lt;/button\u0026gt; 官方给的代码里有上面的一个示例，如果你用了这个示例，但是不起作用，那你估计是没有初始化ClipboardJS示例的。\n注意：下面的函数必须要主动调用，这样才能给响应的DOM元素注册事件。 ClipboardJS源代码压缩后大约有3kb，虽然很小了，但是如果你不需要它的这么多功能的话，其实你自己写几行代码就可以搞定复制功能。\nnew ClipboardJS(\u0026#39;.btn\u0026#39;); ","permalink":"https://wdd.js.org/posts/2018/clipboard-copy-tutorial/","summary":"1. 兼容情况 如果想浏览器支持粘贴功能，那么浏览器必须支持，document.execCommand(\u0026lsquo;copy\u0026rsquo;)方法，也可以根据document.queryCommandEnabled(\u0026lsquo;copy\u0026rsquo;)，返回的true或者false判断浏览器是否支持copy命令。\n从下表可以看出，主流的浏览器都支持execCommand命令\n2. 复制的原理 查询元素 选中元素 执行复制命令 3. 代码展示 // html \u0026lt;input id=\u0026#34;username\u0026#34; value=\u0026#34;123456\u0026#34;\u0026gt; // 查询元素 var username = document.getElementById(‘username’) // 选中元素 username.select() // 执行复制 document.execCommand(\u0026#39;copy\u0026#39;) 注意: 以上代码只是简单示意，在实践过程中还有几个要判断的情况\n首要要去检测浏览器execCommand能力检测 选取元素时，有可能选取元素为空，要考虑这种情况的处理 4. 第三方方案 clipboard.js是一个比较方便的剪贴板库，功能蛮多的。\n\u0026lt;!-- Target --\u0026gt; \u0026lt;textarea id=\u0026#34;bar\u0026#34;\u0026gt;Mussum ipsum cacilds...\u0026lt;/textarea\u0026gt; \u0026lt;!-- Trigger --\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; data-clipboard-action=\u0026#34;cut\u0026#34; data-clipboard-target=\u0026#34;#bar\u0026#34;\u0026gt; Cut to clipboard \u0026lt;/button\u0026gt; 官方给的代码里有上面的一个示例，如果你用了这个示例，但是不起作用，那你估计是没有初始化ClipboardJS示例的。\n注意：下面的函数必须要主动调用，这样才能给响应的DOM元素注册事件。 ClipboardJS源代码压缩后大约有3kb，虽然很小了，但是如果你不需要它的这么多功能的话，其实你自己写几行代码就可以搞定复制功能。\nnew ClipboardJS(\u0026#39;.btn\u0026#39;); ","title":"前端剪贴板复制功能实现原理"},{"content":"从分工到专业化 分工提高生产效率，专业化提高个人价值。很多人都认为，一旦我们进入了某一行，我们就应该在这个行业深挖到底。例如我是做前端的，我就会去学习各种前端的知识点，各种层出不穷的框架。我总是在如饥似渴的希望自己能够保持在深入学习的状态，我不想哪一天自己突然out了。\n专业化的危机在哪？ 以前我在上初中的时候，就稍稍的学习了一点点ActionScript的知识。可能有些人不知道ActionScript是干嘛的，它是在flash的环境中工作的，可以在flash里做一些动画和特效之类的。那时候flash是很火的技术，几乎所有的网站都是有flash的，所以会ActionScript语言的程序员，工资都不低。\n但是，你现在还听过什么ActionScript吗？ 它的宿主环境flash都已经被淘汰了，皮之不存毛将焉附。可想而知，flash的淘汰，同时也让时长淘汰了一批在ActionScript的专家。\n所以，专业化并不是一个安全的道路。准确来说，世界上本来就没有安全的路。大多说认为这条路安全，是因为他们总是以静态的眼光看这条路。说点题外话，如果你书读多了，你会发现，其实一直在你思想里的那些观念，那些故事，往往都是忽悠人的。你可以看看我的一个书单：2018年我的阅读计划。\n从企业的角度考虑，每个老板都想招在某一方面专家。但是从个人的角度考虑，如果你在专业化的道路钻研的非常深，或许有时候你应该放慢脚步，找个长椅，坐着想一想，如果你前面马上就是死路了，你应该怎么办？\n我们应该怎么办？ 世界上没有安全的路，世界上也没有一直安全的职业。一个职业的火爆，往往因为这个行业的火爆。而永远也没有永远火爆的行业，当退潮时，将会有大批的弄潮儿会搁浅，干死，窒息\u0026hellip;\u0026hellip;\n除去环境造成的扰动，人的身体也会随着年龄会慢慢老化。\n你可以想象一下，当你四十多岁时。那些新来的实习生，比你要的工资低，比你更容易接受这个行业的前沿知识，比你更加能加班，比你能力更强时，比你更听话时。你的优势在哪里？我相信到那时候，你的领导会毫不犹豫开了你。\n在此，你要改变。我给出以下几个角度，你可以自行延伸。\n开始锻炼身体 这是一切的基石 搞一搞副业，学习一下你喜欢的东西，你可以去深入学学如何做菜，如何摄影等等 学习理财知识，这是学校从没教你的，但是却是非常重要的东西 读书，越多越好 参考文献 专业主义 日 大前研一 富爸爸穷爸爸 罗伯特·清崎 / 莎伦·莱希特 国富论 英 亚当·斯密 失控 乌合之众 法 古斯塔夫·勒庞 未来世界的幸存者 阮一峰 新生 七年就是一辈子 李笑来 ","permalink":"https://wdd.js.org/posts/2018/feature-of-dangerous-professional-skill/","summary":"从分工到专业化 分工提高生产效率，专业化提高个人价值。很多人都认为，一旦我们进入了某一行，我们就应该在这个行业深挖到底。例如我是做前端的，我就会去学习各种前端的知识点，各种层出不穷的框架。我总是在如饥似渴的希望自己能够保持在深入学习的状态，我不想哪一天自己突然out了。\n专业化的危机在哪？ 以前我在上初中的时候，就稍稍的学习了一点点ActionScript的知识。可能有些人不知道ActionScript是干嘛的，它是在flash的环境中工作的，可以在flash里做一些动画和特效之类的。那时候flash是很火的技术，几乎所有的网站都是有flash的，所以会ActionScript语言的程序员，工资都不低。\n但是，你现在还听过什么ActionScript吗？ 它的宿主环境flash都已经被淘汰了，皮之不存毛将焉附。可想而知，flash的淘汰，同时也让时长淘汰了一批在ActionScript的专家。\n所以，专业化并不是一个安全的道路。准确来说，世界上本来就没有安全的路。大多说认为这条路安全，是因为他们总是以静态的眼光看这条路。说点题外话，如果你书读多了，你会发现，其实一直在你思想里的那些观念，那些故事，往往都是忽悠人的。你可以看看我的一个书单：2018年我的阅读计划。\n从企业的角度考虑，每个老板都想招在某一方面专家。但是从个人的角度考虑，如果你在专业化的道路钻研的非常深，或许有时候你应该放慢脚步，找个长椅，坐着想一想，如果你前面马上就是死路了，你应该怎么办？\n我们应该怎么办？ 世界上没有安全的路，世界上也没有一直安全的职业。一个职业的火爆，往往因为这个行业的火爆。而永远也没有永远火爆的行业，当退潮时，将会有大批的弄潮儿会搁浅，干死，窒息\u0026hellip;\u0026hellip;\n除去环境造成的扰动，人的身体也会随着年龄会慢慢老化。\n你可以想象一下，当你四十多岁时。那些新来的实习生，比你要的工资低，比你更容易接受这个行业的前沿知识，比你更加能加班，比你能力更强时，比你更听话时。你的优势在哪里？我相信到那时候，你的领导会毫不犹豫开了你。\n在此，你要改变。我给出以下几个角度，你可以自行延伸。\n开始锻炼身体 这是一切的基石 搞一搞副业，学习一下你喜欢的东西，你可以去深入学学如何做菜，如何摄影等等 学习理财知识，这是学校从没教你的，但是却是非常重要的东西 读书，越多越好 参考文献 专业主义 日 大前研一 富爸爸穷爸爸 罗伯特·清崎 / 莎伦·莱希特 国富论 英 亚当·斯密 失控 乌合之众 法 古斯塔夫·勒庞 未来世界的幸存者 阮一峰 新生 七年就是一辈子 李笑来 ","title":"你不知道的专业化道路"},{"content":"1. 问题表现 以file:///xxx.html打开某个html文件，发送ajax请求时报错：\nResponse to preflight request doesn\u0026#39;t pass access control check: The \u0026#39;Access-Control-Allow-Origin\u0026#39; header has a value \u0026#39;null\u0026#39; that is not equal to the supplied origin. Origin \u0026#39;null\u0026#39; is therefore not allowed access. 2. 问题原因 Origin null是本地文件系统，因此这表明您正在加载通过file：// URL进行加载调用的HTML页面（例如，只需在本地文件浏览器或类似文件中双击它）。不同的浏览器采用不同的方法将相同来源策略应用到本地文件。Chrome要求比较严格，不允许这种形势的跨域请求。而最好使用http:// 访问html.\n3. 解决方案 以下给出三个解决方案，第一个最快，第三个作为彻底。\n3.1. 方案1 给Chrome快捷方式中增加 \u0026ndash;allow-file-access-from-files 打开Chrome快捷方式的属性中设置：右击Chrome浏览器快捷方式，选择“属性”，在“目标”中加\u0026quot;\u0026ndash;allow-file-access-from-files\u0026quot;，注意前面有个空格，重启Chrome浏览器便可。\n3.2. 方案2 启动一个简单的静态文件服务器, 以http协议访问html 参见我的这篇文章: 一行命令搭建简易静态文件http服务器\n3.3. 方案3 服务端响应修改Access-Control-Allow-Origin : * response.addHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;,\u0026#34;*\u0026#34;) 4. 参考文章 如何解决XMLHttpRequest cannot load file~~~~~~~Origin \u0026rsquo;null\u0026rsquo; is therefore not allowed access 让chrome支持本地Ajax请求,Ajax请求status cancel Origin null is not allowed by Access-Control-Allow-Origin Origin null is not allowed by Access-Control-Allow-Origin ","permalink":"https://wdd.js.org/posts/2018/origin-null-is-not-allowed/","summary":"1. 问题表现 以file:///xxx.html打开某个html文件，发送ajax请求时报错：\nResponse to preflight request doesn\u0026#39;t pass access control check: The \u0026#39;Access-Control-Allow-Origin\u0026#39; header has a value \u0026#39;null\u0026#39; that is not equal to the supplied origin. Origin \u0026#39;null\u0026#39; is therefore not allowed access. 2. 问题原因 Origin null是本地文件系统，因此这表明您正在加载通过file：// URL进行加载调用的HTML页面（例如，只需在本地文件浏览器或类似文件中双击它）。不同的浏览器采用不同的方法将相同来源策略应用到本地文件。Chrome要求比较严格，不允许这种形势的跨域请求。而最好使用http:// 访问html.\n3. 解决方案 以下给出三个解决方案，第一个最快，第三个作为彻底。\n3.1. 方案1 给Chrome快捷方式中增加 \u0026ndash;allow-file-access-from-files 打开Chrome快捷方式的属性中设置：右击Chrome浏览器快捷方式，选择“属性”，在“目标”中加\u0026quot;\u0026ndash;allow-file-access-from-files\u0026quot;，注意前面有个空格，重启Chrome浏览器便可。\n3.2. 方案2 启动一个简单的静态文件服务器, 以http协议访问html 参见我的这篇文章: 一行命令搭建简易静态文件http服务器\n3.3. 方案3 服务端响应修改Access-Control-Allow-Origin : * response.addHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;,\u0026#34;*\u0026#34;) 4. 参考文章 如何解决XMLHttpRequest cannot load file~~~~~~~Origin \u0026rsquo;null\u0026rsquo; is therefore not allowed access 让chrome支持本地Ajax请求,Ajax请求status cancel Origin null is not allowed by Access-Control-Allow-Origin Origin null is not allowed by Access-Control-Allow-Origin ","title":"Chrome本地跨域origin-null-is-not-allowed问题分析与解决方案"},{"content":"之前因为有优惠政策，于是我在xx云上买了一台位于香港的最低配置的服务器，期限三年，主要用来搭建ss, 用来跨栏。\n用了一段时间，感觉挺稳定的。后来一纸通知，收到了整改信息。于是我就把ss服务停了。\n三年的主机不能浪费，于是我就思考一下曲线救国的思路。\n即使用ssh链接上远程服务器后，使用googler命令进行搜索，然后点击链接，使用本地浏览器打开搜索结果\n关于googler可以查看，https://github.com/jarun/googler#installation\n","permalink":"https://wdd.js.org/posts/2018/use-googler-for-serarch/","summary":"之前因为有优惠政策，于是我在xx云上买了一台位于香港的最低配置的服务器，期限三年，主要用来搭建ss, 用来跨栏。\n用了一段时间，感觉挺稳定的。后来一纸通知，收到了整改信息。于是我就把ss服务停了。\n三年的主机不能浪费，于是我就思考一下曲线救国的思路。\n即使用ssh链接上远程服务器后，使用googler命令进行搜索，然后点击链接，使用本地浏览器打开搜索结果\n关于googler可以查看，https://github.com/jarun/googler#installation","title":"曲线救国 使用googler命令行搜索"},{"content":"1. 书籍类 1.1. 老太婆一样的罗里吧嗦： Python学习手册（第4版） 这本书相当的啰嗦，讲的内容空洞乏力，一些概念蜻蜓点水，买了必定会后悔。\n1.2. 很有意思：Python编程：从入门到实践 这本书讲的知识点虽然不是很全面，但是要点都讲的很清晰，行文也很有意思，最后一些实践项目也很有趣。\n1.3. 干货满满：Python语言及其应用 这本书虽然不是非常有趣，但是都是干货满满，知识点讲解也是很到位，非常推荐初学者看看。\n2. 免费在线资料 2.1. 廖雪峰pthon3教程：中文，免费，零起点，完整示例，基于最新的Python 3版本 2.2. 菜鸟教程 python3 非常适合作为一个快速查找的手册\n2.3. 进阶 Python Cookbook 3 适合有一定python基础的同学看\n2.4. 把这个放在枕头下面 The Python Standard Library Python官方标准库参考手册，有什么需要刨根问底的问题需要查的时候，此处务必需要查阅一下。\n","permalink":"https://wdd.js.org/posts/2018/python-books-comments/","summary":"1. 书籍类 1.1. 老太婆一样的罗里吧嗦： Python学习手册（第4版） 这本书相当的啰嗦，讲的内容空洞乏力，一些概念蜻蜓点水，买了必定会后悔。\n1.2. 很有意思：Python编程：从入门到实践 这本书讲的知识点虽然不是很全面，但是要点都讲的很清晰，行文也很有意思，最后一些实践项目也很有趣。\n1.3. 干货满满：Python语言及其应用 这本书虽然不是非常有趣，但是都是干货满满，知识点讲解也是很到位，非常推荐初学者看看。\n2. 免费在线资料 2.1. 廖雪峰pthon3教程：中文，免费，零起点，完整示例，基于最新的Python 3版本 2.2. 菜鸟教程 python3 非常适合作为一个快速查找的手册\n2.3. 进阶 Python Cookbook 3 适合有一定python基础的同学看\n2.4. 把这个放在枕头下面 The Python Standard Library Python官方标准库参考手册，有什么需要刨根问底的问题需要查的时候，此处务必需要查阅一下。","title":"python3入门书籍与在线资料"},{"content":"1. 功能最强：regex101 优点：\n支持多种语言, prec,php,javascript,python,golang 界面美观大方 支持错误提示，实时匹配 缺点：\n有时候加载速度太慢 2. 可视化正则绘图: Regulex 优点：\n实时根据正则表达式绘图 页面加载速度快 3. 可视化正则绘图：regexper 优点：\n根据正则表达式绘图 页面加载速度快 缺点：\n无法实时绘图，需要点击才可以 4. 专注于python正则：pyregex 专注python 页面加载速度快 ","permalink":"https://wdd.js.org/posts/2018/regex-online-tools/","summary":"1. 功能最强：regex101 优点：\n支持多种语言, prec,php,javascript,python,golang 界面美观大方 支持错误提示，实时匹配 缺点：\n有时候加载速度太慢 2. 可视化正则绘图: Regulex 优点：\n实时根据正则表达式绘图 页面加载速度快 3. 可视化正则绘图：regexper 优点：\n根据正则表达式绘图 页面加载速度快 缺点：\n无法实时绘图，需要点击才可以 4. 专注于python正则：pyregex 专注python 页面加载速度快 ","title":"正则表达式在线工具集合"},{"content":"1. 问答题 1.1. HTML相关 1.1.1. 的作用是什么？ 1.1.2. script, script async和script defer之间有什么区别？ 1.1.3. cookie, sessionStorage 和 localStorage之间有什么区别？ 1.1.4. 用过哪些html模板渲染工具？ 1.2. CSS相关 1.2.1. 简述CSS盒子模型 1.2.2. CSS有哪些选择器？ 1.2.3. CSS sprite是什么？ 1.2.4. 写一下你知道的前端UI框架？ 1.3. JS相关 1.3.1. js有哪些数据类型？ 1.3.2. js有哪些假值？ 1.3.3. js数字和字符串之间有什么快速转换的写法？ 1.3.4. 经常使用哪些ES6的语法？ 1.3.5. 什么是同源策略？ 1.3.6. 跨域有哪些解决方法？ 1.3.7. 网页进度条实现的原理 1.3.8. 请问console.log是同步的，还是异步的？ 1.3.9. 下面console输出的值是什么？ var scores = [10,11,12]; var total = 0; for(var score in scores){ total += score; } var average = total/scores.length; console.log(average); 1.3.10. 请问下面的写法问题在哪？ console.log(1) (function(){ console.log(1) })() 1.3.11. 请问s.length是多少，s[2]是多少 var s = [] s[3] = 4 s.length ? s[2] ? 1.3.12. 说说你对setTimeout的深入理解？ setTimeout(function(){ console.log(\u0026#39;hi\u0026#39;) }, 1000) 1.3.13. 解释闭包概念及其作用 1.3.14. 如何理解js 函数first class的概念？ 1.3.15. 函数有哪些调用方式？不同this的会指向哪里？ 1.3.16. applly和call有什么区别？ 1.3.17. 函数的length属性的代表什么？ 1.3.18. 有用过哪些js编程风格 1.3.19. 如何理解EventLoop? 1.3.20. 使用过哪些构建工具？各有什么优缺点？ 1.4. 其它 1.4.1. 平时使用什么搜索引擎查资料？ 1.4.2. 对翻墙有什么看法？如何翻墙？ 1.4.3. 个人有没有技术博客，地址是什么？ 1.4.4. github上有没有项目？ 1.5. 网络相关 1.5.1. 请求状态码 1xx,2xx,3xx,4xx,5xx分别有什么含义？ 1.5.2. 发送某些post请求时，有时会多一些options请求，请问这是为什么？ 1.5.3. http报文有哪些组成部分？ 1.5.4. http端到端首部和逐跳首部有什么区别？ 1.5.5. http与https在同时使用时，有什么注意点？ 1.5.6. http, tcp, udp, websocket，分别位于7层网络的那一层？tcp和udp有什么不同？ 2. 编码题 2.1. 写一个函数，返回一个数组中所有元素被第一个元素除后的结果 2.2. 写一个函数，来判断变量是否是数组，至少使用两种写法 2.3. 写一个函数，将秒转化成时分秒格式，如80转化成：00:01:20 写一个函数，将对象中属性值为\u0026rsquo;\u0026rsquo;, undefined, null的属性删除掉 // 处理前 var obj = { name: \u0026#39;wdd\u0026#39;, address: { code: \u0026#39;\u0026#39;, tt: null, age: 1 }, ss: [], vv: undefined } // 处理后 { name: \u0026#39;wdd\u0026#39;, address: { age: 1 }, ss: [] } 3. 翻译题 Aggregation operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. MongoDB provides three ways to perform aggregation: the aggregation pipeline, the map-reduce function, and single purpose aggregation methods.\n","permalink":"https://wdd.js.org/posts/2018/front-end-interview-handbook/","summary":"1. 问答题 1.1. HTML相关 1.1.1. 的作用是什么？ 1.1.2. script, script async和script defer之间有什么区别？ 1.1.3. cookie, sessionStorage 和 localStorage之间有什么区别？ 1.1.4. 用过哪些html模板渲染工具？ 1.2. CSS相关 1.2.1. 简述CSS盒子模型 1.2.2. CSS有哪些选择器？ 1.2.3. CSS sprite是什么？ 1.2.4. 写一下你知道的前端UI框架？ 1.3. JS相关 1.3.1. js有哪些数据类型？ 1.3.2. js有哪些假值？ 1.3.3. js数字和字符串之间有什么快速转换的写法？ 1.3.4. 经常使用哪些ES6的语法？ 1.3.5. 什么是同源策略？ 1.3.6. 跨域有哪些解决方法？ 1.3.7. 网页进度条实现的原理 1.3.8. 请问console.log是同步的，还是异步的？ 1.3.9. 下面console输出的值是什么？ var scores = [10,11,12]; var total = 0; for(var score in scores){ total += score; } var average = total/scores.length; console.log(average); 1.","title":"前端面试和笔试题目"},{"content":"床底下秘密 我是一个毅力不是很够的人。我曾经下定决心要锻炼身体，买了一些健身器材，例如瑜伽垫，仰卧起坐的器材，俯卧撑的器材。然而三分钟的热度过后，我把瑜伽垫卷了起来，塞到床底下。把仰卧起坐的器材拆开，也塞到了床底下。\n所以每次我都不敢看床底下，那里塞满了我的羞愧。我常常想，我这不就是永远睡在羞愧之上吗？\n那么，是什么让我放弃了自己的目标，慢慢活成了自己讨厌的样子呢？\n之前和朋友聊天，我们有一段时间没见了。我突然觉得他也太能聊了，说了很多我不知道的新鲜事，还有一些可以让人茅塞顿开的想法。完了之后，他劝我让我多读书。我觉得这个想法很多。我是确实需要读书了。毕竟我的床底下已经没有空间再塞其他的东西了。\n于是我在多看阅读上买了一下电子书，在京东上买了一些实体书，然后又买了一个kindle。在读书的过程中，有时候作者也会推荐你看一些其他的书。我给自己定了2018年我的阅读计划，给自己定下要看哪些书。\n看书的方法 当我决定要看书，并且为此付出了不少的金钱的情况下。我是非常不愿因让我的金钱的付出白白打水漂的，毕竟买书以及买设备，这不是免费的服务。于是我给自己指定了一个非常完善的定量阅读标准\n读书方法v1.0.0 版 如下\n每天至少看三本书 每本书看50页 人要有标准才能判断是否达标，没有标准，没有数字化的支撑，那是很难以持续的。比如说中国的菜谱，做某道菜中写了一句：加入少许盐。中国人看了会想，那我就按照口味随便加点盐吧。外国人就会被搞得非常迷糊，少许是多少克盐？ 20g, 30g? 完全没有标准嘛。\n按照读书方法 v1.0.0版，我看了几天，这个效果是很好的。但是我很累，电子书50页可不是个小数目。有时候很难完成的。于是我必须要升级我的读书方法。\n读书方法v1.0.1 版 如下\n每天至少看三本书 每本书看10页 按照读书方法v1.0.1 版，我看了几天，虽然读书的进度很慢，但是我很容易有满足感，因为这个目标是很容易就达成的。因为你随便去上个厕所，看个10页电子书也是绰绰有余的。但是这个版本也有个问题。\n如果我今天看的这本书看的流连忘返，一不小心忘记看页码了，居然不知不觉读了38页，那么是不是已经消耗了未来几天的阅读量呢，明天这本书要不要度呢？ 所以，我要升级我的读书方法。\n读书方法v1.0.2版：\n每天至少读三本书 每本书至少读10页 我按照这个方法，感觉做的不错。每天都有一定的阅读量要看，而且阅读量不是很大，不会让我觉得很累。而且当我完成了这个目标，我是会获得不小的满足感。\n大目标分解成小目标去逐个击破，这是我这篇文章的核心观点。\n冲量公式 I = F x T 冲量是力的时间累积效应的量度，是矢量。如果物体所受的力是大小和方向都不变的恒力F，冲量I就是F和作用时间t的乘积。 冲量是描述力对物体作用的时间累积效应的物理量。力的冲量是一个过程量。在谈及冲量时，必须明确是哪个力在哪段时间上的冲量。\n个人好习惯的养成，不是一蹴而就的，而是类似于物理学冲量的概念：力在一段时间内的累积，是过程量\n三分钟的热度对应的冲量：I = F_max x T_min。使用很大的力，作用时间超短，基本上没啥效果，冲量趋近于零。\n微习惯对应的冲量：I = F_min x T_max。使用很小的力，做长时间的积累。冲量不会趋近于零，而是会慢慢增长，然后趋近于一个稳定水平。比如你给自己规定每天看1页书，但是大多数情况下，如果你做了看书的动作，基本上你看书的页数一定会大于1页。\n看什么样的书 我自己喜欢看计算机，心理学，历史人文方面的出版书籍。而我的选择标准有两个，符合任一一个，我都会去看。\n要有用。无论是对我的专业知识，还是对人际交往，金融理财等方面要用有益之处 要有趣。没趣的书我是断然不会去看的。 读书实际上是读人，一流作家写的一流的书，三流作家只能写出九流的书。\n","permalink":"https://wdd.js.org/posts/2018/small-is-better-than-big/","summary":"床底下秘密 我是一个毅力不是很够的人。我曾经下定决心要锻炼身体，买了一些健身器材，例如瑜伽垫，仰卧起坐的器材，俯卧撑的器材。然而三分钟的热度过后，我把瑜伽垫卷了起来，塞到床底下。把仰卧起坐的器材拆开，也塞到了床底下。\n所以每次我都不敢看床底下，那里塞满了我的羞愧。我常常想，我这不就是永远睡在羞愧之上吗？\n那么，是什么让我放弃了自己的目标，慢慢活成了自己讨厌的样子呢？\n之前和朋友聊天，我们有一段时间没见了。我突然觉得他也太能聊了，说了很多我不知道的新鲜事，还有一些可以让人茅塞顿开的想法。完了之后，他劝我让我多读书。我觉得这个想法很多。我是确实需要读书了。毕竟我的床底下已经没有空间再塞其他的东西了。\n于是我在多看阅读上买了一下电子书，在京东上买了一些实体书，然后又买了一个kindle。在读书的过程中，有时候作者也会推荐你看一些其他的书。我给自己定了2018年我的阅读计划，给自己定下要看哪些书。\n看书的方法 当我决定要看书，并且为此付出了不少的金钱的情况下。我是非常不愿因让我的金钱的付出白白打水漂的，毕竟买书以及买设备，这不是免费的服务。于是我给自己指定了一个非常完善的定量阅读标准\n读书方法v1.0.0 版 如下\n每天至少看三本书 每本书看50页 人要有标准才能判断是否达标，没有标准，没有数字化的支撑，那是很难以持续的。比如说中国的菜谱，做某道菜中写了一句：加入少许盐。中国人看了会想，那我就按照口味随便加点盐吧。外国人就会被搞得非常迷糊，少许是多少克盐？ 20g, 30g? 完全没有标准嘛。\n按照读书方法 v1.0.0版，我看了几天，这个效果是很好的。但是我很累，电子书50页可不是个小数目。有时候很难完成的。于是我必须要升级我的读书方法。\n读书方法v1.0.1 版 如下\n每天至少看三本书 每本书看10页 按照读书方法v1.0.1 版，我看了几天，虽然读书的进度很慢，但是我很容易有满足感，因为这个目标是很容易就达成的。因为你随便去上个厕所，看个10页电子书也是绰绰有余的。但是这个版本也有个问题。\n如果我今天看的这本书看的流连忘返，一不小心忘记看页码了，居然不知不觉读了38页，那么是不是已经消耗了未来几天的阅读量呢，明天这本书要不要度呢？ 所以，我要升级我的读书方法。\n读书方法v1.0.2版：\n每天至少读三本书 每本书至少读10页 我按照这个方法，感觉做的不错。每天都有一定的阅读量要看，而且阅读量不是很大，不会让我觉得很累。而且当我完成了这个目标，我是会获得不小的满足感。\n大目标分解成小目标去逐个击破，这是我这篇文章的核心观点。\n冲量公式 I = F x T 冲量是力的时间累积效应的量度，是矢量。如果物体所受的力是大小和方向都不变的恒力F，冲量I就是F和作用时间t的乘积。 冲量是描述力对物体作用的时间累积效应的物理量。力的冲量是一个过程量。在谈及冲量时，必须明确是哪个力在哪段时间上的冲量。\n个人好习惯的养成，不是一蹴而就的，而是类似于物理学冲量的概念：力在一段时间内的累积，是过程量\n三分钟的热度对应的冲量：I = F_max x T_min。使用很大的力，作用时间超短，基本上没啥效果，冲量趋近于零。\n微习惯对应的冲量：I = F_min x T_max。使用很小的力，做长时间的积累。冲量不会趋近于零，而是会慢慢增长，然后趋近于一个稳定水平。比如你给自己规定每天看1页书，但是大多数情况下，如果你做了看书的动作，基本上你看书的页数一定会大于1页。\n看什么样的书 我自己喜欢看计算机，心理学，历史人文方面的出版书籍。而我的选择标准有两个，符合任一一个，我都会去看。\n要有用。无论是对我的专业知识，还是对人际交往，金融理财等方面要用有益之处 要有趣。没趣的书我是断然不会去看的。 读书实际上是读人，一流作家写的一流的书，三流作家只能写出九流的书。","title":"small is better than big 我的读书方法论"},{"content":"1. 环境 macOS Sierra 10.12.5 vscode 1.20.0 最新版 2. 如何重现这个问题 在使用中文输入法输入中文的时候，一直按后退键，例如输入sfsf，当你按了4下后退键时，你会发现，搜狗输入法弹出框虽然消失了，但是页面上还会剩下一个s, 这是你如何再次按一下后退的话，s就会变成bs, 变成隐藏字符。这个一般是右边有markdown渲染插件时才会出现。\n从更确切的角度说，是你的编辑器一旦开了webview，就会出现这个问题，即使是vscode的欢迎页，也是webview，也会导致这个问题。所以最好在写代码时尽量关闭webview。\n3. 如何让隐藏字符现身 Mac版的vscode控制字符一般是不会显示出来的，可以用一下的方法让其显示出来\n\u0026#34;editor.renderControlCharacters\u0026#34;: true 在编辑器中显示的像很小的BS, 表示backspace的意思。一般是在输入时，按了后退或者删除会偶尔出现这个字符。\n4. 隐藏的控制字符会出现什么问题？ 4.1. 控制字符在github上会出现问号 例如下图的的和同字之间就是出现一个隐藏字符，在github上就会出现一个带有背景的问号。\n4.2. 控制字符在Hexo NexT Local Search 会导致search.xml渲染失败，搜索框一直在转圈 如果你使用浏览器打开search.xml，会发现解析报错\n5. 如何解决 5.1. 手动删除隐藏字符 可以使用替换，先复制一个隐藏字符，然后把隐藏字符替换成空\n5.2. 使用插件 Remove backspace control character Remove backspace control character\n在本家chromium已被合并，因此，在8月上旬发行的vscode 1.15将会重新确定(vscode 1.15, electron 1.7.4)。事实上，到现在这个问题还是没解决的\n特点\n格式化程序，用于删除打开的文档中包含的控制字符。要被删除的控制字符默认如下。\n/[\\u0000]|[\\u0001]|[\\u0002]|[\\u0003]|[\\u0004]|[\\u0005]|[\\u0006]|[\\u0007]|[\\u0008]|[\\u000b]|[\\u000c]|[\\u000d]|[\\u000e]|[\\u000f]|[\\u0010]|[\\u0011]|[\\u0012]|[\\u0013]|[\\u0014]|[\\u0015]|[\\u0016]|[\\u0017]|[\\u0018]|[\\u0019]|[\\u001a]|[\\u001b]|[\\u001c]|[\\u001d]|[\\u001e]|[\\u001f]|[\\u001c]|[\\u007f]/gm 用法\n\u0026ldquo;editor.formatOnSave\u0026rdquo;: true 如果被设定,保存时启动 \u0026ldquo;editor.formatOnType\u0026rdquo;: true 在被设定的情况下，进行变换时;输入时启动 5.3. 坐等官方给出更好的解决方案 官方这个bug依然还是open状态。Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114\n5.4. 关闭所有webview 这个问题一般出现在标签页含有webview时发生，所以在升级到vscode最新版后，在写代码时要注意，不要开启任何有webview的标签页，其中包括\n关闭markdown渲染插件实时渲染的功能 关闭vscode欢迎页标签页 6. 为什么官方不直接解决这个问题？ vscode底层使用了electron，这是electron的Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173bug, electron不解决这个问题，vscode就不会解决。\nelectron底层使用了chromium， 这是chromium的Two backspaces required to delete last character in webview inputbug, chromium不解决，elctron就无法解决。\n综上，截止文章写出之时，这个问题依然没解决。\n7. 参考 Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？ Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层 Backspace can not erase the last one character during Chinese/Japanese IME conversion (macOS) #24981 Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173 Two backspaces required to delete last character in webview input 控制字符 Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114 ","permalink":"https://wdd.js.org/posts/2018/vscode-control-characters-problem/","summary":"1. 环境 macOS Sierra 10.12.5 vscode 1.20.0 最新版 2. 如何重现这个问题 在使用中文输入法输入中文的时候，一直按后退键，例如输入sfsf，当你按了4下后退键时，你会发现，搜狗输入法弹出框虽然消失了，但是页面上还会剩下一个s, 这是你如何再次按一下后退的话，s就会变成bs, 变成隐藏字符。这个一般是右边有markdown渲染插件时才会出现。\n从更确切的角度说，是你的编辑器一旦开了webview，就会出现这个问题，即使是vscode的欢迎页，也是webview，也会导致这个问题。所以最好在写代码时尽量关闭webview。\n3. 如何让隐藏字符现身 Mac版的vscode控制字符一般是不会显示出来的，可以用一下的方法让其显示出来\n\u0026#34;editor.renderControlCharacters\u0026#34;: true 在编辑器中显示的像很小的BS, 表示backspace的意思。一般是在输入时，按了后退或者删除会偶尔出现这个字符。\n4. 隐藏的控制字符会出现什么问题？ 4.1. 控制字符在github上会出现问号 例如下图的的和同字之间就是出现一个隐藏字符，在github上就会出现一个带有背景的问号。\n4.2. 控制字符在Hexo NexT Local Search 会导致search.xml渲染失败，搜索框一直在转圈 如果你使用浏览器打开search.xml，会发现解析报错\n5. 如何解决 5.1. 手动删除隐藏字符 可以使用替换，先复制一个隐藏字符，然后把隐藏字符替换成空\n5.2. 使用插件 Remove backspace control character Remove backspace control character\n在本家chromium已被合并，因此，在8月上旬发行的vscode 1.15将会重新确定(vscode 1.15, electron 1.7.4)。事实上，到现在这个问题还是没解决的\n特点\n格式化程序，用于删除打开的文档中包含的控制字符。要被删除的控制字符默认如下。\n/[\\u0000]|[\\u0001]|[\\u0002]|[\\u0003]|[\\u0004]|[\\u0005]|[\\u0006]|[\\u0007]|[\\u0008]|[\\u000b]|[\\u000c]|[\\u000d]|[\\u000e]|[\\u000f]|[\\u0010]|[\\u0011]|[\\u0012]|[\\u0013]|[\\u0014]|[\\u0015]|[\\u0016]|[\\u0017]|[\\u0018]|[\\u0019]|[\\u001a]|[\\u001b]|[\\u001c]|[\\u001d]|[\\u001e]|[\\u001f]|[\\u001c]|[\\u007f]/gm 用法\n\u0026ldquo;editor.formatOnSave\u0026rdquo;: true 如果被设定,保存时启动 \u0026ldquo;editor.formatOnType\u0026rdquo;: true 在被设定的情况下，进行变换时;输入时启动 5.3. 坐等官方给出更好的解决方案 官方这个bug依然还是open状态。Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114","title":"vscode控制字符引起的问题以及解决思路"},{"content":"1. 【字符串替换】快速修改配置文件版本号 语法：%s/str1/str2/g 将文件中所有的str1字符串替换成str2字符串。\n示例：某个服务从43版本升级到44版本\n// vi某个配置文件， 进入vi命令模式，输入 :%s/43/44/g 这样做的好处是不需要移动光标去查找，然后进入插入模式去修改版本，而是直接替换，这样比较快捷。\n注意：务必确认要被替换的字符串只有一个，否则可能造成误替换。\n更多用法：\n语法 功能 示例 :s/str1/str2/ 替换当前行第一个str1为str2 :s/44/45 :s/str1/str2/g 替换当前行所有的str1为str2 :s/44/45/g :%s/str1/str2/ 替换每一行第一个str1为str2 :%s/44/45 :%s/str1/str2/g 替换每一行所有的str1为str2 :%s/44/45/g 2. 光标移动 注意：可配合 :set nu显示行号\n语法 功能 示例 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。 20G 则会移动到这个档案的第20行 gg 移动到这个档案的第一行 n\u0026lt;Enter\u0026gt; n 为数字 光标向下移动 n 行 3\u0026lt;Enter\u0026gt; 向下移动三行 3. vi快捷手册 ","permalink":"https://wdd.js.org/posts/2018/vi-useful-expressions/","summary":"1. 【字符串替换】快速修改配置文件版本号 语法：%s/str1/str2/g 将文件中所有的str1字符串替换成str2字符串。\n示例：某个服务从43版本升级到44版本\n// vi某个配置文件， 进入vi命令模式，输入 :%s/43/44/g 这样做的好处是不需要移动光标去查找，然后进入插入模式去修改版本，而是直接替换，这样比较快捷。\n注意：务必确认要被替换的字符串只有一个，否则可能造成误替换。\n更多用法：\n语法 功能 示例 :s/str1/str2/ 替换当前行第一个str1为str2 :s/44/45 :s/str1/str2/g 替换当前行所有的str1为str2 :s/44/45/g :%s/str1/str2/ 替换每一行第一个str1为str2 :%s/44/45 :%s/str1/str2/g 替换每一行所有的str1为str2 :%s/44/45/g 2. 光标移动 注意：可配合 :set nu显示行号\n语法 功能 示例 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。 20G 则会移动到这个档案的第20行 gg 移动到这个档案的第一行 n\u0026lt;Enter\u0026gt; n 为数字 光标向下移动 n 行 3\u0026lt;Enter\u0026gt; 向下移动三行 3. vi快捷手册 ","title":"VI必备常用场景快捷操作"},{"content":"1 JavaScript Standard Style简介 本工具通过以下三种方式为你（及你的团队）节省大量时间：\n无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard \u0026ndash;fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 无须犹豫。再也不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。 安装：\nnpm i standard -g 关于JavaScript 代码规范, 你可以点击链接看一下。\n2 如何在vscode中用JavaScript Standard Style风格去验证 vue文件 实际上JavaScript Standard Style有一个FAQ, 说明了如何使用。\n但是有一点非常重要的作者没有提到，就是eslint-plugin-html这个插件必须要安装3.x.x版本的, 现在eslint-plugin-html, 已经升级到4.x版本，默认不写版本号安装的就是4.x版本的，所以会出现问题。参考\nESLint v4 is only supported by eslint-plugin-html v3, so you can\u0026rsquo;t use eslint-plugin-html v1.5.2 with it (I should add a warning about this when trying to use the plugin with an incompatible version on ESLint).\nIf you do not use ESLint v4, please provide more information (package.json, a gist to reproduce, \u0026hellip;)\n// FAQ How to lint script tag in vue or html files? You can lint them with eslint-plugin-html, just install it first, then enable linting for those file types in settings.json with: \u0026#34;standard.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, \u0026#34;html\u0026#34; ], \u0026#34;standard.options\u0026#34;: { \u0026#34;plugins\u0026#34;: [\u0026#34;html\u0026#34;] }, \u0026#34;files.associations\u0026#34;: { \u0026#34;*.vue\u0026#34;: \u0026#34;html\u0026#34; }, If you want to enable autoFix for the new languages, you should enable it yourself: \u0026#34;standard.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, { \u0026#34;language\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;autoFix\u0026#34;: true } ], \u0026#34;standard.options\u0026#34;: { \u0026#34;plugins\u0026#34;: [\u0026#34;html\u0026#34;] } 3 综上， 整理一下安装思路 3.1 需要安装哪些包？ npm i -g standard npm i -g eslint-plugin-html@3.2.2 必须是3x版本 npm i -g eslint 以上三个包都是全局安装的，如果你想看看全局安装了哪些包可以用npm list -g --depth=0查看 3.2 vscode config 如何写？ \u0026#34;standard.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, { \u0026#34;language\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;autoFix\u0026#34;: true } ], \u0026#34;standard.options\u0026#34;: { \u0026#34;plugin\u0026#34;: [\u0026#34;html\u0026#34;] }, \u0026#34;files.associations\u0026#34;: { \u0026#34;*.vue\u0026#34;: \u0026#34;html\u0026#34; }, 3.3 如何在保存文件时，自动使用standard格式化vue文件 \u0026#34;standard.autoFixOnSave\u0026#34;: true 4. 如果还不行怎么办？ 重启一下vscode 重启一下电脑 在此文后追加评论 ","permalink":"https://wdd.js.org/posts/2018/vscode-lint-vue-file-by-standard-style/","summary":"1 JavaScript Standard Style简介 本工具通过以下三种方式为你（及你的团队）节省大量时间：\n无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard \u0026ndash;fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 无须犹豫。再也不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。 安装：\nnpm i standard -g 关于JavaScript 代码规范, 你可以点击链接看一下。\n2 如何在vscode中用JavaScript Standard Style风格去验证 vue文件 实际上JavaScript Standard Style有一个FAQ, 说明了如何使用。\n但是有一点非常重要的作者没有提到，就是eslint-plugin-html这个插件必须要安装3.x.x版本的, 现在eslint-plugin-html, 已经升级到4.x版本，默认不写版本号安装的就是4.x版本的，所以会出现问题。参考\nESLint v4 is only supported by eslint-plugin-html v3, so you can\u0026rsquo;t use eslint-plugin-html v1.5.2 with it (I should add a warning about this when trying to use the plugin with an incompatible version on ESLint).","title":"如何在vscode中用standard style 风格去验证 vue文件"},{"content":"0 阅前须知 本文并不是教程，只是实现方案 我只是从WEB端考虑这个问题，实际还需要后端sip服务器的配合 jsSIP有个非常不错的在线demo, 可以去哪里玩耍，很好玩呢 try jssip 1. 技术简介 WebRTC: WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准 SIP: 会话发起协议（Session Initiation Protocol，缩写SIP）是一个由IETF MMUSIC工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000年11月，SIP被正式批准成为3GPP信号协议之一，并成为IMS体系结构的一个永久单元。SIP与H.323一样，是用于VoIP最主要的信令协议之一。 一般来说，要么使用实体话机，要么在系统上安装基于sip的客户端程序。实体话机硬件成本高，基于sip的客户端往往兼容性差，无法跨平台，易被杀毒软件查杀。\n而WebRTC或许是更好的解决方案，只要一个浏览器就可以实时语音视频通话，这是很不错的解决方案。WebSocket可以用来传递sip信令，而WebRTC用来实时传输语音视频流。\n2. 前端WebRTC实现方案 其实我们不需要去自己处理WebRTC的相关方法，或者去处理视频或者媒体流。市面上已经有不错的模块可供选择。\n2.1 jsSIP jsSIP是JavaScript SIP 库\n功能特点如下：\n可以在浏览器或者Nodejs中运行 使用WebSocket传递SIP协议 视频音频实时消息使用WebRTC 非常轻量 100%纯JavaScript 使用简单并且具有强大的Api 服务端支持 OverSIP, Kamailio, Asterisk, OfficeSIP，reSIProcate，Frafos ABC SBC，TekSIP 是RFC 7118 and OverSIP的作者写的 下面是使用JsSIP打电话的例子，非常简单吧\n// Create our JsSIP instance and run it: var socket = new JsSIP.WebSocketInterface(\u0026#39;wss://sip.myhost.com\u0026#39;); var configuration = { sockets : [ socket ], uri : \u0026#39;sip:alice@example.com\u0026#39;, password : \u0026#39;superpassword\u0026#39; }; var ua = new JsSIP.UA(configuration); ua.start(); // Register callbacks to desired call events var eventHandlers = { \u0026#39;progress\u0026#39;: function(e) { console.log(\u0026#39;call is in progress\u0026#39;); }, \u0026#39;failed\u0026#39;: function(e) { console.log(\u0026#39;call failed with cause: \u0026#39;+ e.data.cause); }, \u0026#39;ended\u0026#39;: function(e) { console.log(\u0026#39;call ended with cause: \u0026#39;+ e.data.cause); }, \u0026#39;confirmed\u0026#39;: function(e) { console.log(\u0026#39;call confirmed\u0026#39;); } }; var options = { \u0026#39;eventHandlers\u0026#39; : eventHandlers, \u0026#39;mediaConstraints\u0026#39; : { \u0026#39;audio\u0026#39;: true, \u0026#39;video\u0026#39;: true } }; var session = ua.call(\u0026#39;sip:bob@example.com\u0026#39;, options); 2.2 SIP.js sip.js项目实际是fork自jsSIP的，这里主要介绍它的服务端支持情况。其他接口自己自行查阅\nFreeSWITCH Asterisk OnSIP FreeSWITCH Legacy 3. 平台考量 由于WebRTC对浏览器有较高的要求，你可以看看下图，哪些浏览器支持WebRTC, 所有IE浏览器都不行，chrome系支持情况不错。\n3.1 考量标准 跨平台 兼容性 体积 集成性 硬件要求 开发成本 3.2 考量表格 种类 适用平台 优点 缺点 基于electron开发的桌面客户端 window, mac, linux 跨平台，兼容好 要下载安装，体积大（压缩后至少48MB），对电脑性能有要求 开发js sdk 现代浏览器 体积小，容易第三方集成 兼容差(因为涉及到webRTC, IE11以及以都不行，对宿主环境要求高)，客户集成需要开发量 开发谷歌浏览器扩展 谷歌浏览器 体积小 兼容差（仅限类chrome浏览器） 4 参考文档 and 延伸阅读 and 动手实践 Js SIP Getting Started 120行代码实现 浏览器WebRTC视频聊天 SIP协议状态码： 5 常见问题 422: \u0026ldquo;Session Interval Too Small\u0026rdquo; jsSIP默认携带Session-Expires: 90的头部信息，如果这个超时字段小于服务端的设定值，那么就会得到如下422的响应。参见SIP协议状态码：, 可以在call请求中设置sessionTimersExpires, 使其超过服务端的设定值即可\ncall(targer, options ) option.sessionTimersExpires Number (in seconds) for the default Session Timers interval (default value is 90, do not set a lower value). 6 最后，你我共勉 ","permalink":"https://wdd.js.org/posts/2018/webrtc-web-sip-phone/","summary":"0 阅前须知 本文并不是教程，只是实现方案 我只是从WEB端考虑这个问题，实际还需要后端sip服务器的配合 jsSIP有个非常不错的在线demo, 可以去哪里玩耍，很好玩呢 try jssip 1. 技术简介 WebRTC: WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准 SIP: 会话发起协议（Session Initiation Protocol，缩写SIP）是一个由IETF MMUSIC工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000年11月，SIP被正式批准成为3GPP信号协议之一，并成为IMS体系结构的一个永久单元。SIP与H.323一样，是用于VoIP最主要的信令协议之一。 一般来说，要么使用实体话机，要么在系统上安装基于sip的客户端程序。实体话机硬件成本高，基于sip的客户端往往兼容性差，无法跨平台，易被杀毒软件查杀。\n而WebRTC或许是更好的解决方案，只要一个浏览器就可以实时语音视频通话，这是很不错的解决方案。WebSocket可以用来传递sip信令，而WebRTC用来实时传输语音视频流。\n2. 前端WebRTC实现方案 其实我们不需要去自己处理WebRTC的相关方法，或者去处理视频或者媒体流。市面上已经有不错的模块可供选择。\n2.1 jsSIP jsSIP是JavaScript SIP 库\n功能特点如下：\n可以在浏览器或者Nodejs中运行 使用WebSocket传递SIP协议 视频音频实时消息使用WebRTC 非常轻量 100%纯JavaScript 使用简单并且具有强大的Api 服务端支持 OverSIP, Kamailio, Asterisk, OfficeSIP，reSIProcate，Frafos ABC SBC，TekSIP 是RFC 7118 and OverSIP的作者写的 下面是使用JsSIP打电话的例子，非常简单吧\n// Create our JsSIP instance and run it: var socket = new JsSIP.WebSocketInterface(\u0026#39;wss://sip.myhost.com\u0026#39;); var configuration = { sockets : [ socket ], uri : \u0026#39;sip:alice@example.","title":"基于 WebRTC 构建 Web SIP Phone"},{"content":"1 You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。\n内容目录\n手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子\n2 You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。\n来自开发者的声音\n在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment\n你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript\n我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular\n我承认，我曾经过度使用lodash. —@therebelrobot, Maker of web things, Facilitator for Node.js/io.js\n内容目录\nArray _.compact _.concat _.fill _.find _.findIndex _.first _.flatten _.flattenDeep _.head and _.tail _.indexOf _.join _.last _.lastIndexOf _.reverse _.without _.slice _.isArray Collection _.each _.every _.filter _.groupBy _.includes _.map _.minBy and _.maxBy _.pluck _.range _.reduce _.reduceRight _.size _.some Function _.after Lang _.isNaN Object _.assign _.keys _.toPairs _.values String _.repeat _.template _.toLower _.toUpper _.trim _.replace 3 You-Dont-Need-jQuery 纯JavaScript的例子, 实现做jQuery与查询，样式，dom，ajax，事件等\n前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。\n内容目录\nTranslations Query Selector CSS \u0026amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support You-Dont-Need-GUI 图形用户界面对计算机用户非常友好。它们被引入以响应命令行界面（CLI）感知的陡峭学习曲线。\n但是，他们往往需要更多的资源，功能不强，难以通过脚本自动化。\n作为计算机专家，我们希望更高效，更好地完成工作。我们知道命令字可能不容易被发现或助记符，所以我们尝试列出一些您可能试图在GUI中执行的常见任务。\n内容目录\n复制一个文件 复制一个文件 复制一个文件夹 复制一个文件夹 移动一个文件 重命名一个文件 移动一个文件夹 重命名文件夹 合并文件夹 创建一个新的文件 新建一个文件夹 显示文件/文件夹大小 用默认程序打开一个文件 压缩一个文件夹 解压缩文件夹 删除一个文件 删除一个文件夹 列出文件夹内容 树查看文件夹及其子文件夹 找到一个陈旧的文件 显示一个日历 找到未来的日期 使用计算器 强制退出程序 ","permalink":"https://wdd.js.org/posts/2018/you-dont-need-serial/","summary":"1 You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。\n内容目录\n手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子\n2 You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。\n来自开发者的声音\n在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment\n你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript\n我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular","title":"you-dont-need-serial"},{"content":"1 visibilitychange事件 触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.\n使用场景：当标签页显示或者隐藏时，触发一些业务逻辑\ndocument.addEventListener(\u0026#34;visibilitychange\u0026#34;, function() { console.log( document.visibilityState ); }); 2 storage事件 触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时\n使用场景：标签页间通信\n// AB页面同源 // 在A 页面 window.addEventListener(\u0026#39;storage\u0026#39;, (e) =\u0026gt; {console.log(e)}) // 在B 页面，向120打个电话 localStorage.setItem(\u0026#39;makeCall\u0026#39;,\u0026#39;120\u0026#39;) // 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知 ...key: \u0026#34;makeCall\u0026#34;, oldValue: \u0026#34;119\u0026#34;, newValue: \u0026#34;120\u0026#34;, ... 3 beforeunload事件 触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时\n使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等\nwindow.addEventListener(\u0026#34;beforeunload\u0026#34;, function (e) { var confirmationMessage = \u0026#34;\\o/\u0026#34;; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome \u0026lt;34 }); 4 navigator.sendBeacon 这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。\n使用 sendBeacon() 方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！\n注意：该方法在IE和safari没有实现\n使用场景：发送崩溃报告\nwindow.addEventListener(\u0026#39;unload\u0026#39;, logData, false); function logData() { navigator.sendBeacon(\u0026#34;/log\u0026#34;, analyticsData); } ","permalink":"https://wdd.js.org/posts/2018/useful-browser-events/","summary":"1 visibilitychange事件 触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.\n使用场景：当标签页显示或者隐藏时，触发一些业务逻辑\ndocument.addEventListener(\u0026#34;visibilitychange\u0026#34;, function() { console.log( document.visibilityState ); }); 2 storage事件 触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时\n使用场景：标签页间通信\n// AB页面同源 // 在A 页面 window.addEventListener(\u0026#39;storage\u0026#39;, (e) =\u0026gt; {console.log(e)}) // 在B 页面，向120打个电话 localStorage.setItem(\u0026#39;makeCall\u0026#39;,\u0026#39;120\u0026#39;) // 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知 ...key: \u0026#34;makeCall\u0026#34;, oldValue: \u0026#34;119\u0026#34;, newValue: \u0026#34;120\u0026#34;, ... 3 beforeunload事件 触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时\n使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等\nwindow.addEventListener(\u0026#34;beforeunload\u0026#34;, function (e) { var confirmationMessage = \u0026#34;\\o/\u0026#34;; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome \u0026lt;34 }); 4 navigator.","title":"不常用却很有妙用的事件及方法"},{"content":" trim-everything trim所有字段，因为底层使用的JSON.stringify作为遍历器，所以如果字段的值是function，那么会被trim掉。\n项目地址：trim-everything\n安装 npm i -S trim-everything yarn add trim-everything 特点 trim undefined trim null trim number trim string trim object trim array 零依赖 开始 下面使用jest做的测试用例，可以从中看出trim的用法。\n/* global test, expect */ const trim = require(\u0026#39;trim-everything\u0026#39;) test(\u0026#39;trim undefined\u0026#39;, () =\u0026gt; { expect(trim()).toBeUndefined() }) test(\u0026#39;trim null\u0026#39;, () =\u0026gt; { expect(trim(null)).toBeNull() }) test(\u0026#39;trim number\u0026#39;, () =\u0026gt; { expect(trim(12.12)).toBe(12.12) }) test(\u0026#39;trim string\u0026#39;, () =\u0026gt; { expect(trim(\u0026#39; 12abcd \u0026#39;)).toBe(\u0026#39;12abcd\u0026#39;) }) test(\u0026#39;trim object\u0026#39;, () =\u0026gt; { expect(trim({ userName: \u0026#39; wangdd \u0026#39;, age: 12, some: false, address: \u0026#39; shanghai\u0026#39; })) .toEqual({ userName: \u0026#39;wangdd\u0026#39;, age: 12, some: false, address: \u0026#39;shanghai\u0026#39; }) }) test(\u0026#39;trim array\u0026#39;, () =\u0026gt; { expect(trim([ { userName: \u0026#39; wangdd \u0026#39;, age: 12, some: false, address: \u0026#39; shanghai\u0026#39; }, \u0026#39; abcd \u0026#39;, false, 12.12, { userName: \u0026#39; wangdd \u0026#39;, age: 12, some: false, address: \u0026#39; shanghai\u0026#39;, child: { userName: \u0026#39; wangdd \u0026#39;, age: 12, some: false, address: \u0026#39; shanghai\u0026#39; } } ])) .toEqual( [ { userName: \u0026#39;wangdd\u0026#39;, age: 12, some: false, address: \u0026#39;shanghai\u0026#39; }, \u0026#39;abcd\u0026#39;, false, 12.12, { userName: \u0026#39;wangdd\u0026#39;, age: 12, some: false, address: \u0026#39;shanghai\u0026#39;, child: { userName: \u0026#39;wangdd\u0026#39;, age: 12, some: false, address: \u0026#39;shanghai\u0026#39; } } ] ) }) ","permalink":"https://wdd.js.org/posts/2018/trim-every-thing/","summary":"trim-everything trim所有字段，因为底层使用的JSON.stringify作为遍历器，所以如果字段的值是function，那么会被trim掉。\n项目地址：trim-everything\n安装 npm i -S trim-everything yarn add trim-everything 特点 trim undefined trim null trim number trim string trim object trim array 零依赖 开始 下面使用jest做的测试用例，可以从中看出trim的用法。\n/* global test, expect */ const trim = require(\u0026#39;trim-everything\u0026#39;) test(\u0026#39;trim undefined\u0026#39;, () =\u0026gt; { expect(trim()).toBeUndefined() }) test(\u0026#39;trim null\u0026#39;, () =\u0026gt; { expect(trim(null)).toBeNull() }) test(\u0026#39;trim number\u0026#39;, () =\u0026gt; { expect(trim(12.12)).toBe(12.12) }) test(\u0026#39;trim string\u0026#39;, () =\u0026gt; { expect(trim(\u0026#39; 12abcd \u0026#39;)).toBe(\u0026#39;12abcd\u0026#39;) }) test(\u0026#39;trim object\u0026#39;, () =\u0026gt; { expect(trim({ userName: \u0026#39; wangdd \u0026#39;, age: 12, some: false, address: \u0026#39; shanghai\u0026#39; })) .","title":"trim-everything trim所有数据类型"},{"content":"0. 现象 Could not create temporary directory: Permission denied\n1. 问题起因 在 /Users/username/Library/Caches/目录下，有以下两个文件， 可以看到，他们两个的用户是不一样的，一个是root一个username, 一般来说，我是以username来使用我的mac的。就是因为这两个文件的用户不一样，导致了更新失败。\ndrwxr-xr-x 6 username staff 204B Jan 17 20:33 com.microsoft.VSCode drwxr--r-- 2 root staff 68B Dec 17 13:51 com.microsoft.VSCode.ShipIt 2. 解决方法 注意： 先把vscode 完全关闭\n// 1. 这一步是需要输入密码的 sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/ // 2. 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错 sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/* // 3. 更新xattr xattr -dr com.apple.quarantine /Applications/Visual\\ Studio\\ Code.app 3. 打开vscode Code \u0026gt; Check for Updates, 点击之后，你会发现Check for Updates已经变成灰色了，那么你需要稍等片刻，马上就可以更新，之后会跳出提示，让你重启vscode, 然后重启一下vscode, 就ok了。\n4. 参考 joaomoreno commented on Feb 7, 2017 • edited ","permalink":"https://wdd.js.org/posts/2018/mac-vscode-update-permission-denied/","summary":"0. 现象 Could not create temporary directory: Permission denied\n1. 问题起因 在 /Users/username/Library/Caches/目录下，有以下两个文件， 可以看到，他们两个的用户是不一样的，一个是root一个username, 一般来说，我是以username来使用我的mac的。就是因为这两个文件的用户不一样，导致了更新失败。\ndrwxr-xr-x 6 username staff 204B Jan 17 20:33 com.microsoft.VSCode drwxr--r-- 2 root staff 68B Dec 17 13:51 com.microsoft.VSCode.ShipIt 2. 解决方法 注意： 先把vscode 完全关闭\n// 1. 这一步是需要输入密码的 sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/ // 2. 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错 sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/* // 3. 更新xattr xattr -dr com.apple.quarantine /Applications/Visual\\ Studio\\ Code.app 3. 打开vscode Code \u0026gt; Check for Updates, 点击之后，你会发现Check for Updates已经变成灰色了，那么你需要稍等片刻，马上就可以更新，之后会跳出提示，让你重启vscode, 然后重启一下vscode, 就ok了。","title":"mac vscode 更新失败 Permission denied解决办法"},{"content":"一千个IE浏览器访问同一个页面，可能报一千种错误。前端激进派对IE恨得牙痒痒，但是无论你爱，或者不爱，IE就在那里，不来不去。\n一些银行，以及政府部门，往往都是指定必须使用IE浏览器。所以，一些仅在IE浏览器上出现的问题。总结起来问题的原因很简单：IE的配置不正确\n下面就将一个我曾经遇到的问题: IE11 0x2ee4， 以及其他的问题的解决方案\n1. IE11 SCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4 背景介绍：在一个HTTPS域向另外一个HTTPS域发送跨域POTST请求时\n这个问题在浏览器的输出内容如下，怪异的是，并不是所有IE11都会报这个错误。\nSCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4, 由于出现错误 00002ee4 而导致此项操作无法完成 stackoverflow上有个答案，它的思路是：在post请求发送之前，先进行一次get操作 这个方式我试过，是可行的。但是深层次的原因我不是很明白。\n然而真相总有大白的一天，其实深层次的原因是，IE11的配置。\n去掉检查证书吊销的的检查，解决0x2ee4的问题\n解决方法\n去掉check for server certificate revocation*， 也有可能你那边是中文翻译的：叫检查服务器证书是否已吊销 去掉检查发型商证书是否已吊销 点击确定 重启计算机 2 其他常规设置 2.1 去掉兼容模式， 使用Edge文档模式 下图中红色框里的按钮也要取消勾选 2.2 有些使用activeX，还是需要检查是否启用的 2.3 允许跨域 如果你的接口跨域了，还要检查浏览器是否允许跨域，否则浏览器可能默认就禁止跨域的\n设置方法\ninternet选项 安全 自定义级别 启用通过跨域访问数据源 启用跨域浏览窗口和框架 确定 然后重启电脑 ","permalink":"https://wdd.js.org/posts/2018/ie11-0x2ee4-bug/","summary":"一千个IE浏览器访问同一个页面，可能报一千种错误。前端激进派对IE恨得牙痒痒，但是无论你爱，或者不爱，IE就在那里，不来不去。\n一些银行，以及政府部门，往往都是指定必须使用IE浏览器。所以，一些仅在IE浏览器上出现的问题。总结起来问题的原因很简单：IE的配置不正确\n下面就将一个我曾经遇到的问题: IE11 0x2ee4， 以及其他的问题的解决方案\n1. IE11 SCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4 背景介绍：在一个HTTPS域向另外一个HTTPS域发送跨域POTST请求时\n这个问题在浏览器的输出内容如下，怪异的是，并不是所有IE11都会报这个错误。\nSCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4, 由于出现错误 00002ee4 而导致此项操作无法完成 stackoverflow上有个答案，它的思路是：在post请求发送之前，先进行一次get操作 这个方式我试过，是可行的。但是深层次的原因我不是很明白。\n然而真相总有大白的一天，其实深层次的原因是，IE11的配置。\n去掉检查证书吊销的的检查，解决0x2ee4的问题\n解决方法\n去掉check for server certificate revocation*， 也有可能你那边是中文翻译的：叫检查服务器证书是否已吊销 去掉检查发型商证书是否已吊销 点击确定 重启计算机 2 其他常规设置 2.1 去掉兼容模式， 使用Edge文档模式 下图中红色框里的按钮也要取消勾选 2.2 有些使用activeX，还是需要检查是否启用的 2.3 允许跨域 如果你的接口跨域了，还要检查浏览器是否允许跨域，否则浏览器可能默认就禁止跨域的\n设置方法\ninternet选项 安全 自定义级别 启用通过跨域访问数据源 启用跨域浏览窗口和框架 确定 然后重启电脑 ","title":"IE11 0x2ee4 bug 以及类似问题解决方法"},{"content":" markdown写文档虽然如行云流水，但是一旦需要引入图片了。往往需要四五步操作，如果图片仅仅保存在本地，那么复制markdown时，图片路径往往都不对了，还要重新上传一遍图片，很是麻烦。\n因此，最好把图片直接上传到图床上，然后通过公网链接来引入图片。图床选择上，我选择七牛云。\n我在网上找到了3个不错的工具，在此记录一下。\n1. 三个工具分析一览 这些工具在上传图片成功后，会把链接保存在剪贴板中，在markdown文件中只需要粘贴一下就可以了。\n名称 | 收费标准 | 优点 | 缺点 | 推荐指数 | 说明 | 下载地址 \u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;- ipic | 50元/年 | 支持很多的云服务，压缩，拖拽上传 | 死贵, 免费版只能用新浪图床，图片很可能会丢失 | A |功能很多，价钱死贵 | 可通过mac app store 下载 UCQCloud | 免费 | 免费，支持压缩，拖拽上传，截图上传 | 仅支持七牛，服务器仅支持华东和华北 | AAA | 免费，功能够用 | UCQCloud1.3.3.dmg cuImage | 终身1元 | 剪贴板上传，压缩上传，拖拽上传，快捷键上传，自动把链接转成markdown的形式 | 仅支持七牛 | AAAA | cuImage的压缩率要比UCQCloud高很多 | 可通过mac app store 下载\n总体来说：如果你用七牛图床，cuImage是性价比最高, 用户体验最好的\n2. 三个工具操作截图与简介 3. cuImage 图片上传完成后自动复制URL。 在“上传历史”中查看已上传图片。 批量上传图片。 通过截图或复制上传图片。 通过拖拽上传图片。 通过”服务“菜单上传图片。 通过全局快捷键上传图片。 上传之前压缩图片。 支持BMP/JPEG/PNG/GIF/TIFF等多种文件格式。 只支持七牛云，已兼容七牛云华东、华北、华南及北美的存储区域。 4. UCQCloud 1、文件上传(带上传进度)\n支持软件面板拖放、选择文件(任意二进制文件)上传\n支持状态栏粘贴板图片上传\n支持状态栏拖放文件上传 2、图片高质量压缩\n本地图片上传使用Tinypng在线高质量无损压缩\n粘贴板图片上传使用开源库pngquant压缩\n正常情况压缩节省50%以上空间,大幅提高博客图片加载速度，节约网盘存储空间。 3、上传历史记录管理\n文件预览查看，删除，拷贝上传外链地址等\n4、支持文件夹批量处理\n直接拖入文件夹，或文件批量处理 作者：huluo666 链接：https://www.jianshu.com/p/694dad59f20c 來源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n5. ipic 图床神器 iPic 可自动上传图片、保存 Markdown 链接，给你前所未有的插图体验。\n上传前压缩图片 通过拖拽上传图片 通过服务上传图片 [Command + U… 6. 参考文献 iPic - 图床神器 Mac七牛图床与文件批量上传工具: UCQCloud1.3.3 cuImage - 图床利器 ","permalink":"https://wdd.js.org/posts/2018/tool-upload-img-to-cloud/","summary":"markdown写文档虽然如行云流水，但是一旦需要引入图片了。往往需要四五步操作，如果图片仅仅保存在本地，那么复制markdown时，图片路径往往都不对了，还要重新上传一遍图片，很是麻烦。\n因此，最好把图片直接上传到图床上，然后通过公网链接来引入图片。图床选择上，我选择七牛云。\n我在网上找到了3个不错的工具，在此记录一下。\n1. 三个工具分析一览 这些工具在上传图片成功后，会把链接保存在剪贴板中，在markdown文件中只需要粘贴一下就可以了。\n名称 | 收费标准 | 优点 | 缺点 | 推荐指数 | 说明 | 下载地址 \u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;- ipic | 50元/年 | 支持很多的云服务，压缩，拖拽上传 | 死贵, 免费版只能用新浪图床，图片很可能会丢失 | A |功能很多，价钱死贵 | 可通过mac app store 下载 UCQCloud | 免费 | 免费，支持压缩，拖拽上传，截图上传 | 仅支持七牛，服务器仅支持华东和华北 | AAA | 免费，功能够用 | UCQCloud1.3.3.dmg cuImage | 终身1元 | 剪贴板上传，压缩上传，拖拽上传，快捷键上传，自动把链接转成markdown的形式 | 仅支持七牛 | AAAA | cuImage的压缩率要比UCQCloud高很多 | 可通过mac app store 下载\n总体来说：如果你用七牛图床，cuImage是性价比最高, 用户体验最好的\n2. 三个工具操作截图与简介 3.","title":"Mac版：上传图片到远程图床哪家强？"},{"content":"1. 简介 1.1. 相关技术 Vue Vue-cli ElementUI yarn (之前我用npm, 并使用cnpm的源，但是用了yarn之后，我发现它比cnpm的速度还快，功能更好，我就毫不犹豫选择yarn了) Audio相关API和事件 1.2. 从本教程你会学到什么？ Vue单文件组件开发知识 Element UI基本用法 Audio原生API及Audio相关事件 音频播放器的基本原理 音频的播放暂停控制 更新音频显示时间 音频进度条控制与跳转 音频音量控制 音频播放速度控制 音频静音控制 音频下载控制 个性化配置与排他性播放 一点点ES6语法 2. 学前准备 基本上不需要什么准备，但是如果你能先看一下Aduio相关API和事件将会更好\nAudio: 如果你愿意一层一层剥开我的心 使用 HTML5 音频和视频 3. 在线demon 没有在线demo的教程都是耍流氓\n查看在线demon 项目地址 4. 开始编码 5. 项目初始化 ➜ test vue init webpack element-audio A newer version of vue-cli is available. latest: 2.9.2 installed: 2.9.1 ? Project name element-audio ? Project description A Vue.js project ? Author wangdd \u0026lt;wangdd@xxxxxx.com\u0026gt; ? Vue build standalone ? Install vue-router? No ? Use ESLint to lint your code? No ? Set up unit tests No ? Setup e2e tests with Nightwatch? No ? Should we run `npm install` for you after the project has been created? (recommended) npm ➜ test cd element-audio ➜ element-audio npm run dev 浏览器打开 http://localhost:8080/, 看到如下界面，说明项目初始化成功\n5.1. 安装ElementUI并插入audio标签 5.1.1. 安装ElementUI yarn add element-ui // or npm i element-ui -S 5.1.2. 在src/main.js中引入Element UI // filename: src/main.js import Vue from \u0026#39;vue\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39; import App from \u0026#39;./App\u0026#39; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39; Vue.config.productionTip = false Vue.use(ElementUI) /* eslint-disable no-new */ new Vue({ el: \u0026#39;#app\u0026#39;, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, components: { App } }) 5.1.3. 创建src/components/VueAudio.vue // filename: src/components/VueAudio.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;audio src=\u0026#34;http://devtest.qiniudn.com/secret base~.mp3\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data () { return {} } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 5.1.4. 修改src/App.vue, 并引入VueAudio.vue组件 // filename: src/App.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;VueAudio /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import VueAudio from \u0026#39;./components/VueAudio\u0026#39; export default { name: \u0026#39;app\u0026#39;, components: { VueAudio }, data () { return {} } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 打开：http://localhost:8080/，你应该能看到如下效果，说明引入成功，你可以点击播放按钮看看，音频是否能够播放 5.2. 音频的播放暂停控制 我们需要用一个按钮去控制音频的播放与暂停，这里调用了audio的两个api,以及两个事件\naudio.play() audio.pause() play事件 pause事件 修改src/components/VueAudio.vue\n// filename: src/components/VueAudio.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 此处的ref属性，可以很方便的在vue组件中通过 this.$refs.audio获取该dom元素 --\u0026gt; \u0026lt;audio ref=\u0026#34;audio\u0026#34; @pause=\u0026#34;onPause\u0026#34; @play=\u0026#34;onPlay\u0026#34; src=\u0026#34;http://devtest.qiniudn.com/secret base~.mp3\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- 音频播放控件 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;startPlayOrPause\u0026#34;\u0026gt;{{audio.playing | transPlayPause}}\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data () { return { audio: { // 该字段是音频是否处于播放状态的属性 playing: false } } }, methods: { // 控制音频的播放与暂停 startPlayOrPause () { return this.audio.playing ? this.pause() : this.play() }, // 播放音频 play () { this.$refs.audio.play() }, // 暂停音频 pause () { this.$refs.audio.pause() }, // 当音频播放 onPlay () { this.audio.playing = true }, // 当音频暂停 onPause () { this.audio.playing = false } }, filters: { // 使用组件过滤器来动态改变按钮的显示 transPlayPause(value) { return value ? \u0026#39;暂停\u0026#39; : \u0026#39;播放\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 5.3. 音频显示时间 音频的时间显示主要有两部分，音频的总时长和当前播放时间。可以从两个事件中获取\nloadedmetadata:代表音频的元数据已经被加载完成，可以从中获取音频总时长 timeupdate: 当前播放位置作为正常播放的一部分而改变，或者以特别有趣的方式，例如不连续地改变，可以从该事件中获取音频的当前播放时间，该事件在播放过程中会不断被触发 要点代码：整数格式化成时:分:秒\nfunction realFormatSecond(second) { var secondType = typeof second if (secondType === \u0026#39;number\u0026#39; || secondType === \u0026#39;string\u0026#39;) { second = parseInt(second) var hours = Math.floor(second / 3600) second = second - hours * 3600 var mimute = Math.floor(second / 60) second = second - mimute * 60 return hours + \u0026#39;:\u0026#39; + (\u0026#39;0\u0026#39; + mimute).slice(-2) + \u0026#39;:\u0026#39; + (\u0026#39;0\u0026#39; + second).slice(-2) } else { return \u0026#39;0:00:00\u0026#39; } } 要点代码： 两个事件的处理\n// 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间 onTimeupdate(res) { console.log(\u0026#39;timeupdate\u0026#39;) console.log(res) this.audio.currentTime = res.target.currentTime }, // 当加载语音流元数据完成后，会触发该事件的回调函数 // 语音元数据主要是语音的长度之类的数据 onLoadedmetadata(res) { console.log(\u0026#39;loadedmetadata\u0026#39;) console.log(res) this.audio.maxTime = parseInt(res.target.duration) } 完整代码\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 此处的ref属性，可以很方便的在vue组件中通过 this.$refs.audio获取该dom元素 --\u0026gt; \u0026lt;audio ref=\u0026#34;audio\u0026#34; @pause=\u0026#34;onPause\u0026#34; @play=\u0026#34;onPlay\u0026#34; @timeupdate=\u0026#34;onTimeupdate\u0026#34; @loadedmetadata=\u0026#34;onLoadedmetadata\u0026#34; src=\u0026#34;http://devtest.qiniudn.com/secret base~.mp3\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- 音频播放控件 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;startPlayOrPause\u0026#34;\u0026gt;{{audio.playing | transPlayPause}}\u0026lt;/el-button\u0026gt; \u0026lt;el-tag type=\u0026#34;info\u0026#34;\u0026gt;{{ audio.currentTime | formatSecond}}\u0026lt;/el-tag\u0026gt; \u0026lt;el-tag type=\u0026#34;info\u0026#34;\u0026gt;{{ audio.maxTime | formatSecond}}\u0026lt;/el-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 将整数转换成 时：分：秒的格式 function realFormatSecond(second) { var secondType = typeof second if (secondType === \u0026#39;number\u0026#39; || secondType === \u0026#39;string\u0026#39;) { second = parseInt(second) var hours = Math.floor(second / 3600) second = second - hours * 3600 var mimute = Math.floor(second / 60) second = second - mimute * 60 return hours + \u0026#39;:\u0026#39; + (\u0026#39;0\u0026#39; + mimute).slice(-2) + \u0026#39;:\u0026#39; + (\u0026#39;0\u0026#39; + second).slice(-2) } else { return \u0026#39;0:00:00\u0026#39; } } export default { data () { return { audio: { // 该字段是音频是否处于播放状态的属性 playing: false, // 音频当前播放时长 currentTime: 0, // 音频最大播放时长 maxTime: 0 } } }, methods: { // 控制音频的播放与暂停 startPlayOrPause () { return this.audio.playing ? this.pause() : this.play() }, // 播放音频 play () { this.$refs.audio.play() }, // 暂停音频 pause () { this.$refs.audio.pause() }, // 当音频播放 onPlay () { this.audio.playing = true }, // 当音频暂停 onPause () { this.audio.playing = false }, // 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间 onTimeupdate(res) { console.log(\u0026#39;timeupdate\u0026#39;) console.log(res) this.audio.currentTime = res.target.currentTime }, // 当加载语音流元数据完成后，会触发该事件的回调函数 // 语音元数据主要是语音的长度之类的数据 onLoadedmetadata(res) { console.log(\u0026#39;loadedmetadata\u0026#39;) console.log(res) this.audio.maxTime = parseInt(res.target.duration) } }, filters: { // 使用组件过滤器来动态改变按钮的显示 transPlayPause(value) { return value ? \u0026#39;暂停\u0026#39; : \u0026#39;播放\u0026#39; }, // 将整数转化成时分秒 formatSecond(second = 0) { return realFormatSecond(second) } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 打开浏览器可以看到，当音频播放时，当前时间也在改变。 5.4. 音频进度条控制 进度条主要有两个控制，改变进度的原理是：改变audio.currentTime属性值\n音频播放后，当前时间改变，进度条就要随之改变 拖动进度条，可以改变音频的当前时间 // 进度条ui \u0026lt;el-slider v-model=\u0026#34;sliderTime\u0026#34; :format-tooltip=\u0026#34;formatProcessToolTip\u0026#34; @change=\u0026#34;changeCurrentTime\u0026#34; class=\u0026#34;slider\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; // 拖动进度条，改变当前时间，index是进度条改变时的回调函数的参数0-100之间，需要换算成实际时间 changeCurrentTime(index) { this.$refs.audio.currentTime = parseInt(index / 100 * this.audio.maxTime) }, // 当音频当前时间改变后，进度条也要改变 onTimeupdate(res) { console.log(\u0026#39;timeupdate\u0026#39;) console.log(res) this.audio.currentTime = res.target.currentTime this.sliderTime = parseInt(this.audio.currentTime / this.audio.maxTime * 100) }, // 进度条格式化toolTip formatProcessToolTip(index = 0) { index = parseInt(this.audio.maxTime / 100 * index) return \u0026#39;进度条: \u0026#39; + realFormatSecond(index) }, 5.5. 音频音量控制 音频的音量控制和进度控制差不多，也是通过拖动滑动条，去修改aduio.volume属性值，此处不再啰嗦\n5.6. 音频播放速度控制 音频播放速度控制和进度控制差不多，也是点击按钮，去修改aduio.playbackRate属性值，该属性代表音量的大小，取值范围是0 - 1，用滑动条的时候，也是需要换算一下值，此处不再啰嗦\n5.7. 音频静音控制 静音的控制是点击按钮，去修改aduio.muted属性，该属性有两个值: true(静音)，false(不静音)。 注意，静音的时候，音频的进度条还是会继续往前走的。\n5.8. 音频下载控制 音频下载是一个a链接，记得加上download属性，不然浏览器会在新标签打开音频，而不是下载音频\n\u0026lt;a :href=\u0026#34;url\u0026#34; v-show=\u0026#34;!controlList.noDownload\u0026#34; target=\u0026#34;_blank\u0026#34; class=\u0026#34;download\u0026#34; download\u0026gt;下载\u0026lt;/a\u0026gt; 5.9. 个性化配置 音频的个性化配置有很多，大家可以自己扩展，通过父组件传递响应的值，可以做到个性化设置。\ncontrolList: { // 不显示下载 noDownload: false, // 不显示静音 noMuted: false, // 不显示音量条 noVolume: false, // 不显示进度条 noProcess: false, // 只能播放一个 onlyOnePlaying: false, // 不要快进按钮 noSpeed: false } setControlList () { let controlList = this.theControlList.split(\u0026#39; \u0026#39;) controlList.forEach((item) =\u0026gt; { if(this.controlList[item] !== undefined){ this.controlList[item] = true } }) }, 例如父组件这样\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;item in audios\u0026#34; :key=\u0026#34;item.url\u0026#34;\u0026gt; \u0026lt;VueAudio :theUrl=\u0026#34;item.url\u0026#34; :theControlList=\u0026#34;item.controlList\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import VueAudio from \u0026#39;./components/VueAudio\u0026#39; export default { name: \u0026#39;app\u0026#39;, components: { VueAudio }, data () { return { audios: [ { url: \u0026#39;http://devtest.qiniudn.com/secret base~.mp3\u0026#39;, controlList: \u0026#39;onlyOnePlaying\u0026#39; }, { url: \u0026#39;http://devtest.qiniudn.com/回レ！雪月花.mp3\u0026#39;, controlList: \u0026#39;noDownload noMuted onlyOnePlaying\u0026#39; },{ url: \u0026#39;http://devtest.qiniudn.com/あっちゅ～ま青春!.mp3\u0026#39;, controlList: \u0026#39;noDownload noVolume noMuted onlyOnePlaying\u0026#39; },{ url: \u0026#39;http://devtest.qiniudn.com/Preparation.mp3\u0026#39;, controlList: \u0026#39;noDownload noSpeed onlyOnePlaying\u0026#39; } ] } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 5.10. 一点点ES6语法 大多数时候，我们希望页面上播放一个音频时，其他音频可以暂停。 [...audios]可以把一个类数组转化成数组，这个是我常用的。\nonPlay (res) { console.log(res) this.audio.playing = true this.audio.loading = false if(!this.controlList.onlyOnePlaying){ return } let target = res.target let audios = document.getElementsByTagName(\u0026#39;audio\u0026#39;); // 如果设置了排他性，当前音频播放是，其他音频都要暂停 [...audios].forEach((item) =\u0026gt; { if(item !== target){ item.pause() } }) }, 5.11. 完成后的文件 //filename: VueAudio.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;di main-wrap\u0026#34; v-loading=\u0026#34;audio.waiting\u0026#34;\u0026gt; \u0026lt;!-- 这里设置了ref属性后，在vue组件中，就可以用this.$refs.audio来访问该dom元素 --\u0026gt; \u0026lt;audio ref=\u0026#34;audio\u0026#34; class=\u0026#34;dn\u0026#34; :src=\u0026#34;url\u0026#34; :preload=\u0026#34;audio.preload\u0026#34; @play=\u0026#34;onPlay\u0026#34; @error=\u0026#34;onError\u0026#34; @waiting=\u0026#34;onWaiting\u0026#34; @pause=\u0026#34;onPause\u0026#34; @timeupdate=\u0026#34;onTimeupdate\u0026#34; @loadedmetadata=\u0026#34;onLoadedmetadata\u0026#34; \u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;startPlayOrPause\u0026#34;\u0026gt;{{audio.playing | transPlayPause}}\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-show=\u0026#34;!controlList.noSpeed\u0026#34; type=\u0026#34;text\u0026#34; @click=\u0026#34;changeSpeed\u0026#34;\u0026gt;{{audio.speed | transSpeed}}\u0026lt;/el-button\u0026gt; \u0026lt;el-tag type=\u0026#34;info\u0026#34;\u0026gt;{{ audio.currentTime | formatSecond}}\u0026lt;/el-tag\u0026gt; \u0026lt;el-slider v-show=\u0026#34;!controlList.noProcess\u0026#34; v-model=\u0026#34;sliderTime\u0026#34; :format-tooltip=\u0026#34;formatProcessToolTip\u0026#34; @change=\u0026#34;changeCurrentTime\u0026#34; class=\u0026#34;slider\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;el-tag type=\u0026#34;info\u0026#34;\u0026gt;{{ audio.maxTime | formatSecond }}\u0026lt;/el-tag\u0026gt; \u0026lt;el-button v-show=\u0026#34;!controlList.noMuted\u0026#34; type=\u0026#34;text\u0026#34; @click=\u0026#34;startMutedOrNot\u0026#34;\u0026gt;{{audio.muted | transMutedOrNot}}\u0026lt;/el-button\u0026gt; \u0026lt;el-slider v-show=\u0026#34;!controlList.noVolume\u0026#34; v-model=\u0026#34;volume\u0026#34; :format-tooltip=\u0026#34;formatVolumeToolTip\u0026#34; @change=\u0026#34;changeVolume\u0026#34; class=\u0026#34;slider\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34; v-show=\u0026#34;!controlList.noDownload\u0026#34; target=\u0026#34;_blank\u0026#34; class=\u0026#34;download\u0026#34; download\u0026gt;下载\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; function realFormatSecond(second) { var secondType = typeof second if (secondType === \u0026#39;number\u0026#39; || secondType === \u0026#39;string\u0026#39;) { second = parseInt(second) var hours = Math.floor(second / 3600) second = second - hours * 3600 var mimute = Math.floor(second / 60) second = second - mimute * 60 return hours + \u0026#39;:\u0026#39; + (\u0026#39;0\u0026#39; + mimute).slice(-2) + \u0026#39;:\u0026#39; + (\u0026#39;0\u0026#39; + second).slice(-2) } else { return \u0026#39;0:00:00\u0026#39; } } export default { props: { theUrl: { type: String, required: true, }, theSpeeds: { type: Array, default () { return [1, 1.5, 2] } }, theControlList: { type: String, default: \u0026#39;\u0026#39; } }, name: \u0026#39;VueAudio\u0026#39;, data() { return { url: this.theUrl || \u0026#39;http://devtest.qiniudn.com/secret base~.mp3\u0026#39;, audio: { currentTime: 0, maxTime: 0, playing: false, muted: false, speed: 1, waiting: true, preload: \u0026#39;auto\u0026#39; }, sliderTime: 0, volume: 100, speeds: this.theSpeeds, controlList: { // 不显示下载 noDownload: false, // 不显示静音 noMuted: false, // 不显示音量条 noVolume: false, // 不显示进度条 noProcess: false, // 只能播放一个 onlyOnePlaying: false, // 不要快进按钮 noSpeed: false } } }, methods: { setControlList () { let controlList = this.theControlList.split(\u0026#39; \u0026#39;) controlList.forEach((item) =\u0026gt; { if(this.controlList[item] !== undefined){ this.controlList[item] = true } }) }, changeSpeed() { let index = this.speeds.indexOf(this.audio.speed) + 1 this.audio.speed = this.speeds[index % this.speeds.length] this.$refs.audio.playbackRate = this.audio.speed }, startMutedOrNot() { this.$refs.audio.muted = !this.$refs.audio.muted this.audio.muted = this.$refs.audio.muted }, // 音量条toolTip formatVolumeToolTip(index) { return \u0026#39;音量条: \u0026#39; + index }, // 进度条toolTip formatProcessToolTip(index = 0) { index = parseInt(this.audio.maxTime / 100 * index) return \u0026#39;进度条: \u0026#39; + realFormatSecond(index) }, // 音量改变 changeVolume(index = 0) { this.$refs.audio.volume = index / 100 this.volume = index }, // 播放跳转 changeCurrentTime(index) { this.$refs.audio.currentTime = parseInt(index / 100 * this.audio.maxTime) }, startPlayOrPause() { return this.audio.playing ? this.pausePlay() : this.startPlay() }, // 开始播放 startPlay() { this.$refs.audio.play() }, // 暂停 pausePlay() { this.$refs.audio.pause() }, // 当音频暂停 onPause () { this.audio.playing = false }, // 当发生错误, 就出现loading状态 onError () { this.audio.waiting = true }, // 当音频开始等待 onWaiting (res) { console.log(res) }, // 当音频开始播放 onPlay (res) { console.log(res) this.audio.playing = true this.audio.loading = false if(!this.controlList.onlyOnePlaying){ return } let target = res.target let audios = document.getElementsByTagName(\u0026#39;audio\u0026#39;); [...audios].forEach((item) =\u0026gt; { if(item !== target){ item.pause() } }) }, // 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间 onTimeupdate(res) { // console.log(\u0026#39;timeupdate\u0026#39;) // console.log(res) this.audio.currentTime = res.target.currentTime this.sliderTime = parseInt(this.audio.currentTime / this.audio.maxTime * 100) }, // 当加载语音流元数据完成后，会触发该事件的回调函数 // 语音元数据主要是语音的长度之类的数据 onLoadedmetadata(res) { console.log(\u0026#39;loadedmetadata\u0026#39;) console.log(res) this.audio.waiting = false this.audio.maxTime = parseInt(res.target.duration) } }, filters: { formatSecond(second = 0) { return realFormatSecond(second) }, transPlayPause(value) { return value ? \u0026#39;暂停\u0026#39; : \u0026#39;播放\u0026#39; }, transMutedOrNot(value) { return value ? \u0026#39;放音\u0026#39; : \u0026#39;静音\u0026#39; }, transSpeed(value) { return \u0026#39;快进: x\u0026#39; + value } }, created() { this.setControlList() } } \u0026lt;/script\u0026gt; \u0026lt;!-- Add \u0026#34;scoped\u0026#34; attribute to limit CSS to this component only --\u0026gt; \u0026lt;style scoped\u0026gt; .main-wrap{ padding: 10px 15px; } .slider { display: inline-block; width: 100px; position: relative; top: 14px; margin-left: 15px; } .di { display: inline-block; } .download { color: #409EFF; margin-left: 15px; } .dn{ display: none; } \u0026lt;/style\u0026gt; 6. 感谢 如果你需要一个小型的vue音乐播放器，你可以试试vue-aplayer, 该播放器不仅仅支持vue组件，非Vue的也支持，你可以看看他们的demo\n","permalink":"https://wdd.js.org/posts/2018/vue-elementui-audio-component/","summary":"1. 简介 1.1. 相关技术 Vue Vue-cli ElementUI yarn (之前我用npm, 并使用cnpm的源，但是用了yarn之后，我发现它比cnpm的速度还快，功能更好，我就毫不犹豫选择yarn了) Audio相关API和事件 1.2. 从本教程你会学到什么？ Vue单文件组件开发知识 Element UI基本用法 Audio原生API及Audio相关事件 音频播放器的基本原理 音频的播放暂停控制 更新音频显示时间 音频进度条控制与跳转 音频音量控制 音频播放速度控制 音频静音控制 音频下载控制 个性化配置与排他性播放 一点点ES6语法 2. 学前准备 基本上不需要什么准备，但是如果你能先看一下Aduio相关API和事件将会更好\nAudio: 如果你愿意一层一层剥开我的心 使用 HTML5 音频和视频 3. 在线demon 没有在线demo的教程都是耍流氓\n查看在线demon 项目地址 4. 开始编码 5. 项目初始化 ➜ test vue init webpack element-audio A newer version of vue-cli is available. latest: 2.9.2 installed: 2.9.1 ? Project name element-audio ? Project description A Vue.js project ?","title":"Vue+ElementUI 手把手教你做一个audio组件"},{"content":" 一般的方法往往给表单的各个input、select等加上readonly，但是这个方法有很多缺点。此处就不一一赘述。\n我说的方法只需要给表单加上一个类，就可以让表单只读。\n\u0026lt;form class=\u0026#34;form-readonly\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; 1. 方法1: 用:before给form做个看不见的蒙版，遮住下面所有的元素，使之不响应任何事件 .form-readonly{ position: relative; } .form-readonly:before{ content: \u0026#34;\u0026#34;; z-index: 1; position: absolute; top: 0; right: 0; bottom: 0; left: 0; } 2. 方法2: 用pointer-events:none, 让所有事件穿透form .form-readonly{ pointer-events:none; } 关于pointer-events属性，可以看看这个介绍：https://segmentfault.com/a/1190000011182335\n","permalink":"https://wdd.js.org/posts/2018/css-form-readonly/","summary":"一般的方法往往给表单的各个input、select等加上readonly，但是这个方法有很多缺点。此处就不一一赘述。\n我说的方法只需要给表单加上一个类，就可以让表单只读。\n\u0026lt;form class=\u0026#34;form-readonly\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; 1. 方法1: 用:before给form做个看不见的蒙版，遮住下面所有的元素，使之不响应任何事件 .form-readonly{ position: relative; } .form-readonly:before{ content: \u0026#34;\u0026#34;; z-index: 1; position: absolute; top: 0; right: 0; bottom: 0; left: 0; } 2. 方法2: 用pointer-events:none, 让所有事件穿透form .form-readonly{ pointer-events:none; } 关于pointer-events属性，可以看看这个介绍：https://segmentfault.com/a/1190000011182335","title":"奇技淫巧：css实现整个表单只读 form readonly"},{"content":"1. 语法 JSON.stringify(value[, replacer[, space]]) 一般用法：\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user); \u0026#34;{\u0026#34;name\u0026#34;:\u0026#34;andy\u0026#34;,\u0026#34;isDead\u0026#34;:false,\u0026#34;age\u0026#34;:11,\u0026#34;addr\u0026#34;:\u0026#34;shanghai\u0026#34;}\u0026#34; 2. 扩展用法 2.1. replacer replacer可以是函数或者是数组。\n功能1: 改变属性值 将isDead属性的值翻译成0或1，0对应false,1对应true\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user, function(key, value){ if(key === \u0026#39;isDead\u0026#39;){ return value === true ? 1 : 0; } return value; }); \u0026#34;{\u0026#34;name\u0026#34;:\u0026#34;andy\u0026#34;,\u0026#34;isDead\u0026#34;:0,\u0026#34;age\u0026#34;:11,\u0026#34;addr\u0026#34;:\u0026#34;shanghai\u0026#34;}\u0026#34; 功能2：删除某个属性 将isDead属性删除，如果replacer的返回值是undefined,那么该属性会被删除。\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user, function(key, value){ if(key === \u0026#39;isDead\u0026#39;){ return undefined; } return value; }); \u0026#34;{\u0026#34;name\u0026#34;:\u0026#34;andy\u0026#34;,\u0026#34;age\u0026#34;:11,\u0026#34;addr\u0026#34;:\u0026#34;shanghai\u0026#34;}\u0026#34; 功能3: 通过数组过滤某些属性 只需要name属性和addr属性，其他不要。\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user, [\u0026#39;name\u0026#39;, \u0026#39;addr\u0026#39;]); \u0026#34;{\u0026#34;name\u0026#34;:\u0026#34;andy\u0026#34;,\u0026#34;addr\u0026#34;:\u0026#34;shanghai\u0026#34;}\u0026#34; 2.2. space space可以是数字或者是字符串, 如果是数字则表示属性名前加上空格符号的数量，如果是字符串，则直接在属性名前加上该字符串。\n功能1: 给输出属性前加上n个空格\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user, null, 4); \u0026#34;{ \u0026#34;name\u0026#34;: \u0026#34;andy\u0026#34;, \u0026#34;isDead\u0026#34;: false, \u0026#34;age\u0026#34;: 11, \u0026#34;addr\u0026#34;: \u0026#34;shanghai\u0026#34; }\u0026#34; 功能2: tab格式化输出\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user, null, \u0026#39;\\t\u0026#39;); \u0026#34;{ \u0026#34;name\u0026#34;: \u0026#34;andy\u0026#34;, \u0026#34;isDead\u0026#34;: false, \u0026#34;age\u0026#34;: 11, \u0026#34;addr\u0026#34;: \u0026#34;shanghai\u0026#34; }\u0026#34; 功能3： 搞笑\nJSON.stringify(user, null, \u0026#39;good\u0026#39;); \u0026#34;{ good\u0026#34;name\u0026#34;: \u0026#34;andy\u0026#34;, good\u0026#34;isDead\u0026#34;: false, good\u0026#34;age\u0026#34;: 11, good\u0026#34;addr\u0026#34;: \u0026#34;shanghai\u0026#34; }\u0026#34; 2.3. 深拷贝 var user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; var temp = JSON.stringify(user); var user2 = JSON.parse(temp); 3. 其他 JSON.parse() 其实也是支持第二个参数的。功能类似于JSON.stringify的第二个参数的功能。\n4. 参考 MDN JSON.stringify() ","permalink":"https://wdd.js.org/posts/2018/json-stringify-powerful/","summary":"1. 语法 JSON.stringify(value[, replacer[, space]]) 一般用法：\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user); \u0026#34;{\u0026#34;name\u0026#34;:\u0026#34;andy\u0026#34;,\u0026#34;isDead\u0026#34;:false,\u0026#34;age\u0026#34;:11,\u0026#34;addr\u0026#34;:\u0026#34;shanghai\u0026#34;}\u0026#34; 2. 扩展用法 2.1. replacer replacer可以是函数或者是数组。\n功能1: 改变属性值 将isDead属性的值翻译成0或1，0对应false,1对应true\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.stringify(user, function(key, value){ if(key === \u0026#39;isDead\u0026#39;){ return value === true ? 1 : 0; } return value; }); \u0026#34;{\u0026#34;name\u0026#34;:\u0026#34;andy\u0026#34;,\u0026#34;isDead\u0026#34;:0,\u0026#34;age\u0026#34;:11,\u0026#34;addr\u0026#34;:\u0026#34;shanghai\u0026#34;}\u0026#34; 功能2：删除某个属性 将isDead属性删除，如果replacer的返回值是undefined,那么该属性会被删除。\nvar user = {name: \u0026#39;andy\u0026#39;, isDead: false, age: 11, addr: \u0026#39;shanghai\u0026#39;}; JSON.","title":"你不知道的JSON.stringify()妙用"},{"content":"注意：该文章中设置代理的方法存在很大的问题，请不要在使用。这里只作为记录。 非常推荐你使用http-proxy-middleware，作为生产环境代理的包。你可以看我的这篇文章，里面有一个非常小巧的写法，可以实现各种代理的方法，Express 代理中间件的写法 关于该文章中设置代理会产生的问题，在这篇文章中我会做详细的说明, TCP链接高Recv-Q的原因以及解决方法\nnodejs比较好的代理包有：node-http-proxy和http-proxy-middleware。这两个我都用过，它们的优点自不用说，只说说缺点：它们不能从配置文件里读取代理配置。每添加一个拦截路径都需要多加一个接口调用。\n所以，我需要自己写一个http代理，要包含一下功能：\n从配置文件里读取代理配置 可以路径重写 这样做的好处是：新增服务只需要在配置文件上加上该服务，无需修改业务逻辑\n1. /config/default.js module.exports = { \u0026#34;ENV\u0026#34;:\u0026#34;dev\u0026#34;, \u0026#34;PORT\u0026#34;:\u0026#34;8088\u0026#34;, \u0026#34;maxAge\u0026#34;: 10, \u0026#34;proxy\u0026#34;:{ \u0026#34;olap\u0026#34;:{ \u0026#34;host\u0026#34;:\u0026#34;172.16.200.225\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;8092\u0026#34;, \u0026#34;form\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;\u0026#34; }, \u0026#34;qc\u0026#34;:{ \u0026#34;host\u0026#34;:\u0026#34;192.168.40.231\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;30088\u0026#34; }, \u0026#34;api\u0026#34;:{ \u0026#34;host\u0026#34;:\u0026#34;192.168.40.231\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;30412\u0026#34; }, \u0026#34;ocm\u0026#34;:{ \u0026#34;host\u0026#34;: process.env.ocm_host || \u0026#34;192.168.40.119\u0026#34;, \u0026#34;port\u0026#34;: process.env.ocm_port || \u0026#34;31003\u0026#34; } } } 2. /app.js 将所有要走代理的路径前必需加上 /p, 这个是我的个人配置，当然也可以是其他的名字。\nvar express = require(\u0026#39;express\u0026#39;); var compression = require(\u0026#39;compression\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var config = require(\u0026#39;config\u0026#39;); var log4js = require(\u0026#39;log4js\u0026#39;); var wsProxyConfig = config.get(\u0026#39;proxy\u0026#39;); var routes = require(\u0026#39;./routes/index\u0026#39;); var views = require(\u0026#39;./routes/views\u0026#39;); var proxy = require(\u0026#39;./routes/proxy\u0026#39;); app.use(\u0026#39;/p\u0026#39;,proxy); 3. /routes/proxy.js var express = require(\u0026#39;express\u0026#39;); // config是一个第三方包，它的功能是 // 自动根据环境变量帮你读取config目录下 // 的配置文件，默认会读取default.json， // config支持很多文件类型。 var config = require(\u0026#39;config\u0026#39;); var request = require(\u0026#39;request\u0026#39;); var log4js = require(\u0026#39;log4js\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var router = express.Router(); // 此处就是获取配置文件的proxy项了 var proxyConfig = config.get(\u0026#39;proxy\u0026#39;); // 这里记录代理的日志 log4js.configure({ appenders: [ { type: \u0026#39;file\u0026#39;, filename: \u0026#39;./logs/all-proxy-logs.log\u0026#39;, maxLogSize: 10*1024*1024, //max 10mb backups: 5, compress: true }, { type: \u0026#39;stdout\u0026#39; } ] }); var logger = log4js.getLogger(\u0026#39;proxy\u0026#39;); router.all(\u0026#39;/:apiName/*\u0026#39;, function(req, res, next) { // apiName 必需要对应配置文件的proxy的属性名 var apiName = req.params.apiName; if(!apiName){ res.status(404).end(\u0026#39;api not found\u0026#39;); } // 如果apiName不在配置文件里，则报500 else if(!proxyConfig[apiName]){ res.status(500).end(\u0026#39;api has no config\u0026#39;); } else{ // originUrl是原始的url // 例如 /p/qc/calls var originalUrl = req.originalUrl; var api = proxyConfig[apiName]; var url = originalUrl.replace(\u0026#39;/p\u0026#39;,\u0026#39;\u0026#39;); url = `http://${api.host}:${api.port}` + url; // 某些需要路径重写的地方 if(api.form \u0026amp;\u0026amp; api.to){ url = url.replace(api.form, api.to); } // 必须要删除这个host // 因为本地测试时，这个host是localhost // 这会导致服务端报错 delete req.headers.host; // 修改好的请求头 var option = { url: url, headers: req.headers }; // 使用request发起请求 var proxy = request(option); // 此处是关键，将请求流写入代理，将代理的响应写入原始响应 req.pipe(proxy); proxy.pipe(res); // 代理结束响应时，原始请求结束，并输出日志 proxy.on(\u0026#39;end\u0026#39;, function(){ var log = `${req.method} ${res.statusCode} ${req.originalUrl} ---\u0026gt; ${option.url} ${req.headers.sessionid}`; if(res.statusCode \u0026lt; 400){ logger.info(log); } else{ logger.error(log); } res.end(); }); } }); module.exports = router; 4. 相关第三方模块 node-config\nrequest\nlog4js-node\n","permalink":"https://wdd.js.org/posts/2018/write-configurable-nodejs-http-proxy/","summary":"注意：该文章中设置代理的方法存在很大的问题，请不要在使用。这里只作为记录。 非常推荐你使用http-proxy-middleware，作为生产环境代理的包。你可以看我的这篇文章，里面有一个非常小巧的写法，可以实现各种代理的方法，Express 代理中间件的写法 关于该文章中设置代理会产生的问题，在这篇文章中我会做详细的说明, TCP链接高Recv-Q的原因以及解决方法\nnodejs比较好的代理包有：node-http-proxy和http-proxy-middleware。这两个我都用过，它们的优点自不用说，只说说缺点：它们不能从配置文件里读取代理配置。每添加一个拦截路径都需要多加一个接口调用。\n所以，我需要自己写一个http代理，要包含一下功能：\n从配置文件里读取代理配置 可以路径重写 这样做的好处是：新增服务只需要在配置文件上加上该服务，无需修改业务逻辑\n1. /config/default.js module.exports = { \u0026#34;ENV\u0026#34;:\u0026#34;dev\u0026#34;, \u0026#34;PORT\u0026#34;:\u0026#34;8088\u0026#34;, \u0026#34;maxAge\u0026#34;: 10, \u0026#34;proxy\u0026#34;:{ \u0026#34;olap\u0026#34;:{ \u0026#34;host\u0026#34;:\u0026#34;172.16.200.225\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;8092\u0026#34;, \u0026#34;form\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;\u0026#34; }, \u0026#34;qc\u0026#34;:{ \u0026#34;host\u0026#34;:\u0026#34;192.168.40.231\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;30088\u0026#34; }, \u0026#34;api\u0026#34;:{ \u0026#34;host\u0026#34;:\u0026#34;192.168.40.231\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;30412\u0026#34; }, \u0026#34;ocm\u0026#34;:{ \u0026#34;host\u0026#34;: process.env.ocm_host || \u0026#34;192.168.40.119\u0026#34;, \u0026#34;port\u0026#34;: process.env.ocm_port || \u0026#34;31003\u0026#34; } } } 2. /app.js 将所有要走代理的路径前必需加上 /p, 这个是我的个人配置，当然也可以是其他的名字。\nvar express = require(\u0026#39;express\u0026#39;); var compression = require(\u0026#39;compression\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var config = require(\u0026#39;config\u0026#39;); var log4js = require(\u0026#39;log4js\u0026#39;); var wsProxyConfig = config.","title":"手写可配置的express \u0026 nodejs的代理"},{"content":"1. 小栗子 最早我是想通过dispatchAction方法去改变选中的省份，但是没有起作用，如果你知道这个方法怎么实现，麻烦你可以告诉我。 我实现的方法是另外一种。\ndispatchAction({ type: \u0026#39;geoSelect\u0026#39;, // 可选，系列 index，可以是一个数组指定多个系列 seriesIndex?: number|Array, // 可选，系列名称，可以是一个数组指定多个系列 seriesName?: string|Array, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 dataIndex?: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name?: string }) 后来我改变了一个方法。这个方法的核心思路是定时获取图标的配置，然后更新配置，最后在设置配置。\nvar myChart = echarts.init(document.getElementById(\u0026#39;china-map\u0026#39;)); var COLORS = [\u0026#34;#070093\u0026#34;, \u0026#34;#1c3fbf\u0026#34;, \u0026#34;#1482e5\u0026#34;, \u0026#34;#70b4eb\u0026#34;, \u0026#34;#b4e0f3\u0026#34;, \u0026#34;#ffffff\u0026#34;]; // 指定图表的配置项和数据 var option = { tooltip: { trigger: \u0026#39;item\u0026#39;, formatter: \u0026#39;{b}\u0026#39; }, series: [ { name: \u0026#39;中国\u0026#39;, type: \u0026#39;map\u0026#39;, mapType: \u0026#39;china\u0026#39;, selectedMode : \u0026#39;single\u0026#39;, label: { normal: { show: true }, emphasis: { show: true } }, data:[ // 默认高亮安徽省 {name:\u0026#39;安徽\u0026#39;, selected:true} ], itemStyle: { normal: { areaColor: \u0026#39;rgba(255,255,255,0.5)\u0026#39;, color: \u0026#39;#000000\u0026#39;, shadowBlur: 200, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; }, emphasis:{ areaColor: \u0026#39;#3be2fb\u0026#39;, color: \u0026#39;#000000\u0026#39;, shadowBlur: 200, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); myChart.on(\u0026#39;click\u0026#39;, function(params) { console.log(params); }); setInterval(function(){ var op = myChart.getOption(); var data = op.series[0].data; var length = data.length; data.some(function(item, index){ if(item.selected){ item.selected = false; var next = (index + 1)%length; data[next].selected = true; return true; } }); myChart.setOption(op); }, 3000); 2. 后续补充 我从这里发现：https://github.com/ecomfe/echarts/issues/3282，选中地图的写法是这样的，而试了一下果然可以。主要是type要是mapSelect,而不是geoSelect\nmyChart.dispatchAction({ type: \u0026#39;mapSelect\u0026#39;, // 可选，系列 index，可以是一个数组指定多个系列 // seriesIndex: 0, // 可选，系列名称，可以是一个数组指定多个系列 // seriesName: string|Array, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 // dataIndex: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name: \u0026#39;河北\u0026#39; }); 3. 哪里去下载中国地图？ 官方示例里是没有中国地图的，不过你可以去github的官方仓库里找。地址是：https://github.com/apache/incubator-echarts/tree/master/map\n4. 地图学习的栗子哪里有？ 4.1. 先学习一下美国地图怎么玩吧 echarts官方文档上有美国地图的实例，地址：http://echarts.baidu.com/examples/editor.html?c=map-usa\n4.2. 我国地图也是有的，参考iphone销量这个栗子 地址：http://echarts.baidu.com/option.html#series-map, 注意：地图的相关文档在series-\u0026gt;type:map中\n","permalink":"https://wdd.js.org/posts/2018/echarts-highlight-china-map/","summary":"1. 小栗子 最早我是想通过dispatchAction方法去改变选中的省份，但是没有起作用，如果你知道这个方法怎么实现，麻烦你可以告诉我。 我实现的方法是另外一种。\ndispatchAction({ type: \u0026#39;geoSelect\u0026#39;, // 可选，系列 index，可以是一个数组指定多个系列 seriesIndex?: number|Array, // 可选，系列名称，可以是一个数组指定多个系列 seriesName?: string|Array, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 dataIndex?: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name?: string }) 后来我改变了一个方法。这个方法的核心思路是定时获取图标的配置，然后更新配置，最后在设置配置。\nvar myChart = echarts.init(document.getElementById(\u0026#39;china-map\u0026#39;)); var COLORS = [\u0026#34;#070093\u0026#34;, \u0026#34;#1c3fbf\u0026#34;, \u0026#34;#1482e5\u0026#34;, \u0026#34;#70b4eb\u0026#34;, \u0026#34;#b4e0f3\u0026#34;, \u0026#34;#ffffff\u0026#34;]; // 指定图表的配置项和数据 var option = { tooltip: { trigger: \u0026#39;item\u0026#39;, formatter: \u0026#39;{b}\u0026#39; }, series: [ { name: \u0026#39;中国\u0026#39;, type: \u0026#39;map\u0026#39;, mapType: \u0026#39;china\u0026#39;, selectedMode : \u0026#39;single\u0026#39;, label: { normal: { show: true }, emphasis: { show: true } }, data:[ // 默认高亮安徽省 {name:\u0026#39;安徽\u0026#39;, selected:true} ], itemStyle: { normal: { areaColor: \u0026#39;rgba(255,255,255,0.","title":"ECharts 轮流高亮中国地图各个省份"},{"content":"1. 使用[]或者list()创建列表 user = [] user = list() 2. 使用list() 可以将其他类型转换成列表 # 将字符串转成列表 \u0026gt;\u0026gt;\u0026gt; list(\u0026#39;abcde\u0026#39;) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] # 将元祖转成列表 \u0026gt;\u0026gt;\u0026gt; list((\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;)) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 3. 使用[offset]获取元素 或 修改元素 \u0026gt;\u0026gt;\u0026gt; users = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] # 可以使用整数来获取某个元素 \u0026gt;\u0026gt;\u0026gt; users[0] \u0026#39;a\u0026#39; # 可以使用负整数来表示从尾部获取某个元素 \u0026gt;\u0026gt;\u0026gt; users[-1] \u0026#39;e\u0026#39; # 数组越界会报错 \u0026gt;\u0026gt;\u0026gt; users[100] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range \u0026gt;\u0026gt;\u0026gt; users[-100] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range # 修改某个元素 \u0026gt;\u0026gt;\u0026gt; users[0] = \u0026#39;wdd\u0026#39; \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] \u0026gt;\u0026gt;\u0026gt; 4. 列表切片与提取元素 列表的切片或者提取之后仍然是一个列表 形式如：list[start:end:step]\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] # 正常截取 注意这里并不会截取到users[2] \u0026gt;\u0026gt;\u0026gt; users[0:2] [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;] # 也可从尾部截取 \u0026gt;\u0026gt;\u0026gt; users[0:-2] [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] # 这样可以获取所有的元素 \u0026gt;\u0026gt;\u0026gt; users[:] [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] # 也可以加上步长参数 \u0026gt;\u0026gt;\u0026gt; users[0:4:2] [\u0026#39;wdd\u0026#39;, \u0026#39;c\u0026#39;] # 也可以通过这种方式去将列表取反 \u0026gt;\u0026gt;\u0026gt; users[::-1] [\u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;wdd\u0026#39;] # 注意切片时，偏移量可以越界，越界之后不会报错，仍然按照界限来处理 例如开始偏移量如果小于0，那么仍然会按照0去计算。 \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users[-100:3] [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users[-100:100] [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] \u0026gt;\u0026gt;\u0026gt; 5. 使用append()添加元素至尾部 形式如：list.append(item)\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.append(\u0026#39;ddw\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;] 6. 使用extend()或+=合并列表 形式如：list1.extend(list2) 这两个方法都会直接修改原列表\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;] \u0026gt;\u0026gt;\u0026gt; names [\u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.extend(names) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users += names \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;] 7. 使用insert()在指定位置插入元素 形式如：list.insert(offset, item) insert也不存在越界的问题，偏移量正负都行，越界之后会自动伸缩到界限之内，并不会报错\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.insert(0,\u0026#39;xiaoxiao\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.insert(-1,\u0026#39;-xiaoxiao\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] # 下面-100肯定越界了 \u0026gt;\u0026gt;\u0026gt; users.insert(-100,\u0026#39;-xiaoxiao\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] # 下面100也是越界了 \u0026gt;\u0026gt;\u0026gt; users.insert(100,\u0026#39;-xiaoxiao\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] 8. 使用del删除某个元素 形式如：del list[offset] del是python的语句，而不是列表的方法，del删除不存在的元素时，也会提示越界\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] \u0026gt;\u0026gt;\u0026gt; del users[0] \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] \u0026gt;\u0026gt;\u0026gt; del users[100] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list assignment index out of range \u0026gt;\u0026gt;\u0026gt; del users[-100] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list assignment index out of range 9. 使用remove删除具有指定值的元素 形式如：list.remove(value)\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] # 删除指定值\u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; users.remove(\u0026#39;c\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] # 删除不存在的值会报错 \u0026gt;\u0026gt;\u0026gt; users.remove(\u0026#39;alsdkfjalsdf\u0026#39;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: list.remove(x): x not in list # 如果该值存在多个，那么只能删除到第一个 \u0026gt;\u0026gt;\u0026gt; users.remove(\u0026#39;haha\u0026#39;) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] 10. 使用pop()方式返回某个元素后，并在数组里删除它 形式如：list.pop(offset=-1) 偏移量默认等于-1，也就是删除最后的元素\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] # 删除最后的元素 \u0026gt;\u0026gt;\u0026gt; users.pop() \u0026#39;-xiaoxiao\u0026#39; \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;xiaoxiao\u0026#39;, \u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] # 如果列表本身就是空的，那么pop时会报错 \u0026gt;\u0026gt;\u0026gt; user.pop(0) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: pop from empty list \u0026gt;\u0026gt;\u0026gt; users.pop(0) \u0026#39;xiaoxiao\u0026#39; \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] # 越界时也会报错 \u0026gt;\u0026gt;\u0026gt; users.pop(100) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: pop index out of range 11. 使用index()查询具有特定值的元素位置 形式如：list.index(value)\n# index只会返回第一遇到该值得位置 \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.index(\u0026#39;heihei\u0026#39;) 5 # 如果该值不存在，也会报错 \u0026gt;\u0026gt;\u0026gt; users.index(\u0026#39;laksdf\u0026#39;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: \u0026#39;laksdf\u0026#39; is not in list 12. 使用in判断值是否存在列表 形式如：value in list\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;wdd\u0026#39; in users True 13. 使用count()记录特定值出现的次数 形式如：list.count(value)\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.count(\u0026#39;heihei\u0026#39;) 2 \u0026gt;\u0026gt;\u0026gt; users.count(\u0026#39;h\u0026#39;) 0 14. 使用join()将列表转为字符串 形式如：string.join(list)\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;,\u0026#39;.join(users) \u0026#39;wdd,b,d,e,ddw,heihei,heihei,-xiaoxiao,haha\u0026#39; \u0026gt;\u0026gt;\u0026gt; user [] \u0026gt;\u0026gt;\u0026gt; \u0026#39;,\u0026#39;.join(user) \u0026#39;\u0026#39; 15. 使用sort()重新排列列表元素 形式如：list.sort()\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;, \u0026#39;haha\u0026#39;] # 默认是升序排序 \u0026gt;\u0026gt;\u0026gt; users.sort() \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;wdd\u0026#39;] # 加入reverse=True, 可以降序排序 \u0026gt;\u0026gt;\u0026gt; users.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] # 通过匿名函数，传入函数进行自定义排序 \u0026gt;\u0026gt;\u0026gt; students [{\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;, \u0026#39;age\u0026#39;: 343}, {\u0026#39;name\u0026#39;: \u0026#39;ddw\u0026#39;, \u0026#39;age\u0026#39;: 43}, {\u0026#39;name\u0026#39;: \u0026#39;jik\u0026#39;, \u0026#39;age\u0026#39;: 90}] \u0026gt;\u0026gt;\u0026gt; students.sort(key=lambda item: item[\u0026#39;age\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; students [{\u0026#39;name\u0026#39;: \u0026#39;ddw\u0026#39;, \u0026#39;age\u0026#39;: 43}, {\u0026#39;name\u0026#39;: \u0026#39;jik\u0026#39;, \u0026#39;age\u0026#39;: 90}, {\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;, \u0026#39;age\u0026#39;: 343}] \u0026gt;\u0026gt;\u0026gt; students.sort(key=lambda item: item[\u0026#39;age\u0026#39;], reverse=True) \u0026gt;\u0026gt;\u0026gt; students [{\u0026#39;name\u0026#39;: \u0026#39;wdd\u0026#39;, \u0026#39;age\u0026#39;: 343}, {\u0026#39;name\u0026#39;: \u0026#39;jik\u0026#39;, \u0026#39;age\u0026#39;: 90}, {\u0026#39;name\u0026#39;: \u0026#39;ddw\u0026#39;, \u0026#39;age\u0026#39;: 43}] \u0026gt;\u0026gt;\u0026gt; 16. 使用reverse()将列表翻转 形式如：list.reverse()\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;-xiaoxiao\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users.reverse() \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;wdd\u0026#39;] 17. 使用copy()复制列表 形式如：list2 = list1.copy() list2 = list1 这种并不是列表的复制，只是给列表起了别名。实际上还是指向同一个值。\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;wdd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users2 = users.copy() \u0026gt;\u0026gt;\u0026gt; users2 [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;wdd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; 18. 使用clear()清空列表 形式如： list.clear()\n\u0026gt;\u0026gt;\u0026gt; users2 [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;wdd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; users2.clear() \u0026gt;\u0026gt;\u0026gt; users2 [] 19. 使用len()获取列表长度 形式如：len(list)\n\u0026gt;\u0026gt;\u0026gt; users [\u0026#39;-xiaoxiao\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;ddw\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;haha\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;heihei\u0026#39;, \u0026#39;wdd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; len(users) 9 20. 关于列表越界的深入思考 写了这些方法后，我有一些疑问，为什么有些操作会提示越界，有些则不会呢？\n会提示偏移量越界的操作有\nlist[offset] 读取或者修改某个元素 del list[offset] 删除指定位置的元素 list.remove(value) 删除指定值的元素 list.pop(offset) 删除指定位置的元素 如果偏移量越界，这些方法会报错的。我的个人理解是: 假如我想读取偏移量为10的元素，但是该元素并不存在，如果系统自动给你读取了列表的最后一个元素，而且不报错，这是无法容忍的bug。 如果我想删除第10个元素，但是第10个元素并不存在，而系统帮你删除了列表的最后一个元素，我觉得这也是无法容忍的。\n所以在使用这些方法时，务必确认该偏移量的元素是否存，否则可能会报错。\n","permalink":"https://wdd.js.org/posts/2018/python3-list-methods-collect/","summary":"1. 使用[]或者list()创建列表 user = [] user = list() 2. 使用list() 可以将其他类型转换成列表 # 将字符串转成列表 \u0026gt;\u0026gt;\u0026gt; list(\u0026#39;abcde\u0026#39;) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] # 将元祖转成列表 \u0026gt;\u0026gt;\u0026gt; list((\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;)) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 3. 使用[offset]获取元素 或 修改元素 \u0026gt;\u0026gt;\u0026gt; users = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] # 可以使用整数来获取某个元素 \u0026gt;\u0026gt;\u0026gt; users[0] \u0026#39;a\u0026#39; # 可以使用负整数来表示从尾部获取某个元素 \u0026gt;\u0026gt;\u0026gt; users[-1] \u0026#39;e\u0026#39; # 数组越界会报错 \u0026gt;\u0026gt;\u0026gt; users[100] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range \u0026gt;\u0026gt;\u0026gt; users[-100] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range # 修改某个元素 \u0026gt;\u0026gt;\u0026gt; users[0] = \u0026#39;wdd\u0026#39; \u0026gt;\u0026gt;\u0026gt; users [\u0026#39;wdd\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] \u0026gt;\u0026gt;\u0026gt; 4.","title":"Python3笔记 列表方法详解"},{"content":"1. 问题1：chosen插件无法显示图标 问题现象 在我本地调试的时候，我使用了一个多选下拉框的插件，就是chosen, 不知道为什么，这个多选框上面的图标不见了。我找了半天没有找到原因，然后我把我的机器的内网地址给我同事，让他访问我机器，当它访问到这个页面时。他的电脑上居然显示出了这个下拉框的图标。\n这是什么鬼？, 为什么同样的代码，在我的电脑上显示不出图标，但是在他的电脑上可以显示。有句名言说的好：没有什么bug是一遍调试解决不了的，如果有，就再仔细调试一遍。于是我就再次调试一遍。\n我发现了一些第一遍没有注意到的东西媒体查询，就是在css里有这样的语句：\n@media 从这里作为切入口，我发现：媒体查询的类会覆盖它原生的类的属性\n由于我的电脑视网膜屏幕，分辨率比较高，触发了媒体查询，这就导致了媒体查询的类覆盖了原生的类。而覆盖后的类，使用了chosen-sprite@2x.png作为图标的背景图片。但是这个图片并没有被放在这个插件的目录下，有的只有chosen-sprite.png这个图片。在一般情况下，都是用chosen-sprite.png作为背景图片的。这就解释了：为什么同事的电脑上出现了图标，但是我的电脑上没有出现这个图标。\n总结: 如果你要使用一个插件，你最好把这个插件的所有文件都放在同一个目录下。而不要只放一些你认为有用的文件。最后：媒体查询的相关知识也是必要的。\n2. 问题2：jQuery 与 Vue之间的暧昧 jQuery流派代表着直接操纵DOM的流派，Vue流派代表着操纵数据的流派。\n如果在项目里，你使用了一些jQuery插件，也使用了Vue，这就可能导致一些问题。\n举个例子：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.4.4/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 姓名 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;userName\u0026#34;\u0026gt; \u0026lt;br/\u0026gt; 年龄 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;userAge\u0026#34; v-model=\u0026#34;userAge\u0026#34;\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { userName: \u0026#39;\u0026#39;, userAge: 12 } }); $(\u0026#39;#userAge\u0026#39;).val(14); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在页面刚打开时：姓名输入框是空的，年龄输入框是14。但是一旦你在姓名输入框输入任何字符时，年龄输入框的值就会变成12。\n如果你仔细看过Vue官方文档，你会很容易定位问题所在。\nv-model 会忽略所有表单元素的 value、checked、selected 特性的初始值。因为它会选择 Vue 实例数据来作为具体的值。你应该通过 JavaScript 在组件的 data 选项中声明初始值。---Vue官方文档 你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。\n当userAge被jQuery改成14时，Vue实例中的userAge任然是12。当你输入userName时，Vue发现数据改变，触发虚拟DOM的重新渲染，同时也将userAge渲染成了12。\n总结：如果你在Vue项目中逼不得已使用jQuery, 你要知道这会导致哪些常见的问题，以及解决思路。\n3. 最后 我苦苦寻找诡异的bug原因，其实是我的无知。\n","permalink":"https://wdd.js.org/posts/2018/real-reason-of-my-bugs/","summary":"1. 问题1：chosen插件无法显示图标 问题现象 在我本地调试的时候，我使用了一个多选下拉框的插件，就是chosen, 不知道为什么，这个多选框上面的图标不见了。我找了半天没有找到原因，然后我把我的机器的内网地址给我同事，让他访问我机器，当它访问到这个页面时。他的电脑上居然显示出了这个下拉框的图标。\n这是什么鬼？, 为什么同样的代码，在我的电脑上显示不出图标，但是在他的电脑上可以显示。有句名言说的好：没有什么bug是一遍调试解决不了的，如果有，就再仔细调试一遍。于是我就再次调试一遍。\n我发现了一些第一遍没有注意到的东西媒体查询，就是在css里有这样的语句：\n@media 从这里作为切入口，我发现：媒体查询的类会覆盖它原生的类的属性\n由于我的电脑视网膜屏幕，分辨率比较高，触发了媒体查询，这就导致了媒体查询的类覆盖了原生的类。而覆盖后的类，使用了chosen-sprite@2x.png作为图标的背景图片。但是这个图片并没有被放在这个插件的目录下，有的只有chosen-sprite.png这个图片。在一般情况下，都是用chosen-sprite.png作为背景图片的。这就解释了：为什么同事的电脑上出现了图标，但是我的电脑上没有出现这个图标。\n总结: 如果你要使用一个插件，你最好把这个插件的所有文件都放在同一个目录下。而不要只放一些你认为有用的文件。最后：媒体查询的相关知识也是必要的。\n2. 问题2：jQuery 与 Vue之间的暧昧 jQuery流派代表着直接操纵DOM的流派，Vue流派代表着操纵数据的流派。\n如果在项目里，你使用了一些jQuery插件，也使用了Vue，这就可能导致一些问题。\n举个例子：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.4.4/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 姓名 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;userName\u0026#34;\u0026gt; \u0026lt;br/\u0026gt; 年龄 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;userAge\u0026#34; v-model=\u0026#34;userAge\u0026#34;\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { userName: \u0026#39;\u0026#39;, userAge: 12 } }); $(\u0026#39;#userAge\u0026#39;).val(14); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在页面刚打开时：姓名输入框是空的，年龄输入框是14。但是一旦你在姓名输入框输入任何字符时，年龄输入框的值就会变成12。\n如果你仔细看过Vue官方文档，你会很容易定位问题所在。\nv-model 会忽略所有表单元素的 value、checked、selected 特性的初始值。因为它会选择 Vue 实例数据来作为具体的值。你应该通过 JavaScript 在组件的 data 选项中声明初始值。---Vue官方文档 你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。","title":"我苦苦寻找诡异的bug原因，其实是我的无知"},{"content":"简易服务器：在命令执行的所在路径启动一个http服务器，然后你可以通过浏览器访问该路径下的所有文件。\n在局域网内传文件，或者自己测试使用都是非常方便的。\n1. 基于python 1.1. 基于Python2 python -m SimpleHTTPServer port\n\u0026gt; python -m SimpleHTTPServer 8099 Serving HTTP on 0.0.0.0 port 8099 ... 127.0.0.1 - - [24/Oct/2017 11:07:56] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 1.2. 基于python3 python3 -m http.server port\n\u0026gt; python3 -m http.server 8099 Serving HTTP on 0.0.0.0 port 8099 (http://0.0.0.0:8099/) ... 127.0.0.1 - - [24/Oct/2017 11:05:06] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 127.0.0.1 - - [24/Oct/2017 11:05:06] code 404, message File not found 127.0.0.1 - - [24/Oct/2017 11:05:06] \u0026#34;GET /favicon.ico HTTP/1.1\u0026#34; 404 - 2. 基于nodejs 首先你要安装nodejs 2.1. http-server // 安装 npm install http-server -g // 用法 http-server [path] [options] 2.2. serve // 安装 npm install -g serve // 用法 serve [options] \u0026lt;path\u0026gt; 2.3. webpack-dev-server // 安装 npm install webpack-dev-server -g // 用法 webpack-dev-server 2.4. anywhere // 安装 npm install -g anywhere // 用法 anywhere anywhere -p port 2.5. puer // 安装 npm -g install puer // 使用 puer - 提供一个当前或指定路径的静态服务器 - 所有浏览器的实时刷新：编辑css实时更新(update)页面样式，其它文件则重载(reload)页面 - 提供简单熟悉的mock请求的配置功能，并且配置也是自动更新。 - 可用作代理服务器，调试开发既有服务器的页面，可与mock功能配合使用 - 集成了weinre，并提供二维码地址，方便移动端的调试 - 可以作为connect中间件使用(前提是后端为nodejs，否则请使用代理模式) ","permalink":"https://wdd.js.org/posts/2018/one-command-create-static-file-server/","summary":"简易服务器：在命令执行的所在路径启动一个http服务器，然后你可以通过浏览器访问该路径下的所有文件。\n在局域网内传文件，或者自己测试使用都是非常方便的。\n1. 基于python 1.1. 基于Python2 python -m SimpleHTTPServer port\n\u0026gt; python -m SimpleHTTPServer 8099 Serving HTTP on 0.0.0.0 port 8099 ... 127.0.0.1 - - [24/Oct/2017 11:07:56] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 1.2. 基于python3 python3 -m http.server port\n\u0026gt; python3 -m http.server 8099 Serving HTTP on 0.0.0.0 port 8099 (http://0.0.0.0:8099/) ... 127.0.0.1 - - [24/Oct/2017 11:05:06] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 127.0.0.1 - - [24/Oct/2017 11:05:06] code 404, message File not found 127.","title":"一行命令搭建简易静态文件http服务器"},{"content":"原文地址 git地址\n1. 基础工具 accounting.js async axios chance date-fns format.js immutable is.js lodash Math.js Moment.js Numeral.js string.js underscore.js voca wait xregexp.com 2. 编译 / 类型检查 Babel TypeScript Flow 3. 代码分析引擎 Tern 4. JavaScript兼容性检查器 jscc.info/ 5. Linting/ Hinting \u0026amp; Style Linter eslint 6. 单元测试 AVA Jasmine Mocha Tape 7. 单元测试断言库 Chai expect.js should.js 8. 单元测试数据模拟 sinon.js Kakapo.js mockjs 9. E2E测试 puppeteer 10. 代码格式化 / 整洁 esformatter js-beautify jsfmt prettier 11. 性能测试 benchmark.js jsperf.co 12. 可视化，静态分析，复杂性，覆盖工具 Coveralls Esprima istanbul 13. 优化 UglifyJS 2 optimize-js 14. 混淆 Javascript Obfuscator JScrambler 15. 可共享/可运行的代码编辑器 es6fiddle.net jsbin.com jsfiddle.net 16. 在线正则表达式编辑器/可视化工具 debuggex regex101 regexper RegExr 17. 创作公约工具 Airbnb\u0026rsquo;s ESLint config, following our styleguide Standard - ESLint Shareable Config 18. json可视化 jsonviewernew 19. 代码可视化 lambda-view 20. 静态文件服务器 http-server serve anywhere puer ","permalink":"https://wdd.js.org/posts/2018/top-javascript-tools-in-2017/","summary":"原文地址 git地址\n1. 基础工具 accounting.js async axios chance date-fns format.js immutable is.js lodash Math.js Moment.js Numeral.js string.js underscore.js voca wait xregexp.com 2. 编译 / 类型检查 Babel TypeScript Flow 3. 代码分析引擎 Tern 4. JavaScript兼容性检查器 jscc.info/ 5. Linting/ Hinting \u0026amp; Style Linter eslint 6. 单元测试 AVA Jasmine Mocha Tape 7. 单元测试断言库 Chai expect.js should.js 8. 单元测试数据模拟 sinon.js Kakapo.js mockjs 9. E2E测试 puppeteer 10. 代码格式化 / 整洁 esformatter js-beautify jsfmt prettier 11. 性能测试 benchmark.","title":"top-javascript-tools-in-2017"},{"content":" 本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。\n本栗子的地址 本栗子的pages地址\n因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的\n1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone(\u0026#39;87fYv4ncOoa0Cjne\u0026#39;); // 房间名必须以 \u0026#39;observable-\u0026#39;开头 var roomName = \u0026#39;observable-\u0026#39; + roomHash; var configuration = { iceServers: [{ urls: \u0026#39;stun:stun.l.google.com:19302\u0026#39; // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console.error(error); } drone.on(\u0026#39;open\u0026#39;, function(error){ if (error) { return console.error(error);} room = drone.subscribe(roomName); room.on(\u0026#39;open\u0026#39;, function(error){ if (error) {onError(error);} }); // 已经链接到房间后，就会收到一个 members 数组，代表房间里的成员 // 这时候信令服务已经就绪 room.on(\u0026#39;members\u0026#39;, function(members){ console.log(\u0026#39;MEMBERS\u0026#39;, members); // 如果你是第二个链接到房间的人，就会创建offer var isOfferer = members.length === 2; startWebRTC(isOfferer); }); }); // 通过Scaledrone发送信令消息 function sendMessage(message) { drone.publish({ room: roomName, message }); } function startWebRTC(isOfferer) { pc = new RTCPeerConnection(configuration); // 当本地ICE Agent需要通过信号服务器发送信息到其他端时 // 会触发icecandidate事件回调 pc.onicecandidate = function(event){ if (event.candidate) { sendMessage({ \u0026#39;candidate\u0026#39;: event.candidate }); } }; // 如果用户是第二个进入的人，就在negotiationneeded 事件后创建sdp if (isOfferer) { // onnegotiationneeded 在要求sesssion协商时发生 pc.onnegotiationneeded = function() { // 创建本地sdp描述 SDP (Session Description Protocol) session描述协议 pc.createOffer().then(localDescCreated).catch(onError); }; } // 当远程数据流到达时，将数据流装载到video中 pc.onaddstream = function(event){ remoteVideo.srcObject = event.stream; }; // 获取本地媒体流 navigator.mediaDevices.getUserMedia({ audio: true, video: true, }).then( function(stream) { // 将本地捕获的视频流装载到本地video中 localVideo.srcObject = stream; // 将本地流加入RTCPeerConnection 实例中 发送到其他端 pc.addStream(stream); }, onError); // 从Scaledrone监听信令数据 room.on(\u0026#39;data\u0026#39;, function(message, client){ // 消息是我自己发送的，则不处理 if (client.id === drone.clientId) { return; } if (message.sdp) { // 设置远程sdp, 在offer 或者 answer后 pc.setRemoteDescription(new RTCSessionDescription(message.sdp), function(){ // 当收到offer 后就接听 if (pc.remoteDescription.type === \u0026#39;offer\u0026#39;) { pc.createAnswer().then(localDescCreated).catch(onError); } }, onError); } else if (message.candidate) { // 增加新的 ICE canidatet 到本地的链接中 pc.addIceCandidate( new RTCIceCandidate(message.candidate), onSuccess, onError ); } }); } function localDescCreated(desc) { pc.setLocalDescription(desc, function(){ sendMessage({ \u0026#39;sdp\u0026#39;: pc.localDescription }); },onError); } 5. WebRTC简介 5.1. 介绍 WebRTC 是一个开源项目，用于Web浏览器之间进行实时音频视频通讯，数据传递。 WebRTC有几个JavaScript APIS。 点击链接去查看demo。\ngetUserMedia(): 捕获音频视频 MediaRecorder: 记录音频视频 RTCPeerConnection: 在用户之间传递音频流和视频流 RTCDataChannel: 在用户之间传递文件流 5.2. 在哪里使用WebRTC? Chrome FireFox Opera Android iOS 5.3. 什么是信令 WebRTC使用RTCPeerConnection在浏览器之间传递流数据, 但是也需要一种机制去协调收发控制信息，这就是信令。信令的方法和协议并不是在WebRTC中明文规定的。 在codelad中用的是Node，也有许多其他的方法。\n5.4. 什么是STUN和TURN和ICE? STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 wikipedia STUN\nTURN（全名Traversal Using Relay NAT, NAT中继穿透），是一种资料传输协议（data-transfer protocol）。允许在TCP或UDP的连线上跨越NAT或防火墙。 TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过取得应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通讯开始前与TURN server进行交互，并要求TURN server产生\u0026quot;relay port\u0026quot;，也就是relayed-transport-address。这时TURN server会建立peer，即远端端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将资料传送至peer，再由peer转传到另一方的TURN client。wikipedia TURN\nICE （Interactive Connectivity Establishment，互动式连接建立 ），一种综合性的NAT穿越的技术。 互动式连接建立是由IETF的MMUSIC工作组开发出来的一种framework，可整合各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。[wikipedia ICE]\nWebRTC被设计用于点对点之间工作，因此用户可以通过最直接的途径连接。然而，WebRTC的构建是为了应付现实中的网络: 客户端应用程序需要穿越NAT网关和防火墙，并且对等网络需要在直接连接失败的情况下进行回调。 作为这个过程的一部分，WebRTC api使用STUN服务器来获取计算机的IP地址，并将服务器作为中继服务器运行，以防止对等通信失败。(现实世界中的WebRTC更详细地解释了这一点。)\n5.5. WebRTC是否安全? WebRTC组件是强制要求加密的，并且它的JavaScript APIS只能在安全的域下使用(HTTPS 或者 localhost)。信令机制并没有被WebRTC标准定义，所以是否使用安全的协议就取决于你自己了。\n6. WebRTC 参考资料 官网教程\nWebRTC 简单的视频聊天 repo\nWebRTC 教程\nMDN WebRTC API\n谷歌codelab WebRT教程\ngithub上WebRTC各种例子\nsegemntfault上关于WebRTC的教程\n","permalink":"https://wdd.js.org/posts/2018/webrtc-tutorial-simple-video-chat/","summary":"本例子是参考webrtc-tutorial-simple-video-chat做的。 这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。\n本栗子的地址 本栗子的pages地址\n因为使用的是ScaleDrone的js sdk, 后期很可能服务不稳定之类的\n1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处 4. 源码分析 // 产生随机数 if (!location.hash) { location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16); } // 获取房间号 var roomHash = location.hash.substring(1); // 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel // 你也可以自己创建 var drone = new ScaleDrone(\u0026#39;87fYv4ncOoa0Cjne\u0026#39;); // 房间名必须以 \u0026#39;observable-\u0026#39;开头 var roomName = \u0026#39;observable-\u0026#39; + roomHash; var configuration = { iceServers: [{ urls: \u0026#39;stun:stun.l.google.com:19302\u0026#39; // 使用谷歌的stun服务 }] }; var room; var pc; function onSuccess() {} function onError(error) { console.","title":"120行代码实现 浏览器WebRTC视频聊天"},{"content":" 本文来自于公司内部的一个分享。 在文档方面，对内的一些接口文档主要是用swagger来写的。虽然可以在线测试，比较方便。但是也存在着一些更新不及时，swgger文档无法导出成文件的问题。 在对外提供的文档方面：我主要负责做一个浏览器端的一个js sdk。文档还算可以github地址，所以想把一些写文档的心得分享给大家。\n1. 衡量好文档的唯一标准是什么？ Martin(Bob大叔)曾在《代码整洁之道》一书打趣地说：当你的代码在做 Code Review 时，审查者要是愤怒地吼道：\n“What the fuck is this shit?” “Dude, What the fuck！” 等言辞激烈的词语时，那说明你写的代码是 Bad Code，如果审查者只是漫不经心的吐出几个\n“What the fuck?”，\n那说明你写的是 Good Code。衡量代码质量的唯一标准就是每分钟骂出“WTF” 的频率。\n衡量文档的标准也是如此。\n2. 好文档的特点 简洁：一句话可以说完的事情，就不要分两句话来说。并不是文档越厚越好，太厚的文档大多没人看。 准确: 字段类型，默认值，备注，是否必填等属性说明。 逻辑性: 文档如何划分？ 利于查看。 demo胜千言: 好的demo胜过各种字段说明，可以复制下来直接使用。 读者心: 从读者的角度考虑, 方法尽量简洁。可以传递一个参数搞定的事情，绝对不要让用户去传两个参数。 及时更新: 不更新的文档比bug更严重。 向后兼容: 不要随意废弃已有的接口或者某个字段，除非你考虑到这样做的后果。 建立文档词汇表：每个概念只有一个名字，不要随意起名字，名不正则言不顺。 格式统一：例如时间格式。我曾见过2017-09-12 09:32:23, 或2017.09.12 09:32:23或2017.09.12 09:32:23。变量名user_name, userName。 使用专业词语：不要过于口语化 3. 总结: 写出好文档要有以下四点 逻辑性：便于查找 专业性: 值得信赖，质量保证 责任心：及时更新，准确性，向后兼容 读者心：你了解的东西，别人可能并不清楚。从读者的角度去考虑，他们需要什么，而不是一味去强调你能提供什么。 4. 写文档的工具 markdown: 方便快捷，可以导出各种格式的文件 swagger: 功能强大，需要部署，不方便传递文件 5. markdown 工具推荐 蚂蚁笔记 这是我正使用的。 全平台（mac windows ios）有客户端，和浏览器端 笔记可以直接公布为博客 支持独立域名 标签很好用 支持思维导图 支持历史记录 cmd-markdown 有道云笔记 6. 文档之外 公司有个同事，我曾问他使用什么搜索一些技术文档，他说用百度。作为一个翻墙老司机，我惊诧的问他：你为什么不用谷歌去搜索。他说他不会翻墙。我只能呵呵一笑。\n自从有一次搜索：graph for x^8 + y^8，我就决定不再使用百度了。你可以看一下两者的返回结果有什么不同。\n总之：有些鸟儿是关不住的 他们的羽毛太鲜亮了。\n","permalink":"https://wdd.js.org/posts/2018/how-to-write-a-technical-document/","summary":"本文来自于公司内部的一个分享。 在文档方面，对内的一些接口文档主要是用swagger来写的。虽然可以在线测试，比较方便。但是也存在着一些更新不及时，swgger文档无法导出成文件的问题。 在对外提供的文档方面：我主要负责做一个浏览器端的一个js sdk。文档还算可以github地址，所以想把一些写文档的心得分享给大家。\n1. 衡量好文档的唯一标准是什么？ Martin(Bob大叔)曾在《代码整洁之道》一书打趣地说：当你的代码在做 Code Review 时，审查者要是愤怒地吼道：\n“What the fuck is this shit?” “Dude, What the fuck！” 等言辞激烈的词语时，那说明你写的代码是 Bad Code，如果审查者只是漫不经心的吐出几个\n“What the fuck?”，\n那说明你写的是 Good Code。衡量代码质量的唯一标准就是每分钟骂出“WTF” 的频率。\n衡量文档的标准也是如此。\n2. 好文档的特点 简洁：一句话可以说完的事情，就不要分两句话来说。并不是文档越厚越好，太厚的文档大多没人看。 准确: 字段类型，默认值，备注，是否必填等属性说明。 逻辑性: 文档如何划分？ 利于查看。 demo胜千言: 好的demo胜过各种字段说明，可以复制下来直接使用。 读者心: 从读者的角度考虑, 方法尽量简洁。可以传递一个参数搞定的事情，绝对不要让用户去传两个参数。 及时更新: 不更新的文档比bug更严重。 向后兼容: 不要随意废弃已有的接口或者某个字段，除非你考虑到这样做的后果。 建立文档词汇表：每个概念只有一个名字，不要随意起名字，名不正则言不顺。 格式统一：例如时间格式。我曾见过2017-09-12 09:32:23, 或2017.09.12 09:32:23或2017.09.12 09:32:23。变量名user_name, userName。 使用专业词语：不要过于口语化 3. 总结: 写出好文档要有以下四点 逻辑性：便于查找 专业性: 值得信赖，质量保证 责任心：及时更新，准确性，向后兼容 读者心：你了解的东西，别人可能并不清楚。从读者的角度去考虑，他们需要什么，而不是一味去强调你能提供什么。 4. 写文档的工具 markdown: 方便快捷，可以导出各种格式的文件 swagger: 功能强大，需要部署，不方便传递文件 5.","title":"如何写好技术文档?"},{"content":" 做完这个demo后，你会体会到，Vue组件化，webpack, Vue-router等，并不是很难学习，你需要的只是拿起斧头的勇气\n在做demo的过程中，我遇到一个问题，就是vue-router懒加载一直实现不了，纠结了半天。后来回到原点，去vue-route官网看文档，发现是因为syntax-dynamic-import插件没有安装。\n所以说：你以为的bug, 实际上是你没看透文档\n初次学习这个教程，你不需要有任何担忧某些东西不会，你也不需要写任何代码。因为基本上所有代码都是从element官网上拷贝的，你所做的只是把他们组装在一起罢了。\n在线预览 仓库地址：https://github.com/wangduanduan/vue-el-dashboard\n效果图： 使用到的技术：\nVue Vue-router Element-ui webpack Normalize.css vue-awesome babel 1. vue-cli 安装模板 ➜ vue-el-dashboard git:(master) vue init webpack ? Generate project in current directory? Yes ? Project name vue-el-dashboard ? Project description A Vue.js project ? Author wangdd \u0026lt;wangdd@welljoint.com\u0026gt; ? Vue build standalone ? Install vue-router? Yes ? Use ESLint to lint your code? Yes ? Pick an ESLint preset Standard ? Setup unit tests No ? Setup e2e tests with Nightwatch? No vue-cli · Generated \u0026#34;vue-el-dashboard\u0026#34;. To get started: npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 2. 安装依赖并运行 ➜ vue-el-dashboard git:(master) ✗ cnpm i ✔ Installed 44 packages ✔ Linked 680 latest versions ➜ npm run dev 浏览器打开如下页面:\n3. 安装初始化页面布局 安装并使用Element UI\ncnpm i element-ui -S 修改 /src/main.js 为：\nimport Vue from \u0026#39;vue\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39; import App from \u0026#39;./App\u0026#39; Vue.config.productionTip = false Vue.use(ElementUI) /* eslint-disable no-new */ new Vue({ el: \u0026#39;#app\u0026#39;, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, components: { App } }) 我需要的布局是这种： 在 Element 上复制对应的代码, 并粘贴到 /src/App.vue文件中：\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt;Header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;Aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;app\u0026#39; } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 不出意外的话，你可以在浏览器上看到如下布局： 现在，布局就这么成了。\n4. 安装侧边菜单栏 我需要侧边栏是下图右边的自定义颜色的那种菜单 在components文件夹下新建NavMenu.vue\n\u0026lt;template\u0026gt; \u0026lt;el-row class=\u0026#34;tac\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;默认颜色\u0026lt;/h5\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleOpen\u0026#34; @close=\u0026#34;handleClose\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航一\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;分组一\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-menu-item-group title=\u0026#34;分组2\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-submenu index=\u0026#34;1-4\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;选项4\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航二\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-setting\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航三\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;自定义颜色\u0026lt;/h5\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleOpen\u0026#34; @close=\u0026#34;handleClose\u0026#34; background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航一\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;分组一\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-menu-item-group title=\u0026#34;分组2\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-submenu index=\u0026#34;1-4\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;选项4\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航二\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-setting\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航三\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleOpen(key, keyPath) { console.log(key, keyPath); }, handleClose(key, keyPath) { console.log(key, keyPath); } } } \u0026lt;/script\u0026gt; 然后将NavMenu组件导入到App.vue中, 修改App.vue：\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt;Header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;navmenu\u0026gt;\u0026lt;/navmenu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import NavMenu from \u0026#39;@/components/NavMenu\u0026#39; export default { name: \u0026#39;app\u0026#39;, components: { \u0026#39;navmenu\u0026#39;: NavMenu } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 这里要解释一下这条语句, 该语句中的@, 符号是什么意思？\nimport NavMenu from \u0026#39;@/components/NavMenu\u0026#39; 在build/webpack.base.conf.js中有如下代码, alias就是起别名，@符号就是代表src路径， 所以@/components/NavMenu就是src/components/NavMenu。 这样webpack就知道如何引入文件了。这样做的好处是不必到处去写src了。\nresolve: { extensions: [\u0026#39;.js\u0026#39;, \u0026#39;.vue\u0026#39;, \u0026#39;.json\u0026#39;], alias: { \u0026#39;vue$\u0026#39;: \u0026#39;vue/dist/vue.esm.js\u0026#39;, \u0026#39;@\u0026#39;: resolve(\u0026#39;src\u0026#39;), } }, 现在打开浏览器，应该可以看到如下界面： 可以看到菜单已经引入进来了，但是是两个菜单，下面我们需要修改一下，只要右边的菜单，并删除一些多余的元素。 修改NavMenu.vue文件。\n\u0026lt;template\u0026gt; \u0026lt;el-row class=\u0026#34;tac\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleOpen\u0026#34; @close=\u0026#34;handleClose\u0026#34; unique-opened router background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航一\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4\u0026#34;\u0026gt;选项4\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-submenu index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航二\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4\u0026#34;\u0026gt;选项4\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleOpen(key, keyPath) { console.log(key, keyPath) }, handleClose(key, keyPath) { console.log(key, keyPath) } } } \u0026lt;/script\u0026gt; 现在打开浏览器看看： 点击展开菜单看看： 5. 侧边菜单栏进阶 我们需要的功能：\n每次只能展开一个一级菜单 每次点击一个二级菜单可以自动改变路由，跳转到对应的组件 由于菜单在路由中也会使用，所以最好抽象出来，做成一个配置文件 第1点和第二点比较好搞，Element上已经有配置文档:\nunique-opened: 是否只保持一个子菜单的展开 router: 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转 修改NavMenu.vue\n\u0026lt;template\u0026gt; \u0026lt;el-row class=\u0026#34;tac\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleOpen\u0026#34; @close=\u0026#34;handleClose\u0026#34; unique-opened router background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航一\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4\u0026#34;\u0026gt;选项4\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-submenu index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航二\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4\u0026#34;\u0026gt;选项4\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleOpen (key, keyPath) { console.log(key, keyPath) }, handleClose (key, keyPath) { console.log(key, keyPath) } } } \u0026lt;/script\u0026gt; 打开浏览器，点击一个二级菜单看看，你会发现，效果并不像预期那样，而且控制台还向你扔出一个bug： 添加一个暂时的路由: 修改main.js\nimport Vue from \u0026#39;vue\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39; import App from \u0026#39;./App\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false Vue.use(ElementUI) /* eslint-disable no-new */ new Vue({ el: \u0026#39;#app\u0026#39;, router, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, components: { App } }) 打开浏览器，点击一个二级菜单，这时候没有报错，浏览器的路径也变了, 变成http://localhost:8080/#/1-3 每次增加一个菜单都要写点html是不能忍的，能用js的，就别用html。\n在src目录下创建一个config目录，目录下创建一个menu-config.js 文件： 外层的数组代表一级菜单，内层sub数组代表二级菜单。\nmodule.exports = [{ name: \u0026#39;基础\u0026#39;, id: \u0026#39;basic\u0026#39;, sub: [{ name: \u0026#39;Layout 布局\u0026#39;, componentName: \u0026#39;BasicLayout\u0026#39; }, { name: \u0026#39;Container 布局容器\u0026#39;, componentName: \u0026#39;BasicContainer\u0026#39; }] }, { name: \u0026#39;Form\u0026#39;, id: \u0026#39;form\u0026#39;, sub: [{ name: \u0026#39;Radio 单选框\u0026#39;, componentName: \u0026#39;FormRadio\u0026#39; }, { name: \u0026#39;Checkbox 多选框\u0026#39;, componentName: \u0026#39;FormCheckbox\u0026#39; }] }] 在NavMenu.vue中引入这个文件，并使用v-for循环去渲染这个菜单：\n\u0026lt;template\u0026gt; \u0026lt;el-row class=\u0026#34;tac\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;el-menu class=\u0026#34;el-menu-vertical-demo\u0026#34; router unique-opened @open=\u0026#34;handleOpen\u0026#34; @close=\u0026#34;handleClose\u0026#34; background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-submenu v-for=\u0026#34;item in menu\u0026#34; :index=\u0026#34;item.id\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;span v-text=\u0026#34;item.name\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group class=\u0026#34;over-hide\u0026#34; v-for=\u0026#34;sub in item.sub\u0026#34; :key=\u0026#34;sub.componentName\u0026#34;\u0026gt; \u0026lt;el-menu-item :index=\u0026#34;sub.componentName\u0026#34; v-text=\u0026#34;sub.name\u0026#34;\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; .over-hide{ overflow: hidden; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import menu from \u0026#39;@/config/menu-config\u0026#39; export default { data () { return { menu: menu } }, methods: { handleOpen (key, keyPath) { console.log(key, keyPath) }, handleClose (key, keyPath) { console.log(key, keyPath) } } } \u0026lt;/script\u0026gt; 这里要说明一下，我给二级菜单加上了over-hide类，二级菜单在展开时，有点溢出父元素了。 打开浏览器看看, 这时候菜单已经是根据配置文件渲染的了。\n6. 先加个头部吧，秃顶太丑了 在componets文件夹下创建一个Header.vue, 并在App.vue中引入，\nHeader.vue\n\u0026lt;template\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34; \u0026lt;div class=\u0026#34;head-wrap\u0026#34;\u0026gt;Element\u0026lt;/div\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; .head-wrap{ } \u0026lt;/style\u0026gt; App.vue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;vheader /\u0026gt; \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;navmenu\u0026gt;\u0026lt;/navmenu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import NavMenu from \u0026#39;@/components/NavMenu\u0026#39; import Header from \u0026#39;@/components/Header\u0026#39; export default { name: \u0026#39;app\u0026#39;, components: { \u0026#39;navmenu\u0026#39;: NavMenu, \u0026#39;vheader\u0026#39;: Header } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .header { background-color: #409EFF; color: #fff; line-height: 60px; } \u0026lt;/style\u0026gt; 这时候打开浏览器看看, 是不是已经好看一点了。但是body有边框，不好看啊！ 再次美化\n使用css reset Normalize.css 使用font-awesome vue-awesome图标库 安装Normalize.css, vue-awesome\ncnpm i normalize.css -D cnpm i vue-awesome -D 这里主要贴一下main.js的改动，其他的代码就不贴了：\nimport Vue from \u0026#39;vue\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39; import NormailizeCss from \u0026#39;normalize.css\u0026#39; import \u0026#39;vue-awesome/icons\u0026#39; import Icon from \u0026#39;vue-awesome/components/Icon\u0026#39; import App from \u0026#39;./App\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false Vue.use(ElementUI) Vue.component(\u0026#39;icon\u0026#39;, Icon) /* eslint-disable no-new */ new Vue({ el: \u0026#39;#app\u0026#39;, router, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, components: { App } }) 看下效果, 图标什么的都有了。 7. 组件路由与懒加载 在components新增四个文件：\nBasicContainer.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 这是：Container 布局容器 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; BasicLayout.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 这是：Layout 布局 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; FormCheckbox.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 这是：Checkbox 多选框 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; FormRadio.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 这是：Radio 单选框 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 修改route/index.js文件, 关于路由和懒加载就不在此赘述，任何文档都没有官方文档说的好。\n注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。 也就是说，你要先安装syntax-dynamic-import, 不然懒加载根本不行。\ncnpm install --save-dev babel-plugin-syntax-dynamic-import import Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import menus from \u0026#39;@/config/menu-config\u0026#39; Vue.use(Router) var routes = [] menus.forEach((item) =\u0026gt; { item.sub.forEach((sub) =\u0026gt; { routes.push({ path: `/${sub.componentName}`, name: sub.componentName, component: () =\u0026gt; import(`@/components/${sub.componentName}`) }) }) }) export default new Router({ routes }) 另外App.vue文件需要加上 router-view\n\u0026lt;el-main\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/el-main\u0026gt; 看看效果：点击菜单，路径跳转，并且每次都是单独去加载路由的文件。\n8. github 部署 如果你想在github上部署，那么你要修改config/index.js的以下代码, 不然有些文件因为路径问题可能会找不到。\nbuild: { // Template for index.html index: path.resolve(__dirname, \u0026#39;../docs/index.html\u0026#39;), // Paths assetsRoot: path.resolve(__dirname, \u0026#39;../docs\u0026#39;), assetsSubDirectory: \u0026#39;static\u0026#39;, assetsPublicPath: \u0026#39;/vue-el-dashboard/\u0026#39;, ","permalink":"https://wdd.js.org/posts/2018/vue-vue-router-elementui-stupid-simple-dashboard/","summary":"做完这个demo后，你会体会到，Vue组件化，webpack, Vue-router等，并不是很难学习，你需要的只是拿起斧头的勇气\n在做demo的过程中，我遇到一个问题，就是vue-router懒加载一直实现不了，纠结了半天。后来回到原点，去vue-route官网看文档，发现是因为syntax-dynamic-import插件没有安装。\n所以说：你以为的bug, 实际上是你没看透文档\n初次学习这个教程，你不需要有任何担忧某些东西不会，你也不需要写任何代码。因为基本上所有代码都是从element官网上拷贝的，你所做的只是把他们组装在一起罢了。\n在线预览 仓库地址：https://github.com/wangduanduan/vue-el-dashboard\n效果图： 使用到的技术：\nVue Vue-router Element-ui webpack Normalize.css vue-awesome babel 1. vue-cli 安装模板 ➜ vue-el-dashboard git:(master) vue init webpack ? Generate project in current directory? Yes ? Project name vue-el-dashboard ? Project description A Vue.js project ? Author wangdd \u0026lt;wangdd@welljoint.com\u0026gt; ? Vue build standalone ? Install vue-router? Yes ? Use ESLint to lint your code? Yes ? Pick an ESLint preset Standard ?","title":"Vue + Vue-router + Element-ui 搭建一个非常简单的dashboard demo"},{"content":" 原文阅读: nodebestpractices\n1. 工程结构最佳实践 1.1. 组件化 bad: 按照功能划分\ncontrollers api.js home.js order.js product.js user.js models order.js product.js user.js test testOrder.js testProduct.js testUser.js good：按照组件划分\norder product user index.js user.js userApi.js userError.js userTesting.js userAction.js 1.2. 层次化 不要在express中写太多业务逻辑，express专注web层 业务层要单独抽出 数据库层单独抽出 1.3. NPM化 把常用组件做成NPM包\n1.4. 分离Express的 app 和 server 1.5. 配置化 环境感知： 根据不同环境使用不同配置 ","permalink":"https://wdd.js.org/posts/2018/nodejs-project-best-struct/","summary":" 原文阅读: nodebestpractices\n1. 工程结构最佳实践 1.1. 组件化 bad: 按照功能划分\ncontrollers api.js home.js order.js product.js user.js models order.js product.js user.js test testOrder.js testProduct.js testUser.js good：按照组件划分\norder product user index.js user.js userApi.js userError.js userTesting.js userAction.js 1.2. 层次化 不要在express中写太多业务逻辑，express专注web层 业务层要单独抽出 数据库层单独抽出 1.3. NPM化 把常用组件做成NPM包\n1.4. 分离Express的 app 和 server 1.5. 配置化 环境感知： 根据不同环境使用不同配置 ","title":"笔记 node最佳实践1 项目工程最佳实践"},{"content":"1. grep 常用参数 参考： GNU Grep 3.0\n--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log \u0026gt; error.log\n4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log\n5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log\n6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log\n7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log\n8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E 'ERROR|DEBUG' trace.log\n9. 多文件：从多个.log文件中搜索含有ERROR的日志 grep ERROR *.log\n10. 省略文件名：从多个.log文件中搜索ERROR字段日志，并不显示日志文件名 从多个文件中搜索的日志默认每行会带有日志文件名\ngrep -h ERROR *.log\n11. 时间范围： 按照时间范围搜索日志 awk '$2\u0026gt;\u0026quot;17:30:00\u0026quot; \u0026amp;\u0026amp; $2\u0026lt;\u0026quot;18:00:00\u0026quot;' trace.log 日志形式如下, $2代表第二列即11:44:58, awk需要指定列\n11-21 16:44:58 /user/info/ 12. 有没有：搜索到第一个匹配行后就停止搜索 grep -m 1 ERROR trace.log\n13. 使用正则提取字符串 grep -Eo 'cause\u0026quot;:\u0026quot;(.*?)\u0026quot;' test.log\ncause\u0026#34;:\u0026#34;A\u0026#34; cause\u0026#34;:\u0026#34;B\u0026#34; cause\u0026#34;:\u0026#34;A\u0026#34; cause\u0026#34;:\u0026#34;A\u0026#34; cause\u0026#34;:\u0026#34;A\u0026#34; 如果相对提取字符串的结果进行按照出现的次数进行排序，可以使用sort, uniq命令\ngrep -Eo \u0026#39;cause\u0026#34;:\u0026#34;(.*?)\u0026#34;\u0026#39; test.log | sort | uniq -c | sort -k1,1 -n 步骤分解\nsort 对结果进行排序 uniq -c 对结果进行去重并统计出现次数 sort -k1,1 -n 按照第一列的结果，进行数值大小排序 ","permalink":"https://wdd.js.org/posts/2018/grep-awk-search-log/","summary":"1. grep 常用参数 参考： GNU Grep 3.0\n--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 3. 输出文件：可以将日志输出文件中 grep ERROR trace.log \u0026gt; error.log\n4. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log\n5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log\n6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log\n7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log\n8. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E 'ERROR|DEBUG' trace.","title":"grep awk 搜索日志常用命令"},{"content":"1. 广告拦截：AdBlock 2. 获取网页样式：CSS Peeper 3. 扩展管理：扩展管理器（Extension Manager） 4. json格式化：JSON-handle 5. 多点高亮查找：Multi-highlight 6. github源码阅读：Octotree 7. http接口调试：Postman 8. 脚本增强：Tampermonkey 9. 脚本注入：Script Injector 10. 键步如飞：Vimium 11. Vue开发利器：Vue.js devtools 12. 前端资讯：掘金 13. 让不支持markdown的富文本编辑器支持markdown: Markdown Here 14. 多标签页时，自动释放内存，开100个标签页也毫无压力：The Great Suspender 15. 接口测试：Restlet Client - REST API Testing restlet Client和post man功能差不多，restlet更轻量，只在新开一个标签页。postman 需要打开一个app。\n","permalink":"https://wdd.js.org/posts/2018/my-chrome-extensions-collection/","summary":"1. 广告拦截：AdBlock 2. 获取网页样式：CSS Peeper 3. 扩展管理：扩展管理器（Extension Manager） 4. json格式化：JSON-handle 5. 多点高亮查找：Multi-highlight 6. github源码阅读：Octotree 7. http接口调试：Postman 8. 脚本增强：Tampermonkey 9. 脚本注入：Script Injector 10. 键步如飞：Vimium 11. Vue开发利器：Vue.js devtools 12. 前端资讯：掘金 13. 让不支持markdown的富文本编辑器支持markdown: Markdown Here 14. 多标签页时，自动释放内存，开100个标签页也毫无压力：The Great Suspender 15. 接口测试：Restlet Client - REST API Testing restlet Client和post man功能差不多，restlet更轻量，只在新开一个标签页。postman 需要打开一个app。","title":"我的谷歌浏览器插件集（15个）"},{"content":"1. 问题现象 使用netstat -ntp命令时发现，Recv-Q 1692012 异常偏高（正常情况下，该值应该是0），导致应用占用过多的内存。\ntcp 1692012 0 172.17.72.4:48444 10.254.149.149:58080 ESTABLISHED 27/node 问题原因：代理的转发时，没有删除逐跳首部\n2. 什么是Hop-by-hop 逐跳首部？ http首部可以分为两种\n端到端首部 End-to-end: 端到端首部代理在转发时必须携带的 逐跳首部 Hop-by-hop: 逐跳首部只对单次转发有效，代理在转发时，必须删除这些首部 逐跳首部有以下几个, 这些首部在代理进行转发前必须删除\nConnetion Keep-Alive Proxy-Authenticate Proxy-Authortization Trailer TE Transfer-Encodeing Upgrade 3. 什么是哑代理？ 很多老的或简单的代理都是盲中继(blind relay),它们只是将字节从一个连接转发到另一个连接中去,不对Connection首部进行特殊的处理。\n(1)在图4-15a中 Web客户端向代理发送了一条报文,其中包含了Connection:Keep-Alive首部,如果可能的话请求建立一条keep-alive连接。客户端等待响应,以确定对方是否认可它对keep-alive信道的请求。\n(2) 哑代理收到了这条HTTP请求,但它并不理解 Connection首部(只是将其作为一个扩展首部对待)。代理不知道keep-alive是什么意思,因此只是沿着转发链路将报文一字不漏地发送给服务器(图4-15b)。但Connection首部是个逐跳首部,只适用于单条传输链路,不应该沿着传输链路向下传输。接下来,就要发生一些很糟糕的事情了。\n(3) 在图4-15b中,经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时,会误以为代理(对服务器来说,这个代理看起来就和所有其他客户端一样)希望进行keep-alive对话!对Web服务器来说这没什么问题——它同意进行keep-alive对话,并在图4-15c中回送了一个Connection: Keep-Alive响应首部。所以,此时W eb服务器认为它在与代理进行keep-alive对话,会遵循keep-alive的规则。但代理却对keep-alive一无所知。不妙。\n(4) 在图4-15d中,哑代理将Web服务器的响应报文回送给客户端,并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部,就会认为代理同意进行keep-alive对话。所以,此时客户端和服务器都认为它们在进行keep-alive对话,但与它们进行对话的代理却对keep-alive一无所知。\n(5) 由于代理对keep-alive一无所知,所以会将收到的所有数据都回送给客户端,然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了,所以不会去关闭连接。这样,代理就会挂在那里等待连接的关闭。\n(6) 客户端在图4-15d中收到了回送的响应报文时,会立即转向下一条请求,在keep-alive连接上向代理发送另一条请求(参见图4-15e)。而代理并不认为同一条连接上会有其他请求到来,请求被忽略,浏览器就在这里转圈,不会有任何进展了。\n(7) 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 \u0026ndash;《HTTP权威指南》\n这是HTTP权威指南中，关于HTTP哑代理的描述。这里这里说了哑代理会造成的一个问题。\n这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 实际上，我认为哑代理还是造成以下问题的原因\nTCP链接高Recv-Q tcp链接不断开，导致服务器内存过高，内存泄露 节点iowait高 在我们自己的代理的代码中，我有发现，在代理进行转发时，只删除了headers.host, 并没有删除headers.Connection等逐跳首部的字段\ndelete req.headers.host var option = { url: url, headers: req.headers } var proxy = request(option) req.pipe(proxy) proxy.pipe(res) 4. 解决方案 解决方案有两个， 我推荐使用第二个方案，具体方法参考Express 代理中间件的写法\n更改自己的原有代码 使用成熟的开源产品 5. 参考文献 What is the reason for a high Recv-Q of a TCP connection? TCP buffers keep filling up (Recv-Q full): named unresponsive linux探秘:netstat中Recv-Q 深究 深入剖析 Socket——TCP 通信中由于底层队列填满而造成的死锁问题 netstat Recv-Q和Send-Q 深入剖析 Socket——数据传输的底层实现 Use of Recv-Q and Send-Q 【美】David Gourley / Brian Totty HTTP权威指南 【日】上野宣 于均良 图解HTTP ","permalink":"https://wdd.js.org/posts/2018/tcp-high-recv-q-or-send-q-reasons/","summary":"1. 问题现象 使用netstat -ntp命令时发现，Recv-Q 1692012 异常偏高（正常情况下，该值应该是0），导致应用占用过多的内存。\ntcp 1692012 0 172.17.72.4:48444 10.254.149.149:58080 ESTABLISHED 27/node 问题原因：代理的转发时，没有删除逐跳首部\n2. 什么是Hop-by-hop 逐跳首部？ http首部可以分为两种\n端到端首部 End-to-end: 端到端首部代理在转发时必须携带的 逐跳首部 Hop-by-hop: 逐跳首部只对单次转发有效，代理在转发时，必须删除这些首部 逐跳首部有以下几个, 这些首部在代理进行转发前必须删除\nConnetion Keep-Alive Proxy-Authenticate Proxy-Authortization Trailer TE Transfer-Encodeing Upgrade 3. 什么是哑代理？ 很多老的或简单的代理都是盲中继(blind relay),它们只是将字节从一个连接转发到另一个连接中去,不对Connection首部进行特殊的处理。\n(1)在图4-15a中 Web客户端向代理发送了一条报文,其中包含了Connection:Keep-Alive首部,如果可能的话请求建立一条keep-alive连接。客户端等待响应,以确定对方是否认可它对keep-alive信道的请求。\n(2) 哑代理收到了这条HTTP请求,但它并不理解 Connection首部(只是将其作为一个扩展首部对待)。代理不知道keep-alive是什么意思,因此只是沿着转发链路将报文一字不漏地发送给服务器(图4-15b)。但Connection首部是个逐跳首部,只适用于单条传输链路,不应该沿着传输链路向下传输。接下来,就要发生一些很糟糕的事情了。\n(3) 在图4-15b中,经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时,会误以为代理(对服务器来说,这个代理看起来就和所有其他客户端一样)希望进行keep-alive对话!对Web服务器来说这没什么问题——它同意进行keep-alive对话,并在图4-15c中回送了一个Connection: Keep-Alive响应首部。所以,此时W eb服务器认为它在与代理进行keep-alive对话,会遵循keep-alive的规则。但代理却对keep-alive一无所知。不妙。\n(4) 在图4-15d中,哑代理将Web服务器的响应报文回送给客户端,并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部,就会认为代理同意进行keep-alive对话。所以,此时客户端和服务器都认为它们在进行keep-alive对话,但与它们进行对话的代理却对keep-alive一无所知。\n(5) 由于代理对keep-alive一无所知,所以会将收到的所有数据都回送给客户端,然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了,所以不会去关闭连接。这样,代理就会挂在那里等待连接的关闭。\n(6) 客户端在图4-15d中收到了回送的响应报文时,会立即转向下一条请求,在keep-alive连接上向代理发送另一条请求(参见图4-15e)。而代理并不认为同一条连接上会有其他请求到来,请求被忽略,浏览器就在这里转圈,不会有任何进展了。\n(7) 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 \u0026ndash;《HTTP权威指南》\n这是HTTP权威指南中，关于HTTP哑代理的描述。这里这里说了哑代理会造成的一个问题。\n这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 实际上，我认为哑代理还是造成以下问题的原因\nTCP链接高Recv-Q tcp链接不断开，导致服务器内存过高，内存泄露 节点iowait高 在我们自己的代理的代码中，我有发现，在代理进行转发时，只删除了headers.host, 并没有删除headers.Connection等逐跳首部的字段\ndelete req.headers.host var option = { url: url, headers: req.","title":"哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首"},{"content":" 1. 文件名重复了怎么办？ 使用hexo new filename命令用来新建一个文章，但是如果你创建文章时，已经存在了同样的一个文件名，那么Hexo会怎样处理？\n报错 覆盖之前的文章 在文件名后面加个序号 实际上Hexo使用第三个方式来处理，例如\n// 执行下面命令两次，会产生两个文件 filename.md, filename-1.md hexo new filename hexo new filename 所以，在创建文章时，你根本不需要考虑文章重名的事情，Hexo会自动帮你加上序号后处理。\n","permalink":"https://wdd.js.org/posts/2018/something-you-may-dont-konw-about-hexo/","summary":"1. 文件名重复了怎么办？ 使用hexo new filename命令用来新建一个文章，但是如果你创建文章时，已经存在了同样的一个文件名，那么Hexo会怎样处理？\n报错 覆盖之前的文章 在文件名后面加个序号 实际上Hexo使用第三个方式来处理，例如\n// 执行下面命令两次，会产生两个文件 filename.md, filename-1.md hexo new filename hexo new filename 所以，在创建文章时，你根本不需要考虑文章重名的事情，Hexo会自动帮你加上序号后处理。","title":"一些关于Hexo的疑问"},{"content":" 默认情况下NexT主题的首页，每篇文章几乎都会全部渲染出来。这是这样来看，首页就会变得非常长，不利于快速浏览。\n而我希望首页可以尽量缩短，每个文章只需要稍微一点介绍，如果有图片，就设置一张封面就好了。\n下面是具体的设置步骤\n1. Next主题设置摘要 filename: themes/next/_config.yml，将auto_excerpt.enable设置成true，length属性表示摘要的字数限制。\nauto_excerpt: enable: true length: 150 2. 文章具体设置 在 \u0026lt;!-- more --\u0026gt;上面放一张图片就可以了\n--- title: Hexo NexT主题设置封面的方法 date: 2018-02-08 21:09:50 tags: - hexo --- ![](https://wdd.js.org/img/images/20180208212257_BZZjA5_1200px-The_Great_Wave_off_Kanagawa.jpeg) 文章摘要 \u0026lt;!-- more --\u0026gt; 文章正文 ","permalink":"https://wdd.js.org/posts/2018/hexo-next-theme-set-cover/","summary":" 默认情况下NexT主题的首页，每篇文章几乎都会全部渲染出来。这是这样来看，首页就会变得非常长，不利于快速浏览。\n而我希望首页可以尽量缩短，每个文章只需要稍微一点介绍，如果有图片，就设置一张封面就好了。\n下面是具体的设置步骤\n1. Next主题设置摘要 filename: themes/next/_config.yml，将auto_excerpt.enable设置成true，length属性表示摘要的字数限制。\nauto_excerpt: enable: true length: 150 2. 文章具体设置 在 \u0026lt;!-- more --\u0026gt;上面放一张图片就可以了\n--- title: Hexo NexT主题设置封面的方法 date: 2018-02-08 21:09:50 tags: - hexo --- ![](https://wdd.js.org/img/images/20180208212257_BZZjA5_1200px-The_Great_Wave_off_Kanagawa.jpeg) 文章摘要 \u0026lt;!-- more --\u0026gt; 文章正文 ","title":"Hexo NexT主题设置封面的方法"},{"content":" 我曾经在csdn上写过博客\n后来因为csdn的广告太多，我就不再csdn上写了\n我也曾在博客园上写过博客\n后来因为博客园上对markdown支持不够好，所以我也放弃了\n我也曾在segmentfault上写过博客\n它上面的markdown编辑器也还好用\n但是有时候不知道是什么原因\n它的markdown编辑器有时候太卡了，而且经常会出现上传图片失败\n最让我不能容忍的是\n你在SegmentFault删除自己的博客，那其实是逻辑删除\n别人还是可以通过连接去访问的\n而且SegmentFault上的广告也开始慢慢变多了\n而且SegmentFault上对文章的限制也是比较多的\n大树底下好乘凉，但是你的流量也是需要给大树的\n互联网时代，看似任何服务都是免费的\n其实免费的才是最贵的\n你用了别人的服务，无论如何，你总要提供给别人价值\n无论怎样，你总要做出你的回报\n但是，无论如何，我总是需要一个更加独立的领地\n她可以完全属于我\n无论是野草还是野花\n无论是杨柳依依还是雨雪霏霏\n我都可以放肆潇洒\n我需要一片净土\n来书写我自己的芳华\n所以，最近一直在把SegmentFault上的文章搬迁到github pages上\n另外图片全部存在七牛云上\n使用hexo next主题，做一个完全自主的静态博客\n","permalink":"https://wdd.js.org/posts/2018/write-blog-belong-myself/","summary":"我曾经在csdn上写过博客\n后来因为csdn的广告太多，我就不再csdn上写了\n我也曾在博客园上写过博客\n后来因为博客园上对markdown支持不够好，所以我也放弃了\n我也曾在segmentfault上写过博客\n它上面的markdown编辑器也还好用\n但是有时候不知道是什么原因\n它的markdown编辑器有时候太卡了，而且经常会出现上传图片失败\n最让我不能容忍的是\n你在SegmentFault删除自己的博客，那其实是逻辑删除\n别人还是可以通过连接去访问的\n而且SegmentFault上的广告也开始慢慢变多了\n而且SegmentFault上对文章的限制也是比较多的\n大树底下好乘凉，但是你的流量也是需要给大树的\n互联网时代，看似任何服务都是免费的\n其实免费的才是最贵的\n你用了别人的服务，无论如何，你总要提供给别人价值\n无论怎样，你总要做出你的回报\n但是，无论如何，我总是需要一个更加独立的领地\n她可以完全属于我\n无论是野草还是野花\n无论是杨柳依依还是雨雪霏霏\n我都可以放肆潇洒\n我需要一片净土\n来书写我自己的芳华\n所以，最近一直在把SegmentFault上的文章搬迁到github pages上\n另外图片全部存在七牛云上\n使用hexo next主题，做一个完全自主的静态博客","title":"寻一片净土 书写我自己的芳华"},{"content":"对于执行时间过长的脚本，有的浏览器会弹出警告，说页面无响应。有的浏览器会直接终止脚本。总而言之，浏览器不希望某一个代码块长时间处于运行状态，因为js是单线程的。一个代码块长时间运行，将会导致其他任何任务都必须等待。从用户体验上来说，很有可能发生页面渲染卡顿或者点击事件无响应的状态。\n如果一段脚本的运行时间超过5秒，有些浏览器（比如Firefox和Opera）将弹出一个对话框警告用户该脚本“无法响应”。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。\u0026ndash;《JavaScript忍者秘籍》\nJavaScript忍者秘籍里有个很好的比喻：页面上发生的各种事情就好像一群人在讨论事情，如果有个人一直在说个不停，其他人肯定不乐意。我们希望有个裁判，定时的切换其他人来说话。\nJs利用定时器来分解任务，关键点有两个。\n按什么维度去分解任务\n任务的现场保存与现场恢复\n1. 例子 要求：动态创建一个表格，一共10000行，每行10个单元格\n1.1. 一次性创建 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var tbody = document.getElementsByTagName(\u0026#39;tbody\u0026#39;)[0]; var allLines = 10000; // 每次渲染的行数 console.time(\u0026#39;wd\u0026#39;); for(var i=0; i\u0026lt;allLines; i++){ var tr = document.createElement(\u0026#39;tr\u0026#39;); for(var j=0; j\u0026lt;10; j++){ var td = document.createElement(\u0026#39;td\u0026#39;); td.appendChild(document.createTextNode(i+\u0026#39;,\u0026#39;+j)); tr.appendChild(td); } tbody.appendChild(tr); } console.timeEnd(\u0026#39;wd\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总共耗时180ms, 浏览器已经给出警告！[Violation] 'setTimeout' handler took 53ms。\n1.2. 分批次动态创建 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var tbody = document.getElementsByTagName(\u0026#39;tbody\u0026#39;)[0]; var allLines = 10000; // 每次渲染的行数 var everyTimeCreateLines = 80; // 当前行 var currentLine = 0; setTimeout(function renderTable(){ console.time(\u0026#39;wd\u0026#39;); for(var i=currentLine; i\u0026lt;currentLine+everyTimeCreateLines \u0026amp;\u0026amp; i\u0026lt;allLines; i++){ var tr = document.createElement(\u0026#39;tr\u0026#39;); for(var j=0; j\u0026lt;10; j++){ var td = document.createElement(\u0026#39;td\u0026#39;); td.appendChild(document.createTextNode(i+\u0026#39;,\u0026#39;+j)); tr.appendChild(td); } tbody.appendChild(tr); } console.timeEnd(\u0026#39;wd\u0026#39;); currentLine = i; if(currentLine \u0026lt; allLines){ setTimeout(renderTable,0); } },0); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这次异步按批次创建，没有耗时的警告。因为控制了每次代码在50ms内运行。实际上每80行耗时约10ms左右。这就不会引起页面卡顿等问题。\n","permalink":"https://wdd.js.org/posts/2018/settimeout-to-splice-big-work/","summary":"对于执行时间过长的脚本，有的浏览器会弹出警告，说页面无响应。有的浏览器会直接终止脚本。总而言之，浏览器不希望某一个代码块长时间处于运行状态，因为js是单线程的。一个代码块长时间运行，将会导致其他任何任务都必须等待。从用户体验上来说，很有可能发生页面渲染卡顿或者点击事件无响应的状态。\n如果一段脚本的运行时间超过5秒，有些浏览器（比如Firefox和Opera）将弹出一个对话框警告用户该脚本“无法响应”。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。\u0026ndash;《JavaScript忍者秘籍》\nJavaScript忍者秘籍里有个很好的比喻：页面上发生的各种事情就好像一群人在讨论事情，如果有个人一直在说个不停，其他人肯定不乐意。我们希望有个裁判，定时的切换其他人来说话。\nJs利用定时器来分解任务，关键点有两个。\n按什么维度去分解任务\n任务的现场保存与现场恢复\n1. 例子 要求：动态创建一个表格，一共10000行，每行10个单元格\n1.1. 一次性创建 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var tbody = document.getElementsByTagName(\u0026#39;tbody\u0026#39;)[0]; var allLines = 10000; // 每次渲染的行数 console.time(\u0026#39;wd\u0026#39;); for(var i=0; i\u0026lt;allLines; i++){ var tr = document.createElement(\u0026#39;tr\u0026#39;); for(var j=0; j\u0026lt;10; j++){ var td = document.createElement(\u0026#39;td\u0026#39;); td.appendChild(document.createTextNode(i+\u0026#39;,\u0026#39;+j)); tr.appendChild(td); } tbody.appendChild(tr); } console.timeEnd(\u0026#39;wd\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总共耗时180ms, 浏览器已经给出警告！[Violation] 'setTimeout' handler took 53ms。\n1.2. 分批次动态创建 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var tbody = document.","title":"定时器学习：利用定时器分解耗时任务案例"},{"content":" 我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。\n然后我继续看了这本书的中文版。有些醍醐灌顶的感觉。 随之在github搜了一下。 我想，即使付费，我也愿意看。\n中文版地址：https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details github原文地址：https://github.com/MostlyAdequate/mostly-adequate-guide\n1. 后记 其实我是想学点函数柯里化的东西，然后用谷歌搜索了一下。第一个结果就是这本书。非常感谢谷歌搜索，如果我用百度，可能就没有缘分遇到这本书了。\n","permalink":"https://wdd.js.org/posts/2018/js-functional-programming/","summary":"我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。\n然后我继续看了这本书的中文版。有些醍醐灌顶的感觉。 随之在github搜了一下。 我想，即使付费，我也愿意看。\n中文版地址：https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details github原文地址：https://github.com/MostlyAdequate/mostly-adequate-guide\n1. 后记 其实我是想学点函数柯里化的东西，然后用谷歌搜索了一下。第一个结果就是这本书。非常感谢谷歌搜索，如果我用百度，可能就没有缘分遇到这本书了。","title":"关于JavaScropt函数式编程，我多么希望能早点看到这本书"},{"content":" 本篇文章来自一个需求，前端websocket会收到各种消息，但是调试的时候，我希望把websoekt推送过来的消息都保存到一个文件里，如果出问题的时候，我可以把这些消息的日志文件提交给后端开发区分析错误。但是在浏览器里，js一般是不能写文件的。鼠标另存为的方法也是不太好，因为会保存所有的console.log的输出。于是，终于找到这个debugout.js。\ndebugout.js的原理是将所有日志序列化后，保存到一个变量里。当然这个变量不会无限大，因为默认的最大日志限制是2500行，这个是可配置的。另外，debugout.js也支持在localStorage里存储日志的。\n1. debugout.js 一般来说，可以使用打开console面板，然后右键save，是可以将console.log输出的信息另存为log文件的。但是这就把所有的日志都包含进来了，如何只保存我想要的日志呢？\n（调试输出）从您的日志中生成可以搜索，时间戳，下载等的文本文件。 参见下面的一些例子。\nDebugout的log（）接受任何类型的对象，包括函数。 Debugout不是一个猴子补丁，而是一个单独的记录类，你使用而不是控制台。\n调试的一些亮点：\n在运行时或任何时间获取整个日志或尾部 搜索并切片日志 更好地了解可选时间戳的使用模式 在一个地方切换实时日志记录（console.log） 可选地将输出存储在window.localStorage中，并在每个会话中持续添加到同一个日志 可选地，将日志上限为X个最新行以限制内存消耗 下图是使用downloadLog方法下载的日志文件。\n官方提供的demo示例，欢迎试玩。http://inorganik.github.io/debugout.js/\n2. 使用 在脚本顶部的全局命名空间中创建一个新的调试对象，并使用debugout的日志方法替换所有控制台日志方法：\nvar bugout = new debugout(); // instead of console.log(\u0026#39;some object or string\u0026#39;) bugout.log(\u0026#39;some object or string\u0026#39;); 3. API log() -像console.log(), 但是会自动存储 getLog() - 返回所有日志 tail(numLines) - 返回尾部执行行日志，默认100行 search(string) - 搜索日志 getSlice(start, numLines) - 日志切割 downloadLog() - 下载日志 clear() - 清空日志 determineType() - 一个更细粒度的typeof为您提供方便 4. 可选配置 ··· // log in real time (forwards to console.log) self.realTimeLoggingOn = true; // insert a timestamp in front of each log self.useTimestamps = false; // store the output using window.localStorage() and continuously add to the same log each session self.useLocalStorage = false; // set to false after you\u0026rsquo;re done debugging to avoid the log eating up memory self.recordLogs = true; // to avoid the log eating up potentially endless memory self.autoTrim = true; // if autoTrim is true, this many most recent lines are saved self.maxLines = 2500; // how many lines tail() will retrieve self.tailNumLines = 100; // filename of log downloaded with downloadLog() self.logFilename = \u0026rsquo;log.txt\u0026rsquo;; // max recursion depth for logged objects self.maxDepth = 25; ···\n5. 项目地址 https://github.com/inorganik/debugout.js\n6. 另外 我自己也模仿debugout.js写了一个日志保存的项目，该项目可以在ie10及以上下载日志。 debugout.js在ie浏览器上下载日志的方式是有问题的。 项目地址：https://github.com/wangduanduan/log4b.git\n","permalink":"https://wdd.js.org/posts/2018/save-console-log-as-file/","summary":"本篇文章来自一个需求，前端websocket会收到各种消息，但是调试的时候，我希望把websoekt推送过来的消息都保存到一个文件里，如果出问题的时候，我可以把这些消息的日志文件提交给后端开发区分析错误。但是在浏览器里，js一般是不能写文件的。鼠标另存为的方法也是不太好，因为会保存所有的console.log的输出。于是，终于找到这个debugout.js。\ndebugout.js的原理是将所有日志序列化后，保存到一个变量里。当然这个变量不会无限大，因为默认的最大日志限制是2500行，这个是可配置的。另外，debugout.js也支持在localStorage里存储日志的。\n1. debugout.js 一般来说，可以使用打开console面板，然后右键save，是可以将console.log输出的信息另存为log文件的。但是这就把所有的日志都包含进来了，如何只保存我想要的日志呢？\n（调试输出）从您的日志中生成可以搜索，时间戳，下载等的文本文件。 参见下面的一些例子。\nDebugout的log（）接受任何类型的对象，包括函数。 Debugout不是一个猴子补丁，而是一个单独的记录类，你使用而不是控制台。\n调试的一些亮点：\n在运行时或任何时间获取整个日志或尾部 搜索并切片日志 更好地了解可选时间戳的使用模式 在一个地方切换实时日志记录（console.log） 可选地将输出存储在window.localStorage中，并在每个会话中持续添加到同一个日志 可选地，将日志上限为X个最新行以限制内存消耗 下图是使用downloadLog方法下载的日志文件。\n官方提供的demo示例，欢迎试玩。http://inorganik.github.io/debugout.js/\n2. 使用 在脚本顶部的全局命名空间中创建一个新的调试对象，并使用debugout的日志方法替换所有控制台日志方法：\nvar bugout = new debugout(); // instead of console.log(\u0026#39;some object or string\u0026#39;) bugout.log(\u0026#39;some object or string\u0026#39;); 3. API log() -像console.log(), 但是会自动存储 getLog() - 返回所有日志 tail(numLines) - 返回尾部执行行日志，默认100行 search(string) - 搜索日志 getSlice(start, numLines) - 日志切割 downloadLog() - 下载日志 clear() - 清空日志 determineType() - 一个更细粒度的typeof为您提供方便 4. 可选配置 ··· // log in real time (forwards to console.","title":"终于找到你！如何将前端console.log的日志保存成文件?"},{"content":"之前一直非常痛苦，在iframe外层根本获取不了里面的信息，后来使用了postMessage用传递消息来实现，但是用起来还是非常不方便。\n其实浏览器本身是可以选择不同的iframe的执行环境的。例如有个变量是在iframe里面定义的，你只需要切换到这个iframe的执行环境，你就可以随意操作这个环境的任何变量了。\n这个小技巧，对于调试非常有用，但是我直到今天才发现。\n1. Chrome 这个小箭头可以让你选择不同的iframe的执行环境，可以切换到你的iframe环境里。\n2. IE 如图所示是ie11的dev tool点击下来箭头，也可以选择不同的iframe执行环境。\n3. 其他浏览器 其他浏览器可以自行摸索一下。。。（G_H）\n","permalink":"https://wdd.js.org/posts/2018/debug-code-in-iframe/","summary":"之前一直非常痛苦，在iframe外层根本获取不了里面的信息，后来使用了postMessage用传递消息来实现，但是用起来还是非常不方便。\n其实浏览器本身是可以选择不同的iframe的执行环境的。例如有个变量是在iframe里面定义的，你只需要切换到这个iframe的执行环境，你就可以随意操作这个环境的任何变量了。\n这个小技巧，对于调试非常有用，但是我直到今天才发现。\n1. Chrome 这个小箭头可以让你选择不同的iframe的执行环境，可以切换到你的iframe环境里。\n2. IE 如图所示是ie11的dev tool点击下来箭头，也可以选择不同的iframe执行环境。\n3. 其他浏览器 其他浏览器可以自行摸索一下。。。（G_H）","title":"如何浏览器里调试iframe里层的代码？"},{"content":"1. 特点 无依赖 无检查 无错误处理 无逻辑 无配置 2. 代码 function render(tpl, data){ var re = /{{([^}]+)?}}/; var match = \u0026#39;\u0026#39;; while(match = re.exec(tpl)){ tpl = tpl.replace(match[0],data[match[1]]); } return tpl; } 3. demo var tpl = \u0026#39;/cube_xinbao_dial_result/{{action}}/{{report_type}}/{{query}}/?userId={{userId}}\u0026#39;; var data = {report_type:1, query: \u0026#39;2323\u0026#39;, action: \u0026#39;todolist\u0026#39;,userId: \u0026#39;23234234\u0026#39;} function render(tpl, data){ var re = /{{([^}]+)?}}/; var match = \u0026#39;\u0026#39;; while(match = re.exec(tpl)){ tpl = tpl.replace(match[0],data[match[1]]); } return tpl; } console.log(render(tpl,data)); \u0026gt; /cube_xinbao_dial_result/todolist/1/2323/?userId=23234234 ","permalink":"https://wdd.js.org/posts/2018/a-very-simple-template-function/","summary":"1. 特点 无依赖 无检查 无错误处理 无逻辑 无配置 2. 代码 function render(tpl, data){ var re = /{{([^}]+)?}}/; var match = \u0026#39;\u0026#39;; while(match = re.exec(tpl)){ tpl = tpl.replace(match[0],data[match[1]]); } return tpl; } 3. demo var tpl = \u0026#39;/cube_xinbao_dial_result/{{action}}/{{report_type}}/{{query}}/?userId={{userId}}\u0026#39;; var data = {report_type:1, query: \u0026#39;2323\u0026#39;, action: \u0026#39;todolist\u0026#39;,userId: \u0026#39;23234234\u0026#39;} function render(tpl, data){ var re = /{{([^}]+)?}}/; var match = \u0026#39;\u0026#39;; while(match = re.exec(tpl)){ tpl = tpl.replace(match[0],data[match[1]]); } return tpl; } console.log(render(tpl,data)); \u0026gt; /cube_xinbao_dial_result/todolist/1/2323/?userId=23234234 ","title":"8行代码的模板字符串替换函数"},{"content":"当我们使用原生的audio标签时，可以看到如下的效果。\n那么如何让下载按钮隐藏掉呢？\n1. controlsList=\u0026ldquo;nodownload\u0026rdquo; // 这个方法只支持 Chrome 58+， 低于该版本的是没有无法隐藏的 \u0026lt;audio src=\u0026#34;/i/horse.ogg\u0026#34; controls=\u0026#34;controls\u0026#34; controlsList=\u0026#34;nodownload\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; controlsList属性只兼容Chrome 58+以上，具体可以参考controlslist.html ，controlsList在线例子\nnodownload: 不要下载 nofullscreen: 不要全屏 noremoteplayback: 不要远程回放 2. css方式来隐藏 // 这个方式兼容所有版本的谷歌浏览器 audio::-webkit-media-controls { overflow: hidden !important } audio::-webkit-media-controls-enclosure { width: calc(100% + 32px); margin-left: auto; } 3. 即使让下载按钮隐藏了，如何禁止右键下载？ // 给audio标签禁止右键，来禁止下载 \u0026lt;audio src=\u0026#34;/i/horse.ogg\u0026#34; controls=\u0026#34;controls\u0026#34; controlsList=\u0026#34;nodownload\u0026#34; oncontextmenu=\u0026#34;return false\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; 4. 第三方插件: audiojs 项目地址: https://github.com/kolber/audiojs 优点： 简单，无依赖 缺点：异步插入的audio标签，每次还是需要重新调用audiojs.createAll()方法来重新实例化\n// 1. \u0026lt;script src=\u0026#34;/audiojs/audio.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // 2. \u0026lt;script\u0026gt; audiojs.events.ready(function() { var as = audiojs.createAll(); }); \u0026lt;/script\u0026gt; 效果图： 5. audio相关问题以及解决方案 关于动态生成的mp3在audio标签无法拖动的问题: (audio断点续传) 6. 参考文献 https://stackoverflow.com/questions/41115801/in-chrome-55-prevent-showing-download-button-for-html-5-video\nhttps://stackoverflow.com/questions/39602852/disable-download-button-for-google-chrome/40975859#40975859\nhttps://googlechrome.github.io/samples/media/controlslist.html\n","permalink":"https://wdd.js.org/posts/2018/audio-hide-download-icon/","summary":"当我们使用原生的audio标签时，可以看到如下的效果。\n那么如何让下载按钮隐藏掉呢？\n1. controlsList=\u0026ldquo;nodownload\u0026rdquo; // 这个方法只支持 Chrome 58+， 低于该版本的是没有无法隐藏的 \u0026lt;audio src=\u0026#34;/i/horse.ogg\u0026#34; controls=\u0026#34;controls\u0026#34; controlsList=\u0026#34;nodownload\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; controlsList属性只兼容Chrome 58+以上，具体可以参考controlslist.html ，controlsList在线例子\nnodownload: 不要下载 nofullscreen: 不要全屏 noremoteplayback: 不要远程回放 2. css方式来隐藏 // 这个方式兼容所有版本的谷歌浏览器 audio::-webkit-media-controls { overflow: hidden !important } audio::-webkit-media-controls-enclosure { width: calc(100% + 32px); margin-left: auto; } 3. 即使让下载按钮隐藏了，如何禁止右键下载？ // 给audio标签禁止右键，来禁止下载 \u0026lt;audio src=\u0026#34;/i/horse.ogg\u0026#34; controls=\u0026#34;controls\u0026#34; controlsList=\u0026#34;nodownload\u0026#34; oncontextmenu=\u0026#34;return false\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; 4. 第三方插件: audiojs 项目地址: https://github.","title":"谷歌浏览器 audio如何隐藏下载按钮"},{"content":" 我觉得DOM就好像是元素周期表里的元素，JS就好像是实验器材，通过各种化学反应，产生各种魔术。\n1. Audio 通过打开谷歌浏览器的dev tools -\u0026gt; Settings -\u0026gt; Elements -\u0026gt; Show user agent shadow DOM, 你可以看到其实Audio标签也是由常用的 input标签和div等标签合成的。\n2. 基本用法 1 \u0026lt;audio src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br\u0026gt; 2 \u0026lt;audio src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br\u0026gt; // controlsList属性目前只支持 chrome 58+ 3 \u0026lt;audio src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34; controls=\u0026#34;controls\u0026#34; controlsList=\u0026#34;nodownload\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br\u0026gt; 4 \u0026lt;audio controls=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34; type=\u0026#39;audio/mp3\u0026#39; /\u0026gt; \u0026lt;/audio\u0026gt; 你可以看出他们在Chrome里表现的差异\n关于audio标签支持的音频类型，可以参考Audio#Supported_audio_coding_formats\n3. 常用属性 autoplay: 音频流文件就绪后是否自动播放\npreload: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;metadata\u0026rdquo; | \u0026ldquo;auto\u0026rdquo; | \u0026quot;\u0026quot;\n\u0026ldquo;none\u0026rdquo;: 无需预加载 \u0026ldquo;metadata\u0026rdquo;: 只需要加载元数据，例如音频时长，文件大小等。 \u0026ldquo;auto\u0026rdquo;: 自动优化下载整个流文件 controls： \u0026ldquo;controls\u0026rdquo; | \u0026quot;\u0026quot; 是否需要显示控件\nloop： \u0026ldquo;loop\u0026rdquo; or \u0026quot;\u0026quot; 是否循环播放\nmediagroup： string 多个视频或者音频流是否合并\nsrc： 音频地址\n4. API(重点) load(): 加载资源 play(): 播放 pause(): 暂停 canPlayType()： 询问浏览器以确定是否可以播放给定的MIME类型 buffered()：指定文件的缓冲部分的开始和结束时间 5. 常用事件：Media Events(重点) 事件名 何时触发 loadstart 开始加载 progress 正在加载 suspend 用户代理有意无法获取媒体数据，无法获取整个文件 abort 主动终端下载资源并不是由于发生错误 error 获取资源时发生错误 play 开始播放 pause 播放暂停 loadedmetadata 刚获取完元数据 loadeddata 第一次渲染元数据 waiting 等待中 playing 正在播放 canplay 用户代理可以恢复播放媒体数据，但是估计如果现在开始播放，则媒体资源不能以当前播放速率直到其结束呈现，而不必停止进一步缓冲内容。 canplaythrough 用户代理估计，如果现在开始播放，则媒体资源可以以当前播放速率一直呈现到其结束，而不必停止进一步的缓冲。 timeupdate 当前播放位置作为正常播放的一部分而改变，或者以特别有趣的方式，例如不连续地改变。 ended 播放结束 ratechange 媒体播放速度改变 durationchange 媒体时长改变 volumechange 媒体声音大小改变 6. Audio DOM 属性(重点) 6.1. 只读属性 duration： 媒体时长，数值， 单位s ended: 是否完成播放，布尔值 paused: 是否播放暂停，布尔值 6.2. 其他可读写属性(重点) playbackRate： 播放速度，大多数浏览器支持0.5-4， 1表示正常速度，设置该属性可以修改播放速度 volume：0.0-1.0之间，设置该属性可以修改声音大小 muted: 是否静音， 设置该属性可以静音 currentTime：指定播放位置的秒数 // 你可以使用元素的属性seekable来决定媒体目前能查找的范围。它返回一个你可以查找的TimeRanges 时间对象。 var mediaElement = document.getElementById(\u0026#39;mediaElementID\u0026#39;); mediaElement.seekable.start(); // 返回开始时间 (in seconds) mediaElement.seekable.end(); // 返回结束时间 (in seconds) mediaElement.currentTime = 122; // 设定在 122 seconds mediaElement.played.end(); // 返回浏览器播放的秒数 以下方法可以使音频以2倍速度播放。\n\u0026lt;audio id=\u0026#34;wdd\u0026#34; src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;script\u0026gt; var myAudio = document.getElementById(\u0026#39;wdd\u0026#39;); myAudio.playbackRate = 2; \u0026lt;/script\u0026gt; 7. 常见问题及解决方法 录音无法拖动，播放一端就自动停止： https://wenjs.me/p/about-mp3progress-on-audio 如何隐藏Audio的下载按钮：https://segmentfault.com/a/1190000009737051 想找一个简单的录音播放插件： https://github.com/kolber/audiojs 8. 参考资料 W3C: the-audio-element\nwikipedia: HTML5 Audio\nW3C: HTML/Elements/audio\nNative Audio in the browser\nHTMLMediaElement.playbackRate\n使用 HTML5 音频和视频\n","permalink":"https://wdd.js.org/posts/2018/audio-heart-detail/","summary":"我觉得DOM就好像是元素周期表里的元素，JS就好像是实验器材，通过各种化学反应，产生各种魔术。\n1. Audio 通过打开谷歌浏览器的dev tools -\u0026gt; Settings -\u0026gt; Elements -\u0026gt; Show user agent shadow DOM, 你可以看到其实Audio标签也是由常用的 input标签和div等标签合成的。\n2. 基本用法 1 \u0026lt;audio src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br\u0026gt; 2 \u0026lt;audio src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br\u0026gt; // controlsList属性目前只支持 chrome 58+ 3 \u0026lt;audio src=\u0026#34;http://65.ierge.cn/12/186/372266.mp3\u0026#34; controls=\u0026#34;controls\u0026#34; controlsList=\u0026#34;nodownload\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br\u0026gt; 4 \u0026lt;audio controls=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;http://65.","title":"Audio 如果你愿意一层一层剥开我的心"},{"content":"1. serve: 在任意目录开启静态文件服务器 https://github.com/zeit/serve 2. lambda-view：优雅的看js源码 https://github.com/Jianru-Lin/lambda-view 3. ConEmu：windows命令行从未如此迷人 https://github.com/Maximus5/ConEmu 4. Wox：天下武功，唯快不破 https://github.com/Wox-launcher/Wox 5. gow：谁说windows不能用linux命令 https://github.com/bmatzelle/gow 6. vimium：像用vim一样用chrome浏览器 https://github.com/philc/vimium 7. localtunnel：将内网地址转化成公网地址 https://github.com/localtunnel/localtunnel 8. Browsersync：省时省力的浏览器同步测试工具 地址：http://www.browsersync.cn/\n9. PM2: 集负载均衡、热更新、监控等功能于一身的Node.js应用程序的生产流程管理器 地址：https://github.com/Unitech/pm2\n","permalink":"https://wdd.js.org/posts/2018/github-powerful-tools-recommend/","summary":"1. serve: 在任意目录开启静态文件服务器 https://github.com/zeit/serve 2. lambda-view：优雅的看js源码 https://github.com/Jianru-Lin/lambda-view 3. ConEmu：windows命令行从未如此迷人 https://github.com/Maximus5/ConEmu 4. Wox：天下武功，唯快不破 https://github.com/Wox-launcher/Wox 5. gow：谁说windows不能用linux命令 https://github.com/bmatzelle/gow 6. vimium：像用vim一样用chrome浏览器 https://github.com/philc/vimium 7. localtunnel：将内网地址转化成公网地址 https://github.com/localtunnel/localtunnel 8. Browsersync：省时省力的浏览器同步测试工具 地址：http://www.browsersync.cn/\n9. PM2: 集负载均衡、热更新、监控等功能于一身的Node.js应用程序的生产流程管理器 地址：https://github.com/Unitech/pm2","title":"github上的那些前端神器"},{"content":"1. Front-End Developer Handbook 2017 地址：https://frontendmasters.com/books/front-end-handbook/2017/ 这是任何人都可以用来了解前端开发实践的指南。它大致概述并讨论了前端工程的实践：如何学习它，以及在2017年实践时使用什么工具。\n这是专门为潜在的和目前实践的前端开发人员提供专业资源，以配备学习材料和开发工具。其次，管理者，首席技术官，导师和猎头人士可以使用它来了解前端开发的实践。\n手册的内容有利于网络技术（HTML，CSS，DOM和JavaScript）以及直接构建在这些开放技术之上的解决方案。本书中引用和讨论的材料是课堂上最好的或目前提出的问题。\n该书不应被视为对前端开发人员可用的所有资源的全面概述。这本书的价值被简单，集中和及时地组织起来，仅仅是足够的绝对信息，以免任何人在任何一个特定的主题上压倒一切。\n目的是每年发布一次内容更新。\n手册分为三部分。\n第一部分。前端实践\n第一部分广泛描述了前端工程的实践。\n第二部分：学习前端发展\n第二部分指出了自主导向和直接的资源，用于学习成为前端开发人员。\n第三部分：前端开发工具\n第三部分简要解释和识别交易工具。\n2. JS函数式编程指南 英文版地址： 中文版地址：https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\n这本书的主题是函数范式（functional paradigm），我们将使用 JavaScript 这个世界上最流行的函数式编程语言来讲述这一主题。有人可能会觉得选择 JavaScript 并不明智，因为当前的主流观点认为它是一门命令式（imperative）的语言，并不适合用来讲函数式。但我认为，这是学习函数式编程的最好方式，因为：\n你很有可能在日常工作中使用它\n这让你有机会在实际的编程过程中学以致用，而不是在空闲时间用一门深奥的函数式编程语言做一些玩具性质的项目。\n你不必从头学起就能开始编写程序\n在纯函数式编程语言中，你必须使用 monad 才能打印变量或者读取 DOM 节点。JavaScript 则简单得多，可以作弊走捷径，因为毕竟我们的目的是学写纯函数式代码。JavaScript 也更容易入门，因为它是一门混合范式的语言，你随时可以在感觉吃力的时候回退到原有的编程习惯上去。\n这门语言完全有能力书写高级的函数式代码\n只需借助一到两个微型类库，JavaScript 就能模拟 Scala 或 Haskell 这类语言的全部特性。虽然面向对象编程（Object-oriented programing）主导着业界，但很明显这种范式在 JavaScript 里非常笨拙，用起来就像在高速公路上露营或者穿着橡胶套鞋跳踢踏舞一样。我们不得不到处使用 bind 以免 this 不知不觉地变了，语言里没有类可以用（目前还没有），我们还发明了各种变通方法来应对忘记调用 new 关键字后的怪异行为，私有成员只能通过闭包（closure）才能实现，等等。对大多数人来说，函数式编程看起来更加自然。+\n以上说明，强类型的函数式语言毫无疑问将会成为本书所示范式的最佳试验场。JavaScript 是我们学习这种范式的一种手段，将它应用于什么地方则完全取决于你自己。幸运的是，所有的接口都是数学的，因而也是普适的。最终你会发现你习惯了 swiftz、scalaz、haskell 和 purescript，以及其他各种数学偏向的语言。\n3. 前端开发笔记本 地址：http://chanshuyi.github.io/frontend_notebook/\n前端开发笔记本涵括了大部分前端开发所需的知识点，主要包括5大部分：《页面制作》、《JavaScript程序设计》、《DOM编程》、《页面架构》、《前端产品架构》。\n","permalink":"https://wdd.js.org/posts/2018/gitbook-good-book-recommend/","summary":"1. Front-End Developer Handbook 2017 地址：https://frontendmasters.com/books/front-end-handbook/2017/ 这是任何人都可以用来了解前端开发实践的指南。它大致概述并讨论了前端工程的实践：如何学习它，以及在2017年实践时使用什么工具。\n这是专门为潜在的和目前实践的前端开发人员提供专业资源，以配备学习材料和开发工具。其次，管理者，首席技术官，导师和猎头人士可以使用它来了解前端开发的实践。\n手册的内容有利于网络技术（HTML，CSS，DOM和JavaScript）以及直接构建在这些开放技术之上的解决方案。本书中引用和讨论的材料是课堂上最好的或目前提出的问题。\n该书不应被视为对前端开发人员可用的所有资源的全面概述。这本书的价值被简单，集中和及时地组织起来，仅仅是足够的绝对信息，以免任何人在任何一个特定的主题上压倒一切。\n目的是每年发布一次内容更新。\n手册分为三部分。\n第一部分。前端实践\n第一部分广泛描述了前端工程的实践。\n第二部分：学习前端发展\n第二部分指出了自主导向和直接的资源，用于学习成为前端开发人员。\n第三部分：前端开发工具\n第三部分简要解释和识别交易工具。\n2. JS函数式编程指南 英文版地址： 中文版地址：https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\n这本书的主题是函数范式（functional paradigm），我们将使用 JavaScript 这个世界上最流行的函数式编程语言来讲述这一主题。有人可能会觉得选择 JavaScript 并不明智，因为当前的主流观点认为它是一门命令式（imperative）的语言，并不适合用来讲函数式。但我认为，这是学习函数式编程的最好方式，因为：\n你很有可能在日常工作中使用它\n这让你有机会在实际的编程过程中学以致用，而不是在空闲时间用一门深奥的函数式编程语言做一些玩具性质的项目。\n你不必从头学起就能开始编写程序\n在纯函数式编程语言中，你必须使用 monad 才能打印变量或者读取 DOM 节点。JavaScript 则简单得多，可以作弊走捷径，因为毕竟我们的目的是学写纯函数式代码。JavaScript 也更容易入门，因为它是一门混合范式的语言，你随时可以在感觉吃力的时候回退到原有的编程习惯上去。\n这门语言完全有能力书写高级的函数式代码\n只需借助一到两个微型类库，JavaScript 就能模拟 Scala 或 Haskell 这类语言的全部特性。虽然面向对象编程（Object-oriented programing）主导着业界，但很明显这种范式在 JavaScript 里非常笨拙，用起来就像在高速公路上露营或者穿着橡胶套鞋跳踢踏舞一样。我们不得不到处使用 bind 以免 this 不知不觉地变了，语言里没有类可以用（目前还没有），我们还发明了各种变通方法来应对忘记调用 new 关键字后的怪异行为，私有成员只能通过闭包（closure）才能实现，等等。对大多数人来说，函数式编程看起来更加自然。+\n以上说明，强类型的函数式语言毫无疑问将会成为本书所示范式的最佳试验场。JavaScript 是我们学习这种范式的一种手段，将它应用于什么地方则完全取决于你自己。幸运的是，所有的接口都是数学的，因而也是普适的。最终你会发现你习惯了 swiftz、scalaz、haskell 和 purescript，以及其他各种数学偏向的语言。\n3. 前端开发笔记本 地址：http://chanshuyi.github.io/frontend_notebook/\n前端开发笔记本涵括了大部分前端开发所需的知识点，主要包括5大部分：《页面制作》、《JavaScript程序设计》、《DOM编程》、《页面架构》、《前端产品架构》。","title":"gitbook 前端好书推荐"},{"content":"1. 少啰嗦，先看代码 1.1. package.json { \u0026#34;name\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;node ./bin/www\u0026#34;, \u0026#34;forever\u0026#34;: \u0026#34;node_modules/forever/bin/forever bin/www\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;async\u0026#34;: \u0026#34;0.9.0\u0026#34;, \u0026#34;body-parser\u0026#34;: \u0026#34;1.13.2\u0026#34;, \u0026#34;compression\u0026#34;: \u0026#34;1.6.2\u0026#34;, \u0026#34;config\u0026#34;: \u0026#34;1.12.0\u0026#34;, \u0026#34;connect-multiparty\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;cookie-parser\u0026#34;: \u0026#34;1.3.5\u0026#34;, \u0026#34;debug\u0026#34;: \u0026#34;2.2.0\u0026#34;, \u0026#34;ejs\u0026#34;: \u0026#34;2.3.3\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;4.13.1\u0026#34;, \u0026#34;forever\u0026#34;: \u0026#34;0.15.3\u0026#34;, \u0026#34;http-proxy-middleware\u0026#34;: \u0026#34;0.17.3\u0026#34;, \u0026#34;log4js\u0026#34;: \u0026#34;0.6.24\u0026#34;, \u0026#34;serve-favicon\u0026#34;: \u0026#34;2.3.0\u0026#34; } } 1.2. dockerfile FROM node:9.2.1-alpine RUN apk update \u0026amp;\u0026amp; apk add bash tzdata \\ \u0026amp;\u0026amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime WORKDIR /app COPY package.json yarn.lock /app/ RUN yarn install --production \u0026amp;\u0026amp; yarn cache clean COPY . /app EXPOSE 8088 CMD yarn run server 2. 分析原理 使用alpine的nodejs镜像，显著缩小nodejs镜像大小 node:9.2.1-alpine自带yarn 和 npm copy package到run npm i到copy . /app, 这样的顺序可以充分使用镜像缓存 修改过后，对比之前通过jenkins打包时间从10分钟缩短到7.4秒\n3. 参考资料 How to write excellent Dockerfiles ","permalink":"https://wdd.js.org/posts/2018/nodejs-best-dockerfile/","summary":"1. 少啰嗦，先看代码 1.1. package.json { \u0026#34;name\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;node ./bin/www\u0026#34;, \u0026#34;forever\u0026#34;: \u0026#34;node_modules/forever/bin/forever bin/www\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;async\u0026#34;: \u0026#34;0.9.0\u0026#34;, \u0026#34;body-parser\u0026#34;: \u0026#34;1.13.2\u0026#34;, \u0026#34;compression\u0026#34;: \u0026#34;1.6.2\u0026#34;, \u0026#34;config\u0026#34;: \u0026#34;1.12.0\u0026#34;, \u0026#34;connect-multiparty\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;cookie-parser\u0026#34;: \u0026#34;1.3.5\u0026#34;, \u0026#34;debug\u0026#34;: \u0026#34;2.2.0\u0026#34;, \u0026#34;ejs\u0026#34;: \u0026#34;2.3.3\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;4.13.1\u0026#34;, \u0026#34;forever\u0026#34;: \u0026#34;0.15.3\u0026#34;, \u0026#34;http-proxy-middleware\u0026#34;: \u0026#34;0.17.3\u0026#34;, \u0026#34;log4js\u0026#34;: \u0026#34;0.6.24\u0026#34;, \u0026#34;serve-favicon\u0026#34;: \u0026#34;2.3.0\u0026#34; } } 1.2. dockerfile FROM node:9.2.1-alpine RUN apk update \u0026amp;\u0026amp; apk add bash tzdata \\ \u0026amp;\u0026amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime WORKDIR /app COPY package.","title":"Nodejs Express dockerfile最佳实践"},{"content":"1. 基本对比 名称 gitbub地址 stars 文档地址 jquery-validation 这里 7859(截止7/21) 这里 Parsley.js 这里 7979(截止7/21) 这里 2. 强烈推荐Parsley 这两个表格验证插件我都用过，最早用的是jqueryValidataion, 现在用Parsley。 这两个插件都依赖jQuery。但是如果说那个跟好用的话，真心推荐Parsley。Parsley号称不用写一行代码就能验证表单。另外从star的数量上也可以看出来Parsley更流行。而且Parsley支持在html中就将错误信息定义在里面。\nParsley优势\n直观的DOM API: 像没有其他表单验证库一样，只需用HTML格式写入您的要求，Parsley将会做剩下的所有事情！不需要编写一行代码来验证表单。 动态表单验证： parsley现在更聪明，它会自动检测您的表单的修改并相应地调整其验证。简单地添加，删除或编辑字段，parsley将会自动验证。 还有好多\u0026hellip; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; required=\u0026#34;\u0026#34; data-parsley-checkphonenum data-parsley-checkphonenum-message=\u0026#34;手机号码格式有误\u0026#34; name=\u0026#34;phoneNum\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;请填写手机号\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; //验证表单 // 注意 checkphonenum是我自定义的验证规则，添加到parsley里面的 $(\u0026#39;from\u0026#39;).parsley().validate(); ","permalink":"https://wdd.js.org/posts/2018/jquery-validation-vs-parsley/","summary":"1. 基本对比 名称 gitbub地址 stars 文档地址 jquery-validation 这里 7859(截止7/21) 这里 Parsley.js 这里 7979(截止7/21) 这里 2. 强烈推荐Parsley 这两个表格验证插件我都用过，最早用的是jqueryValidataion, 现在用Parsley。 这两个插件都依赖jQuery。但是如果说那个跟好用的话，真心推荐Parsley。Parsley号称不用写一行代码就能验证表单。另外从star的数量上也可以看出来Parsley更流行。而且Parsley支持在html中就将错误信息定义在里面。\nParsley优势\n直观的DOM API: 像没有其他表单验证库一样，只需用HTML格式写入您的要求，Parsley将会做剩下的所有事情！不需要编写一行代码来验证表单。 动态表单验证： parsley现在更聪明，它会自动检测您的表单的修改并相应地调整其验证。简单地添加，删除或编辑字段，parsley将会自动验证。 还有好多\u0026hellip; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; required=\u0026#34;\u0026#34; data-parsley-checkphonenum data-parsley-checkphonenum-message=\u0026#34;手机号码格式有误\u0026#34; name=\u0026#34;phoneNum\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;请填写手机号\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; //验证表单 // 注意 checkphonenum是我自定义的验证规则，添加到parsley里面的 $(\u0026#39;from\u0026#39;).parsley().validate(); ","title":"表单验证工具 jquery-validation Vs Parsley"},{"content":"先看效果：\n1. 环境 win7 64位 python 3.5 2. 目标 抓取一篇报纸，并提取出关键字，然后按照出现次数排序，用echarts在页面上显示出来。\n3. 工具选择 因为之前对nodejs的相关工具比较熟悉，在用python的时候，也想有类似的工具。所以就做了一个对比的表格。\n功能 nodejs版 python版 http工具 request requests 中文分词工具 node-segment, nodejieba(一直没有安装成功过) jieba(分词准确度比node-segment好) DOM解析工具 cheeio pyquery(这两个工具都是有类似jQuery那种选择DOM的接口，很方便) 函数编程工具 underscore.js underscore.py(underscore来处理集合比较方便) 服务器 express flask 4. 开始的噩梦：中文乱码 感觉每个学python的人都遇到过中文乱码的问题。我也不例外。\n首先要抓取网页，但是网页在控制台输出的时候，中文总是乱码。搞了好久，搞得我差点要放弃python。最终找到解决方法。 解决python3 UnicodeEncodeError: \u0026lsquo;gbk\u0026rsquo; codec can\u0026rsquo;t encode character \u0026lsquo;\\xXX\u0026rsquo; in position XX\n过程很艰辛，但是从中也学到很多知识。\nimport io import sys sys.stdout = io.TextIOWrapper(sys.stoodout.buffer,encoding=\u0026#39;gb18030\u0026#39;) 5. 函数式编程： 顺享丝滑 #filename word_rank.py import requests import io import re import sys import jieba as _jieba # 中文分词比较优秀的一个库 from pyquery import PyQuery as pq #类似于jquery、cheerio的库 from underscore import _ # underscore.js python版本 sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=\u0026#39;gb18030\u0026#39;) # 解决控制台中文乱码 USELESSWORDS = [\u0026#39;的\u0026#39;,\u0026#39;要\u0026#39;,\u0026#39;了\u0026#39;,\u0026#39;在\u0026#39;,\u0026#39;和\u0026#39;,\u0026#39;是\u0026#39;,\u0026#39;把\u0026#39;,\u0026#39;向\u0026#39;,\u0026#39;上\u0026#39;,\u0026#39;为\u0026#39;,\u0026#39;等\u0026#39;,\u0026#39;个\u0026#39;] # 标记一些无用的单词 TOP = 30 # 只要前面的30个就可以了 def _remove_punctuation(line): # 移除非中文字符 # rule = re.compile(\u0026#34;[^a-zA-Z0-9\\u4e00-\\u9fa5]\u0026#34;) rule = re.compile(\u0026#34;[^\\u4e00-\\u9fa5]\u0026#34;) line = rule.sub(\u0026#39;\u0026#39;,line) return line def _calculate_frequency(words): # 计算分词出现的次数 result = {} res = [] for word in words: if result.get(word, -1) == -1: result[word] = 1 else: result[word] += 1 for word in result: if _.contains(USELESSWORDS, word): # 排除无用的分词 continue res.append({ \u0026#39;word\u0026#39;: word, \u0026#39;fre\u0026#39;: result[word] }) return _.sortBy(res, \u0026#39;fre\u0026#39;)[::-1][:TOP] # 降序排列 def _get_page(url): # 获取页面 return requests.get(url) def _get_text(req): # 获取文章部分 return pq(req.content)(\u0026#39;#ozoom\u0026#39;).text() def main(url): # 入口函数，函数组合 return _.compose( _get_page, _get_text, _remove_punctuation, _jieba.cut, _calculate_frequency )(url) 6. python服务端：Flask浅入浅出 import word_rank from flask import Flask, request, jsonify, render_template app = Flask(__name__) app.debug = True @app.route(\u0026#39;/rank\u0026#39;) # 从query参数里获取pageUrl，并给分词排序 def getRank(): pageUrl = request.args.get(\u0026#39;pageUrl\u0026#39;) app.logger.debug(pageUrl) rank = word_rank.main(pageUrl) app.logger.debug(rank) return jsonify(rank) @app.route(\u0026#39;/\u0026#39;) # 主页面 def getHome(): return render_template(\u0026#39;home.html\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app.run() 7. 总结 据说有个定律：凡是能用JavaScript写出来的，最终都会用JavaScript写出来。 我是很希望这样啦。但是不得不承认，python上有很多非常优秀的库。 这些库在npm上并没有找到合适的替代品。\n所以，我就想: 如何能用nodejs直接调用python的第三方库\n目前的解决方案有两种，第一，只用nodejs的child_processes。这个方案我试过，但是不太好用。\n第二，npm里面有一些包，可以直接调用python的库。例如：node-python, python.js, 但是这些包我在win7上安装的时候总是报错。而且解决方法也蛮麻烦的。索性我就直接用python了。\n最后附上项目地址：https://github.com/wangduanduan/read-newspaper\n","permalink":"https://wdd.js.org/posts/2018/python-paper-word-split/","summary":"先看效果：\n1. 环境 win7 64位 python 3.5 2. 目标 抓取一篇报纸，并提取出关键字，然后按照出现次数排序，用echarts在页面上显示出来。\n3. 工具选择 因为之前对nodejs的相关工具比较熟悉，在用python的时候，也想有类似的工具。所以就做了一个对比的表格。\n功能 nodejs版 python版 http工具 request requests 中文分词工具 node-segment, nodejieba(一直没有安装成功过) jieba(分词准确度比node-segment好) DOM解析工具 cheeio pyquery(这两个工具都是有类似jQuery那种选择DOM的接口，很方便) 函数编程工具 underscore.js underscore.py(underscore来处理集合比较方便) 服务器 express flask 4. 开始的噩梦：中文乱码 感觉每个学python的人都遇到过中文乱码的问题。我也不例外。\n首先要抓取网页，但是网页在控制台输出的时候，中文总是乱码。搞了好久，搞得我差点要放弃python。最终找到解决方法。 解决python3 UnicodeEncodeError: \u0026lsquo;gbk\u0026rsquo; codec can\u0026rsquo;t encode character \u0026lsquo;\\xXX\u0026rsquo; in position XX\n过程很艰辛，但是从中也学到很多知识。\nimport io import sys sys.stdout = io.TextIOWrapper(sys.stoodout.buffer,encoding=\u0026#39;gb18030\u0026#39;) 5. 函数式编程： 顺享丝滑 #filename word_rank.py import requests import io import re import sys import jieba as _jieba # 中文分词比较优秀的一个库 from pyquery import PyQuery as pq #类似于jquery、cheerio的库 from underscore import _ # underscore.","title":"前端小白的python实战 报纸分词排序"},{"content":" 1 关心你的技艺 2 思考你的工作 3 在所有的弱点中，最大的弱点就是害怕暴露弱点 4 提供各种选择，不要找各种蹩脚的借口 5 不要容忍破窗户 6 作变化的催化剂 7 记住大方向 8 让质量成为需求问题 9 知识也会贬值，定期为你的知识投资 每年至少学习一种编程语言 每季度至少读一本技术书籍 也要阅读非技术书籍 上课 上网 玩玩UNIX 跟上潮流 10 批判的分析你读到的和听到的 11 我相信，被打量要被忽略要好 12 你说什么和你怎样说同样重要 13 不要重复你自己, 也不要重复别人 14 糟糕的代码才需要许多注释 15 让复用变得容易 16 消除无关事物之间的影响 (解耦性，正交性) 17 编码 让你的代码保持解耦 避免使用全局数据 避免编写相似的函数 18 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了 19 不存在最终决定 20 稍后就是永不 21 用曳光弹找到目标 22 语言的界限就是一个人世界的界限 23 靠近问题编程 24 估算，避免发生意外 25 用纯文本保存知识 26 利用命令shells的力量 27 用好一种编辑器，彻底了解它，确保你的编辑器能在所有平台上使用 (我现在最爱是vscode, 曾经最爱是sublime) 可配置 可扩展 可编辑 语法高亮 自动完成 自动缩进 跨平台 启动快 占用内存小 漂亮 28 总是使用源码控制 29 要修正问题，而不是发出职责 (关于调试，bug) 30 不要恐慌 (我曾经差点因为上线的之前的重大问题产生辞职的想法) 31 不要假定，要证明 32 你不可能写出完美的软件 33 如果它不可能发生，用断言确保它不会发生 34 将异常用于异常的问题 35 要有始有终 36 使模块之间的耦合减至最小 37 要配置，不要集成 (可配置) 38 将抽象放进代码，将细节放进元数据 39 分析工作流，以改善并发性 40 用服务进行设计 41 总是为并发进行设计 42 将视图与模型分离 43 小心那些替你编写大量代码的工具，除非你了解它在做什么 44 不要靠巧合编程 45 估算你算法的阶 46 早重构，常重构 47 为测试而设计 48 不要搜集需求，挖掘他们 49 与用户一起工作，以像用户一样思考 50 需求不是架构，需求不是设计，也不是用户界面，而是需求。 51 抽象比细节活的更长久 52 使用项目词汇表 (名不正则言不顺) 53 昂贵的工具不一定能制作出更好的设计 54 早测试，常测试，自动测试 55 要到通过全部测试，编码才算完成 56 把网收紧，一个bug只抓一次 57 温和的超出用户的期望 58 在你的作品上签名 59 建立自己的藏书库 ","permalink":"https://wdd.js.org/posts/2018/how-to-be-a-better-programer/","summary":" 1 关心你的技艺 2 思考你的工作 3 在所有的弱点中，最大的弱点就是害怕暴露弱点 4 提供各种选择，不要找各种蹩脚的借口 5 不要容忍破窗户 6 作变化的催化剂 7 记住大方向 8 让质量成为需求问题 9 知识也会贬值，定期为你的知识投资 每年至少学习一种编程语言 每季度至少读一本技术书籍 也要阅读非技术书籍 上课 上网 玩玩UNIX 跟上潮流 10 批判的分析你读到的和听到的 11 我相信，被打量要被忽略要好 12 你说什么和你怎样说同样重要 13 不要重复你自己, 也不要重复别人 14 糟糕的代码才需要许多注释 15 让复用变得容易 16 消除无关事物之间的影响 (解耦性，正交性) 17 编码 让你的代码保持解耦 避免使用全局数据 避免编写相似的函数 18 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了 19 不存在最终决定 20 稍后就是永不 21 用曳光弹找到目标 22 语言的界限就是一个人世界的界限 23 靠近问题编程 24 估算，避免发生意外 25 用纯文本保存知识 26 利用命令shells的力量 27 用好一种编辑器，彻底了解它，确保你的编辑器能在所有平台上使用 (我现在最爱是vscode, 曾经最爱是sublime) 可配置 可扩展 可编辑 语法高亮 自动完成 自动缩进 跨平台 启动快 占用内存小 漂亮 28 总是使用源码控制 29 要修正问题，而不是发出职责 (关于调试，bug) 30 不要恐慌 (我曾经差点因为上线的之前的重大问题产生辞职的想法) 31 不要假定，要证明 32 你不可能写出完美的软件 33 如果它不可能发生，用断言确保它不会发生 34 将异常用于异常的问题 35 要有始有终 36 使模块之间的耦合减至最小 37 要配置，不要集成 (可配置) 38 将抽象放进代码，将细节放进元数据 39 分析工作流，以改善并发性 40 用服务进行设计 41 总是为并发进行设计 42 将视图与模型分离 43 小心那些替你编写大量代码的工具，除非你了解它在做什么 44 不要靠巧合编程 45 估算你算法的阶 46 早重构，常重构 47 为测试而设计 48 不要搜集需求，挖掘他们 49 与用户一起工作，以像用户一样思考 50 需求不是架构，需求不是设计，也不是用户界面，而是需求。 51 抽象比细节活的更长久 52 使用项目词汇表 (名不正则言不顺) 53 昂贵的工具不一定能制作出更好的设计 54 早测试，常测试，自动测试 55 要到通过全部测试，编码才算完成 56 把网收紧，一个bug只抓一次 57 温和的超出用户的期望 58 在你的作品上签名 59 建立自己的藏书库 ","title":"【笔记】 程序员修炼之道 从小工到专家"},{"content":" 1. VisualEvent github地址： https://github.com/DataTables/VisualEvent\n2. 使用教程 打开http://sprymedia.co.uk/VisualEvent/这个页面，然后将visual Event连接拖动到浏览器的书签栏上 随便打开一个页面，然后点击VisualEvent书签后，页面就变成这样了。鼠标移动到蓝色或者黄色边框的元素上，相应得逻辑代码就会出现。截图左下角蓝色长条上有一些有用的信息，最左边有个关闭的按钮。\n3. 最后 VisualEvent并不是万能的，Vue绑定的事件它就无法检测出来。当然Vue的事件是直接写在Dom上的，根本无需定位。 工欲善其事必先利其器，多一个工具总是好的，万一真有需要呢。\n","permalink":"https://wdd.js.org/posts/2018/visual-event-tool/","summary":"1. VisualEvent github地址： https://github.com/DataTables/VisualEvent\n2. 使用教程 打开http://sprymedia.co.uk/VisualEvent/这个页面，然后将visual Event连接拖动到浏览器的书签栏上 随便打开一个页面，然后点击VisualEvent书签后，页面就变成这样了。鼠标移动到蓝色或者黄色边框的元素上，相应得逻辑代码就会出现。截图左下角蓝色长条上有一些有用的信息，最左边有个关闭的按钮。\n3. 最后 VisualEvent并不是万能的，Vue绑定的事件它就无法检测出来。当然Vue的事件是直接写在Dom上的，根本无需定位。 工欲善其事必先利其器，多一个工具总是好的，万一真有需要呢。","title":"定位神器：1秒定位DOM元素绑定的事件代码的位置"},{"content":"1. HTTPS域向HTTP域发送请求会被浏览器直接拒绝，HTTP向HTTPS则不会 例如在github pages页面，这是一个https页面，如果在这个页面向http发送请求，那么会直接被浏览器拒绝，并在控制台输出下面的报错信息。\njquery-1.11.3.min.js:5 Mixed Content: The page at \u0026#39;https://wangduanduan.github.io/ddddddd/\u0026#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint \u0026#39;http://cccccc/log/conf?token=welljoint\u0026#39;. This request has been blocked; the content must be served over HTTPS. 如果你在做第三方集成的系统，如果他们是在浏览器中直接调用你提供的接口，那么最好你使用https协议，这样无论对方是https还是http都可以访问。（相信我，这个很重要，我曾经经历过上线后遇到这个问题，然后连夜申请证书，把http升级到https的痛苦经历）\n2. HTTPS的默认端口是443，而不是443 如果443端口已经被其他服务占用了，那么使用其他任何没有被占用的端口都可以用作HTTPS服务，只不过在请求的时候需要加上端口号罢了。\n3. 如何快速隐藏一个DOM元素 选中一个元素，然后按h,这时候就会在选中的DOM元素上加上__web-inspector-hide-shortcut__类，这个类会让元素隐藏。谷歌和火狐上都可以，IE上没有试过行不行。\n","permalink":"https://wdd.js.org/posts/2018/you-dont-know-https-and-http/","summary":"1. HTTPS域向HTTP域发送请求会被浏览器直接拒绝，HTTP向HTTPS则不会 例如在github pages页面，这是一个https页面，如果在这个页面向http发送请求，那么会直接被浏览器拒绝，并在控制台输出下面的报错信息。\njquery-1.11.3.min.js:5 Mixed Content: The page at \u0026#39;https://wangduanduan.github.io/ddddddd/\u0026#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint \u0026#39;http://cccccc/log/conf?token=welljoint\u0026#39;. This request has been blocked; the content must be served over HTTPS. 如果你在做第三方集成的系统，如果他们是在浏览器中直接调用你提供的接口，那么最好你使用https协议，这样无论对方是https还是http都可以访问。（相信我，这个很重要，我曾经经历过上线后遇到这个问题，然后连夜申请证书，把http升级到https的痛苦经历）\n2. HTTPS的默认端口是443，而不是443 如果443端口已经被其他服务占用了，那么使用其他任何没有被占用的端口都可以用作HTTPS服务，只不过在请求的时候需要加上端口号罢了。\n3. 如何快速隐藏一个DOM元素 选中一个元素，然后按h,这时候就会在选中的DOM元素上加上__web-inspector-hide-shortcut__类，这个类会让元素隐藏。谷歌和火狐上都可以，IE上没有试过行不行。","title":"可能被遗漏的https与http的知识点"},{"content":"英文好的，直接看原文\nhttps://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools\n1. 要求 Node.js 6.3+ Chrome 55+ 2. 操作步骤 1 打开连接 chrome://flags/#enable-devtools-experiments 2 开启开发者工具实验性功能 3 重启浏览器 4 打开 DevTools Setting -\u0026gt; Experiments tab 5 按6次shift后，隐藏的功能会出现，勾选\u0026quot;Node debugging\u0026quot; 3. 运行程序 必须要有 --inspect\n\u0026gt; node --inspect www Debugger listening on port 9229. Warning: This is an experimental feature and could change at any time. To start debugging, open the following URL in Chrome: chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true\u0026amp;v8only=true\u0026amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf 将这个地址粘贴到谷歌浏览器：chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true\u0026amp;v8only=true\u0026amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf\n程序后端输出的日志也回输出到谷歌浏览器的console里面，同时也可以在Sources里进行断点调试了。 ","permalink":"https://wdd.js.org/posts/2018/debug-nodejs-in-chrome-devtool/","summary":"英文好的，直接看原文\nhttps://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools\n1. 要求 Node.js 6.3+ Chrome 55+ 2. 操作步骤 1 打开连接 chrome://flags/#enable-devtools-experiments 2 开启开发者工具实验性功能 3 重启浏览器 4 打开 DevTools Setting -\u0026gt; Experiments tab 5 按6次shift后，隐藏的功能会出现，勾选\u0026quot;Node debugging\u0026quot; 3. 运行程序 必须要有 --inspect\n\u0026gt; node --inspect www Debugger listening on port 9229. Warning: This is an experimental feature and could change at any time. To start debugging, open the following URL in Chrome: chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true\u0026amp;v8only=true\u0026amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf 将这个地址粘贴到谷歌浏览器：chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true\u0026amp;v8only=true\u0026amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf\n程序后端输出的日志也回输出到谷歌浏览器的console里面，同时也可以在Sources里进行断点调试了。 ","title":"直接在Chrome DevTools调试Node.js"},{"content":" 本文是译文，原文是https://da-14.com/blog/top-11-javascript-libraries-are-worth-your-attention 我在原文的基础上加了百度的Echats图表库，这个也是毫不逊色其他图表库的。另外Handsontable电子表格库也是蛮好玩的。\n前端开发工具在过去几年中取得了进步和成功。这些日子，JS库和框架可以简化工作流程，提高开发过程，并在响应式设计方面提供更好的功能。\n考虑到一个长的JavaScript库列表，它可能是挑战选择，那是值得的时间和精力。我们已经讨论了最好的JavaScript框架，今天我们想研究JS库中的新星。你可能听说过像jQuery或React这样的大名字，这是最有用的JavaScript库之一，虽然有很多其他解决方案。\n一些库是几乎必须在每个其他项目应用，而其他的更集中和用于执行应用程序中的特定功能。为了清楚起见，我们按类型分组了最好的JavaScript库，所以让我们开始。\n1. 图表类 1.1. D3 D3.js（数据驱动文档）通常被称为最强大的开源JavaScript可视化库。它的生态系统包括几十个插件和其他库建立在D3js的顶部。同时，支持社区和大量的文档可以帮助您立即开始。\nD3符合W3C网络标准，几乎支持所有现代浏览器。尽管事实上它不包括任何预先构建的图表，它提供了许多例子和“输入和退出”选择，容易的调试过程和强大的转换等有用的功能。\n1.2. Chart.js Chart.js是一个简单的开源解决方案，用于小项目和这些情况下，当你需要快速创建图表。它有八种图表类型和混合它们的能力，外加令人惊叹的动画选项开箱。强烈建议使用此JavaScript图形库，以便简单的设置过程，工作灵活性和全面的文档，尽管其功能相当有限。 Chartist.js具有类似的功能，而它是基于SVG，而不是HTML5画布在Chartjs。\n1.3. FusionCharts FusionCharts是迄今为止最好的JavaScript图表库。作为设计师和开发者最全面的解决方案，它包括90多种图表类型和1000个地图，将Google图表和MetricsGraphics保留在后面。\n今天FusionCharts可以拥有超过24,000个客户，其中包括白宫，Oracle，IBM，微软，谷歌等等。作为最流行的JavaScript库之一，它是高度可扩展的，并与各种设备和浏览器，包括IE 6,7和8兼容。但是，水印版本可以免费使用商业和个人项目，但删除水印你需要购买许可证。\n1.4. Google Charts Google图表允许您构建从纯色图表到复杂树形图的所有内容。它配备了广泛的预构建的图表库，各种数据工具和多个自定义选项。 HTML5和SVG上的基础图表​​此库确保跨浏览器和跨平台兼容性，而对于较旧的IE版本，它包括VML。\n由于详细的文档，代码注释和分步说明，Google Charts工具可以成为任何人谁想要使用JavaScript构建图表的一个很好的起点。但是，由于文件是从Google的服务器上传的，因此您的Web JavaScript应用程序应该在线以查看图表。\n1.5. Echarts（百度出品） 更小文件 更大作为\n更小体积的文件，满足更轻便的使用需求 更灵活的打包方式，可自由选择你需要的图表和组件 移动端强势来袭\n良好的自适应效果 专属的移动端交互体验 更丰富的可视化效果\n新增更多图表类型，更好的满足不同数据的处理需求 更多的搭配方案让你的数据呈现方式更个性和完美 2. 动画 2.1. GSAP GSAP（GreenSock动画平台）是一个先进的动画解决方案，由全球最大的企业使用创建惊人的互动动画，没有麻烦。它被超过200万网站雇用，在他们的客户中，你可以找到像福特，耐克，Adobe，微软，三星和许多其他的伟大的名字。\nGSAP与新旧浏览器以及移动设备高度兼容。在顶级功能SVG支持，使任何DOM元素可拖动，可旋转或可滑动滚动和快速性能的能力。它还带有定向旋转，3D变换，模块化架构，快速加载，零依赖性等等。\n2.2. Bounce.js Bounce.js是一个整洁的JavaScript动画库，使您能够创建有吸引力的CSS3动力的动画，像饼图一样简单。它有10个预设，如旋转，旋风，果冻，公路跑步者和其他人，以生成平滑的动画，任何网页设计或自定义项目。\n这个库是绝对免费的和MIT许可的，它是一个不错的选择，在那些情况下，当你不需要一个长列表的动画类型，寻找实验或只是尝试你的手在动画。\n3. Animate.css Animate.css是一个平滑的CSS库，允许您添加整洁的动画到所选对象。它具有超过50种不同的预设，可以应用于文本，形式，对象和CSS3的图片。由于小文件大小，跨浏览器支持和易于使用它可以是一个非常适合移动项目，滑块，主页等。\n4. 时间日期 4.1. Moment.js Moment.js是一个简单和轻量级的日期库，使解析，操作和格式化日期和时间容易和准确。它具有多语言支持，持续时间，日历时间和各种插件，以获得诸如时区支持，Twitter集成等功能。但重要的是，它消除了使用本机JavaScript日期对象的需要，随后促进复杂解析过程和减少代码量。\n4.2. Date-fns Date-fns是一个高级工具集，用于在浏览器和Node.js中操作时间和日期。它提供了140多个有用的功能，可以通过简单的API轻松访问。由于模块化结构，它允许您只选择您当前需要的项目的那些功能。\n5. 其他 5.1. Math.js Math.js是JavaScript引擎的开源数学库。它有许多函数和常量，灵活的表达式解析器，以及支持复杂和大数字，单位，字符串，分数，矩阵，数组和符号计算。\n5.2. Handsontable Handsontable是一个无障碍的JavaScript电子表格库用于构建一流的Web应用程序。它可以轻松地扩展和修改与自定义插件。由开发人员为开发人员建造，它确保快速和容易的开始，方便的模块化结构和活跃的社区支持。这个表库包括超过30个功能的免费版本和额外的10+功能的专业版。目前Handsontable用于销售报告，人力规划，数据合并，数据库编辑等领域。\n","permalink":"https://wdd.js.org/posts/2018/top-11-javascript-libraries-are-worth-your-attention/","summary":"本文是译文，原文是https://da-14.com/blog/top-11-javascript-libraries-are-worth-your-attention 我在原文的基础上加了百度的Echats图表库，这个也是毫不逊色其他图表库的。另外Handsontable电子表格库也是蛮好玩的。\n前端开发工具在过去几年中取得了进步和成功。这些日子，JS库和框架可以简化工作流程，提高开发过程，并在响应式设计方面提供更好的功能。\n考虑到一个长的JavaScript库列表，它可能是挑战选择，那是值得的时间和精力。我们已经讨论了最好的JavaScript框架，今天我们想研究JS库中的新星。你可能听说过像jQuery或React这样的大名字，这是最有用的JavaScript库之一，虽然有很多其他解决方案。\n一些库是几乎必须在每个其他项目应用，而其他的更集中和用于执行应用程序中的特定功能。为了清楚起见，我们按类型分组了最好的JavaScript库，所以让我们开始。\n1. 图表类 1.1. D3 D3.js（数据驱动文档）通常被称为最强大的开源JavaScript可视化库。它的生态系统包括几十个插件和其他库建立在D3js的顶部。同时，支持社区和大量的文档可以帮助您立即开始。\nD3符合W3C网络标准，几乎支持所有现代浏览器。尽管事实上它不包括任何预先构建的图表，它提供了许多例子和“输入和退出”选择，容易的调试过程和强大的转换等有用的功能。\n1.2. Chart.js Chart.js是一个简单的开源解决方案，用于小项目和这些情况下，当你需要快速创建图表。它有八种图表类型和混合它们的能力，外加令人惊叹的动画选项开箱。强烈建议使用此JavaScript图形库，以便简单的设置过程，工作灵活性和全面的文档，尽管其功能相当有限。 Chartist.js具有类似的功能，而它是基于SVG，而不是HTML5画布在Chartjs。\n1.3. FusionCharts FusionCharts是迄今为止最好的JavaScript图表库。作为设计师和开发者最全面的解决方案，它包括90多种图表类型和1000个地图，将Google图表和MetricsGraphics保留在后面。\n今天FusionCharts可以拥有超过24,000个客户，其中包括白宫，Oracle，IBM，微软，谷歌等等。作为最流行的JavaScript库之一，它是高度可扩展的，并与各种设备和浏览器，包括IE 6,7和8兼容。但是，水印版本可以免费使用商业和个人项目，但删除水印你需要购买许可证。\n1.4. Google Charts Google图表允许您构建从纯色图表到复杂树形图的所有内容。它配备了广泛的预构建的图表库，各种数据工具和多个自定义选项。 HTML5和SVG上的基础图表​​此库确保跨浏览器和跨平台兼容性，而对于较旧的IE版本，它包括VML。\n由于详细的文档，代码注释和分步说明，Google Charts工具可以成为任何人谁想要使用JavaScript构建图表的一个很好的起点。但是，由于文件是从Google的服务器上传的，因此您的Web JavaScript应用程序应该在线以查看图表。\n1.5. Echarts（百度出品） 更小文件 更大作为\n更小体积的文件，满足更轻便的使用需求 更灵活的打包方式，可自由选择你需要的图表和组件 移动端强势来袭\n良好的自适应效果 专属的移动端交互体验 更丰富的可视化效果\n新增更多图表类型，更好的满足不同数据的处理需求 更多的搭配方案让你的数据呈现方式更个性和完美 2. 动画 2.1. GSAP GSAP（GreenSock动画平台）是一个先进的动画解决方案，由全球最大的企业使用创建惊人的互动动画，没有麻烦。它被超过200万网站雇用，在他们的客户中，你可以找到像福特，耐克，Adobe，微软，三星和许多其他的伟大的名字。\nGSAP与新旧浏览器以及移动设备高度兼容。在顶级功能SVG支持，使任何DOM元素可拖动，可旋转或可滑动滚动和快速性能的能力。它还带有定向旋转，3D变换，模块化架构，快速加载，零依赖性等等。\n2.2. Bounce.js Bounce.js是一个整洁的JavaScript动画库，使您能够创建有吸引力的CSS3动力的动画，像饼图一样简单。它有10个预设，如旋转，旋风，果冻，公路跑步者和其他人，以生成平滑的动画，任何网页设计或自定义项目。\n这个库是绝对免费的和MIT许可的，它是一个不错的选择，在那些情况下，当你不需要一个长列表的动画类型，寻找实验或只是尝试你的手在动画。\n3. Animate.css Animate.css是一个平滑的CSS库，允许您添加整洁的动画到所选对象。它具有超过50种不同的预设，可以应用于文本，形式，对象和CSS3的图片。由于小文件大小，跨浏览器支持和易于使用它可以是一个非常适合移动项目，滑块，主页等。\n4. 时间日期 4.1. Moment.js Moment.js是一个简单和轻量级的日期库，使解析，操作和格式化日期和时间容易和准确。它具有多语言支持，持续时间，日历时间和各种插件，以获得诸如时区支持，Twitter集成等功能。但重要的是，它消除了使用本机JavaScript日期对象的需要，随后促进复杂解析过程和减少代码量。\n4.2. Date-fns Date-fns是一个高级工具集，用于在浏览器和Node.js中操作时间和日期。它提供了140多个有用的功能，可以通过简单的API轻松访问。由于模块化结构，它允许您只选择您当前需要的项目的那些功能。\n5. 其他 5.1. Math.js Math.js是JavaScript引擎的开源数学库。它有许多函数和常量，灵活的表达式解析器，以及支持复杂和大数字，单位，字符串，分数，矩阵，数组和符号计算。\n5.2. Handsontable Handsontable是一个无障碍的JavaScript电子表格库用于构建一流的Web应用程序。它可以轻松地扩展和修改与自定义插件。由开发人员为开发人员建造，它确保快速和容易的开始，方便的模块化结构和活跃的社区支持。这个表库包括超过30个功能的免费版本和额外的10+功能的专业版。目前Handsontable用于销售报告，人力规划，数据合并，数据库编辑等领域。","title":"12个值得关注的顶级JS库"},{"content":"原文地址：https://hackernoon.com/few-simple-rules-for-good-coding-my-15-years-experience-96cb29d4acd9#.ddzpjb80c\n嗨，我的工作作为一个程序员超过15年，并使用许多不同的语言，范例，框架和其他狗屎。我想和大家分享我写好代码的规则。\n1. 优化VS可读性 去他妈的优化 始终编​​写易于阅读且对开发人员可理解的代码。因为在硬可读代码上花费的时间和资源将远远高于从优化中获得的。 如果你需要进行优化，那么使它像DI的独立模块，具有100％的测试覆盖率，并且不会被触及至少一年。\n2. 架构第一 我看到很多人说“我们需要快速做事，我们没有时间做架构”。其中约99％的人因为这样的想法而遇到了大问题。 编写代码而不考虑其架构是没有用的，就像没有实现它们的计划一样，梦想你的愿望。 在编写代码的第一行之前，你应该明白它将要做什么，它将如何使用，模块，服务如何相互工作，它将有什么结构，如何进行测试和调试，以及如何更新。\n3. 测试覆盖率 测试是好事，但他们并不总是负担得起，对项目有意义。\n当你需要测试：\n当你编写模块时，微服务将不会被触及至少一个月。 当你编写开源代码。 当你编写涉及金融渠道的核心代码或代码。 当您有代码更新的同时更新测试的资源。 当你不需要测试时：\n当你是一个创业。 当你有小团队和代码更改是快速。 当你编写的脚本，可以简单地通过他们的输出手动测试。 记住，带有严格测试的代码可能比没有测试的代码更有害。\n4. 保持简单，极度简单 不要编写复杂的代码。更多更简单，那么更少的错误它可能有和更少的时间来调试它们。代码应该做的只是它需要没有非常多的抽象和其他OOP shit（尤其是涉及java开发人员）+ 20％的东西可能需要在将来以简单的方式更新它。\n5. 注释 出现注释说明你的代码不够好。好的代码应该是可以理解的，没有一行注释。但是如何为新开发人员节省时间？ - 编写简单的内联文档描述什么和如何方法工作。这将节省很多时间来理解，甚至更多 - 它将给人们更多的机会来提出更好的实施这种方法。并且它将是全球代码文档的良好开端。\n6. 硬耦合VS较小耦合 始终尝试使用微服务架构。单片软件可以比微服务软件运行得更快，但只能在一个服务器的上下文中运行。 微服务使您可以不仅在许多服务器上，而且有时甚至在一台机器上（我的意思是过程分发）高效地分发您的软件。\n7. 代码审查 代码审查可以是好的，也以是坏的。 您可以组织代码审查，只有当您有开发人员了解95％的代码，谁可以监控所有更新，而不浪费很多时间。在其他情况下，这将是只是耗时，每个人都会讨厌这个。\n在这部分有很多问题，所以更深入地描述这一点。\n许多人认为代码审查是一个很好的方式教新手，或者工作在不同部分的代码的队友。但是代码审查的主要目标是保持代码质量，而不是教学。让我们想象你的团队制作代码用于控制核反应堆或太空火箭发动机的冷却系统。你在非常硬的逻辑中犯了巨大的错误，然后你给这个代码审查新的家伙。你怎么认为会发生意外的风险？ - 我的练习率超过70％。\n良好的团队是每个人都有自己的角色，负责确切的工作。如果有人想要理解另一段代码，那么他去一个负责任去问他。你不可能知道一切，更好的优秀的理解小块代码而不是理解所有。\n8. 重构没啥用 在我的职业生涯中，我听到很多次“不要担心，我们以后会重构它”。在未来，这会导致大的技术债务或从头开始删除所有的代码和写作。\n所以，不要得到一个债务，除非你有钱从头开发你的软件几次。\n9. 当你累了或在一个坏的心情不要写代码。 当开发人员厌倦时，他们正在制造2到5倍或者更多的bug。所以工作更多是非常糟糕的做法。这就是为什么越来越多的国家思考6小时工作日，其中一些已经有了。精神工作不同于使用你的二头肌。\n10. 不要一次写全部 - 使开发迭代 在编写代码分析和预测之前，您的客户/客户真正需要什么，然后选择您可以在短期内以高质量开发的MVF（最有价值的功能）。使用这样的迭代来部署质量更新，而不是腰部时间和资源对不合理的愿望和牺牲与质量。\n11. 自动化VS手动 自动化是长期的100％成功。所以如果你有资源自动化的东西，现在应该做。你可能认为“只需要5分钟，为什么我应该自动化？但让我计算这个。例如，它是5个开发人员的日常任务。 5分钟* 5天* 21天* 12个月= 6 300分钟= 105小时= 13.125天〜5250 $。 如果你有40 000名员工，这将需要多少费用？\n12. 出去浪，学习新爱好 差异化工作可以增加心智能力，并提供新想法。所以，暂停现在的工作，出去呼吸一下新鲜空气，与朋友交谈，弹吉他等。 ps: 莫春者，春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归。------《论语.先进》。\n13. 在空闲时间学习新事物 当人们停止学习时，他们开始退化。\n","permalink":"https://wdd.js.org/posts/2018/few-simple-rules-for-good-coding-my-15-years-experience/","summary":"原文地址：https://hackernoon.com/few-simple-rules-for-good-coding-my-15-years-experience-96cb29d4acd9#.ddzpjb80c\n嗨，我的工作作为一个程序员超过15年，并使用许多不同的语言，范例，框架和其他狗屎。我想和大家分享我写好代码的规则。\n1. 优化VS可读性 去他妈的优化 始终编​​写易于阅读且对开发人员可理解的代码。因为在硬可读代码上花费的时间和资源将远远高于从优化中获得的。 如果你需要进行优化，那么使它像DI的独立模块，具有100％的测试覆盖率，并且不会被触及至少一年。\n2. 架构第一 我看到很多人说“我们需要快速做事，我们没有时间做架构”。其中约99％的人因为这样的想法而遇到了大问题。 编写代码而不考虑其架构是没有用的，就像没有实现它们的计划一样，梦想你的愿望。 在编写代码的第一行之前，你应该明白它将要做什么，它将如何使用，模块，服务如何相互工作，它将有什么结构，如何进行测试和调试，以及如何更新。\n3. 测试覆盖率 测试是好事，但他们并不总是负担得起，对项目有意义。\n当你需要测试：\n当你编写模块时，微服务将不会被触及至少一个月。 当你编写开源代码。 当你编写涉及金融渠道的核心代码或代码。 当您有代码更新的同时更新测试的资源。 当你不需要测试时：\n当你是一个创业。 当你有小团队和代码更改是快速。 当你编写的脚本，可以简单地通过他们的输出手动测试。 记住，带有严格测试的代码可能比没有测试的代码更有害。\n4. 保持简单，极度简单 不要编写复杂的代码。更多更简单，那么更少的错误它可能有和更少的时间来调试它们。代码应该做的只是它需要没有非常多的抽象和其他OOP shit（尤其是涉及java开发人员）+ 20％的东西可能需要在将来以简单的方式更新它。\n5. 注释 出现注释说明你的代码不够好。好的代码应该是可以理解的，没有一行注释。但是如何为新开发人员节省时间？ - 编写简单的内联文档描述什么和如何方法工作。这将节省很多时间来理解，甚至更多 - 它将给人们更多的机会来提出更好的实施这种方法。并且它将是全球代码文档的良好开端。\n6. 硬耦合VS较小耦合 始终尝试使用微服务架构。单片软件可以比微服务软件运行得更快，但只能在一个服务器的上下文中运行。 微服务使您可以不仅在许多服务器上，而且有时甚至在一台机器上（我的意思是过程分发）高效地分发您的软件。\n7. 代码审查 代码审查可以是好的，也以是坏的。 您可以组织代码审查，只有当您有开发人员了解95％的代码，谁可以监控所有更新，而不浪费很多时间。在其他情况下，这将是只是耗时，每个人都会讨厌这个。\n在这部分有很多问题，所以更深入地描述这一点。\n许多人认为代码审查是一个很好的方式教新手，或者工作在不同部分的代码的队友。但是代码审查的主要目标是保持代码质量，而不是教学。让我们想象你的团队制作代码用于控制核反应堆或太空火箭发动机的冷却系统。你在非常硬的逻辑中犯了巨大的错误，然后你给这个代码审查新的家伙。你怎么认为会发生意外的风险？ - 我的练习率超过70％。\n良好的团队是每个人都有自己的角色，负责确切的工作。如果有人想要理解另一段代码，那么他去一个负责任去问他。你不可能知道一切，更好的优秀的理解小块代码而不是理解所有。\n8. 重构没啥用 在我的职业生涯中，我听到很多次“不要担心，我们以后会重构它”。在未来，这会导致大的技术债务或从头开始删除所有的代码和写作。\n所以，不要得到一个债务，除非你有钱从头开发你的软件几次。\n9. 当你累了或在一个坏的心情不要写代码。 当开发人员厌倦时，他们正在制造2到5倍或者更多的bug。所以工作更多是非常糟糕的做法。这就是为什么越来越多的国家思考6小时工作日，其中一些已经有了。精神工作不同于使用你的二头肌。\n10. 不要一次写全部 - 使开发迭代 在编写代码分析和预测之前，您的客户/客户真正需要什么，然后选择您可以在短期内以高质量开发的MVF（最有价值的功能）。使用这样的迭代来部署质量更新，而不是腰部时间和资源对不合理的愿望和牺牲与质量。\n11. 自动化VS手动 自动化是长期的100％成功。所以如果你有资源自动化的东西，现在应该做。你可能认为“只需要5分钟，为什么我应该自动化？但让我计算这个。例如，它是5个开发人员的日常任务。 5分钟* 5天* 21天* 12个月= 6 300分钟= 105小时= 13.","title":"【译】13简单的优秀编码规则（从我15年的经验）"},{"content":"有个需求，想看点赞最多的头条，但是页面没有这种按钮。怎么办？自己写吧。\n先看效果 再看代码\nvar rows = $(\u0026#39;.news__item\u0026#39;).each(function(){ var key = +$(this).find(\u0026#39;.news__item-zan-number\u0026#39;).text(); $(this).data(\u0026#39;key\u0026#39;, key); }).get(); rows.sort(function(a,b){ var keyA = $(a).data(\u0026#39;key\u0026#39;); var keyB = $(b).data(\u0026#39;key\u0026#39;); if(keyA\u0026lt;keyB){return -1;} else{return 1;} }); $.each(rows, function(index, row){ $(\u0026#39;.news__list\u0026#39;).prepend(row); }); ","permalink":"https://wdd.js.org/posts/2018/sort-for-sf/","summary":"有个需求，想看点赞最多的头条，但是页面没有这种按钮。怎么办？自己写吧。\n先看效果 再看代码\nvar rows = $(\u0026#39;.news__item\u0026#39;).each(function(){ var key = +$(this).find(\u0026#39;.news__item-zan-number\u0026#39;).text(); $(this).data(\u0026#39;key\u0026#39;, key); }).get(); rows.sort(function(a,b){ var keyA = $(a).data(\u0026#39;key\u0026#39;); var keyB = $(b).data(\u0026#39;key\u0026#39;); if(keyA\u0026lt;keyB){return -1;} else{return 1;} }); $.each(rows, function(index, row){ $(\u0026#39;.news__list\u0026#39;).prepend(row); }); ","title":"15行代码为segmentfault增加头条文章排序功能"},{"content":"1. 曾经，你可以能习惯这样阅读javascript 2. 现在，你可以用这个姿势阅读 3. 怎么做呢? 3.1. step1: npm install -g lambda-view 3.2. step2: // 阅读本地代码 lv targer.js // 阅读远程代码 lv https://code.jquery.com/jquery-3.1.1.js // 阅读多个代码 lv file1.js file2.js file3.js // 阅读所有 lv *.js 4. 项目地址：https://github.com/Jianru-Lin/lambda-view 5. 欢迎试玩！ ","permalink":"https://wdd.js.org/posts/2018/visual-reading-js-code/","summary":"1. 曾经，你可以能习惯这样阅读javascript 2. 现在，你可以用这个姿势阅读 3. 怎么做呢? 3.1. step1: npm install -g lambda-view 3.2. step2: // 阅读本地代码 lv targer.js // 阅读远程代码 lv https://code.jquery.com/jquery-3.1.1.js // 阅读多个代码 lv file1.js file2.js file3.js // 阅读所有 lv *.js 4. 项目地址：https://github.com/Jianru-Lin/lambda-view 5. 欢迎试玩！ ","title":"可视化交互阅读JS源代码"},{"content":" Snippets是可以在Chrome DevTools的“源”面板中创建和执行的小脚本。 您可以从任何页面访问和运行它们。 当您运行代码段时，它会从当前打开的页面的上下文执行。\n1. 显示所有元素的边框，看页面布局非常方便 [].forEach.call($$(\u0026#34;*\u0026#34;),function(a){ a.style.outline=\u0026#34;1px solid #\u0026#34;+(~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16) }); 2. allcolors.js 从页面上的元素中使用的计算样式打印所有颜色。 使用样式化的console.log调用来可视化每种颜色。\n// allcolors.js // https://github.com/bgrins/devtools-snippets // Print out CSS colors used in elements on the page. (function () { // Should include colors from elements that have a border color but have a zero width? var includeBorderColorsWithZeroWidth = false; var allColors = {}; var props = [\u0026#34;background-color\u0026#34;, \u0026#34;color\u0026#34;, \u0026#34;border-top-color\u0026#34;, \u0026#34;border-right-color\u0026#34;, \u0026#34;border-bottom-color\u0026#34;, \u0026#34;border-left-color\u0026#34;]; var skipColors = { \u0026#34;rgb(0, 0, 0)\u0026#34;: 1, \u0026#34;rgba(0, 0, 0, 0)\u0026#34;: 1, \u0026#34;rgb(255, 255, 255)\u0026#34;: 1 }; [].forEach.call(document.querySelectorAll(\u0026#34;*\u0026#34;), function (node) { var nodeColors = {}; props.forEach(function (prop) { var color = window.getComputedStyle(node, null).getPropertyValue(prop), thisIsABorderProperty = (prop.indexOf(\u0026#34;border\u0026#34;) != -1), notBorderZero = thisIsABorderProperty ? window.getComputedStyle(node, null).getPropertyValue(prop.replace(\u0026#34;color\u0026#34;, \u0026#34;width\u0026#34;)) !== \u0026#34;0px\u0026#34; : true, colorConditionsMet; if (includeBorderColorsWithZeroWidth) { colorConditionsMet = color \u0026amp;\u0026amp; !skipColors[color]; } else { colorConditionsMet = color \u0026amp;\u0026amp; !skipColors[color] \u0026amp;\u0026amp; notBorderZero; } if (colorConditionsMet) { if (!allColors[color]) { allColors[color] = { count: 0, nodes: [] }; } if (!nodeColors[color]) { allColors[color].count++; allColors[color].nodes.push(node); } nodeColors[color] = true; } }); }); function rgbTextToRgbArray(rgbText) { return rgbText.replace(/\\s/g, \u0026#34;\u0026#34;).match(/\\d+,\\d+,\\d+/)[0].split(\u0026#34;,\u0026#34;).map(function(num) { return parseInt(num, 10); }); } function componentToHex(c) { var hex = c.toString(16); return hex.length == 1 ? \u0026#34;0\u0026#34; + hex : hex; } function rgbToHex(rgbArray) { var r = rgbArray[0], g = rgbArray[1], b = rgbArray[2]; return \u0026#34;#\u0026#34; + componentToHex(r) + componentToHex(g) + componentToHex(b); } var allColorsSorted = []; for (var i in allColors) { var rgbArray = rgbTextToRgbArray(i); var hexValue = rgbToHex(rgbArray); allColorsSorted.push({ key: i, value: allColors[i], hexValue: hexValue }); } allColorsSorted = allColorsSorted.sort(function (a, b) { return b.value.count - a.value.count; }); var nameStyle = \u0026#34;font-weight:normal;\u0026#34;; var countStyle = \u0026#34;font-weight:bold;\u0026#34;; function colorStyle(color) { return \u0026#34;background:\u0026#34; + color + \u0026#34;;color:\u0026#34; + color + \u0026#34;;border:1px solid #333;\u0026#34;; }; console.group(\u0026#34;Total colors used in elements on the page: \u0026#34; + window.location.href + \u0026#34; are \u0026#34; + allColorsSorted.length); allColorsSorted.forEach(function (c) { console.groupCollapsed(\u0026#34;%c %c \u0026#34; + c.key + \u0026#34; \u0026#34; + c.hexValue + \u0026#34; %c(\u0026#34; + c.value.count + \u0026#34; times)\u0026#34;, colorStyle(c.key), nameStyle, countStyle); c.value.nodes.forEach(function (node) { console.log(node); }); console.groupEnd(); }); console.groupEnd(\u0026#34;All colors used in elements on the page\u0026#34;); })(); 3. cachebuster.js 通过在href和src属性的末尾添加Date.now（）来覆盖所有链接和（可选）脚本标记。 默认情况下，不执行处理脚本，应将变量process_scripts更改为true以运行这些脚本。\n//Cache Buster (function (){ var rep = /.*\\?.*/, links = document.getElementsByTagName(\u0026#39;link\u0026#39;), scripts = document.getElementsByTagName(\u0026#39;script\u0026#39;), process_scripts = false; for (var i=0;i\u0026lt;links.length;i++){ var link = links[i], href = link.href; if(rep.test(href)){ link.href = href+\u0026#39;\u0026amp;\u0026#39;+Date.now(); } else{ link.href = href+\u0026#39;?\u0026#39;+Date.now(); } } if(process_scripts){ for (var i=0;i\u0026lt;scripts.length;i++){ var script = scripts[i], src = script.src; if(rep.test(src)){ script.src = src+\u0026#39;\u0026amp;\u0026#39;+Date.now(); } else{ script.src = src+\u0026#39;?\u0026#39;+Date.now(); } } } })(); 4. console-save.js 从控制台将对象保存为.json文件的简单方法包括一个chrome扩展和一个纯文本。\nconsole.save(data, [filename]) (function(console){ console.save = function(data, filename){ if(!data) { console.error(\u0026#39;Console.save: No data\u0026#39;) return; } if(!filename) filename = \u0026#39;console.json\u0026#39; if(typeof data === \u0026#34;object\u0026#34;){ data = JSON.stringify(data, undefined, 4) } var blob = new Blob([data], {type: \u0026#39;text/json\u0026#39;}), e = document.createEvent(\u0026#39;MouseEvents\u0026#39;), a = document.createElement(\u0026#39;a\u0026#39;) a.download = filename a.href = window.URL.createObjectURL(blob) a.dataset.downloadurl = [\u0026#39;text/json\u0026#39;, a.download, a.href].join(\u0026#39;:\u0026#39;) e.initMouseEvent(\u0026#39;click\u0026#39;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null) a.dispatchEvent(e) } })(console) 5. formcontrols.js 在一个不错的表中显示所有html表单元素及其值和类型。 在页面上为每个表单添加一个新表\n// formcontrols.js // https://github.com/bgrins/devtools-snippets // Print out forms and their controls (function() { var forms = document.querySelectorAll(\u0026#34;form\u0026#34;); for (var i = 0, len = forms.length; i \u0026lt; len; i++) { var tab = [ ]; console.group(\u0026#34;HTMLForm quot;\u0026#34; + forms[i].name + \u0026#34;quot;: \u0026#34; + forms[i].action); console.log(\u0026#34;Element:\u0026#34;, forms[i], \u0026#34;\\nName: \u0026#34;+forms[i].name+\u0026#34;\\nMethod: \u0026#34;+forms[i].method.toUpperCase()+\u0026#34;\\nAction: \u0026#34;+forms[i].action || \u0026#34;null\u0026#34;); [\u0026#34;input\u0026#34;, \u0026#34;textarea\u0026#34;, \u0026#34;select\u0026#34;].forEach(function (control) { [].forEach.call(forms[i].querySelectorAll(control), function (node) { tab.push({ \u0026#34;Element\u0026#34;: node, \u0026#34;Type\u0026#34;: node.type, \u0026#34;Name\u0026#34;: node.name, \u0026#34;Value\u0026#34;: node.value, \u0026#34;Pretty Value\u0026#34;: (isNaN(node.value) || node.value === \u0026#34;\u0026#34; ? node.value : parseFloat(node.value)) }); }); }); console.table(tab); console.groupEnd(); } })(); 6. log-globals.js 打印全局变量\n* log-globals by Sindre Sorhus https://github.com/sindresorhus/log-globals MIT License */ (function () { \u0026#39;use strict\u0026#39;; function getIframe() { var el = document.createElement(\u0026#39;iframe\u0026#39;); el.style.display = \u0026#39;none\u0026#39;; document.body.appendChild(el); var win = el.contentWindow; document.body.removeChild(el); return win; } function detectGlobals() { var iframe = getIframe(); var ret = Object.create(null); for (var prop in window) { if (!(prop in iframe)) { ret[prop] = window[prop]; } } return ret; } console.log(detectGlobals()); })(); 7. performance.js 打印有关window.performance对象的信息。 使用console.table和分组来组织信息。\n// performance.js // https://github.com/bgrins/devtools-snippets // Print out window.performance information. // https://developer.mozilla.org/en-US/docs/Navigation_timing (function () { var t = window.performance.timing; var lt = window.chrome \u0026amp;\u0026amp; window.chrome.loadTimes \u0026amp;\u0026amp; window.chrome.loadTimes(); var timings = []; timings.push({ label: \u0026#34;Time Until Page Loaded\u0026#34;, time: t.loadEventEnd - t.navigationStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Time Until DOMContentLoaded\u0026#34;, time: t.domContentLoadedEventEnd - t.navigationStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Total Response Time\u0026#34;, time: t.responseEnd - t.requestStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Connection\u0026#34;, time: t.connectEnd - t.connectStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Response\u0026#34;, time: t.responseEnd - t.responseStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Domain Lookup\u0026#34;, time: t.domainLookupEnd - t.domainLookupStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Load Event\u0026#34;, time: t.loadEventEnd - t.loadEventStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;Unload Event\u0026#34;, time: t.unloadEventEnd - t.unloadEventStart + \u0026#34;ms\u0026#34; }); timings.push({ label: \u0026#34;DOMContentLoaded Event\u0026#34;, time: t.domContentLoadedEventEnd - t.domContentLoadedEventStart + \u0026#34;ms\u0026#34; }); if(lt) { if(lt.wasNpnNegotiated) { timings.push({ label: \u0026#34;NPN negotiation protocol\u0026#34;, time: lt.npnNegotiatedProtocol }); } timings.push({ label: \u0026#34;Connection Info\u0026#34;, time: lt.connectionInfo }); timings.push({ label: \u0026#34;First paint after Document load\u0026#34;, time: Math.ceil(lt.firstPaintTime - lt.finishDocumentLoadTime) + \u0026#34;ms\u0026#34; }); } var navigation = window.performance.navigation; var navigationTypes = { }; navigationTypes[navigation.TYPE_NAVIGATENEXT || 0] = \u0026#34;Navigation started by clicking on a link, or entering the URL in the user agent\u0026#39;s address bar, or form submission.\u0026#34;, navigationTypes[navigation.TYPE_RELOAD] = \u0026#34;Navigation through the reload operation or the location.reload() method.\u0026#34;, navigationTypes[navigation.TYPE_BACK_FORWARD] = \u0026#34;Navigation through a history traversal operation.\u0026#34;, navigationTypes[navigation.TYPE_UNDEFINED] = \u0026#34;Navigation type is undefined.\u0026#34;, console.group(\u0026#34;window.performance\u0026#34;); console.log(window.performance); console.group(\u0026#34;Navigation Information\u0026#34;); console.log(navigationTypes[navigation.type]); console.log(\u0026#34;Number of redirects that have taken place: \u0026#34;, navigation.redirectCount) console.groupEnd(\u0026#34;Navigation Information\u0026#34;); console.group(\u0026#34;Timing\u0026#34;); console.log(window.performance.timing); console.table(timings, [\u0026#34;label\u0026#34;, \u0026#34;time\u0026#34;]); console.groupEnd(\u0026#34;Timing\u0026#34;); console.groupEnd(\u0026#34;window.performance\u0026#34;); })(); 8. 更多有意思的： http://bgrins.github.io/devtools-snippets/ ","permalink":"https://wdd.js.org/posts/2018/chrome-snippets-collect/","summary":"Snippets是可以在Chrome DevTools的“源”面板中创建和执行的小脚本。 您可以从任何页面访问和运行它们。 当您运行代码段时，它会从当前打开的页面的上下文执行。\n1. 显示所有元素的边框，看页面布局非常方便 [].forEach.call($$(\u0026#34;*\u0026#34;),function(a){ a.style.outline=\u0026#34;1px solid #\u0026#34;+(~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16) }); 2. allcolors.js 从页面上的元素中使用的计算样式打印所有颜色。 使用样式化的console.log调用来可视化每种颜色。\n// allcolors.js // https://github.com/bgrins/devtools-snippets // Print out CSS colors used in elements on the page. (function () { // Should include colors from elements that have a border color but have a zero width? var includeBorderColorsWithZeroWidth = false; var allColors = {}; var props = [\u0026#34;background-color\u0026#34;, \u0026#34;color\u0026#34;, \u0026#34;border-top-color\u0026#34;, \u0026#34;border-right-color\u0026#34;, \u0026#34;border-bottom-color\u0026#34;, \u0026#34;border-left-color\u0026#34;]; var skipColors = { \u0026#34;rgb(0, 0, 0)\u0026#34;: 1, \u0026#34;rgba(0, 0, 0, 0)\u0026#34;: 1, \u0026#34;rgb(255, 255, 255)\u0026#34;: 1 }; [].","title":"谷歌浏览器： Snippets小程序哪家强？"},{"content":"1. morgan 【优点】morgan配置非常简单 【优点】支持自定义日志格式 【优点】支持日志分机 【优点】支持日志压缩：使用rotating-file-stream 【缺点】无法同时往console和文件中写日志 2. log4js-node 【优点】配置简单 【优点】支持同时往控制台和文件中写数据 【优点】支持按照时间或文件大小分割文件 【优点】支持文件压缩 \u0026#34;use strict\u0026#34;; var path = require(\u0026#39;path\u0026#39;) , log4js = require(\u0026#39;../lib/log4js\u0026#39;); log4js.configure( { appenders: [ { type: \u0026#34;file\u0026#34;, filename: \u0026#34;important-things.log\u0026#34;, maxLogSize: 10*1024*1024, // = 10Mb numBackups: 5, // keep five backup files compress: true, // compress the backups encoding: \u0026#39;utf-8\u0026#39;, mode: parseInt(\u0026#39;0640\u0026#39;, 8), flags: \u0026#39;w+\u0026#39; }, { type: \u0026#34;dateFile\u0026#34;, filename: \u0026#34;more-important-things.log\u0026#34;, pattern: \u0026#34;yyyy-MM-dd-hh\u0026#34;, compress: true }, { type: \u0026#34;stdout\u0026#34; } ] } ); var logger = log4js.getLogger(\u0026#39;things\u0026#39;); logger.debug(\u0026#34;This little thing went to market\u0026#34;); logger.info(\u0026#34;This little thing stayed at home\u0026#34;); logger.error(\u0026#34;This little thing had roast beef\u0026#34;); logger.fatal(\u0026#34;This little thing had none\u0026#34;); logger.trace(\u0026#34;and this little thing went wee, wee, wee, all the way home.\u0026#34;); 3. winston 没用过，不做评论 4. fluent-logger-node 往fluntd中写日志，没用过 5. express-winston 没用过 6. 如何自定义一个日志插件 可以自定义日志结构 日志文件可以用gzip压缩 不影响往console写日志 可以按时间分割日志 支持日志覆盖，最多保留1个月的备份 使用rotating-file-stream\nvar path = require(\u0026#39;path\u0026#39;); var fs = require(\u0026#39;fs\u0026#39;); var rfs = require(\u0026#39;rotating-file-stream\u0026#39;); var logDirectory = __dirname; function Wpad(num) { return (num \u0026gt; 9 ? \u0026#34;\u0026#34; : \u0026#34;0\u0026#34;) + num; } /** * [Wgenerator 创建文件名函数] * @Author Wdd * @DateTime 2017-02-22T10:13:39+0800 * 日志会保留一个月的：因为日志文件名是只使用日期，9月8号的日志就会覆盖8月8号的日志 * 文件的格式是gzip * 文件名例如：22-log.gizp */ function Wgenerator(time, index) { if(! time){ return \u0026#34;temp-log.txt.gzip\u0026#34;; } return \u0026#34;/storage/\u0026#34;+ Wpad(time.getDate()) +\u0026#34;-log.txt.gzip\u0026#34;; } var accessLogStream = rfs(Wgenerator, { interval: \u0026#39;1d\u0026#39;, // 周期为1天 path: logDirectory, compress: \u0026#39;gzip\u0026#39; , rotationTime:true }); /** * [exports description] * @Author Wdd * @DateTime 2017-02-22T10:24:06+0800 * 使用方式： * 1. 安装rotating-file-stream * 2. 在根目录下创建一个文件夹，例如logs。然后把access-log.js放进去 * 3. 在app.js中var mylog = require(\u0026#39;./logs/access-log\u0026#39;); * 4. 在app = express(); 后添加一句 app.use(mylog); * 5. 日志文件会自动生成在./logs/storage文件夹下面，当天的日志会保存在暂存的./logs/temp-log.gzip里 */ module.exports = function(req, res, next){ req._startTime = new Date(); res.once(\u0026#39;finish\u0026#39;, function(){ var msg = \u0026#34;\u0026#34;; //hostname msg = process.env.hostname+\u0026#34; \u0026#34;; // 时间 msg += new Date()+\u0026#34; \u0026#34;; // 请求方式 msg += req.method+\u0026#34; \u0026#34;; // 响应状态码 msg += res.statusCode+\u0026#34; \u0026#34;; // sessionId msg += req.headers.sessionid+\u0026#34; \u0026#34;; // 响应时长 msg += new Date() - req._startTime ; // 请求路径 msg += \u0026#34; \u0026#34; + req.originalUrl +\u0026#39;\\n\\r\\n\\r\u0026#39;; accessLogStream.write(msg); }); next(); }; ","permalink":"https://wdd.js.org/posts/2018/nodejs-log-packages/","summary":"1. morgan 【优点】morgan配置非常简单 【优点】支持自定义日志格式 【优点】支持日志分机 【优点】支持日志压缩：使用rotating-file-stream 【缺点】无法同时往console和文件中写日志 2. log4js-node 【优点】配置简单 【优点】支持同时往控制台和文件中写数据 【优点】支持按照时间或文件大小分割文件 【优点】支持文件压缩 \u0026#34;use strict\u0026#34;; var path = require(\u0026#39;path\u0026#39;) , log4js = require(\u0026#39;../lib/log4js\u0026#39;); log4js.configure( { appenders: [ { type: \u0026#34;file\u0026#34;, filename: \u0026#34;important-things.log\u0026#34;, maxLogSize: 10*1024*1024, // = 10Mb numBackups: 5, // keep five backup files compress: true, // compress the backups encoding: \u0026#39;utf-8\u0026#39;, mode: parseInt(\u0026#39;0640\u0026#39;, 8), flags: \u0026#39;w+\u0026#39; }, { type: \u0026#34;dateFile\u0026#34;, filename: \u0026#34;more-important-things.log\u0026#34;, pattern: \u0026#34;yyyy-MM-dd-hh\u0026#34;, compress: true }, { type: \u0026#34;stdout\u0026#34; } ] } ); var logger = log4js.","title":"nodejs 日志插件比较 VS 自定义日志插件"},{"content":"0.1. 安全类型检测 javascript内置类型检测并不可靠 safari某些版本（\u0026lt;4）typeof正则表达式返回为function 建议使用Object.prototype.toString.call()方法检测数据类型\nfunction isArray(value){ return Object.prototype.toString.call(value) === \u0026#34;[object Array]\u0026#34;; } function isFunction(value){ return Object.prototype.toString.call(value) === \u0026#34;[object Function]\u0026#34;; } function isRegExp(value){ return Object.prototype.toString.call(value) === \u0026#34;[object RegExp]\u0026#34;; } function isNativeJSON(){ return window.JSON \u0026amp;\u0026amp; Object.prototype.toString.call(JSON) === \u0026#34;[object JSON]\u0026#34;; } 对于ie中一COM对象形式实现的任何函数，isFunction都返回false，因为他们并非原生的javascript函数。\n在web开发中，能够区分原生与非原生的对象非常重要。只有这样才能确切知道某个对象是否有哪些功能\n以上所有的正确性的前提是：Object.prototype.toString没有被修改过\n0.2. 作用域安全的构造函数 function Person(name){ this.name = name; } //使用new来创建一个对象 var one = new Person(\u0026#39;wdd\u0026#39;); //直接调用构造函数 Person(); 由于this是运行时分配的，如果你使用new来操作，this指向的就是one。如果直接调用构造函数，那么this会指向全局对象window,然后你的代码就会覆盖window的原生name。如果有其他地方使用过window.name, 那么你的函数将会埋下一个深藏的bug。\n==那么，如何才能创建一个作用域安全的构造函数？== 方法1\nfunction Person(name){ if(this instanceof Person){ this.name = name; } else{ return new Person(name); } } 1. 惰性载入函数 假设有一个方法X，在A类浏览器里叫A,在b类浏览器里叫B,有些浏览器并没有这个方法,你想实现一个跨浏览器的方法。\n惰性载入函数的思想是：在函数内部改变函数自身的执行逻辑\nfunction X(){ if(A){ return new A(); } else{ if(B){ return new B(); } else{ throw new Error(\u0026#39;no A or B\u0026#39;); } } } 换一种写法\nfunction X(){ if(A){ X = function(){ return new A(); }; } else{ if(B){ X = function(){ return new B(); }; } else{ throw new Error(\u0026#39;no A or B\u0026#39;); } } return new X(); } 2. 防篡改对象 2.1. 不可扩展对象 Object.preventExtensions // 下面代码在谷歌浏览器中执行 \u0026gt; var person = {name: \u0026#39;wdd\u0026#39;}; undefined \u0026gt; Object.preventExtensions(person); Object {name: \u0026#34;wdd\u0026#34;} \u0026gt; person.age = 10 10 \u0026gt; person Object {name: \u0026#34;wdd\u0026#34;} \u0026gt; Object.isExtensible(person) false 2.2. 密封对象Object.seal 密封对象不可扩展，并且不能删除对象的属性或者方法。但是属性值可以修改。\n\u0026gt; var one = {name: \u0026#39;hihi\u0026#39;} undefined \u0026gt; Object.seal(one) Object {name: \u0026#34;hihi\u0026#34;} \u0026gt; one.age = 12 12 \u0026gt; one Object {name: \u0026#34;hihi\u0026#34;} \u0026gt; delete one.name false \u0026gt; one Object {name: \u0026#34;hihi\u0026#34;} 2.3. 冻结对象 Object.freeze 最严格的防篡改就是冻结对象。对象不可扩展，而且密封，不能修改。只能访问。\n3. 高级定时器 3.1. 函数节流 函数节流的思想是：某些代码不可以没有间断的连续重复执行\nvar processor = { timeoutId: null, // 实际进行处理的方法 performProcessing: function(){ ... }, // 初始化调用方法 process: function(){ clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function(){ that.performProcessing(); }, 100); } } // 尝试开始执行 processor.process(); 3.2. 中央定时器 页面如果有十个区域要动态显示当前时间，一般来说，可以用10个定时来实现。其实一个中央定时器就可以搞定。\n中央定时器动画 demo地址：http://wangduanduan.coding.me/my-all-demos/ninja/center-time-control.html\nvar timers = { timerId: 0, timers: [], add: function(fn){ this.timers.push(fn); }, start: function(){ if(this.timerId){ return; } (function runNext(){ if(timers.timers.length \u0026gt; 0){ for(var i=0; i \u0026lt; timers.timers.length ; i++){ if(timers.timers[i]() === false){ timers.timers.splice(i, 1); i--; } } timers.timerId = setTimeout(runNext, 16); } })(); }, stop: function(){ clearTimeout(timers.timerId); this.timerId = 0; } }; 参考书籍： 《javascript高级程序设计》 《javascript忍者秘籍》\n","permalink":"https://wdd.js.org/posts/2018/js-high-skills/","summary":"0.1. 安全类型检测 javascript内置类型检测并不可靠 safari某些版本（\u0026lt;4）typeof正则表达式返回为function 建议使用Object.prototype.toString.call()方法检测数据类型\nfunction isArray(value){ return Object.prototype.toString.call(value) === \u0026#34;[object Array]\u0026#34;; } function isFunction(value){ return Object.prototype.toString.call(value) === \u0026#34;[object Function]\u0026#34;; } function isRegExp(value){ return Object.prototype.toString.call(value) === \u0026#34;[object RegExp]\u0026#34;; } function isNativeJSON(){ return window.JSON \u0026amp;\u0026amp; Object.prototype.toString.call(JSON) === \u0026#34;[object JSON]\u0026#34;; } 对于ie中一COM对象形式实现的任何函数，isFunction都返回false，因为他们并非原生的javascript函数。\n在web开发中，能够区分原生与非原生的对象非常重要。只有这样才能确切知道某个对象是否有哪些功能\n以上所有的正确性的前提是：Object.prototype.toString没有被修改过\n0.2. 作用域安全的构造函数 function Person(name){ this.name = name; } //使用new来创建一个对象 var one = new Person(\u0026#39;wdd\u0026#39;); //直接调用构造函数 Person(); 由于this是运行时分配的，如果你使用new来操作，this指向的就是one。如果直接调用构造函数，那么this会指向全局对象window,然后你的代码就会覆盖window的原生name。如果有其他地方使用过window.name, 那么你的函数将会埋下一个深藏的bug。\n==那么，如何才能创建一个作用域安全的构造函数？== 方法1\nfunction Person(name){ if(this instanceof Person){ this.name = name; } else{ return new Person(name); } } 1.","title":"JavaScript 高级技巧"},{"content":"1. 需求 需要自定义一个log方法，这个方法可以像原生的console.log一样 在开发环境我希望调用这个log会输出日志信息，生产环境我希望即使调用了这个方法，也不会输出日志信息。 2. 实现这个log 可能要使用apply或者call方法 log的参数个数和类型都是不固定的 call的参数个数是固定的，要排除它 apply的参数是需要一个数组，这个合适，可以使用arguments来当做数组传递 3. 代码 var MyLog = { silent: false, log: function(){ if(!this.silent){ console.log.apply(this, arguments); } } }; 4. 试用 \u0026gt; MyLog.log(1,2,3, \u0026#39;4545\u0026#39;); 1 2 3 \u0026#34;4545\u0026#34; undefined \u0026gt; MyLog.silent = true true \u0026gt; MyLog.log(1,2,3, \u0026#39;4545\u0026#39;); undefined 5. 后记 不要随处使用console.log，因为这样当你不需要日志输出的时候，你就要到处填坑了 不要使用alert，这个很烦人 ","permalink":"https://wdd.js.org/posts/2018/how-to-use-apply/","summary":"1. 需求 需要自定义一个log方法，这个方法可以像原生的console.log一样 在开发环境我希望调用这个log会输出日志信息，生产环境我希望即使调用了这个方法，也不会输出日志信息。 2. 实现这个log 可能要使用apply或者call方法 log的参数个数和类型都是不固定的 call的参数个数是固定的，要排除它 apply的参数是需要一个数组，这个合适，可以使用arguments来当做数组传递 3. 代码 var MyLog = { silent: false, log: function(){ if(!this.silent){ console.log.apply(this, arguments); } } }; 4. 试用 \u0026gt; MyLog.log(1,2,3, \u0026#39;4545\u0026#39;); 1 2 3 \u0026#34;4545\u0026#34; undefined \u0026gt; MyLog.silent = true true \u0026gt; MyLog.log(1,2,3, \u0026#39;4545\u0026#39;); undefined 5. 后记 不要随处使用console.log，因为这样当你不需要日志输出的时候，你就要到处填坑了 不要使用alert，这个很烦人 ","title":"从一个小场景学会使用 apply方法"},{"content":"0.1. 先看题：mean的值是什么？ var scores = [10,11,12]; var total = 0; for(var score in scores){ total += score; } var mean = total/scores.length; console.log(mean); 0.2. 是11？ 恭喜你：答错了！\n0.3. 是1？ 恭喜你：答错了！\n0.4. 正确答案： 4 解释： for in 循环循环的值永远是key, key是一个字符串。所以total的值是：\u0026lsquo;0012\u0026rsquo;。它是一个字符串，字符串'0012\u0026rsquo;/3,0012会被转换成12，然后除以3，结果是4。\n0.5. 后记 这个示例是来自《编写高质量JavaScript的68个方法》的第49条：数组迭代要优先使用for循环而不是for in循环。 既然已经发布，就可能有好事者拿出去当面试题。这个题目很有可能坑一堆人。其中包括我。\n这里涉及到许多js的基础知识.\nfor in 循环是循环对象的索引属性，key是一个字符串。 数值类型和字符串相加，会自动转换为字符串 字符串除以数值类型，会先把字符串转为数值，最终结果为数值 正确方法\nvar scores = [10,11,12]; var total = 0; for(var i=0, n=scores.length; i \u0026lt; n; i++){ total += scores[i]; } var mean = total/scores.length; console.log(mean); 这样写有几个好处。\n循环的终止条件简单且明确 即使在循环体内修改了数组，也能有效的终止循环。否则就可能变成死循环。 编译器很难保证重启计算scores.length是安全的。 提前确定了循环终止条件，避免多次计算数组长度。这个可能会被一些浏览器优化。 ","permalink":"https://wdd.js.org/posts/2018/i-realy-dont-know-js/","summary":"0.1. 先看题：mean的值是什么？ var scores = [10,11,12]; var total = 0; for(var score in scores){ total += score; } var mean = total/scores.length; console.log(mean); 0.2. 是11？ 恭喜你：答错了！\n0.3. 是1？ 恭喜你：答错了！\n0.4. 正确答案： 4 解释： for in 循环循环的值永远是key, key是一个字符串。所以total的值是：\u0026lsquo;0012\u0026rsquo;。它是一个字符串，字符串'0012\u0026rsquo;/3,0012会被转换成12，然后除以3，结果是4。\n0.5. 后记 这个示例是来自《编写高质量JavaScript的68个方法》的第49条：数组迭代要优先使用for循环而不是for in循环。 既然已经发布，就可能有好事者拿出去当面试题。这个题目很有可能坑一堆人。其中包括我。\n这里涉及到许多js的基础知识.\nfor in 循环是循环对象的索引属性，key是一个字符串。 数值类型和字符串相加，会自动转换为字符串 字符串除以数值类型，会先把字符串转为数值，最终结果为数值 正确方法\nvar scores = [10,11,12]; var total = 0; for(var i=0, n=scores.length; i \u0026lt; n; i++){ total += scores[i]; } var mean = total/scores.","title":"突然觉得自己好像没学过JS"},{"content":"由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。\n2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。\nhtml\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-cn\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34; id=\u0026#34;event-queue\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;当前状态\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;状态改变时间\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;工号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;分机号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;对方号码\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;呼入数\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;呼出数\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in eventQueue\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{item.agentStatus | transAgentStatus}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.agentStatusTime}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.userName}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.loginName}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.deviceId}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/vue/1.0.26/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/websocket-suport.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; js\nvar tm = (function(){ var App = function(){}; var app = App.prototype; var config = { dest: \u0026#39;http://xxx.xxx.xxx.xxx:58080/mvc/stomp\u0026#39;, topic: \u0026#39;/topic/csta/namespace/testwdd2.com\u0026#39; // topic: \u0026#39;/topic/csta/device/8002@testwdd2.com\u0026#39; }; var eventQueue = []; var vm = new Vue({ el:\u0026#39;#event-queue\u0026#39;, data:{ eventQueue: eventQueue } }); Vue.filter(\u0026#39;transAgentStatus\u0026#39;, function(status){ switch(status){ case \u0026#39;NotReady\u0026#39;: return \u0026#39;未就绪\u0026#39;; case \u0026#39;WorkNotReady\u0026#39;: return \u0026#39;话后处理状态\u0026#39;; case \u0026#39;Idle\u0026#39;: return \u0026#39;就绪\u0026#39;; case \u0026#39;OnCallIn\u0026#39;: return \u0026#39;呼入通话\u0026#39;; case \u0026#39;OnCallOut\u0026#39;: return \u0026#39;呼出通话\u0026#39;; case \u0026#39;Logout\u0026#39;: return \u0026#39;登出\u0026#39;; case \u0026#39;Ringing\u0026#39;: return \u0026#39;振铃\u0026#39;; case \u0026#39;OffHook\u0026#39;: return \u0026#39;摘机\u0026#39;; case \u0026#39;CallInternal\u0026#39;: return \u0026#39;内部通话\u0026#39;; case \u0026#39;Dailing\u0026#39;: return \u0026#39;外线已经振铃\u0026#39;; case \u0026#39;Ringback\u0026#39;: return \u0026#39;回铃\u0026#39;; case \u0026#39;Conference\u0026#39;: return \u0026#39;会议\u0026#39;; case \u0026#39;OnHold\u0026#39;: return \u0026#39;保持\u0026#39;; case \u0026#39;Other\u0026#39;: return \u0026#39;其他\u0026#39;; } return \u0026#39;\u0026#39;; }); /** * [render description] * @Author Wdd * @DateTime 2016-12-26T16:06:16+0800 * @param {[string]} tpl [模板字符串] * @param {[object]} data [data对象] * @return {[string]} [渲染后的字符串] */ app.render = function(tpl,data){ var re = /{{([^}]+)?}}/g; while(match = re.exec(tpl)){ tpl = tpl.replace(match[0],data[match[1]] || \u0026#39;\u0026#39;); } return tpl; }; app.initWebSocket = function(dest, topic){ dest = dest || config.dest; topic = topic || config.topic; var socket = new SockJS(dest); var ws = Stomp.over(socket); ws.connect({}, function(frame) { ws.subscribe(topic, function(event) { // var eventInfo = JSON.parse(event.body); app.handerEvent(JSON.parse(event.body)); }); }, function(frame) { console.log(frame); console.error(new Date() + \u0026#39;websocket失去连接\u0026#39;); }); }; /** * [findAgentIndex description] * @Author Wdd * @DateTime 2016-12-28T10:34:13+0800 * @param {[string]} agentId [description] * @return {[int]} [description] */ app.findAgentIndex = function(agentId){ for(var i = eventQueue.length - 1; i \u0026gt;= 0; i--){ if(eventQueue[i].agentId === agentId){ return i; } } return -1; }; /** * [handerEvent 处理websocket事件] * @Author Wdd * @DateTime 2016-12-28T10:33:03+0800 * @param {[object]} data [description] * @return {[type]} [description] */ app.handerEvent = function(data){ if(data.eventType === \u0026#39;CallEvent\u0026#39;){ return; } if(!data.eventSrc){ return; } var eventItem = { agentStatus: \u0026#39;\u0026#39;, eventName: data.eventName, agentId: \u0026#39;\u0026#39;, loginName: \u0026#39;\u0026#39;, userName: \u0026#39;\u0026#39;, deviceId: data.deviceId, agentStatusTime: \u0026#39;\u0026#39; }; var agent = data.eventSrc.agent || \u0026#39;\u0026#39;; if(agent){ eventItem.agentId = agent.agentId; eventItem.loginName = agent.loginName; eventItem.userName = agent.userName; eventItem.agentStatus = agent.agentStatus; eventItem.agentStatusTime = agent.agentStatusTime; } // 针对登出事件的agentId在外层 else if(data.agentMode){ eventItem.agentStatus = data.agentMode; eventItem.agentId = data.agentId; } else if(data.agentStatus){ eventItem.agentStatus = data.agentStatus; } if(!eventItem.agentId){ return; } var itemIndex = app.findAgentIndex(eventItem.agentId); // 新的座席加入 if(itemIndex === -1){ eventQueue.push(eventItem); } // 更新已有座席的状态 else{ eventQueue[itemIndex].agentStatus = eventItem.agentStatus; eventQueue[itemIndex].agentStatusTime = eventItem.agentStatusTime; eventQueue[itemIndex].eventName = eventItem.eventName; } }; return new App(); })(); 打开控制台，输入tm.initWebsocket()后，websocket连接正常。 之后坐席状态改变，可以看到有事件推送过来。 看下整个页面： 最后，这个小小的监控如果用jQuery写，也可以，不过就是太坑了，每次都要去找到Dom元素，再更新DOM，用了Vue这类的框架，页面的dom操作完全不用关心了，真是太舒服了。\\(^o^)/\n1. 关于stomp的重连 程序后服务端使用RabbitMQ 这里我直接引用我的另一个项目的部分代码，这个没有使用SockJS， 直接使用浏览器原生的WebSocket。 重连的原理很简单，就是检测到断开时，去调用我的reconnectWs方法，这里我也做了重连的次数限制。\ninitWebSocket: function(callback, errorCallback) { callback = callback || function(){}; if(ws \u0026amp;\u0026amp; ws.connected){ return; } Config.isManCloseWs = false; var url = Config.wsProtocol + Config.SDK + Config.eventPort + Config.eventBasePath + \u0026#34;/websocket\u0026#34;; if(typeof WebSocket != \u0026#39;function\u0026#39;){ alert(\u0026#39;您的浏览器版本太太太老了，请升级你的浏览器到IE11，或使用任何支持原生WebSocket的浏览器\u0026#39;); return; } try{ var socket = new WebSocket(url); } catch(e){ console.log(e); return; } var wsHeartbeatId = \u0026#39;\u0026#39;; ws = Stomp.over(socket); if(!Config.useWsLog){ ws.debug = null; } ws.connect({}, function(frame) { Config.currentReconnectTimes = 0; var dest = Config.newWsTopic + env.loginId.replace(/\\./g,\u0026#39;_\u0026#39;); var lastEventSerial = \u0026#39;\u0026#39;; ws.subscribe(dest, function(event) { var eventInfo = {}; try{ eventInfo = JSON.parse(event.body); delete eventInfo.params; delete eventInfo._type; delete eventInfo.topics; } catch(e){ console.log(e); return; } if(lastEventSerial === eventInfo.serial){ util.error(\u0026#39;Error: event repeat sent !\u0026#39;); return; } else{ lastEventSerial = eventInfo.serial; } if(Config.useEventLog){ util.debugout.log(\u0026#39; \u0026#39; + JSON.stringify(eventInfo)); } eventHandler.deliverEvent(eventInfo); }); callback(); }, function(frame) { // websocket upexpected disconnected // maybe network disconnection, or browser in offline // this condition will emit wsDisconnected event if(Config.isManCloseWs){return;} errorCallback(); util.log(frame); util.error(new Date() + \u0026#39;websocket disconnect\u0026#39;); // clearInterval(wsHeartbeatId); if(Config.currentReconnectTimes \u0026lt; Config.maxReconnectTimes){ Config.currentReconnectTimes++; util.reconnectWs(); } else{ var errorMsg = { eventName: \u0026#39;wsDisconnected\u0026#39;, msg: \u0026#39;websocket disconnect\u0026#39; }; wellClient.ui.main({ eventName:\u0026#39;wsDisconnected\u0026#39; }); util.debugout.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; websocket disconnect\u0026#39;); wellClient.triggerInnerOn(errorMsg); } }); }, reconnectWs: function(){ setTimeout(function(){ util.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; try to reconnect\u0026#39;); util.debugout.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; try to reconnect\u0026#39;); util.initWebSocket(function(){},function(){}); }, Config.timeout * 1000); }, 2. 参考 STOMP Over WebSocket\n","permalink":"https://wdd.js.org/posts/2018/vue-ws-monitor-agent-status/","summary":"由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。\n2018-01-09新增： 后端的MQ事件结构现在也改了，该demo只能看看了。\nhtml\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-cn\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34; id=\u0026#34;event-queue\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;当前状态\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;状态改变时间\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;工号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;分机号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;对方号码\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;呼入数\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;呼出数\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in eventQueue\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{item.agentStatus | transAgentStatus}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.agentStatusTime}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.userName}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.loginName}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.deviceId}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/vue/1.0.26/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/websocket-suport.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; js\nvar tm = (function(){ var App = function(){}; var app = App.","title":"Vue+websocket+stompjs 实时监控坐席状态demo"},{"content":"1. 命令行神器 1.1. GOW Gow（Gnu On Windows）是Cygwin的轻量级替代品。 它使用一个方便的NSIS安装程序，安装超过100个非常有用的开源UNIX应用程序，编译为本机win32二进制文件。 它被设计为尽可能小，大约18 MB，而不是Cygwin，它可以运行超过100 MB根据选项。\n1.2. 强烈推荐 ConEmu 非常强大，可以在里面愉快的ctrl+v,ctrl+c 用过你才知道好用 https://conemu.github.io/\n2. 搜索神器 2.1. Wox Windows下一款最接近 Alfred 的软件启动/文件搜索利器\n2.2. Everything 快速批量查找文件的利器\n3. 包管理神器 4. Chocolatey 安装软件再也不用烦恼 教程\n5. 健康管理神器 6. f.lux 有没有注意到人们在夜间发短信的怪异蓝色发光？或者醒来准备写下一个伟大的想法，并被你的电脑屏幕蒙蔽？白天，电脑屏幕看起来很好，他们的设计看起来像太阳。但是，在晚上9点，晚上10点或凌晨3点，你可能不应该看太阳。f.lux修复这个：它使你的电脑显示器的颜色适应一天的时间，在夜间温暖和白天喜欢阳光。甚至有可能你因为你的电脑而停滞太晚。你可以使用f.lux因为它使你睡得更好，或者你可以只使用它，只是因为它使你的电脑看起来更好。\n7. 谷歌浏览器插件神器 7.1. 强烈推荐vimium 速度起飞，只用键盘就可以完全操纵谷歌浏览器\n7.2. shortKeys vimium的快捷键其实已经足够多了，但是如果你想有更多自定义的快捷键，例如：关闭右侧的标签页，这个快捷键。你可以试试shortKeys。唯一遗憾的是，这里面也没有关闭其他标签页的快捷键，如果你知道有哪些工具可以做到，麻烦请告诉我。\n7.3. infinity新标签页 8. 参考 http://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/ http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/ https://www.zhihu.com/question/22919326 https://blogs.msdn.microsoft.com/scott_hanselman/2013/07/31/windows/ ","permalink":"https://wdd.js.org/posts/2018/windows-powerful-tools/","summary":"1. 命令行神器 1.1. GOW Gow（Gnu On Windows）是Cygwin的轻量级替代品。 它使用一个方便的NSIS安装程序，安装超过100个非常有用的开源UNIX应用程序，编译为本机win32二进制文件。 它被设计为尽可能小，大约18 MB，而不是Cygwin，它可以运行超过100 MB根据选项。\n1.2. 强烈推荐 ConEmu 非常强大，可以在里面愉快的ctrl+v,ctrl+c 用过你才知道好用 https://conemu.github.io/\n2. 搜索神器 2.1. Wox Windows下一款最接近 Alfred 的软件启动/文件搜索利器\n2.2. Everything 快速批量查找文件的利器\n3. 包管理神器 4. Chocolatey 安装软件再也不用烦恼 教程\n5. 健康管理神器 6. f.lux 有没有注意到人们在夜间发短信的怪异蓝色发光？或者醒来准备写下一个伟大的想法，并被你的电脑屏幕蒙蔽？白天，电脑屏幕看起来很好，他们的设计看起来像太阳。但是，在晚上9点，晚上10点或凌晨3点，你可能不应该看太阳。f.lux修复这个：它使你的电脑显示器的颜色适应一天的时间，在夜间温暖和白天喜欢阳光。甚至有可能你因为你的电脑而停滞太晚。你可以使用f.lux因为它使你睡得更好，或者你可以只使用它，只是因为它使你的电脑看起来更好。\n7. 谷歌浏览器插件神器 7.1. 强烈推荐vimium 速度起飞，只用键盘就可以完全操纵谷歌浏览器\n7.2. shortKeys vimium的快捷键其实已经足够多了，但是如果你想有更多自定义的快捷键，例如：关闭右侧的标签页，这个快捷键。你可以试试shortKeys。唯一遗憾的是，这里面也没有关闭其他标签页的快捷键，如果你知道有哪些工具可以做到，麻烦请告诉我。\n7.3. infinity新标签页 8. 参考 http://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/ http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/ https://www.zhihu.com/question/22919326 https://blogs.msdn.microsoft.com/scott_hanselman/2013/07/31/windows/ ","title":"自从装了windows神器，再也不用羡慕mac了"},{"content":"0.1. 同步Ajax 这种需求主要用于当浏览器关闭，或者刷新时，向后端发起Ajax请求。\nwindow.onunload = function(){ $.ajax({url:\u0026#34;http://localhost:8888/test.php?\u0026#34;, async:false}); }; 使用async：false参数使请求同步（默认是异步的）。\n同步请求锁定浏览器，直到完成。 如果请求是异步的，页面只是继续卸载。 它足够快，以至于该请求甚至没有时间触发。服务端很可能收不到请求。\n0.2. navigator.sendBeacon 优点：简洁、异步、非阻塞 缺点：这是实验性的技术，并非所有浏览器都支持。其中IE和safari不支持该技术。\n示例：\nwindow.addEventListener(\u0026#39;unload\u0026#39;, logData, false); function logData() { navigator.sendBeacon(\u0026#34;/log\u0026#34;, analyticsData); } 参考：http://stackoverflow.com/questions/1821625/ajax-request-with-jquery-on-page-unload 参考：https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon\n","permalink":"https://wdd.js.org/posts/2018/send-ajax-when-page-unload/","summary":"0.1. 同步Ajax 这种需求主要用于当浏览器关闭，或者刷新时，向后端发起Ajax请求。\nwindow.onunload = function(){ $.ajax({url:\u0026#34;http://localhost:8888/test.php?\u0026#34;, async:false}); }; 使用async：false参数使请求同步（默认是异步的）。\n同步请求锁定浏览器，直到完成。 如果请求是异步的，页面只是继续卸载。 它足够快，以至于该请求甚至没有时间触发。服务端很可能收不到请求。\n0.2. navigator.sendBeacon 优点：简洁、异步、非阻塞 缺点：这是实验性的技术，并非所有浏览器都支持。其中IE和safari不支持该技术。\n示例：\nwindow.addEventListener(\u0026#39;unload\u0026#39;, logData, false); function logData() { navigator.sendBeacon(\u0026#34;/log\u0026#34;, analyticsData); } 参考：http://stackoverflow.com/questions/1821625/ajax-request-with-jquery-on-page-unload 参考：https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon","title":"发起Ajax请求当页面onunload"},{"content":" 1. Git Bash 2. Gow 1 2 3 4 5 6 7 8 9 10 awk basename bash bc bison bunzip2 bzip2 bzip2 bzip2recover cat chgrp chmod chown chroot cksum clear cp csplit curl cut dc dd df diff diff3 dirname dos2unix du egrep env expand expr factor fgrep flex fmt fold gawk gdbm3 gfind gow grep gsar gsort gzip head history5 hostid hostname id indent install join jwhois less lesskey libcurl libeay32 libiconv-2 libidn-11 libintl-2 libintl3 libssl32 ln ls m4 make md5sum mkdir mkfifo mknod msys-1 msys-regex-1 msys-termcap-0 mv nano ncftp nl od pageant paste patch pathchk pcre3 plink pr printenv printf pscp psftp putty puttygen pwd readline5 regex2 rm rmdir scp sdiff sed seq sftp sha1sum shar sleep split ssh ssleay32 su sum sync tac tail tar tee test touch tr uname unexpand uniq unix2dos unlink unrar unrar3 unshar uudecode uuencode vim wc wget whereis which whoami xargs yes zip zip32z64 3. ConEmu 4. gerp 5. Chrome Extensions 5.1. vimium 5.2. Multi-highlight 5.3. Restlet Client - REST API Testing 5.4. Tampermonkey 6. Web Tools 6.1. jsonviewernew https://www.bejson.com/jsonviewernew/\n6.2. regex101 6.3. Linux 工具快速教程 ","permalink":"https://wdd.js.org/posts/2018/tool-improve-work-efficiency/","summary":"1. Git Bash 2. Gow 1 2 3 4 5 6 7 8 9 10 awk basename bash bc bison bunzip2 bzip2 bzip2 bzip2recover cat chgrp chmod chown chroot cksum clear cp csplit curl cut dc dd df diff diff3 dirname dos2unix du egrep env expand expr factor fgrep flex fmt fold gawk gdbm3 gfind gow grep gsar gsort gzip head history5 hostid hostname id indent install join jwhois less lesskey libcurl libeay32 libiconv-2 libidn-11 libintl-2 libintl3 libssl32 ln ls m4 make md5sum mkdir mkfifo mknod msys-1 msys-regex-1 msys-termcap-0 mv nano ncftp nl od pageant paste patch pathchk pcre3 plink pr printenv printf pscp psftp putty puttygen pwd readline5 regex2 rm rmdir scp sdiff sed seq sftp sha1sum shar sleep split ssh ssleay32 su sum sync tac tail tar tee test touch tr uname unexpand uniq unix2dos unlink unrar unrar3 unshar uudecode uuencode vim wc wget whereis which whoami xargs yes zip zip32z64 3.","title":"无坚不摧：打造极大提高工作效率的装备库"},{"content":"1. 前提说明 仓库A: http://gitlab.tt.cc:30000/fe/omp.git 仓库B: 仓库Bfork自仓库A, 仓库A的地址是：http://gitlab.tt.cc:30000/wangdd/omp.git 某一时刻，仓库A更新了。仓库B需要同步上游分支的更新。\n2. 本地操作 // 1 查看远程分支 ➜ omp git:(master) git remote -v origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (fetch) origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (push) // 2 添加一个远程同步的上游仓库 ➜ omp git:(master) git remote add upstream http://gitlab.tt.cc:30000/fe/omp.git ➜ omp git:(master) git remote -v origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (fetch) origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (push) upstream\thttp://gitlab.tt.cc:30000/fe/omp.git (fetch) upstream\thttp://gitlab.tt.cc:30000/fe/omp.git (push) // 3 拉去上游分支到本地，并且会被存储在一个新分支upstream/master ➜ omp git:(master) git fetch upstream remote: Counting objects: 4, done. remote: Compressing objects: 100% (4/4), done. remote: Total 4 (delta 2), reused 0 (delta 0) Unpacking objects: 100% (4/4), done. From http://gitlab.tt.cc:30000/fe/omp * [new branch] master -\u0026gt; upstream/master // 4 将upstream/master分支合并到master分支，由于我已经在master分支，此处就不在切换到master分支 ➜ omp git:(master) git merge upstream/master Updating 29c098c..6413803 Fast-forward README.md | 1 + 1 file changed, 1 insertion(+) // 5 查看一下，此次合并，本地有哪些更新 ➜ omp git:(master) git log -p // 6 然后将更新推送到仓库B ➜ omp git:(master) git push 3. 总结 通过上述操作，仓库B就同步了仓库A的代码。整体的逻辑就是将上游分支拉去到本地，然后合并到本地分支上。就这么简单。\n","permalink":"https://wdd.js.org/posts/2018/fork-sync-learn/","summary":"1. 前提说明 仓库A: http://gitlab.tt.cc:30000/fe/omp.git 仓库B: 仓库Bfork自仓库A, 仓库A的地址是：http://gitlab.tt.cc:30000/wangdd/omp.git 某一时刻，仓库A更新了。仓库B需要同步上游分支的更新。\n2. 本地操作 // 1 查看远程分支 ➜ omp git:(master) git remote -v origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (fetch) origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (push) // 2 添加一个远程同步的上游仓库 ➜ omp git:(master) git remote add upstream http://gitlab.tt.cc:30000/fe/omp.git ➜ omp git:(master) git remote -v origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (fetch) origin\thttp://gitlab.tt.cc:30000/wangdd/omp.git (push) upstream\thttp://gitlab.tt.cc:30000/fe/omp.git (fetch) upstream\thttp://gitlab.tt.cc:30000/fe/omp.git (push) // 3 拉去上游分支到本地，并且会被存储在一个新分支upstream/master ➜ omp git:(master) git fetch upstream remote: Counting objects: 4, done. remote: Compressing objects: 100% (4/4), done.","title":"git合并上游仓库即同步fork后的仓库"},{"content":" 个人简介 我是端端！\n精通JavaScript/Node.js，现在的兴趣是学习go语言 精通VOIP相关技术栈：SIP/opensips/Freeswitch等等 精通VIM email: 1779706607@qq.com Github: github.com/wangduanduan 语雀: yuque.com/wangdd, 将不会更新 个人博客: wdd.js.org, 最新内容将会发布在wdd.js.org 博客说明 博客取名为洞香春，灵感来自孙皓晖所著《大秦帝国》。\n洞香春大致在战国时代中期所在地：魏国安邑。\n战国时期，社会制度发生着巨大变化，工商业日益兴旺，出现了以白圭为首的一批巨贾商人，而位于魏国安邑的洞香春酒肆就是白氏家族创办的产业中最为著名的一个。\n洞香春以名士荟萃、谈论国事、交流思想而著称于当时列国\n","permalink":"https://wdd.js.org/about/","summary":"个人简介 我是端端！\n精通JavaScript/Node.js，现在的兴趣是学习go语言 精通VOIP相关技术栈：SIP/opensips/Freeswitch等等 精通VIM email: 1779706607@qq.com Github: github.com/wangduanduan 语雀: yuque.com/wangdd, 将不会更新 个人博客: wdd.js.org, 最新内容将会发布在wdd.js.org 博客说明 博客取名为洞香春，灵感来自孙皓晖所著《大秦帝国》。\n洞香春大致在战国时代中期所在地：魏国安邑。\n战国时期，社会制度发生着巨大变化，工商业日益兴旺，出现了以白圭为首的一批巨贾商人，而位于魏国安邑的洞香春酒肆就是白氏家族创办的产业中最为著名的一个。\n洞香春以名士荟萃、谈论国事、交流思想而著称于当时列国","title":"关于我"},{"content":"1. lsof: 根据端口号查监听的进程号 参考\n使用模型：lsof -i :port\n已知某服务占用8088端口，请查出使用该端口的进程号\nlsof -i :8088 lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。lsof命令详情\n2. grep: 搜索神器 参考： GNU Grep 3.0\n--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2.1. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 2.2. 输出文件：可以将日志输出文件中 grep ERROR trace.log \u0026gt; error.log\n2.3. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log\n2.4. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.log\n2.5. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志 grep -A 10 ERROR trace.log\n2.6. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志 grep -C 10 ERROR trace.log\n2.7. 多字段：搜索包含ERROR和DEBUG字段的日志 gerp -E 'ERROR|DEBUG' trace.log\n2.8. 多文件：从多个.log文件中搜索含有ERROR的日志 grep ERROR *.log\n2.9. 省略文件名：从多个.log文件中搜索ERROR字段日志，并不显示日志文件名 从多个文件中搜索的日志默认每行会带有日志文件名\ngrep -h ERROR *.log\n2.10. 时间范围： 按照时间范围搜索日志 awk '$2\u0026gt;\u0026quot;17:30:00\u0026quot; \u0026amp;\u0026amp; $2\u0026lt;\u0026quot;18:00:00\u0026quot;' trace.log 日志形式如下, $2代表第二列即11:44:58, awk需要指定列\n11-21 16:44:58 /user/info/ 2.11. 有没有：搜索到第一个匹配行后就停止搜索 grep -m 1 ERROR trace.log\n2.12. 行数统计: 统计ERROR出现了多少行 grep -c ERROR trace.log\n2.13. 单词统计：统计ERROR出现了多少次 grep -c ERROR trace.log | wc -w\n3. wc：单词统计 4. 参考文献 Linux工具快速教程 ","permalink":"https://wdd.js.org/posts/2018/linux-common-cmds/","summary":"1. lsof: 根据端口号查监听的进程号 参考\n使用模型：lsof -i :port\n已知某服务占用8088端口，请查出使用该端口的进程号\nlsof -i :8088 lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。lsof命令详情\n2. grep: 搜索神器 参考： GNU Grep 3.0\n--color:高亮显示匹配到的字符串 -v：显示不能被pattern匹配到的 -i：忽略字符大小写 -o：仅显示匹配到的字符串 -q：静默模式，不输出任何信息 -A#：after，匹配到的后#行 -B#：before，匹配到的前#行 -C#：context，匹配到的前后各#行 -E：使用ERE，支持使用扩展的正则表达式 －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符)。 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 - m: 匹配多少个关键词之后就停止搜索 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 2.1. 普通：搜索trace.log 中含有ERROR字段的日志 grep ERROR trace.log 2.2. 输出文件：可以将日志输出文件中 grep ERROR trace.log \u0026gt; error.log\n2.3. 反向：搜索不包含ERROR字段的日志 grep -v ERROR trace.log\n2.4. 向前：搜索包含ERROR,并且显示ERROR前10行的日志 grep -B 10 ERROR trace.","title":"linux常用命令使用场景总结"},{"content":"原文链接\n读书，嗯，读书\n1. 教程目的 通过邮件向kindle推送一本电子书 2. 前期准备 一台可以上网的电脑 一个电子书 一个kindle 3. 你的kindle邮箱是什么？ 登录亚马逊，地址：https://www.amazon.cn/ref=nav_logo 鼠标移动到导航栏上的我的账户 点击下拉框中的：管理我的内容和设备 会出现下面tab页面 =\u0026gt; 设置 =\u0026gt; 个人文档设置 =\u0026gt; 里面会有电子邮件地址 里面的邮箱即为你邮件发送的收件方地址。例如：abcd@kindle.cc 4. 如何设置邮箱白名单？ 并不是所有邮件都能发送到abcd@kindle.cc, 需要在上一步的同一个页面设置已认可的发件人电子邮箱, 只有来自认可的邮箱的电子书，亚马逊才会接受。你需要添加认可的电子邮箱。例如发件的邮箱写为：abcd@qq.com\n5. 邮件该怎么写？ 必须使用上一步白名单里面的邮箱来发送\n收件人写你的kindle邮箱 主题写：Convert 在邮件的附件中添加准备好的电子书 点击发送 6. 在哪里查找已经发送的电子书？ 还是在管理我的内容和设备页面 点击我的内容 在显示中选择：个人文档 例如你可以在截图中看到，我刚刚上传的一本：you dont konw js 如果没有找到你已经发送的书籍，请再次检查一下，你的kindle邮箱和白名单中的邮箱是否正确\n7. 如何向kindle推送电子书 紧接着上一步.\n选择要发送的书籍 点击发送 在出现的弹出框中，在下拉框中选择你的kindle设备 点击发送 kindle链接WiFi，进入我的图书馆，点击设备，同步 8. 使用体验的思考？ 之前用多看阅读，WIFI传书非常方便。kindle的上传图书其实蛮复杂的，过程中可能直接过滤掉一些用户。\n我在想为什么亚马逊不在：管理我的内容和设备页面添加一个上传图书的按钮呢？\n9. 重点划线 一封电子邮件最多只能包含25个附件，并且最多只能发送至15个不同的〖发送至Kindle〗电子邮箱。文档的总大小不得超过50MB。 在电子邮件主题中输入“Convert”以将您的文档转换为Kindle格式，然后再将其发送至您的设备以及【管理我的内容和设备】页面中的【我的内容】 如果您的设备或阅读软件暂时无法连接无线网络，我们最多可以为您保存个人文档60天 Kindle个人文档服务支持以下文件类型： Kindle格式（.MOBI、.AZW） Microsoft Word（.DOC、.DOCX） HTML（.HTML、.HTM） RTF (.RTF) Text (.TXT) (Kindle X 咪咕电子书阅读器不支持) JPEG（.JPEG、.JPG） GIF (.GIF) PNG (.PNG) BMP (.BMP) PDF (.PDF) 建议您在发送文件之前将文件名改成英文 10. 参考文档 使用您的〖发送至Kindle〗电子邮箱 添加用于接收文档的电子邮箱 Kindle个人文档服务 Kindle个人文档服务使用条件 ","permalink":"https://wdd.js.org/posts/2018/send-book-to-kindle/","summary":"原文链接\n读书，嗯，读书\n1. 教程目的 通过邮件向kindle推送一本电子书 2. 前期准备 一台可以上网的电脑 一个电子书 一个kindle 3. 你的kindle邮箱是什么？ 登录亚马逊，地址：https://www.amazon.cn/ref=nav_logo 鼠标移动到导航栏上的我的账户 点击下拉框中的：管理我的内容和设备 会出现下面tab页面 =\u0026gt; 设置 =\u0026gt; 个人文档设置 =\u0026gt; 里面会有电子邮件地址 里面的邮箱即为你邮件发送的收件方地址。例如：abcd@kindle.cc 4. 如何设置邮箱白名单？ 并不是所有邮件都能发送到abcd@kindle.cc, 需要在上一步的同一个页面设置已认可的发件人电子邮箱, 只有来自认可的邮箱的电子书，亚马逊才会接受。你需要添加认可的电子邮箱。例如发件的邮箱写为：abcd@qq.com\n5. 邮件该怎么写？ 必须使用上一步白名单里面的邮箱来发送\n收件人写你的kindle邮箱 主题写：Convert 在邮件的附件中添加准备好的电子书 点击发送 6. 在哪里查找已经发送的电子书？ 还是在管理我的内容和设备页面 点击我的内容 在显示中选择：个人文档 例如你可以在截图中看到，我刚刚上传的一本：you dont konw js 如果没有找到你已经发送的书籍，请再次检查一下，你的kindle邮箱和白名单中的邮箱是否正确\n7. 如何向kindle推送电子书 紧接着上一步.\n选择要发送的书籍 点击发送 在出现的弹出框中，在下拉框中选择你的kindle设备 点击发送 kindle链接WiFi，进入我的图书馆，点击设备，同步 8. 使用体验的思考？ 之前用多看阅读，WIFI传书非常方便。kindle的上传图书其实蛮复杂的，过程中可能直接过滤掉一些用户。\n我在想为什么亚马逊不在：管理我的内容和设备页面添加一个上传图书的按钮呢？\n9. 重点划线 一封电子邮件最多只能包含25个附件，并且最多只能发送至15个不同的〖发送至Kindle〗电子邮箱。文档的总大小不得超过50MB。 在电子邮件主题中输入“Convert”以将您的文档转换为Kindle格式，然后再将其发送至您的设备以及【管理我的内容和设备】页面中的【我的内容】 如果您的设备或阅读软件暂时无法连接无线网络，我们最多可以为您保存个人文档60天 Kindle个人文档服务支持以下文件类型： Kindle格式（.MOBI、.AZW） Microsoft Word（.DOC、.DOCX） HTML（.HTML、.HTM） RTF (.RTF) Text (.","title":"猴子都能懂的教程：向kindle推送电子书"},{"content":"1. 什么是查询字符串？ 给个例子：\nhttps://en.wikipedia.org/w/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=startup\u0026amp;only=scripts\u0026amp;skin=vector 查询字符串是url中问号后边的部分，形式如：key1=value1\u0026amp;key2=value2\u0026amp;key3=value3。这部分称为查询(query)组件。\n2. 查询组件的最小数据集 参数名： 是否必须： 是否是精确查询： 描述： 示例：必须要有，比如说如果查询的是一个时间。那么时间的格式有很多种，务必给出示例 约束： 字符串：最小长度，最大长度。[3,10] 数值型：取值区间。[4, 10] 枚举型：枚举字符串。1代表男，0代表女 3. 举例说明：一个用户查询的接口 参数名 是否必须 是否是精确查询 描述 示例 约束 email 否 是 邮箱 test@tt.cc 长度：[6, 10] age 否 是 年龄 18 取值：[0, 110] gender 否 是 性别 1 1代表男，0代表女 userName 否 否 用户名 alex 长度：[4, 40] token 是 是 认证令牌 90sdflkajf0asdflkja 长度：60 registerBeginTime 否 是 开始注册时间，返回的结果都是该时间以后的数据 2018-09-20 17:23:00 长度：19 很多资源\n4. 参考 wikipedia:Query_string ","permalink":"https://wdd.js.org/posts/2018/query-string-mds/","summary":"1. 什么是查询字符串？ 给个例子：\nhttps://en.wikipedia.org/w/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=startup\u0026amp;only=scripts\u0026amp;skin=vector 查询字符串是url中问号后边的部分，形式如：key1=value1\u0026amp;key2=value2\u0026amp;key3=value3。这部分称为查询(query)组件。\n2. 查询组件的最小数据集 参数名： 是否必须： 是否是精确查询： 描述： 示例：必须要有，比如说如果查询的是一个时间。那么时间的格式有很多种，务必给出示例 约束： 字符串：最小长度，最大长度。[3,10] 数值型：取值区间。[4, 10] 枚举型：枚举字符串。1代表男，0代表女 3. 举例说明：一个用户查询的接口 参数名 是否必须 是否是精确查询 描述 示例 约束 email 否 是 邮箱 test@tt.cc 长度：[6, 10] age 否 是 年龄 18 取值：[0, 110] gender 否 是 性别 1 1代表男，0代表女 userName 否 否 用户名 alex 长度：[4, 40] token 是 是 认证令牌 90sdflkajf0asdflkja 长度：60 registerBeginTime 否 是 开始注册时间，返回的结果都是该时间以后的数据 2018-09-20 17:23:00 长度：19 很多资源\n4. 参考 wikipedia:Query_string ","title":"查询字符串的最小数据集"},{"content":" 1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息 一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数\n3. 路径中的参数表达式 URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}\n例如：\n/api/user/{userId} /api/user/{userType}?age={age}\u0026amp;gender={gender} 4. 数据模型定义 数据模型定义包括：\n路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集：\n名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。\n一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。\n另外：数据模型非常建议使用表格来表现。\n举个栗子🌰：\n名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例 // general POST http://www.testapi.com/api/user // request payload { \u0026#34;name\u0026#34;: \u0026#34;qianxun\u0026#34;, \u0026#34;age\u0026#34;: 14, \u0026#34;like\u0026#34;: [\u0026#34;music\u0026#34;, \u0026#34;reading\u0026#34;], \u0026#34;userType\u0026#34;: \u0026#34;vip\u0026#34; } // response { \u0026#34;id\u0026#34;: \u0026#34;asdkfjalsdkf\u0026#34; } 6. 异常处理 异常处理最小数据集\n状态码 说明 解决方案 举个栗子🌰：\n状态码 说明 解决方案 401 用户名密码错误 检查用户名密码是否正确 424 超过最大在线数量 请在控制台修改最大在线数量 之前我一直不想把解决方案加入异常处理的最小数据集，但是对于很多开发者来说，即使它知道424代表超过最大在线数量。如果你不告诉如果解决这个问题，那么他们可能就会直接来问你。所以最好能够一步到位，直接告诉他应该如何解决，这样省时省力。\n7. 如何组织？ 7.1. 一个创建用户的例子：创建用户 1 请求示例\n// general POST http://www.testapi.com/api/user/vip/?token=abcdefg // request payload { \u0026#34;name\u0026#34;: \u0026#34;qianxun\u0026#34;, \u0026#34;age\u0026#34;: 14, \u0026#34;like\u0026#34;: [\u0026#34;music\u0026#34;, \u0026#34;reading\u0026#34;] } // response { \u0026#34;id\u0026#34;: \u0026#34;asdkfjalsdkf\u0026#34; } 2 路径与查询字符串参数模型\nPOST http://www.testapi.com/api/user/{userType}/?token={token}\n名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 token 是 认证令牌 3 请求体参数模型\n名称 是否必须 说明 name 是 用户名。4-50个字符 age 否 年龄 like 否 爱好。最多20个 4 响应体参数模型\n名称 说明 id 用户id 5 异常处理\n状态码 说明 解决方案 401 token过期 请重新申请token 424 超过最大在创建人数 请在控制台修改最大创建人数 7.2. 这样组织的原因 请求示例: 请求示例放在第一位的原因是，要用最快的方式告诉开发者，这个接口应该如何请求 路径与查询字符串参数模型： 使用mustache包裹参数 请求体参数模型：如果没有请求体，可以不写 响应体参数模型： 异常处理 8. 文档提供的形式 文档建议由一下两种形式，在线文档，pdf文档。\n在线文档 更新方便 易于随时阅读 易于查找 pdf文档 内容表现始终如一，不依赖文档阅读器 文档只读，不会被轻易修改 其中由于是面对第三方开发者，公开的在线文档必须提供；由于某些特殊的原因，可能需要提供文件形式的文档，建议提供pdf文档。当然，以下的文档形式是非常不建议提供的：\nword文档 markdown文档 word文档和markdown文档有以下缺点：\n文档的表现形式非常依赖文档查看器：各个版本的word文档对word的表现形式差异很大，可能在你的电脑上内容表现很好的文档，到别人的电脑上就会一团乱麻；另外markdown文件也是如此。而且markdown中引入文件只能依靠图片链接，如果文档中含有图片，很可能会出现图片丢失的情况。 文档无法只读：文档无法只读，就有可能会被第三方开发者在不经意间修改，那么文档就无法保证其准确性了。 总结一下，文档形式的要点：\n只读性：保证文档不会被开发者轻易修改 一致性：保证文档在不同设备，不同文档查看器上内容表现始终如一 易于版本管理：文档即软件（DAAS: Document as a Software），一般意义上说软件 = 数据 + 算法, 但是我认为文档也是一种组成软件的重要形式。既然软件需要版本管理，文档的版本管理也是比不可少的。 ","permalink":"https://wdd.js.org/posts/2018/how-to-write-better-api-docs/","summary":"1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息 一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数\n3. 路径中的参数表达式 URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName}\n例如：\n/api/user/{userId} /api/user/{userType}?age={age}\u0026amp;gender={gender} 4. 数据模型定义 数据模型定义包括：\n路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集：\n名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。\n一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。\n另外：数据模型非常建议使用表格来表现。\n举个栗子🌰：\n名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例 // general POST http://www.testapi.com/api/user // request payload { \u0026#34;name\u0026#34;: \u0026#34;qianxun\u0026#34;, \u0026#34;age\u0026#34;: 14, \u0026#34;like\u0026#34;: [\u0026#34;music\u0026#34;, \u0026#34;reading\u0026#34;], \u0026#34;userType\u0026#34;: \u0026#34;vip\u0026#34; } // response { \u0026#34;id\u0026#34;: \u0026#34;asdkfjalsdkf\u0026#34; } 6. 异常处理 异常处理最小数据集","title":"如何写好接口文档？"},{"content":"1. ztree获得顶层节点 treeObj.getNodesByParam(\u0026#39;level\u0026#39;,0,null); ","permalink":"https://wdd.js.org/posts/2018/ztree-note/","summary":"1. ztree获得顶层节点 treeObj.getNodesByParam(\u0026#39;level\u0026#39;,0,null); ","title":"ztree-note"},{"content":"1. 实验准备 T450笔记本 2. 进入BIOS 重启电脑 一直不停按enter 按F1 选择Keyboard/mouse 3. 恢复F1-F2恢复原始功能: fn and ctrl key swap [enabled]\n4. 切换ctrl和ctrl的位置: F1-F12 as primary function [enabled]\n5. 保存，退出 ","permalink":"https://wdd.js.org/posts/2018/thinkpad-f1-f12/","summary":"1. 实验准备 T450笔记本 2. 进入BIOS 重启电脑 一直不停按enter 按F1 选择Keyboard/mouse 3. 恢复F1-F2恢复原始功能: fn and ctrl key swap [enabled]\n4. 切换ctrl和ctrl的位置: F1-F12 as primary function [enabled]\n5. 保存，退出 ","title":"thinkpad 系列恢复F1-F12原始功能，切换ctrl和fn的位置"},{"content":"解决方法安装Windows7补丁：KB3008923； 下载地址： http://www.microsoft.com/en-us/download/details.aspx?id=45134 （32位） http://www.microsoft.com/zh-CN/download/details.aspx?id=45154 （64位）\n","permalink":"https://wdd.js.org/posts/2018/ie11-without-devtool/","summary":"解决方法安装Windows7补丁：KB3008923； 下载地址： http://www.microsoft.com/en-us/download/details.aspx?id=45134 （32位） http://www.microsoft.com/zh-CN/download/details.aspx?id=45154 （64位）","title":"win7 ie11 开发者工具打开后一片空白"},{"content":"1. 内容概要 CSTA协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA协议标准 2.1. 什么是CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications)\n基本的呼叫模型在1992建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等\nCSTA是一个应用层接口，用来监控呼叫，设备和网络\nCSTA创建了一个通讯程序的抽象层:\nCSTA并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式\n第三方呼叫控制 一方呼叫控制 CSTA的设计目标是为了提高各种CSTA实现之间的移植性\n规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段1 (发布于 June ’92)\n40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段2 (发布于 Dec. ’94)\n77 特性, 145 页 (服务定义) I/O \u0026amp; 语音单元服务, 更多呼叫控制服务 阶段3 - CSTA Phase II Features \u0026amp; versit CTI Technology\n发布于 Dec. ‘98 136 特性, 650 页 (服务定义) 作为ISO 标准发布于 July 2000 发布 CSTA XML (ECMA-323) June 2004 发布 “Using CSTA with Voice Browsers” (TR/85) Dec. 02 发布 CSTA WSDL (ECMA-348) June 2004 June 2004: 发布对象模型 TR/88\nJune 2004: 发布 “Using CSTA for SIP Phone User Agents (uaCSTA)” TR/87\nJune 2004: 发布 “Application Session Services” (ECMA-354)\nJune 2005: 发布 “WS-Session: WSDL for ECMA-354”(ECMA-366)\nDecember 2005 : 发布 “Management Notification and Computing Function Services”\nDecember 2005 : Session Management, Event Notification, Amendements for ECMA- 348” (TR/90)\nDecember 2006 : Published new editions of ECMA-269, ECMA-323, ECMA-348\n4. CSTA 标准文档 5. CSTA 标准扩展 新的特性可以被加入标准通过发布新版本的标准 新的参数，新的值可以被加入通过发布新版本的标准 未来的新版本必须下向后兼容 具体的实施可以增加属性通过CSTA自带的扩展机制(e.g. ONS – One Number Service) 6. CSTA 操作模型 CSTA操作模型由计算域和转换域组成，是CSTA定义在两个域之间的接口 CSTA标准规定了消息（服务以及事件上报）,还有与之相关的行为 计算域是CSTA程序的宿主环境，用来与转换域交互与控制 转换域 - CSTA模型提供抽象层，程序可以观测并控制的。转换渔包括一些对象例如CSTA呼叫，设备，链接。 7. CSTA 操作模型：呼叫，设备，链接 相关说明是的的的的\n8. 参考 CSTAoverview CSTA_introduction_and_overview ","permalink":"https://wdd.js.org/posts/2018/csta-call-model-overview/","summary":"1. 内容概要 CSTA协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA协议标准 2.1. 什么是CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications)\n基本的呼叫模型在1992建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等\nCSTA是一个应用层接口，用来监控呼叫，设备和网络\nCSTA创建了一个通讯程序的抽象层:\nCSTA并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式\n第三方呼叫控制 一方呼叫控制 CSTA的设计目标是为了提高各种CSTA实现之间的移植性\n规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段1 (发布于 June ’92)\n40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段2 (发布于 Dec. ’94)\n77 特性, 145 页 (服务定义) I/O \u0026amp; 语音单元服务, 更多呼叫控制服务 阶段3 - CSTA Phase II Features \u0026amp; versit CTI Technology\n发布于 Dec. ‘98 136 特性, 650 页 (服务定义) 作为ISO 标准发布于 July 2000 发布 CSTA XML (ECMA-323) June 2004 发布 “Using CSTA with Voice Browsers” (TR/85) Dec.","title":"CSTA 呼叫模型简介"},{"content":"1. 前提说明 A(本机 mac item2) B(远程机器 ip:a.b.c.d centos)\n2. 过程1 3. 生成public_key与private_key 在本机上输入，可以一路回车，不用说明\nssh-keygen -t rsa 最终会在~/.ssh/下生成两个文件\nid_rsa id_rsa.pub 4. 将public_key上传到远程服务器 注意：在本机上输入\n// 回车之后，需要输入远程主机B的登录密码 scp ~/.ssh/id_rsa.pub root@a.b.c.d:/root/.ssh 5. 登录远程主机 在本机上输入\n// 需要输入远程主机的密码 ssh root@a.b.c.d // 进到远程主机~/.ssh/目录下, 此目录下应该已经有了之前上传的id_rsa.pub文件 // 如果目录下没有authorized_keys文件，那么将id_rsa.pub改名成authorized_keys mv id_rsa.pub authorized_keys // 如果远程目录下已经存在authorized_keys文件，可以将id_rsa.pub追加进去 cat id_rsa.pub \u0026gt;\u0026gt; authorized_keys 6. 本机配置 注意，此时需要退出ssh, 在本机上执行以下命令\nvi ~/.ssh/config 在config文件中追加以下内容，并保存退出 Host serverName Hostname a.b.c.d Port 22 User root IdentityFile ~/.ssh/id_rsa 然后试一下，只需要ssh serverName, 就可以直接登录远程服务器，是不是很爽\n7. 参考文献 scp 命令教程 mac用iterm2实现ssh，怎么像SecureCRT一样保存IP和账号密码？ 8. 精华推荐 最后推荐一本非常好的linux常用命令手册，非常不错哦。\nLinux下有很多命令行工具供我们使用，每个工具总是提供了大量参数供我们选择； 实际工作中，我们用到的工具，最常用的总是那么几个参数组合； 为此，我写了这本书相对实用的书；\n这本书专注于Linux工具的最常用用法，以便读者能以最快时间掌握，并在工作中应用；\n《Linux工具快速教程》 ","permalink":"https://wdd.js.org/posts/2018/ssh-login-without-password/","summary":"1. 前提说明 A(本机 mac item2) B(远程机器 ip:a.b.c.d centos)\n2. 过程1 3. 生成public_key与private_key 在本机上输入，可以一路回车，不用说明\nssh-keygen -t rsa 最终会在~/.ssh/下生成两个文件\nid_rsa id_rsa.pub 4. 将public_key上传到远程服务器 注意：在本机上输入\n// 回车之后，需要输入远程主机B的登录密码 scp ~/.ssh/id_rsa.pub root@a.b.c.d:/root/.ssh 5. 登录远程主机 在本机上输入\n// 需要输入远程主机的密码 ssh root@a.b.c.d // 进到远程主机~/.ssh/目录下, 此目录下应该已经有了之前上传的id_rsa.pub文件 // 如果目录下没有authorized_keys文件，那么将id_rsa.pub改名成authorized_keys mv id_rsa.pub authorized_keys // 如果远程目录下已经存在authorized_keys文件，可以将id_rsa.pub追加进去 cat id_rsa.pub \u0026gt;\u0026gt; authorized_keys 6. 本机配置 注意，此时需要退出ssh, 在本机上执行以下命令\nvi ~/.ssh/config 在config文件中追加以下内容，并保存退出 Host serverName Hostname a.b.c.d Port 22 User root IdentityFile ~/.ssh/id_rsa 然后试一下，只需要ssh serverName, 就可以直接登录远程服务器，是不是很爽\n7. 参考文献 scp 命令教程 mac用iterm2实现ssh，怎么像SecureCRT一样保存IP和账号密码？ 8.","title":"ssh 无密码登录远程服务器"},{"content":" 之前我是使用wangduanduan.github.io作为我的博客地址，后来觉得麻烦，有把博客关了。最近有想去折腾折腾。 先看效果：wdd.js.org\n如果你不了解js.org可以看看我的这篇文章:一个值得所有前端开发者关注的网站js.org\n1. 前提 已经有了github pages的一个博客，并且博客中有内容，没有内容会审核不通过的。我第一次申请域名，就是因为内容太少而审核不通过。 2. 想好自己要什么域名？ 比如你想要一个：wdd.js.org的域名，你先在浏览器里访问这个地址，看看有没有人用过，如果已经有人用过，那么你就只能想点其他的域名了。\n3. fork js.org的项目，添加自己的域名 1 fork https://github.com/js-org/dns.js.org 2 修改你fork后的仓库中的cnames_active.js文件，加上自己的一条域名，最好要按照字母顺序\n如下图所示，我在第1100行加入。注意，不要在该行后加任何注释。\n\u0026#34;wdd\u0026#34;: \u0026#34;wangduanduan.github.io\u0026#34;, 3 commit\n4. 加入CNAME文件 我是用hexo和next主题作为博客的模板。其中我在gh-pages分支写博客，然后部署到master分支。\n我在我的gh-pages分支的source目录下加入CNAME文件, 内容只有一行\nwdd.js.org 将博客再次部署好，如果CNAME生效的话，你已经无法从原来的地址访问：wangduanduan.github.io， 这个博客了。\n5. 向js.org项目发起pull-request 找到你fork后的项目，点击 new pull request, 向原来的项目发起请求。\n然后你可以在js-org/dns.js.org项目的pull requests看到你的请求，当这个请求被合并时，你就拥有了js.org的二级域名。\n","permalink":"https://wdd.js.org/posts/2018/how-to-get-jsorg-sub-domain/","summary":"之前我是使用wangduanduan.github.io作为我的博客地址，后来觉得麻烦，有把博客关了。最近有想去折腾折腾。 先看效果：wdd.js.org\n如果你不了解js.org可以看看我的这篇文章:一个值得所有前端开发者关注的网站js.org\n1. 前提 已经有了github pages的一个博客，并且博客中有内容，没有内容会审核不通过的。我第一次申请域名，就是因为内容太少而审核不通过。 2. 想好自己要什么域名？ 比如你想要一个：wdd.js.org的域名，你先在浏览器里访问这个地址，看看有没有人用过，如果已经有人用过，那么你就只能想点其他的域名了。\n3. fork js.org的项目，添加自己的域名 1 fork https://github.com/js-org/dns.js.org 2 修改你fork后的仓库中的cnames_active.js文件，加上自己的一条域名，最好要按照字母顺序\n如下图所示，我在第1100行加入。注意，不要在该行后加任何注释。\n\u0026#34;wdd\u0026#34;: \u0026#34;wangduanduan.github.io\u0026#34;, 3 commit\n4. 加入CNAME文件 我是用hexo和next主题作为博客的模板。其中我在gh-pages分支写博客，然后部署到master分支。\n我在我的gh-pages分支的source目录下加入CNAME文件, 内容只有一行\nwdd.js.org 将博客再次部署好，如果CNAME生效的话，你已经无法从原来的地址访问：wangduanduan.github.io， 这个博客了。\n5. 向js.org项目发起pull-request 找到你fork后的项目，点击 new pull request, 向原来的项目发起请求。\n然后你可以在js-org/dns.js.org项目的pull requests看到你的请求，当这个请求被合并时，你就拥有了js.org的二级域名。","title":"组织在召唤：如何免费获取一个js.org的二级域名"},{"content":"1. visibilitychange事件 触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.\n使用场景：当标签页显示或者隐藏时，触发一些业务逻辑\ndocument.addEventListener(\u0026#34;visibilitychange\u0026#34;, function() { console.log( document.visibilityState ); }); 2. storage事件 触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时\n使用场景：标签页间通信\n// AB页面同源 // 在A 页面 window.addEventListener(\u0026#39;storage\u0026#39;, (e) =\u0026gt; {console.log(e)}) // 在B 页面，向120打个电话 localStorage.setItem(\u0026#39;makeCall\u0026#39;,\u0026#39;120\u0026#39;) // 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知 ...key: \u0026#34;makeCall\u0026#34;, oldValue: \u0026#34;119\u0026#34;, newValue: \u0026#34;120\u0026#34;, ... 3. beforeunload事件 触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时\n使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等\nwindow.addEventListener(\u0026#34;beforeunload\u0026#34;, function (e) { var confirmationMessage = \u0026#34;\\o/\u0026#34;; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome \u0026lt;34 }); 4. navigator.sendBeacon 这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。\n使用 sendBeacon() 方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！\n注意：该方法在IE和safari没有实现\n使用场景：发送崩溃报告\nwindow.addEventListener(\u0026#39;unload\u0026#39;, logData, false); function logData() { navigator.sendBeacon(\u0026#34;/log\u0026#34;, analyticsData); } ","permalink":"https://wdd.js.org/posts/2018/browser-events/","summary":"1. visibilitychange事件 触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件.\n使用场景：当标签页显示或者隐藏时，触发一些业务逻辑\ndocument.addEventListener(\u0026#34;visibilitychange\u0026#34;, function() { console.log( document.visibilityState ); }); 2. storage事件 触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时\n使用场景：标签页间通信\n// AB页面同源 // 在A 页面 window.addEventListener(\u0026#39;storage\u0026#39;, (e) =\u0026gt; {console.log(e)}) // 在B 页面，向120打个电话 localStorage.setItem(\u0026#39;makeCall\u0026#39;,\u0026#39;120\u0026#39;) // 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知 ...key: \u0026#34;makeCall\u0026#34;, oldValue: \u0026#34;119\u0026#34;, newValue: \u0026#34;120\u0026#34;, ... 3. beforeunload事件 触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时\n使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等\nwindow.addEventListener(\u0026#34;beforeunload\u0026#34;, function (e) { var confirmationMessage = \u0026#34;\\o/\u0026#34;; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome \u0026lt;34 }); 4.","title":"不常用却很有妙用的事件及方法"},{"content":" 没有什么事情是一个框架解决不了的，如果有，就再找一个。\nPhoto by 贝莉儿 NG on Unsplash\n1. MVC frameworks 2. Sinatra-like 这些框架提供了丰富的配置，比Rails-like或full-stack少。\nExpress hapi flatiron locomotive total.js koa.js TWEE.IO diet.js Flicker.js ZinkyJS 2.1. Rails-like 正确呈现您的项目。从包含的模板创建自己的艺术\nNodal Strapi CompoundJS geddy Sails.js Adonis RhapsodyJS ThinkJS Trails KambojaJS JS-Web 3. Full-stack frameworks 这就是Node.js真正闪耀的地方。全栈MVC框架与脚手架，模板引擎，websocket和持久性库捆绑在一起，允许您构建实时可伸缩的Web应用程序。\nCatberry.js AllcountJS Derby Feathers SocketCluster SocketStream MEAN.js MEAN.io Meteor Meatier TWEE.IO Mojito Seeds.js SANE COKE Sleekjs Danf Catberry Nuke.js We.js seneca.js Keystone.js Horizon Apogeu 4. REST API frameworks 对于那些使用富客户端/前端MVC框架（或不）的客户，只需要启动一个快速的Node.js REST API服务器即可。\nIvy Restocat actionHero.js Frisby restling restify restmvc percolator LoopBack Fortune.js facet Raddish Restberry Gugamarket Nest microlet Moleculer 5. Other libraries 中间件，库和静态站点生成器。\nConnect\nKraken\newdGateway2\nWintersmith\ndocpad\nBlacksmith\nromulus\nPetrify\nTower.js\nImpress\nRendr\nBacknode\nSequelize\nCylon.js\nVirgilio.js\nSHPS\n","permalink":"https://wdd.js.org/posts/2018/nodejs-server-frameworks/","summary":"没有什么事情是一个框架解决不了的，如果有，就再找一个。\nPhoto by 贝莉儿 NG on Unsplash\n1. MVC frameworks 2. Sinatra-like 这些框架提供了丰富的配置，比Rails-like或full-stack少。\nExpress hapi flatiron locomotive total.js koa.js TWEE.IO diet.js Flicker.js ZinkyJS 2.1. Rails-like 正确呈现您的项目。从包含的模板创建自己的艺术\nNodal Strapi CompoundJS geddy Sails.js Adonis RhapsodyJS ThinkJS Trails KambojaJS JS-Web 3. Full-stack frameworks 这就是Node.js真正闪耀的地方。全栈MVC框架与脚手架，模板引擎，websocket和持久性库捆绑在一起，允许您构建实时可伸缩的Web应用程序。\nCatberry.js AllcountJS Derby Feathers SocketCluster SocketStream MEAN.js MEAN.io Meteor Meatier TWEE.IO Mojito Seeds.js SANE COKE Sleekjs Danf Catberry Nuke.js We.js seneca.js Keystone.js Horizon Apogeu 4. REST API frameworks 对于那些使用富客户端/前端MVC框架（或不）的客户，只需要启动一个快速的Node.","title":"Nodejs 服务端框架合集(78个)"},{"content":"1. You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。\n内容目录\n手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子\n2. You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。\n来自开发者的声音\n在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment\n你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript\n我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular\n我承认，我曾经过度使用lodash. —@therebelrobot, Maker of web things, Facilitator for Node.js/io.js\n内容目录\nArray _.compact _.concat _.fill _.find _.findIndex _.first _.flatten _.flattenDeep _.head and _.tail _.indexOf _.join _.last _.lastIndexOf _.reverse _.without _.slice _.isArray Collection _.each _.every _.filter _.groupBy _.includes _.map _.minBy and _.maxBy _.pluck _.range _.reduce _.reduceRight _.size _.some Function _.after Lang _.isNaN Object _.assign _.keys _.toPairs _.values String _.repeat _.template _.toLower _.toUpper _.trim _.replace 3. You-Dont-Need-jQuery 纯JavaScript的例子, 实现做jQuery与查询，样式，dom，ajax，事件等\n前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。\n内容目录\nTranslations Query Selector CSS \u0026amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support 4. You-Dont-Need-GUI 图形用户界面对计算机用户非常友好。它们被引入以响应命令行界面（CLI）感知的陡峭学习曲线。\n但是，他们往往需要更多的资源，功能不强，难以通过脚本自动化。\n作为计算机专家，我们希望更高效，更好地完成工作。我们知道命令字可能不容易被发现或助记符，所以我们尝试列出一些您可能试图在GUI中执行的常见任务。\n内容目录\n复制一个文件 复制一个文件 复制一个文件夹 复制一个文件夹 移动一个文件 重命名一个文件 移动一个文件夹 重命名文件夹 合并文件夹 创建一个新的文件 新建一个文件夹 显示文件/文件夹大小 用默认程序打开一个文件 压缩一个文件夹 解压缩文件夹 删除一个文件 删除一个文件夹 列出文件夹内容 树查看文件夹及其子文件夹 找到一个陈旧的文件 显示一个日历 找到未来的日期 使用计算器 强制退出程序 ","permalink":"https://wdd.js.org/posts/2018/you-dont-need/","summary":"1. You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。\n内容目录\n手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子\n2. You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。\n来自开发者的声音\n在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment\n你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript\n我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular","title":"You-Dont-Need 你不需要系列"},{"content":"1. 系统环境 centos7 内核：3.10.0-514.26.2.el7.x86_64 安装docker要求内核版本不低于3.10 2. 安装docker yum install docker // 安装docker systemctl start docker.service // 启动docker systemctl enable docker.service // 设置开机启动 3. Nodejs 镜像选择 REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/node 9.2.1-slim 69c9f9292fa4 3 days ago 230 MB docker.io/node 9.2.1-alpine afdc3aaaf748 3 days ago 67.46 MB docker.io/node latest 727b047a1f4e 3 days ago 675.6 MB docker.io/iron/node latest 9ca501065d18 20 months ago 18.56 MB 选择镜像的标准\n官方的 经常维护的 体积小的 要有yarn 和 npm node版本要高 最终选择 node:9.2.1-alpine, 该镜像体积很小，已经内置npm(5.5.1), yarn(1.3.2)\n4. 时区配置 node:9.2.1-alpine的时区默认不是国内的，需要在build时，配置时区。\nFROM node:9.2.1-alpine # Install base packages and set timezone ShangHai RUN apk update \u0026amp;\u0026amp; apk add bash tzdata \\ \u0026amp;\u0026amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ... ... ... CMD [ \u0026#34;node\u0026#34; ] 验证：\n➜ node-dockerfile git:(master) docker run -it e595 sh / # yarn -v 1.3.2 / # npm -v 5.5.1 / # node -v v9.2.1 / # date Tue Dec 12 17:33:26 CST 2017 ","permalink":"https://wdd.js.org/posts/2018/nodejs-alpine-docker/","summary":"1. 系统环境 centos7 内核：3.10.0-514.26.2.el7.x86_64 安装docker要求内核版本不低于3.10 2. 安装docker yum install docker // 安装docker systemctl start docker.service // 启动docker systemctl enable docker.service // 设置开机启动 3. Nodejs 镜像选择 REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/node 9.2.1-slim 69c9f9292fa4 3 days ago 230 MB docker.io/node 9.2.1-alpine afdc3aaaf748 3 days ago 67.46 MB docker.io/node latest 727b047a1f4e 3 days ago 675.6 MB docker.io/iron/node latest 9ca501065d18 20 months ago 18.56 MB 选择镜像的标准\n官方的 经常维护的 体积小的 要有yarn 和 npm node版本要高 最终选择 node:9.","title":"Nodejs alpine 基础docker镜像构建"},{"content":" 当你用浏览器访问某个网页时，你可曾想过，你看到的这个网页，实际上是属于你自己的。\n打个比喻：访问某个网站就好像是网购了一筐鸡蛋，鸡蛋虽然是养鸡场生产的，但是这个蛋我怎么吃，你养鸡场管不着。\n当然了，对于很多人来说，鸡蛋没有别的吃法，鸡蛋只能煮着吃。\n你可以看如下的页面：当你在某搜索引擎上搜索前端开发时\n大多数人看到的页面是这样的, 满屏的广告，满屏的推广，满屏的排名，满屏的中间地址跳转，满屏的流量劫持, 还有莆田系\n但是有些人的页面却是这样的：清晰，自然，链接直达，清水出芙蓉，天然去雕饰 这就是油猴子脚本干的事情， 当然，它能干的事情，远不止如此。它是齐天大圣孙悟空，有七十二变。\n1. 什么是油猴子脚本？ Greasemonkey，简称GM，中文俗称为“油猴”，是Firefox的一个附加组件。它让用户安装一些脚本使大部分HTML为主的网页于用户端直接改变得更方便易用。随着Greasemonkey脚本常驻于浏览器，每次随着目的网页打开而自动做修改，使得运行脚本的用户印象深刻地享受其固定便利性。\nGreasemonkey可替网页加入些新功能（例如在亚马逊书店嵌入商品比价功能）、修正网页错误、组合来自不同网页的数据、或者数繁不及备载的其他功能。写的好的Greasemonkey脚本甚至可让其输出与被修改的页面集成得天衣无缝，像是原本网页里的一部分。 来自维基百科\n2. 如何安装油猴子插件？ 在google商店搜索Tampermonkey, 安装量最高的就是它。\n3. 如何写油猴子脚本？ 油猴子脚本有个新建脚本页面，在此页面可以创建脚本。具体教程可以参考。\n中文 GreaseMonkey 用户脚本开发手册 GreaseMonkey（油猴子）脚本开发 深入浅出 Greasemonkey Greasemonkey Hacks/Getting Started 4. 如何使用他人的脚本？ greasyfork网站提供很多脚本，它仿佛是代码界的github, 可以在该网站搜到很多有意思的脚本。\n5. 有哪些好用的脚本？ 有哪些超神的油猴脚本?\n或者你可以在greasyfork网站查看一些下载量排行\n","permalink":"https://wdd.js.org/posts/2018/tampermonkey/","summary":"当你用浏览器访问某个网页时，你可曾想过，你看到的这个网页，实际上是属于你自己的。\n打个比喻：访问某个网站就好像是网购了一筐鸡蛋，鸡蛋虽然是养鸡场生产的，但是这个蛋我怎么吃，你养鸡场管不着。\n当然了，对于很多人来说，鸡蛋没有别的吃法，鸡蛋只能煮着吃。\n你可以看如下的页面：当你在某搜索引擎上搜索前端开发时\n大多数人看到的页面是这样的, 满屏的广告，满屏的推广，满屏的排名，满屏的中间地址跳转，满屏的流量劫持, 还有莆田系\n但是有些人的页面却是这样的：清晰，自然，链接直达，清水出芙蓉，天然去雕饰 这就是油猴子脚本干的事情， 当然，它能干的事情，远不止如此。它是齐天大圣孙悟空，有七十二变。\n1. 什么是油猴子脚本？ Greasemonkey，简称GM，中文俗称为“油猴”，是Firefox的一个附加组件。它让用户安装一些脚本使大部分HTML为主的网页于用户端直接改变得更方便易用。随着Greasemonkey脚本常驻于浏览器，每次随着目的网页打开而自动做修改，使得运行脚本的用户印象深刻地享受其固定便利性。\nGreasemonkey可替网页加入些新功能（例如在亚马逊书店嵌入商品比价功能）、修正网页错误、组合来自不同网页的数据、或者数繁不及备载的其他功能。写的好的Greasemonkey脚本甚至可让其输出与被修改的页面集成得天衣无缝，像是原本网页里的一部分。 来自维基百科\n2. 如何安装油猴子插件？ 在google商店搜索Tampermonkey, 安装量最高的就是它。\n3. 如何写油猴子脚本？ 油猴子脚本有个新建脚本页面，在此页面可以创建脚本。具体教程可以参考。\n中文 GreaseMonkey 用户脚本开发手册 GreaseMonkey（油猴子）脚本开发 深入浅出 Greasemonkey Greasemonkey Hacks/Getting Started 4. 如何使用他人的脚本？ greasyfork网站提供很多脚本，它仿佛是代码界的github, 可以在该网站搜到很多有意思的脚本。\n5. 有哪些好用的脚本？ 有哪些超神的油猴脚本?\n或者你可以在greasyfork网站查看一些下载量排行","title":"油猴子脚本 - 我的地盘我做主"},{"content":"二十年后，域js.org第一次注册，它终于服务于其明显的目的 - JavaScript社区。\n从一开始，对JavaScript的看法各不相同 - 有些人喜欢的语言，有人讨厌它。但是，对于使JavaScript成为最受欢迎的编程语言之一的社区的威力，应该毫无疑问。 为了与社区的自由开放的心态保持一致，JS.ORG为开发人员及其项目免费提供了子域名。自第一步以来，我们还专注于跟踪JavaScript趋势并传播有关它的新闻。\n贡献是欢迎：如果你有热情开始一个合作项目，或者如果你想成为JS.ORG的成员，并贡献JS.ORG，随时与我联系。\n1. DNS 如果您是JavaScript开发人员，您可能已经听说过 - 或者甚至已经使用GitHub页面来托管您的内容。 DNS.JS.ORG补充GitHub提供的免费网络空间，并提供了一个适合您项目的自由和时尚的网址。\n2. STARTS STATS.JS.ORG获取GitHub上最重要的JavaScript项目的统计参数，并将它们填充到10k行的巨型表中。这个项目旨在使JavaScript的趋势可见。\n3. NEWS 你有什么东西要与社区分享或想阅读其他JavaScript爱好者的东西吗？ NEWS.JS.ORG提供了一种方便的传播，消费和讨论JavaScript项目。\n4. WASM WebAssembly（或简称wasm）是一种用于Web平台上的低级代码的新的二进制语法。 WASM.NEWS是JS.ORG计划的一个分支，并作为这个即将到来的主题的新闻聚合。\n","permalink":"https://wdd.js.org/posts/2018/js-org/","summary":"二十年后，域js.org第一次注册，它终于服务于其明显的目的 - JavaScript社区。\n从一开始，对JavaScript的看法各不相同 - 有些人喜欢的语言，有人讨厌它。但是，对于使JavaScript成为最受欢迎的编程语言之一的社区的威力，应该毫无疑问。 为了与社区的自由开放的心态保持一致，JS.ORG为开发人员及其项目免费提供了子域名。自第一步以来，我们还专注于跟踪JavaScript趋势并传播有关它的新闻。\n贡献是欢迎：如果你有热情开始一个合作项目，或者如果你想成为JS.ORG的成员，并贡献JS.ORG，随时与我联系。\n1. DNS 如果您是JavaScript开发人员，您可能已经听说过 - 或者甚至已经使用GitHub页面来托管您的内容。 DNS.JS.ORG补充GitHub提供的免费网络空间，并提供了一个适合您项目的自由和时尚的网址。\n2. STARTS STATS.JS.ORG获取GitHub上最重要的JavaScript项目的统计参数，并将它们填充到10k行的巨型表中。这个项目旨在使JavaScript的趋势可见。\n3. NEWS 你有什么东西要与社区分享或想阅读其他JavaScript爱好者的东西吗？ NEWS.JS.ORG提供了一种方便的传播，消费和讨论JavaScript项目。\n4. WASM WebAssembly（或简称wasm）是一种用于Web平台上的低级代码的新的二进制语法。 WASM.NEWS是JS.ORG计划的一个分支，并作为这个即将到来的主题的新闻聚合。","title":"【译】一个值得所有前端开发者关注的网站 js.org"},{"content":" 引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？\n看来是时候扒一扒这两个方法的历史了。\n1. 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？\n1950与1960年代\n1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式\n1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能\n1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代\n1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.1. 在C++中首次出现substr() 在c语言中，并没有出现substr或者substring方法。然而在1983，substr()方法已经出现在C++语言中了。然而这时候还没有出现substring, 所以可以见得：substr是stustring的老大哥\nstring substr (size_t pos = 0, size_t len = npos) const; 从C++的方法定义中可以看到, substr的参数是开始下标，以及字符串长度。\nstd::string str=\u0026#34;We think in generalities, but we live in details.\u0026#34;; std::string str2 = str.substr (3,5); // \u0026#34;think\u0026#34; 1.2. 在Java中首次出现substring() 距离substr()方法出现已经有了将近十年之隔，此间涌现一批后起之秀，如: Python, Ruby, VB之类，然而他们之中并没有stustring的基因，在Java的String类中，我们看到两个方法。从这两个方法之中我们可以看到：substring方法基本原型的参数是开始和结束的下标。\nString substring(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) // 返回一个新字符串，它是此字符串的一个子字符串。 2. JavaScript的历史继承 1995年，网景公司招募了Brendan Eich，目的是将Scheme编程语言嵌入到Netscape Navigator中。在开始之前，Netscape Communications与Sun Microsystems公司合作，在Netscape Navigator中引入了更多的静态编程语言Java，以便与微软竞争用户采用Web技术和平台。网景公司决定，他们想创建的脚本语言将补充Java，并且应该有一个类似的语法，排除采用Perl，Python，TCL或Scheme等其他语言。为了捍卫对竞争性提案的JavaScript的想法，公司需要一个原型。 1995年5月，Eich在10天内写完。\n上帝用七天时间创造万物, Brendan Eich用10天时间创造了一门语言。或许用创造并不合适，因为JavaScript是站在了Perl，Python，TCL或Scheme等其他巨人的肩膀上而产生的。\nJavaScript并不像C那样出身名门，在贝尔实验室精心打造，但是JavaScript在往后的自然选择中，并没有因此萧条，反而借助于C,C++, Java, Perl，Python，TCL, Scheme优秀基因，进化出更加强大强大的生命力。\n因此可以想象，在10天之内，当Brendan Eich写到String的substr和substring方法时，或许他并没困惑着两个方法的参数应该如何设置，因为在C++和Java的实现中，已经有了类似的定义。 如果你了解历史，你就不会困惑现在。\n3. 所以，substr和substring究竟有什么不同？ 如下图所示：substr和substring都接受两个参数，他们的第一个参数的含义是相同的，不同的是第二个参数。substr的第二个参数是到达结束点的距离，substring是结束的位置。\n4. 参考文献 维基百科：程式語言歷史 C++ std::string::substr JavaScript 如有不正确的地方，欢迎指正。\n","permalink":"https://wdd.js.org/posts/2018/substr-and-substring-history/","summary":"引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？\n看来是时候扒一扒这两个方法的历史了。\n1. 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？\n1950与1960年代\n1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式\n1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能\n1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代\n1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.","title":"追本溯源：substr与substring历史漫话"},{"content":"1. 情景再现 以前用nodejs写后端程序时，遇到Promise这个概念，这个东西好呀！不用谢一层一层回调，直接用类似于jQuery的连缀方式。后来遇到bluebird这个库，它就是Promise库中很有名的。我希望可以把Promise用在前端的ajax请求上，但是我不想又引入bluebird。后来发现，jquery本身就具有类似于Promise的东西。于是我就jquery的Promise写一些异步请求。\n2. 不堪回首 看看一看我以前写异步请求的方式\n// 函数定义 function sendRequest(req,successCallback,errorCallback){ $.ajax({ ... ... success:function(res){ successCallback(res); }, error:function(res){ errorCallback(res); } }); } // 函数调用,这个函数的匿名函数写的时候很容易出错，而且有时候难以理解 sendRequest(req,function(res){ //请求成功 ... },function(res){ //请求失败 ... }); 3. 面朝大海 下面是我希望的异步调用方式\nsendRequest(req) .done(function(res){ //请求成功 ... }) .fail(function(req){ //请求失败 ... }); 4. 废话少说，放‘码’过来 talk is cheap, show me the code\n// 最底层的发送异步请求，做成Promise的形式 App.addMethod(\u0026#39;_sendRequest\u0026#39;,function(path,method,payload){ var dfd = $.Deferred(); $.ajax({ url:path, type:method || \u0026#34;get\u0026#34;, headers:{ sessionId:session.id || \u0026#39;\u0026#39; }, data:JSON.stringify(payload), dataType:\u0026#34;json\u0026#34;, contentType : \u0026#39;application/json; charset=UTF-8\u0026#39;, success:function(data){ dfd.resolve(data); }, error:function(data){ dfd.reject(data); } }); return dfd.promise(); }); //根据callId查询录音文件，不仅仅是异步请求可以做成Promise形式，任何函数都可以做成Promise形式 App.addMethod(\u0026#39;_getRecordingsByCallId\u0026#39;,function(callId){ var dfd = $.Deferred(), path = \u0026#39;/api/tenantcalls/\u0026#39;+callId+\u0026#39;/recordings\u0026#39;; App._sendRequest(path) .done(function(res){dfd.resolve(res);}) .fail(function(res){dfd.reject(res);}); return dfd.promise(); }); // 获取录音 App.addMethod(\u0026#39;getCallDetailRecordings\u0026#39;,function(callId){ App._getRecordingsByCallId(callId) .done(function(res){ // 获取结果后渲染数据 App.renderRecording(res); }) .fail(function(res){ App.error(res); }); }); 5. 注意事项 jQuery的Promise主要是用了jQquery的$.Derferred()方法，一些老版本的jquery并不支持此方法。 jQuery版本必须大于等于1.5，推荐使用1.11.3 6. 参考文献 jquery官方api文档 jquery维基百科文档 7. 最后 以上文章仅供参考，不包完全正确。欢迎评论，3q。\n","permalink":"https://wdd.js.org/posts/2018/jquery-deferred/","summary":"1. 情景再现 以前用nodejs写后端程序时，遇到Promise这个概念，这个东西好呀！不用谢一层一层回调，直接用类似于jQuery的连缀方式。后来遇到bluebird这个库，它就是Promise库中很有名的。我希望可以把Promise用在前端的ajax请求上，但是我不想又引入bluebird。后来发现，jquery本身就具有类似于Promise的东西。于是我就jquery的Promise写一些异步请求。\n2. 不堪回首 看看一看我以前写异步请求的方式\n// 函数定义 function sendRequest(req,successCallback,errorCallback){ $.ajax({ ... ... success:function(res){ successCallback(res); }, error:function(res){ errorCallback(res); } }); } // 函数调用,这个函数的匿名函数写的时候很容易出错，而且有时候难以理解 sendRequest(req,function(res){ //请求成功 ... },function(res){ //请求失败 ... }); 3. 面朝大海 下面是我希望的异步调用方式\nsendRequest(req) .done(function(res){ //请求成功 ... }) .fail(function(req){ //请求失败 ... }); 4. 废话少说，放‘码’过来 talk is cheap, show me the code\n// 最底层的发送异步请求，做成Promise的形式 App.addMethod(\u0026#39;_sendRequest\u0026#39;,function(path,method,payload){ var dfd = $.Deferred(); $.ajax({ url:path, type:method || \u0026#34;get\u0026#34;, headers:{ sessionId:session.id || \u0026#39;\u0026#39; }, data:JSON.stringify(payload), dataType:\u0026#34;json\u0026#34;, contentType : \u0026#39;application/json; charset=UTF-8\u0026#39;, success:function(data){ dfd.","title":"熟练使用使用jQuery Promise (Deferred)"},{"content":"title: cypress基础教程 tags:\ncypress 端到端测试 categories: [] date: 2018-07-12 16:43:00 1. 软件安装. 2. 安装cypress 安装cypress客户端：http://download.cypress.io/desktop 安装vscode编辑器：https://code.visualstudio.com/Download 3. 初始化 假如项目目录是 /test 打开cypress客户端， 点击箭头位置，通过资源管理器选择/test目录 如果/test没有cypress目录，那么cypress就会在test目录下新建cypress目录，并初始化一些文件 4. cypress目录分析 - cypress // cypress目录 ---- fixtures 测试数据配置文件，可以使用fixture方法读取 ---- integration 测试脚本文件 ---- plugin 插件文件 ---- support 支持文件 - cypress.json // cypress全局配置文件 5. 基本例子 一般流程\n访问某个页面 查找DOM进行交互，例如输入，点击，选择之类 进行断言 describe(\u0026#39;Hacker News登录测试\u0026#39;, () =\u0026gt; { it(\u0026#39;登录页面\u0026#39;, () =\u0026gt; { cy.visit(\u0026#39;https://news.ycombinator.com/login?goto=news\u0026#39;) cy.get(\u0026#39;input[name=\u0026#34;acct\u0026#34;]\u0026#39;).eq(0).type(\u0026#39;test\u0026#39;) cy.get(\u0026#39;input[name=\u0026#34;pw\u0026#34;]\u0026#39;).eq(0).type(\u0026#39;123456\u0026#39;) cy.get(\u0026#39;input[value=\u0026#34;login\u0026#34;]\u0026#39;).click() cy.get(\u0026#39;body\u0026#39;).should(\u0026#39;contain\u0026#39;, \u0026#39;Bad login\u0026#39;) }) }) 6. DOM选取 参考： https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#\njquery选择法 通过客户端GUI工具选取 7. DOM交互 .click() 单击 .dblclick() 双击 .type() 输入 .clear() 清空 .check() 选中 .uncheck() 取消选中 .select() 下拉框选择 .trigger() 反转 8. 断言 .contains() 查找匹配字符串 .should() 更多断言参考 https://docs.cypress.io/guides/references/assertions.html\n8.1. 长度断言 // retry until we find 3 matching \u0026lt;li.selected\u0026gt; cy.get(\u0026#39;li.selected\u0026#39;).should(\u0026#39;have.length\u0026#39;, 3) 8.2. 类断言 // retry until this input does not have class disabled cy.get(\u0026#39;form\u0026#39;).find(\u0026#39;input\u0026#39;).should(\u0026#39;not.have.class\u0026#39;, \u0026#39;disabled\u0026#39;) 8.3. 值断言 // retry until this textarea has the correct value cy.get(\u0026#39;textarea\u0026#39;).should(\u0026#39;have.value\u0026#39;, \u0026#39;foo bar baz\u0026#39;) 8.4. 文本断言 // retry until this span does not contain \u0026#39;click me\u0026#39; cy.get(\u0026#39;a\u0026#39;).parent(\u0026#39;span.help\u0026#39;).should(\u0026#39;not.contain\u0026#39;, \u0026#39;click me\u0026#39;) 8.5. 可见性断言 // retry until this button is visible cy.get(\u0026#39;button\u0026#39;).should(\u0026#39;be.visible\u0026#39;) 8.6. 存在性断言 // retry until loading spinner no longer exists cy.get(\u0026#39;#loading\u0026#39;).should(\u0026#39;not.exist\u0026#39;) 8.7. 状态断言 // retry until our radio is checked cy.get(\u0026#39;:radio\u0026#39;).should(\u0026#39;be.checked\u0026#39;) 9. 读取测试配置数据 Cypress.env() 可以读取全局配置 fixture(文件名).as(变量), 可以将文件中的配置数据读取为变量，作为后续的测试用例来使用，注意这一步是异步的，必须放在before或者beforeEach等钩子函数中使用 describe(\u0026#39;软电话登录\u0026#39;, function () { before(() =\u0026gt; { cy.fixture(Cypress.env(\u0026#39;envName\u0026#39;) + \u0026#39;-login-data.json\u0026#39;).as(\u0026#39;loginData\u0026#39;) }) it(\u0026#39;wellClient test\u0026#39;, function () { cy.log(this.loginData) cy.visit(this.loginData.url) cy.get(\u0026#39;#config-env\u0026#39;).select(\u0026#39;CMB-TEST\u0026#39;) cy.get(\u0026#39;#config\u0026#39;).click() cy.get(\u0026#39;#well-code\u0026#39;).type(this.loginData.jobNumber) cy.get(\u0026#39;#well-password\u0026#39;).type(this.loginData.password) cy.get(\u0026#39;#well-namespace\u0026#39;).type(this.loginData.domain) cy.get(\u0026#39;#well-deviceId\u0026#39;).type(this.loginData.ext) cy.get(\u0026#39;#well-login\u0026#39;).click() cy.wait(3000) cy.get(\u0026#39;#well-login\u0026#39;).should(\u0026#39;not.be.visible\u0026#39;) }) }) 10. 全局配置 cypress.json 参考：https://docs.cypress.io/guides/references/configuration.html#Options\n11. 变量与别称 参考：https://docs.cypress.io/guides/core-concepts/variables-and-aliases.html#\n12. 钩子函数 参考： https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests.html#Hooks\nbefore() beforeEach() afterEach() after() 13. 最佳实践 参考： https://docs.cypress.io/guides/references/best-practices.html\n其他 cy.window() 异步获取window对象，无法直接使用window对象 ","permalink":"https://wdd.js.org/posts/2018/cypress-basic-tutor/","summary":"title: cypress基础教程 tags:\ncypress 端到端测试 categories: [] date: 2018-07-12 16:43:00 1. 软件安装. 2. 安装cypress 安装cypress客户端：http://download.cypress.io/desktop 安装vscode编辑器：https://code.visualstudio.com/Download 3. 初始化 假如项目目录是 /test 打开cypress客户端， 点击箭头位置，通过资源管理器选择/test目录 如果/test没有cypress目录，那么cypress就会在test目录下新建cypress目录，并初始化一些文件 4. cypress目录分析 - cypress // cypress目录 ---- fixtures 测试数据配置文件，可以使用fixture方法读取 ---- integration 测试脚本文件 ---- plugin 插件文件 ---- support 支持文件 - cypress.json // cypress全局配置文件 5. 基本例子 一般流程\n访问某个页面 查找DOM进行交互，例如输入，点击，选择之类 进行断言 describe(\u0026#39;Hacker News登录测试\u0026#39;, () =\u0026gt; { it(\u0026#39;登录页面\u0026#39;, () =\u0026gt; { cy.visit(\u0026#39;https://news.ycombinator.com/login?goto=news\u0026#39;) cy.get(\u0026#39;input[name=\u0026#34;acct\u0026#34;]\u0026#39;).eq(0).type(\u0026#39;test\u0026#39;) cy.get(\u0026#39;input[name=\u0026#34;pw\u0026#34;]\u0026#39;).eq(0).type(\u0026#39;123456\u0026#39;) cy.get(\u0026#39;input[value=\u0026#34;login\u0026#34;]\u0026#39;).click() cy.get(\u0026#39;body\u0026#39;).should(\u0026#39;contain\u0026#39;, \u0026#39;Bad login\u0026#39;) }) }) 6. DOM选取 参考： https://docs.","title":""}]