<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Containers on 洞香春</title>
    <link>https://wdd.js.org/container/</link>
    <description>Recent content in Containers on 洞香春</description>
    <image>
      <title>洞香春</title>
      <url>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wdd.js.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 26 Oct 2022 08:59:44 +0800</lastBuildDate><atom:link href="https://wdd.js.org/container/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优雅停止的pod</title>
      <link>https://wdd.js.org/container/terminating-with-grace/</link>
      <pubDate>Wed, 26 Oct 2022 08:59:44 +0800</pubDate>
      
      <guid>https://wdd.js.org/container/terminating-with-grace/</guid>
      <description>原文：https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-terminating-with-grace
Editor’s note: Today is the fifth installment in a seven-part video and blog series from Google Developer Advocate Sandeep Dinesh on how to get the most out of your Kubernetes environment.
When it comes to distributed systems, handling failure is key. Kubernetes helps with this by utilizing controllers that can watch the state of your system and restart services that have stopped performing. On the other hand, Kubernetes can often forcibly terminate your application as part of the normal operation of the system.</description>
    </item>
    
    <item>
      <title>K8s pod node网络</title>
      <link>https://wdd.js.org/container/k8s-network/</link>
      <pubDate>Wed, 26 Oct 2022 08:57:54 +0800</pubDate>
      
      <guid>https://wdd.js.org/container/k8s-network/</guid>
      <description>1. 同一个Node上的pod网段相同 kube-node1 pod1: 172.16.30.8 pod2: 172.16.30.9 pod3: 172.16.30.23 kube-node2 pod4: 172.18.0.5 pod5: 172.18.0.6 2. pod中service name dns解析 使用nslookup命令去查询service name
第2行 DNS服务器名 第3行 DNS服务器地址 第5行 目标主机的名称 第6行 目标主机的IP地址 bash-5.0# nslookup security Server:	10.254.10.20 Address:	10.254.10.20#53 Name:	security.test.svc.cluster.local Address: 10.254.63.136 2.1. 问题1： 那么问题来了，为什么我要解析的域名是security, 但是返回的主机名是security.test.svc.cluster.local呢？
bash-5.0# cat /etc/resolv.conf nameserver 10.254.10.20 search test.svc.cluster.local svc.cluster.local cluster.local options ndots:5 在/etc/resolve.conf中，search选项后有几个值，它的作用是，如果你搜索的主机名中没有点, 那么你输入的名字就会和search选中的名字组合，也就是说。
你输入的是abc, 那么就会按照如何下的顺序去解析域名
abc.test.svc.cluster.local abc.svc.cluster.local cluster.local 所以我们看到的dns解析的名字就是abc.test.svc.cluster.local。
2.2. 问题2： 在resolve.conf中，dns服务器的地址是10.254.10.20，那么这个地址运行的是什么呢？
我们用dns反向解析，将IP解析为域名，可以看到主机的名称为kube-dns.kube-system.svc.cluster.local.
bash-5.0# nslookup 10.254.10.20 20.10.254.10.in-addr.arpa	name = kube-dns.</description>
    </item>
    
  </channel>
</rss>
