<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Containers on 洞香春</title>
    <link>https://wdd.js.org/container/</link>
    <description>Recent content in Containers on 洞香春</description>
    <generator>Hugo -- 0.151.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 26 Oct 2022 08:59:44 +0800</lastBuildDate>
    <atom:link href="https://wdd.js.org/container/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优雅停止的pod</title>
      <link>https://wdd.js.org/container/terminating-with-grace/</link>
      <pubDate>Wed, 26 Oct 2022 08:59:44 +0800</pubDate>
      <guid>https://wdd.js.org/container/terminating-with-grace/</guid>
      <description>&lt;p&gt;原文：&lt;a href=&#34;https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-terminating-with-grace&#34;&gt;https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-terminating-with-grace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Editor’s note: Today is the fifth installment in a seven-part video and blog series from Google Developer Advocate Sandeep Dinesh on how to get the most out of your Kubernetes environment.&lt;/p&gt;
&lt;p&gt;When it comes to distributed systems, handling failure is key. Kubernetes helps with this by utilizing controllers that can watch the state of your system and restart services that have stopped performing. On the other hand, Kubernetes can often forcibly terminate your application as part of the normal operation of the system.&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s pod node网络</title>
      <link>https://wdd.js.org/container/k8s-network/</link>
      <pubDate>Wed, 26 Oct 2022 08:57:54 +0800</pubDate>
      <guid>https://wdd.js.org/container/k8s-network/</guid>
      <description>&lt;h1 id=&#34;1-同一个node上的pod网段相同&#34;&gt;1. 同一个Node上的pod网段相同&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;kube-node1
&lt;ul&gt;
&lt;li&gt;pod1: 172.16.30.8&lt;/li&gt;
&lt;li&gt;pod2: 172.16.30.9&lt;/li&gt;
&lt;li&gt;pod3: 172.16.30.23&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;kube-node2
&lt;ul&gt;
&lt;li&gt;pod4: 172.18.0.5&lt;/li&gt;
&lt;li&gt;pod5: 172.18.0.6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-pod中service-name-dns解析&#34;&gt;2. pod中service name dns解析&lt;/h1&gt;
&lt;p&gt;使用nslookup命令去查询service name&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第2行 DNS服务器名&lt;/li&gt;
&lt;li&gt;第3行 DNS服务器地址&lt;/li&gt;
&lt;li&gt;第5行 目标主机的名称&lt;/li&gt;
&lt;li&gt;第6行 目标主机的IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bash-5.0# nslookup security
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Server:		10.254.10.20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Address:	10.254.10.20#53
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Name:	security.test.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Address: 10.254.63.136
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;21-问题1&#34;&gt;2.1. 问题1：&lt;/h2&gt;
&lt;p&gt;那么问题来了，为什么我要解析的域名是security, 但是返回的主机名是security.test.svc.cluster.local呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bash-5.0# cat /etc/resolv.conf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nameserver 10.254.10.20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;search test.svc.cluster.local svc.cluster.local cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;options ndots:5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在/etc/resolve.conf中，search选项后有几个值，它的作用是，如果你搜索的主机名中没有点, 那么你输入的名字就会和search选中的名字组合，也就是说。&lt;/p&gt;
&lt;p&gt;你输入的是abc, 那么就会按照如何下的顺序去解析域名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;abc.test.svc.cluster.local&lt;/li&gt;
&lt;li&gt;abc.svc.cluster.local&lt;/li&gt;
&lt;li&gt;cluster.local&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我们看到的dns解析的名字就是abc.test.svc.cluster.local。&lt;/p&gt;
&lt;h2 id=&#34;22-问题2&#34;&gt;2.2. 问题2：&lt;/h2&gt;
&lt;p&gt;在resolve.conf中，dns服务器的地址是10.254.10.20，那么这个地址运行的是什么呢？&lt;/p&gt;
&lt;p&gt;我们用dns反向解析，将IP解析为域名，可以看到主机的名称为kube-dns.kube-system.svc.cluster.local.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bash-5.0# nslookup 10.254.10.20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;20.10.254.10.in-addr.arpa	name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kube-dns.kube-system.svc.cluster.local.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而实际上，这个IP地址就是kube-dns的地址。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
